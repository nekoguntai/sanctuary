var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod3) => function __require() {
  return mod3 || (0, cb[__getOwnPropNames(cb)[0]])((mod3 = { exports: {} }).exports, mod3), mod3.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod3, isNodeMode, target) => (target = mod3 != null ? __create(__getProtoOf(mod3)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod3 || !mod3.__esModule ? __defProp(target, "default", { value: mod3, enumerable: true }) : target,
  mod3
));
var __toCommonJS = (mod3) => __copyProps(__defProp({}, "__esModule", { value: true }), mod3);

// node_modules/events/events.js
var require_events = __commonJS({
  "node_modules/events/events.js"(exports2, module2) {
    "use strict";
    var R = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    var ReflectOwnKeys;
    if (R && typeof R.ownKeys === "function") {
      ReflectOwnKeys = R.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    function ProcessEmitWarning(warning) {
      if (console && console.warn) console.warn(warning);
    }
    var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
      return value !== value;
    };
    function EventEmitter2() {
      EventEmitter2.init.call(this);
    }
    module2.exports = EventEmitter2;
    module2.exports.once = once;
    EventEmitter2.EventEmitter = EventEmitter2;
    EventEmitter2.prototype._events = void 0;
    EventEmitter2.prototype._eventsCount = 0;
    EventEmitter2.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    Object.defineProperty(EventEmitter2, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners = arg;
      }
    });
    EventEmitter2.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter2.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
      }
      this._maxListeners = n;
      return this;
    };
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter2.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter2.prototype.getMaxListeners = function getMaxListeners() {
      return _getMaxListeners(this);
    };
    EventEmitter2.prototype.emit = function emit(type) {
      var args = [];
      for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
      var doError = type === "error";
      var events = this._events;
      if (events !== void 0)
        doError = doError && events.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er;
        if (args.length > 0)
          er = args[0];
        if (er instanceof Error) {
          throw er;
        }
        var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err.context = er;
        throw err;
      }
      var handler = events[type];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          ReflectApply(listeners[i], this, args);
      }
      return true;
    };
    function _addListener(target, type, listener, prepend) {
      var m;
      var events;
      var existing;
      checkListener(listener);
      events = target._events;
      if (events === void 0) {
        events = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events.newListener !== void 0) {
          target.emit(
            "newListener",
            type,
            listener.listener ? listener.listener : listener
          );
          events = target._events;
        }
        existing = events[type];
      }
      if (existing === void 0) {
        existing = events[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events[type] = prepend ? [listener, existing] : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
          existing.warned = true;
          var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w.name = "MaxListenersExceededWarning";
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          ProcessEmitWarning(w);
        }
      }
      return target;
    }
    EventEmitter2.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter2.prototype.on = EventEmitter2.prototype.addListener;
    EventEmitter2.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap(target, type, listener) {
      var state = { fired: false, wrapFn: void 0, target, type, listener };
      var wrapped = onceWrapper.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }
    EventEmitter2.prototype.once = function once2(type, listener) {
      checkListener(listener);
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter2.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter2.prototype.removeListener = function removeListener(type, listener) {
      var list, events, position, i, originalListener;
      checkListener(listener);
      events = this._events;
      if (events === void 0)
        return this;
      list = events[type];
      if (list === void 0)
        return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }
        if (position < 0)
          return this;
        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }
        if (list.length === 1)
          events[type] = list[0];
        if (events.removeListener !== void 0)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners, events, i;
      events = this._events;
      if (events === void 0)
        return this;
      if (events.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== void 0) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else
            delete events[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === "removeListener") continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners = events[type];
      if (typeof listeners === "function") {
        this.removeListener(type, listeners);
      } else if (listeners !== void 0) {
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }
      return this;
    };
    function _listeners(target, type, unwrap) {
      var events = target._events;
      if (events === void 0)
        return [];
      var evlistener = events[type];
      if (evlistener === void 0)
        return [];
      if (typeof evlistener === "function")
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }
    EventEmitter2.prototype.listeners = function listeners(type) {
      return _listeners(this, type, true);
    };
    EventEmitter2.prototype.rawListeners = function rawListeners(type) {
      return _listeners(this, type, false);
    };
    EventEmitter2.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter2.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events = this._events;
      if (events !== void 0) {
        var evlistener = events[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };
    function arrayClone(arr, n) {
      var copy = new Array(n);
      for (var i = 0; i < n; ++i)
        copy[i] = arr[i];
      return copy;
    }
    function spliceOne(list, index) {
      for (; index + 1 < list.length; index++)
        list[index] = list[index + 1];
      list.pop();
    }
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i = 0; i < ret.length; ++i) {
        ret[i] = arr[i].listener || arr[i];
      }
      return ret;
    }
    function once(emitter, name) {
      return new Promise(function(resolve, reject) {
        function errorListener(err) {
          emitter.removeListener(name, resolver);
          reject(err);
        }
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve([].slice.call(arguments));
        }
        ;
        eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
        if (name !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
        }
      });
    }
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name, listener);
        } else {
          emitter.on(name, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name, function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name, wrapListener);
          }
          listener(arg);
        });
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
  }
});

// node_modules/@ledgerhq/errors/lib-es/helpers.js
function isObject(value) {
  return typeof value === "object";
}
var errorClasses, deserializers, addCustomErrorDeserializer, createCustomErrorClass;
var init_helpers = __esm({
  "node_modules/@ledgerhq/errors/lib-es/helpers.js"() {
    errorClasses = {};
    deserializers = {};
    addCustomErrorDeserializer = (name, deserializer) => {
      deserializers[name] = deserializer;
    };
    createCustomErrorClass = (name) => {
      class CustomErrorClass extends Error {
        cause;
        constructor(message, fields, options) {
          super(message || name, options);
          Object.setPrototypeOf(this, CustomErrorClass.prototype);
          this.name = name;
          if (fields) {
            for (const k in fields) {
              this[k] = fields[k];
            }
          }
          if (options && isObject(options) && "cause" in options && !this.cause) {
            const cause = options.cause;
            this.cause = cause;
            if ("stack" in cause) {
              this.stack = this.stack + "\nCAUSE: " + cause.stack;
            }
          }
        }
      }
      errorClasses[name] = CustomErrorClass;
      return CustomErrorClass;
    };
  }
});

// node_modules/@ledgerhq/errors/lib-es/index.js
function getAltStatusMessage(code) {
  switch (code) {
    // improve text of most common errors
    case 26368:
      return "Incorrect length";
    case 26624:
      return "Missing critical parameter";
    case 27010:
      return "Security not satisfied (dongle locked or have invalid access rights)";
    case 27013:
      return "Condition of use not satisfied (denied by the user?)";
    case 27264:
      return "Invalid data received";
    case 27392:
      return "Invalid parameter received";
    case 21781:
      return "Locked device";
  }
  if (28416 <= code && code <= 28671) {
    return "Internal error, please report";
  }
}
var AccountNameRequiredError, AccountNotSupported, AccountAwaitingSendPendingOperations, AmountRequired, BluetoothRequired, BtcUnmatchedApp, CantOpenDevice, CashAddrNotSupported, ClaimRewardsFeesWarning, CurrencyNotSupported, DeviceAppVerifyNotSupported, DeviceGenuineSocketEarlyClose, DeviceNotGenuineError, DeviceOnDashboardExpected, DeviceOnDashboardUnexpected, DeviceInOSUExpected, DeviceHalted, DeviceNameInvalid, DeviceSocketFail, DeviceSocketNoBulkStatus, DeviceNeedsRestart, UnresponsiveDeviceError, DisconnectedDevice, DisconnectedDeviceDuringOperation, DeviceExtractOnboardingStateError, DeviceOnboardingStatePollingError, EnpointConfigError, EthAppPleaseEnableContractData, CeloAppPleaseEnableContractData, FeeEstimationFailed, FirmwareNotRecognized, HardResetFail, InvalidXRPTag, InvalidAddress, InvalidNonce, InvalidAddressBecauseDestinationIsAlsoSource, LatestMCUInstalledError, LatestFirmwareVersionRequired, UnknownMCU, LedgerAPIError, LedgerAPIErrorWithMessage, LedgerAPINotAvailable, ManagerAppAlreadyInstalledError, ManagerAppRelyOnBTCError, ManagerAppDepInstallRequired, ManagerAppDepUninstallRequired, ManagerDeviceLockedError, ManagerFirmwareNotEnoughSpaceError, ManagerNotEnoughSpaceError, ManagerUninstallBTCDep, NetworkDown, NetworkError, NoAddressesFound, NotEnoughBalance, NotEnoughBalanceFees, NotEnoughBalanceSwap, NotEnoughBalanceToDelegate, UnstakeNotEnoughStakedBalanceLeft, RestakeNotEnoughStakedBalanceLeft, NotEnoughToRestake, NotEnoughToUnstake, NotEnoughBalanceInParentAccount, NotEnoughSpendableBalance, NotEnoughBalanceBecauseDestinationNotCreated, NotEnoughToStake, NoAccessToCamera, NotEnoughGas, NotEnoughGasSwap, TronEmptyAccount, MaybeKeepTronAccountAlive, NotSupportedLegacyAddress, GasLessThanEstimate, PriorityFeeTooLow, PriorityFeeTooHigh, PriorityFeeHigherThanMaxFee, MaxFeeTooLow, PasswordsDontMatchError, PasswordIncorrectError, RecommendSubAccountsToEmpty, RecommendUndelegation, TimeoutTagged, UnexpectedBootloader, MCUNotGenuineToDashboard, RecipientRequired, UnavailableTezosOriginatedAccountReceive, UnavailableTezosOriginatedAccountSend, UpdateFetchFileFail, UpdateIncorrectHash, UpdateIncorrectSig, UpdateYourApp, UserRefusedDeviceNameChange, UserRefusedAddress, UserRefusedFirmwareUpdate, UserRefusedAllowManager, UserRefusedOnDevice, PinNotSet, ExpertModeRequired, TransportOpenUserCancelled, TransportInterfaceNotAvailable, TransportRaceCondition, TransportWebUSBGestureRequired, TransactionHasBeenValidatedError, TransportExchangeTimeoutError, DeviceShouldStayInApp, WebsocketConnectionError, WebsocketConnectionFailed, WrongDeviceForAccount, WrongDeviceForAccountPayout, MissingSwapPayloadParamaters, WrongDeviceForAccountRefund, WrongAppForCurrency, ETHAddressNonEIP, CantScanQRCode, FeeNotLoaded, FeeNotLoadedSwap, FeeRequired, FeeTooHigh, PendingOperation, SyncError, PairingFailed, PeerRemovedPairing, GenuineCheckFailed, LedgerAPI4xx, LedgerAPI5xx, FirmwareOrAppUpdateRequired, ReplacementTransactionUnderpriced, OpReturnDataSizeLimit, DustLimit, LanguageNotFound, NoDBPathGiven, DBWrongPassword, DBNotReset, SequenceNumberError, DisabledTransactionBroadcastError, HwTransportErrorType, TransportError, StatusCodes, TransportStatusError, LockedDeviceError;
var init_lib_es = __esm({
  "node_modules/@ledgerhq/errors/lib-es/index.js"() {
    init_helpers();
    AccountNameRequiredError = createCustomErrorClass("AccountNameRequired");
    AccountNotSupported = createCustomErrorClass("AccountNotSupported");
    AccountAwaitingSendPendingOperations = createCustomErrorClass("AccountAwaitingSendPendingOperations");
    AmountRequired = createCustomErrorClass("AmountRequired");
    BluetoothRequired = createCustomErrorClass("BluetoothRequired");
    BtcUnmatchedApp = createCustomErrorClass("BtcUnmatchedApp");
    CantOpenDevice = createCustomErrorClass("CantOpenDevice");
    CashAddrNotSupported = createCustomErrorClass("CashAddrNotSupported");
    ClaimRewardsFeesWarning = createCustomErrorClass("ClaimRewardsFeesWarning");
    CurrencyNotSupported = createCustomErrorClass("CurrencyNotSupported");
    DeviceAppVerifyNotSupported = createCustomErrorClass("DeviceAppVerifyNotSupported");
    DeviceGenuineSocketEarlyClose = createCustomErrorClass("DeviceGenuineSocketEarlyClose");
    DeviceNotGenuineError = createCustomErrorClass("DeviceNotGenuine");
    DeviceOnDashboardExpected = createCustomErrorClass("DeviceOnDashboardExpected");
    DeviceOnDashboardUnexpected = createCustomErrorClass("DeviceOnDashboardUnexpected");
    DeviceInOSUExpected = createCustomErrorClass("DeviceInOSUExpected");
    DeviceHalted = createCustomErrorClass("DeviceHalted");
    DeviceNameInvalid = createCustomErrorClass("DeviceNameInvalid");
    DeviceSocketFail = createCustomErrorClass("DeviceSocketFail");
    DeviceSocketNoBulkStatus = createCustomErrorClass("DeviceSocketNoBulkStatus");
    DeviceNeedsRestart = createCustomErrorClass("DeviceSocketNoBulkStatus");
    UnresponsiveDeviceError = createCustomErrorClass("UnresponsiveDeviceError");
    DisconnectedDevice = createCustomErrorClass("DisconnectedDevice");
    DisconnectedDeviceDuringOperation = createCustomErrorClass("DisconnectedDeviceDuringOperation");
    DeviceExtractOnboardingStateError = createCustomErrorClass("DeviceExtractOnboardingStateError");
    DeviceOnboardingStatePollingError = createCustomErrorClass("DeviceOnboardingStatePollingError");
    EnpointConfigError = createCustomErrorClass("EnpointConfig");
    EthAppPleaseEnableContractData = createCustomErrorClass("EthAppPleaseEnableContractData");
    CeloAppPleaseEnableContractData = createCustomErrorClass("CeloAppPleaseEnableContractData");
    FeeEstimationFailed = createCustomErrorClass("FeeEstimationFailed");
    FirmwareNotRecognized = createCustomErrorClass("FirmwareNotRecognized");
    HardResetFail = createCustomErrorClass("HardResetFail");
    InvalidXRPTag = createCustomErrorClass("InvalidXRPTag");
    InvalidAddress = createCustomErrorClass("InvalidAddress");
    InvalidNonce = createCustomErrorClass("InvalidNonce");
    InvalidAddressBecauseDestinationIsAlsoSource = createCustomErrorClass("InvalidAddressBecauseDestinationIsAlsoSource");
    LatestMCUInstalledError = createCustomErrorClass("LatestMCUInstalledError");
    LatestFirmwareVersionRequired = createCustomErrorClass("LatestFirmwareVersionRequired");
    UnknownMCU = createCustomErrorClass("UnknownMCU");
    LedgerAPIError = createCustomErrorClass("LedgerAPIError");
    LedgerAPIErrorWithMessage = createCustomErrorClass("LedgerAPIErrorWithMessage");
    LedgerAPINotAvailable = createCustomErrorClass("LedgerAPINotAvailable");
    ManagerAppAlreadyInstalledError = createCustomErrorClass("ManagerAppAlreadyInstalled");
    ManagerAppRelyOnBTCError = createCustomErrorClass("ManagerAppRelyOnBTC");
    ManagerAppDepInstallRequired = createCustomErrorClass("ManagerAppDepInstallRequired");
    ManagerAppDepUninstallRequired = createCustomErrorClass("ManagerAppDepUninstallRequired");
    ManagerDeviceLockedError = createCustomErrorClass("ManagerDeviceLocked");
    ManagerFirmwareNotEnoughSpaceError = createCustomErrorClass("ManagerFirmwareNotEnoughSpace");
    ManagerNotEnoughSpaceError = createCustomErrorClass("ManagerNotEnoughSpace");
    ManagerUninstallBTCDep = createCustomErrorClass("ManagerUninstallBTCDep");
    NetworkDown = createCustomErrorClass("NetworkDown");
    NetworkError = createCustomErrorClass("NetworkError");
    NoAddressesFound = createCustomErrorClass("NoAddressesFound");
    NotEnoughBalance = createCustomErrorClass("NotEnoughBalance");
    NotEnoughBalanceFees = createCustomErrorClass("NotEnoughBalanceFees");
    NotEnoughBalanceSwap = createCustomErrorClass("NotEnoughBalanceSwap");
    NotEnoughBalanceToDelegate = createCustomErrorClass("NotEnoughBalanceToDelegate");
    UnstakeNotEnoughStakedBalanceLeft = createCustomErrorClass("UnstakeNotEnoughStakedBalanceLeft");
    RestakeNotEnoughStakedBalanceLeft = createCustomErrorClass("RestakeNotEnoughStakedBalanceLeft");
    NotEnoughToRestake = createCustomErrorClass("NotEnoughToRestake");
    NotEnoughToUnstake = createCustomErrorClass("NotEnoughToUnstake");
    NotEnoughBalanceInParentAccount = createCustomErrorClass("NotEnoughBalanceInParentAccount");
    NotEnoughSpendableBalance = createCustomErrorClass("NotEnoughSpendableBalance");
    NotEnoughBalanceBecauseDestinationNotCreated = createCustomErrorClass("NotEnoughBalanceBecauseDestinationNotCreated");
    NotEnoughToStake = createCustomErrorClass("NotEnoughToStake");
    NoAccessToCamera = createCustomErrorClass("NoAccessToCamera");
    NotEnoughGas = createCustomErrorClass("NotEnoughGas");
    NotEnoughGasSwap = createCustomErrorClass("NotEnoughGasSwap");
    TronEmptyAccount = createCustomErrorClass("TronEmptyAccount");
    MaybeKeepTronAccountAlive = createCustomErrorClass("MaybeKeepTronAccountAlive");
    NotSupportedLegacyAddress = createCustomErrorClass("NotSupportedLegacyAddress");
    GasLessThanEstimate = createCustomErrorClass("GasLessThanEstimate");
    PriorityFeeTooLow = createCustomErrorClass("PriorityFeeTooLow");
    PriorityFeeTooHigh = createCustomErrorClass("PriorityFeeTooHigh");
    PriorityFeeHigherThanMaxFee = createCustomErrorClass("PriorityFeeHigherThanMaxFee");
    MaxFeeTooLow = createCustomErrorClass("MaxFeeTooLow");
    PasswordsDontMatchError = createCustomErrorClass("PasswordsDontMatch");
    PasswordIncorrectError = createCustomErrorClass("PasswordIncorrect");
    RecommendSubAccountsToEmpty = createCustomErrorClass("RecommendSubAccountsToEmpty");
    RecommendUndelegation = createCustomErrorClass("RecommendUndelegation");
    TimeoutTagged = createCustomErrorClass("TimeoutTagged");
    UnexpectedBootloader = createCustomErrorClass("UnexpectedBootloader");
    MCUNotGenuineToDashboard = createCustomErrorClass("MCUNotGenuineToDashboard");
    RecipientRequired = createCustomErrorClass("RecipientRequired");
    UnavailableTezosOriginatedAccountReceive = createCustomErrorClass("UnavailableTezosOriginatedAccountReceive");
    UnavailableTezosOriginatedAccountSend = createCustomErrorClass("UnavailableTezosOriginatedAccountSend");
    UpdateFetchFileFail = createCustomErrorClass("UpdateFetchFileFail");
    UpdateIncorrectHash = createCustomErrorClass("UpdateIncorrectHash");
    UpdateIncorrectSig = createCustomErrorClass("UpdateIncorrectSig");
    UpdateYourApp = createCustomErrorClass("UpdateYourApp");
    UserRefusedDeviceNameChange = createCustomErrorClass("UserRefusedDeviceNameChange");
    UserRefusedAddress = createCustomErrorClass("UserRefusedAddress");
    UserRefusedFirmwareUpdate = createCustomErrorClass("UserRefusedFirmwareUpdate");
    UserRefusedAllowManager = createCustomErrorClass("UserRefusedAllowManager");
    UserRefusedOnDevice = createCustomErrorClass("UserRefusedOnDevice");
    PinNotSet = createCustomErrorClass("PinNotSet");
    ExpertModeRequired = createCustomErrorClass("ExpertModeRequired");
    TransportOpenUserCancelled = createCustomErrorClass("TransportOpenUserCancelled");
    TransportInterfaceNotAvailable = createCustomErrorClass("TransportInterfaceNotAvailable");
    TransportRaceCondition = createCustomErrorClass("TransportRaceCondition");
    TransportWebUSBGestureRequired = createCustomErrorClass("TransportWebUSBGestureRequired");
    TransactionHasBeenValidatedError = createCustomErrorClass("TransactionHasBeenValidatedError");
    TransportExchangeTimeoutError = createCustomErrorClass("TransportExchangeTimeoutError");
    DeviceShouldStayInApp = createCustomErrorClass("DeviceShouldStayInApp");
    WebsocketConnectionError = createCustomErrorClass("WebsocketConnectionError");
    WebsocketConnectionFailed = createCustomErrorClass("WebsocketConnectionFailed");
    WrongDeviceForAccount = createCustomErrorClass("WrongDeviceForAccount");
    WrongDeviceForAccountPayout = createCustomErrorClass("WrongDeviceForAccountPayout");
    MissingSwapPayloadParamaters = createCustomErrorClass("MissingSwapPayloadParamaters");
    WrongDeviceForAccountRefund = createCustomErrorClass("WrongDeviceForAccountRefund");
    WrongAppForCurrency = createCustomErrorClass("WrongAppForCurrency");
    ETHAddressNonEIP = createCustomErrorClass("ETHAddressNonEIP");
    CantScanQRCode = createCustomErrorClass("CantScanQRCode");
    FeeNotLoaded = createCustomErrorClass("FeeNotLoaded");
    FeeNotLoadedSwap = createCustomErrorClass("FeeNotLoadedSwap");
    FeeRequired = createCustomErrorClass("FeeRequired");
    FeeTooHigh = createCustomErrorClass("FeeTooHigh");
    PendingOperation = createCustomErrorClass("PendingOperation");
    SyncError = createCustomErrorClass("SyncError");
    PairingFailed = createCustomErrorClass("PairingFailed");
    PeerRemovedPairing = createCustomErrorClass("PeerRemovedPairing");
    GenuineCheckFailed = createCustomErrorClass("GenuineCheckFailed");
    LedgerAPI4xx = createCustomErrorClass("LedgerAPI4xx");
    LedgerAPI5xx = createCustomErrorClass("LedgerAPI5xx");
    FirmwareOrAppUpdateRequired = createCustomErrorClass("FirmwareOrAppUpdateRequired");
    ReplacementTransactionUnderpriced = createCustomErrorClass("ReplacementTransactionUnderpriced");
    OpReturnDataSizeLimit = createCustomErrorClass("OpReturnSizeLimit");
    DustLimit = createCustomErrorClass("DustLimit");
    LanguageNotFound = createCustomErrorClass("LanguageNotFound");
    NoDBPathGiven = createCustomErrorClass("NoDBPathGiven");
    DBWrongPassword = createCustomErrorClass("DBWrongPassword");
    DBNotReset = createCustomErrorClass("DBNotReset");
    SequenceNumberError = createCustomErrorClass("SequenceNumberError");
    DisabledTransactionBroadcastError = createCustomErrorClass("DisabledTransactionBroadcastError");
    (function(HwTransportErrorType2) {
      HwTransportErrorType2["Unknown"] = "Unknown";
      HwTransportErrorType2["LocationServicesDisabled"] = "LocationServicesDisabled";
      HwTransportErrorType2["LocationServicesUnauthorized"] = "LocationServicesUnauthorized";
      HwTransportErrorType2["BluetoothScanStartFailed"] = "BluetoothScanStartFailed";
    })(HwTransportErrorType || (HwTransportErrorType = {}));
    TransportError = class extends Error {
      id;
      constructor(message, id2) {
        const name = "TransportError";
        super(message || name);
        this.name = name;
        this.message = message;
        this.stack = new Error(message).stack;
        this.id = id2;
      }
    };
    addCustomErrorDeserializer("TransportError", (e) => new TransportError(e.message, e.id));
    StatusCodes = {
      ACCESS_CONDITION_NOT_FULFILLED: 38916,
      ALGORITHM_NOT_SUPPORTED: 38020,
      CLA_NOT_SUPPORTED: 28160,
      CODE_BLOCKED: 38976,
      CODE_NOT_INITIALIZED: 38914,
      COMMAND_INCOMPATIBLE_FILE_STRUCTURE: 27009,
      CONDITIONS_OF_USE_NOT_SATISFIED: 27013,
      CONTRADICTION_INVALIDATION: 38928,
      CONTRADICTION_SECRET_CODE_STATUS: 38920,
      DEVICE_IN_RECOVERY_MODE: 26159,
      CUSTOM_IMAGE_EMPTY: 26158,
      FILE_ALREADY_EXISTS: 27273,
      FILE_NOT_FOUND: 37892,
      GP_AUTH_FAILED: 25344,
      HALTED: 28586,
      INCONSISTENT_FILE: 37896,
      INCORRECT_DATA: 27264,
      INCORRECT_LENGTH: 26368,
      INCORRECT_P1_P2: 27392,
      INS_NOT_SUPPORTED: 27904,
      DEVICE_NOT_ONBOARDED: 27911,
      DEVICE_NOT_ONBOARDED_2: 26129,
      INVALID_KCV: 38021,
      INVALID_OFFSET: 37890,
      LICENSING: 28482,
      LOCKED_DEVICE: 21781,
      MAX_VALUE_REACHED: 38992,
      MEMORY_PROBLEM: 37440,
      MISSING_CRITICAL_PARAMETER: 26624,
      NO_EF_SELECTED: 37888,
      NOT_ENOUGH_MEMORY_SPACE: 27268,
      OK: 36864,
      PIN_REMAINING_ATTEMPTS: 25536,
      REFERENCED_DATA_NOT_FOUND: 27272,
      SECURITY_STATUS_NOT_SATISFIED: 27010,
      TECHNICAL_PROBLEM: 28416,
      UNKNOWN_APDU: 27906,
      USER_REFUSED_ON_DEVICE: 21761,
      NOT_ENOUGH_SPACE: 20738,
      APP_NOT_FOUND_OR_INVALID_CONTEXT: 20771,
      INVALID_APP_NAME_LENGTH: 26378,
      GEN_AES_KEY_FAILED: 21529,
      INTERNAL_CRYPTO_OPERATION_FAILED: 21530,
      INTERNAL_COMPUTE_AES_CMAC_FAILED: 21531,
      ENCRYPT_APP_STORAGE_FAILED: 21532,
      INVALID_BACKUP_STATE: 26178,
      PIN_NOT_SET: 21762,
      INVALID_BACKUP_LENGTH: 26419,
      INVALID_RESTORE_STATE: 26179,
      INVALID_CHUNK_LENGTH: 26420,
      INVALID_BACKUP_HEADER: 26698,
      // Not documented:
      TRUSTCHAIN_WRONG_SEED: 45063
    };
    TransportStatusError = class _TransportStatusError extends Error {
      statusCode;
      statusText;
      /**
       * @param statusCode The error status code coming from a Transport implementation
       * @param options containing:
       *  - canBeMappedToChildError: enable the mapping of TransportStatusError to an error extending/inheriting from it
       *  . Ex: LockedDeviceError. Default to true.
       */
      constructor(statusCode, { canBeMappedToChildError = true } = {}) {
        const statusText = Object.keys(StatusCodes).find((k) => StatusCodes[k] === statusCode) || "UNKNOWN_ERROR";
        const smsg = getAltStatusMessage(statusCode) || statusText;
        const statusCodeStr = statusCode.toString(16);
        const message = `Ledger device: ${smsg} (0x${statusCodeStr})`;
        super(message);
        this.name = "TransportStatusError";
        this.statusCode = statusCode;
        this.statusText = statusText;
        Object.setPrototypeOf(this, _TransportStatusError.prototype);
        if (canBeMappedToChildError && statusCode === StatusCodes.LOCKED_DEVICE) {
          return new LockedDeviceError(message);
        }
      }
    };
    LockedDeviceError = class _LockedDeviceError extends TransportStatusError {
      constructor(message) {
        super(StatusCodes.LOCKED_DEVICE, { canBeMappedToChildError: false });
        if (message) {
          this.message = message;
        }
        this.name = "LockedDeviceError";
        Object.setPrototypeOf(this, _LockedDeviceError.prototype);
      }
    };
    addCustomErrorDeserializer("TransportStatusError", (e) => new TransportStatusError(e.statusCode));
  }
});

// node_modules/@ledgerhq/logs/lib-es/index.js
function dispatch(log2) {
  for (let i = 0; i < subscribers.length; i++) {
    try {
      subscribers[i](log2);
    } catch (e) {
      console.error(e);
    }
  }
}
var id, subscribers, log, trace, LocalTracer, listen;
var init_lib_es2 = __esm({
  "node_modules/@ledgerhq/logs/lib-es/index.js"() {
    id = 0;
    subscribers = [];
    log = (type, message, data) => {
      const obj = {
        type,
        id: String(++id),
        date: /* @__PURE__ */ new Date()
      };
      if (message)
        obj.message = message;
      if (data)
        obj.data = data;
      dispatch(obj);
    };
    trace = ({ type, message, data, context }) => {
      const obj = {
        type,
        id: String(++id),
        date: /* @__PURE__ */ new Date()
      };
      if (message)
        obj.message = message;
      if (data)
        obj.data = data;
      if (context)
        obj.context = context;
      dispatch(obj);
    };
    LocalTracer = class _LocalTracer {
      type;
      context;
      constructor(type, context) {
        this.type = type;
        this.context = context;
      }
      trace(message, data) {
        trace({
          type: this.type,
          message,
          data,
          context: this.context
        });
      }
      getContext() {
        return this.context;
      }
      setContext(context) {
        this.context = context;
      }
      updateContext(contextToAdd) {
        this.context = { ...this.context, ...contextToAdd };
      }
      getType() {
        return this.type;
      }
      setType(type) {
        this.type = type;
      }
      /**
       * Create a new instance of the LocalTracer with an updated `type`
       *
       * It does not mutate the calling instance, but returns a new LocalTracer,
       * following a simple builder pattern.
       */
      withType(type) {
        return new _LocalTracer(type, this.context);
      }
      /**
       * Create a new instance of the LocalTracer with a new `context`
       *
       * It does not mutate the calling instance, but returns a new LocalTracer,
       * following a simple builder pattern.
       *
       * @param context A TraceContext, that can undefined to reset the context
       */
      withContext(context) {
        return new _LocalTracer(this.type, context);
      }
      /**
       * Create a new instance of the LocalTracer with an updated `context`,
       * on which an additional context is merged with the existing one.
       *
       * It does not mutate the calling instance, but returns a new LocalTracer,
       * following a simple builder pattern.
       */
      withUpdatedContext(contextToAdd) {
        return new _LocalTracer(this.type, { ...this.context, ...contextToAdd });
      }
    };
    listen = (cb) => {
      subscribers.push(cb);
      return () => {
        const i = subscribers.indexOf(cb);
        if (i !== -1) {
          subscribers[i] = subscribers[subscribers.length - 1];
          subscribers.pop();
        }
      };
    };
    if (typeof window !== "undefined") {
      window.__ledgerLogsListen = listen;
    }
  }
});

// node_modules/@ledgerhq/hw-transport/lib-es/Transport.js
var import_events, DEFAULT_LOG_TYPE, Transport;
var init_Transport = __esm({
  "node_modules/@ledgerhq/hw-transport/lib-es/Transport.js"() {
    import_events = __toESM(require_events());
    init_lib_es();
    init_lib_es2();
    DEFAULT_LOG_TYPE = "transport";
    Transport = class {
      exchangeTimeout = 3e4;
      unresponsiveTimeout = 15e3;
      deviceModel = null;
      tracer;
      constructor({ context, logType } = {}) {
        this.tracer = new LocalTracer(logType ?? DEFAULT_LOG_TYPE, context);
      }
      /**
       * Check if the transport is supported on the current platform/browser.
       * @returns {Promise<boolean>} A promise that resolves with a boolean indicating support.
       */
      static isSupported;
      /**
       * List all available descriptors for the transport.
       * For a better granularity, checkout `listen()`.
       *
       * @returns {Promise<Array<any>>} A promise that resolves with an array of descriptors.
       * @example
       * TransportFoo.list().then(descriptors => ...)
       */
      static list;
      /**
       * Listen for device events for the transport. The method takes an observer of DescriptorEvent and returns a Subscription.
       * A DescriptorEvent is an object containing a "descriptor" and a "type" field. The "type" field can be "add" or "remove", and the "descriptor" field can be passed to the "open" method.
       * The "listen" method will first emit all currently connected devices and then will emit events as they occur, such as when a USB device is plugged in or a Bluetooth device becomes discoverable.
       * @param {Observer<DescriptorEvent<any>>} observer - An object with "next", "error", and "complete" functions, following the observer pattern.
       * @returns {Subscription} A Subscription object on which you can call ".unsubscribe()" to stop listening to descriptors.
       * @example
      const sub = TransportFoo.listen({
      next: e => {
        if (e.type==="add") {
          sub.unsubscribe();
          const transport = await TransportFoo.open(e.descriptor);
          ...
        }
      },
      error: error => {},
      complete: () => {}
      })
       */
      static listen;
      /**
       * Attempt to create a Transport instance with a specific descriptor.
       * @param {any} descriptor - The descriptor to open the transport with.
       * @param {number} timeout - An optional timeout for the transport connection.
       * @param {TraceContext} context Optional tracing/log context
       * @returns {Promise<Transport>} A promise that resolves with a Transport instance.
       * @example
      TransportFoo.open(descriptor).then(transport => ...)
       */
      static open;
      /**
       * Send data to the device using a low level API.
       * It's recommended to use the "send" method for a higher level API.
       * @param {Buffer} apdu - The data to send.
       * @param {Object} options - Contains optional options for the exchange function
       *  - abortTimeoutMs: stop the exchange after a given timeout. Another timeout exists
       *    to detect unresponsive device (see `unresponsiveTimeout`). This timeout aborts the exchange.
       * @returns {Promise<Buffer>} A promise that resolves with the response data from the device.
       */
      exchange(_apdu, { abortTimeoutMs: _abortTimeoutMs } = {}) {
        throw new Error("exchange not implemented");
      }
      /**
       * Send apdus in batch to the device using a low level API.
       * The default implementation is to call exchange for each apdu.
       * @param {Array<Buffer>} apdus - array of apdus to send.
       * @param {Observer<Buffer>} observer - an observer that will receive the response of each apdu.
       * @returns {Subscription} A Subscription object on which you can call ".unsubscribe()" to stop sending apdus.
       */
      exchangeBulk(apdus, observer) {
        let unsubscribed = false;
        const unsubscribe = () => {
          unsubscribed = true;
        };
        const main = async () => {
          if (unsubscribed)
            return;
          for (const apdu of apdus) {
            const r = await this.exchange(apdu);
            if (unsubscribed)
              return;
            const status = r.readUInt16BE(r.length - 2);
            if (status !== StatusCodes.OK) {
              throw new TransportStatusError(status);
            }
            observer.next(r);
          }
        };
        main().then(() => !unsubscribed && observer.complete(), (e) => !unsubscribed && observer.error(e));
        return { unsubscribe };
      }
      /**
       * Set the "scramble key" for the next data exchanges with the device.
       * Each app can have a different scramble key and it is set internally during instantiation.
       * @param {string} key - The scramble key to set.
       * deprecated This method is no longer needed for modern transports and should be migrated away from.
       * no @ before deprecated as it breaks documentationjs on version 14.0.2
       * https://github.com/documentationjs/documentation/issues/1596
       */
      setScrambleKey(_key) {
      }
      /**
       * Close the connection with the device.
       *
       * Note: for certain transports (hw-transport-node-hid-singleton for ex), once the promise resolved,
       * the transport instance is actually still cached, and the device is disconnected only after a defined timeout.
       * But for the consumer of the Transport, this does not matter and it can consider the transport to be closed.
       *
       * @returns {Promise<void>} A promise that resolves when the transport is closed.
       */
      close() {
        return Promise.resolve();
      }
      _events = new import_events.default();
      /**
       * Listen for an event on the transport instance.
       * Transport implementations may have specific events. Common events include:
       * "disconnect" : triggered when the transport is disconnected.
       * @param {string} eventName - The name of the event to listen for.
       * @param {(...args: Array<any>) => any} cb - The callback function to be invoked when the event occurs.
       */
      on(eventName, cb) {
        this._events.on(eventName, cb);
      }
      /**
       * Stop listening to an event on an instance of transport.
       */
      off(eventName, cb) {
        this._events.removeListener(eventName, cb);
      }
      emit(event, ...args) {
        this._events.emit(event, ...args);
      }
      /**
       * Enable or not logs of the binary exchange
       */
      setDebugMode() {
        console.warn("setDebugMode is deprecated. use @ledgerhq/logs instead. No logs are emitted in this anymore.");
      }
      /**
       * Set a timeout (in milliseconds) for the exchange call. Only some transport might implement it. (e.g. U2F)
       */
      setExchangeTimeout(exchangeTimeout) {
        this.exchangeTimeout = exchangeTimeout;
      }
      /**
       * Define the delay before emitting "unresponsive" on an exchange that does not respond
       */
      setExchangeUnresponsiveTimeout(unresponsiveTimeout) {
        this.unresponsiveTimeout = unresponsiveTimeout;
      }
      /**
       * Send data to the device using the higher level API.
       *
       * @param {number} cla - The instruction class for the command.
       * @param {number} ins - The instruction code for the command.
       * @param {number} p1 - The first parameter for the instruction.
       * @param {number} p2 - The second parameter for the instruction.
       * @param {Buffer} data - The data to be sent. Defaults to an empty buffer.
       * @param {Array<number>} statusList - A list of acceptable status codes for the response. Defaults to [StatusCodes.OK].
       * @param {Object} options - Contains optional options for the exchange function
       *  - abortTimeoutMs: stop the send after a given timeout. Another timeout exists
       *    to detect unresponsive device (see `unresponsiveTimeout`). This timeout aborts the exchange.
       * @returns {Promise<Buffer>} A promise that resolves with the response data from the device.
       */
      send = async (cla, ins, p1, p2, data = Buffer.alloc(0), statusList = [StatusCodes.OK], { abortTimeoutMs } = {}) => {
        const tracer = this.tracer.withUpdatedContext({ function: "send" });
        if (data.length >= 256) {
          tracer.trace("data.length exceeded 256 bytes limit", { dataLength: data.length });
          throw new TransportError("data.length exceed 256 bytes limit. Got: " + data.length, "DataLengthTooBig");
        }
        const response = await this.exchange(
          // The size of the data is added in 1 byte just before `data`
          Buffer.concat([Buffer.from([cla, ins, p1, p2]), Buffer.from([data.length]), data]),
          { abortTimeoutMs }
        );
        const sw = response.readUInt16BE(response.length - 2);
        if (!statusList.some((s) => s === sw)) {
          throw new TransportStatusError(sw);
        }
        return response;
      };
      /**
       * create() allows to open the first descriptor available or
       * throw if there is none or if timeout is reached.
       * This is a light helper, alternative to using listen() and open() (that you may need for any more advanced usecase)
       * @example
      TransportFoo.create().then(transport => ...)
       */
      static create(openTimeout = 3e3, listenTimeout) {
        return new Promise((resolve, reject) => {
          let found = false;
          const sub = this.listen({
            next: (e) => {
              found = true;
              if (sub)
                sub.unsubscribe();
              if (listenTimeoutId)
                clearTimeout(listenTimeoutId);
              this.open(e.descriptor, openTimeout).then(resolve, reject);
            },
            error: (e) => {
              if (listenTimeoutId)
                clearTimeout(listenTimeoutId);
              reject(e);
            },
            complete: () => {
              if (listenTimeoutId)
                clearTimeout(listenTimeoutId);
              if (!found) {
                reject(new TransportError(this.ErrorMessage_NoDeviceFound, "NoDeviceFound"));
              }
            }
          });
          const listenTimeoutId = listenTimeout ? setTimeout(() => {
            sub.unsubscribe();
            reject(new TransportError(this.ErrorMessage_ListenTimeout, "ListenTimeout"));
          }, listenTimeout) : null;
        });
      }
      // Blocks other exchange to happen concurrently
      exchangeBusyPromise;
      /**
       * Wrapper to make an exchange "atomic" (blocking any other exchange)
       *
       * It also handles "unresponsiveness" by emitting "unresponsive" and "responsive" events.
       *
       * @param f The exchange job, using the transport to run
       * @returns a Promise resolving with the output of the given job
       */
      async exchangeAtomicImpl(f) {
        const tracer = this.tracer.withUpdatedContext({
          function: "exchangeAtomicImpl",
          unresponsiveTimeout: this.unresponsiveTimeout
        });
        if (this.exchangeBusyPromise) {
          tracer.trace("Atomic exchange is already busy");
          throw new TransportRaceCondition("An action was already pending on the Ledger device. Please deny or reconnect.");
        }
        let resolveBusy;
        const busyPromise = new Promise((r) => {
          resolveBusy = r;
        });
        this.exchangeBusyPromise = busyPromise;
        let unresponsiveReached = false;
        const timeout = setTimeout(() => {
          tracer.trace(`Timeout reached, emitting Transport event "unresponsive"`, {
            unresponsiveTimeout: this.unresponsiveTimeout
          });
          unresponsiveReached = true;
          this.emit("unresponsive");
        }, this.unresponsiveTimeout);
        try {
          const res = await f();
          if (unresponsiveReached) {
            tracer.trace("Device was unresponsive, emitting responsive");
            this.emit("responsive");
          }
          return res;
        } finally {
          tracer.trace("Finalize, clearing busy guard");
          clearTimeout(timeout);
          if (resolveBusy)
            resolveBusy();
          this.exchangeBusyPromise = null;
        }
      }
      decorateAppAPIMethods(self2, methods, scrambleKey) {
        for (const methodName of methods) {
          self2[methodName] = this.decorateAppAPIMethod(methodName, self2[methodName], self2, scrambleKey);
        }
      }
      _appAPIlock = null;
      decorateAppAPIMethod(methodName, f, ctx, scrambleKey) {
        return async (...args) => {
          const { _appAPIlock } = this;
          if (_appAPIlock) {
            return Promise.reject(new TransportError("Ledger Device is busy (lock " + _appAPIlock + ")", "TransportLocked"));
          }
          try {
            this._appAPIlock = methodName;
            this.setScrambleKey(scrambleKey);
            return await f.apply(ctx, args);
          } finally {
            this._appAPIlock = null;
          }
        };
      }
      /**
       * Sets the context used by the logging/tracing mechanism
       *
       * Useful when re-using (cached) the same Transport instance,
       * but with a new tracing context.
       *
       * @param context A TraceContext, that can undefined to reset the context
       */
      setTraceContext(context) {
        this.tracer = this.tracer.withContext(context);
      }
      /**
       * Updates the context used by the logging/tracing mechanism
       *
       * The update only overrides the key-value that are already defined in the current context.
       *
       * @param contextToAdd A TraceContext that will be added to the current context
       */
      updateTraceContext(contextToAdd) {
        this.tracer.updateContext(contextToAdd);
      }
      /**
       * Gets the tracing context of the transport instance
       */
      getTraceContext() {
        return this.tracer.getContext();
      }
      static ErrorMessage_ListenTimeout = "No Ledger device found (timeout)";
      static ErrorMessage_NoDeviceFound = "No Ledger device found";
    };
  }
});

// node_modules/@ledgerhq/devices/lib-es/hid-framing.js
function asUInt16BE(value) {
  const b2 = Buffer.alloc(2);
  b2.writeUInt16BE(value, 0);
  return b2;
}
var Tag, initialAcc, createHIDframing, hid_framing_default;
var init_hid_framing = __esm({
  "node_modules/@ledgerhq/devices/lib-es/hid-framing.js"() {
    init_lib_es();
    Tag = 5;
    initialAcc = {
      data: Buffer.alloc(0),
      dataLength: 0,
      sequence: 0
    };
    createHIDframing = (channel, packetSize) => {
      return {
        /**
         * Frames/encodes an APDU message into HID USB packets/frames
         *
         * @param apdu The APDU message to send, in a Buffer containing [cla, ins, p1, p2, data length, data(if not empty)]
         * @returns an array of HID USB frames ready to be sent
         */
        makeBlocks(apdu) {
          let data = Buffer.concat([asUInt16BE(apdu.length), apdu]);
          const blockSize = packetSize - 5;
          const nbBlocks = Math.ceil(data.length / blockSize);
          data = Buffer.concat([data, Buffer.alloc(nbBlocks * blockSize - data.length + 1).fill(0)]);
          const blocks = [];
          for (let i = 0; i < nbBlocks; i++) {
            const head = Buffer.alloc(5);
            head.writeUInt16BE(channel, 0);
            head.writeUInt8(Tag, 2);
            head.writeUInt16BE(i, 3);
            const chunk = data.slice(i * blockSize, (i + 1) * blockSize);
            blocks.push(Buffer.concat([head, chunk]));
          }
          return blocks;
        },
        /**
         * Reduces HID USB packets/frames to one response.
         *
         * @param acc The value resulting from (accumulating) the previous call of reduceResponse.
         *   On first call initialized to `initialAcc`. The accumulator enables handling multi-frames messages.
         * @param chunk Current chunk to reduce into accumulator
         * @returns An accumulator value updated with the current chunk
         */
        reduceResponse(acc, chunk) {
          let { data, dataLength, sequence } = acc || initialAcc;
          if (chunk.readUInt16BE(0) !== channel) {
            throw new TransportError("Invalid channel", "InvalidChannel");
          }
          if (chunk.readUInt8(2) !== Tag) {
            throw new TransportError("Invalid tag", "InvalidTag");
          }
          if (chunk.readUInt16BE(3) !== sequence) {
            throw new TransportError("Invalid sequence", "InvalidSequence");
          }
          if (!acc) {
            dataLength = chunk.readUInt16BE(5);
          }
          sequence++;
          const chunkData = chunk.slice(acc ? 5 : 7);
          data = Buffer.concat([data, chunkData]);
          if (data.length > dataLength) {
            data = data.slice(0, dataLength);
          }
          return {
            data,
            dataLength,
            sequence
          };
        },
        /**
         * Returns the response message that has been reduced from the HID USB frames
         *
         * @param acc The accumulator
         * @returns A Buffer containing the cleaned response message, or null if no response message, or undefined if the
         *   accumulator is incorrect (message length is not valid)
         */
        getReducedResult(acc) {
          if (acc && acc.dataLength === acc.data.length) {
            return acc.data;
          }
        }
      };
    };
    hid_framing_default = createHIDframing;
  }
});

// node_modules/semver/internal/constants.js
var require_constants = __commonJS({
  "node_modules/semver/internal/constants.js"(exports2, module2) {
    "use strict";
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var RELEASE_TYPES = [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ];
    module2.exports = {
      MAX_LENGTH,
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_SAFE_INTEGER,
      RELEASE_TYPES,
      SEMVER_SPEC_VERSION,
      FLAG_INCLUDE_PRERELEASE: 1,
      FLAG_LOOSE: 2
    };
  }
});

// node_modules/semver/internal/debug.js
var require_debug = __commonJS({
  "node_modules/semver/internal/debug.js"(exports2, module2) {
    "use strict";
    var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module2.exports = debug;
  }
});

// node_modules/semver/internal/re.js
var require_re = __commonJS({
  "node_modules/semver/internal/re.js"(exports2, module2) {
    "use strict";
    var {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = require_constants();
    var debug = require_debug();
    exports2 = module2.exports = {};
    var re = exports2.re = [];
    var safeRe = exports2.safeRe = [];
    var src = exports2.src = [];
    var safeSrc = exports2.safeSrc = [];
    var t = exports2.t = {};
    var R = 0;
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    var makeSafeRegex = (value) => {
      for (const [token, max] of safeRegexReplacements) {
        value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
      }
      return value;
    };
    var createToken = (name, value, isGlobal) => {
      const safe = makeSafeRegex(value);
      const index = R++;
      debug(name, index, value);
      t[name] = index;
      src[index] = value;
      safeSrc[index] = safe;
      re[index] = new RegExp(value, isGlobal ? "g" : void 0);
      safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken("FULL", `^${src[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
    createToken("COERCE", `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
    createToken("COERCEFULL", src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?(?:${src[t.BUILD]})?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t.COERCE], true);
    createToken("COERCERTLFULL", src[t.COERCEFULL], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports2.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports2.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports2.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
});

// node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "node_modules/semver/internal/parse-options.js"(exports2, module2) {
    "use strict";
    var looseOption = Object.freeze({ loose: true });
    var emptyOpts = Object.freeze({});
    var parseOptions = (options) => {
      if (!options) {
        return emptyOpts;
      }
      if (typeof options !== "object") {
        return looseOption;
      }
      return options;
    };
    module2.exports = parseOptions;
  }
});

// node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "node_modules/semver/internal/identifiers.js"(exports2, module2) {
    "use strict";
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a, b2) => {
      if (typeof a === "number" && typeof b2 === "number") {
        return a === b2 ? 0 : a < b2 ? -1 : 1;
      }
      const anum = numeric.test(a);
      const bnum = numeric.test(b2);
      if (anum && bnum) {
        a = +a;
        b2 = +b2;
      }
      return a === b2 ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b2 ? -1 : 1;
    };
    var rcompareIdentifiers = (a, b2) => compareIdentifiers(b2, a);
    module2.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// node_modules/semver/classes/semver.js
var require_semver = __commonJS({
  "node_modules/semver/classes/semver.js"(exports2, module2) {
    "use strict";
    var debug = require_debug();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();
    var { safeRe: re, t } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class _SemVer {
      constructor(version, options) {
        options = parseOptions(options);
        if (version instanceof _SemVer) {
          if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
            return version;
          } else {
            version = version.version;
          }
        } else if (typeof version !== "string") {
          throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
        }
        if (version.length > MAX_LENGTH) {
          throw new TypeError(
            `version is longer than ${MAX_LENGTH} characters`
          );
        }
        debug("SemVer", version, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m) {
          throw new TypeError(`Invalid Version: ${version}`);
        }
        this.raw = version;
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split(".").map((id2) => {
            if (/^[0-9]+$/.test(id2)) {
              const num = +id2;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id2;
          });
        }
        this.build = m[5] ? m[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof _SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new _SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        if (this.major < other.major) {
          return -1;
        }
        if (this.major > other.major) {
          return 1;
        }
        if (this.minor < other.minor) {
          return -1;
        }
        if (this.minor > other.minor) {
          return 1;
        }
        if (this.patch < other.patch) {
          return -1;
        }
        if (this.patch > other.patch) {
          return 1;
        }
        return 0;
      }
      comparePre(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i = 0;
        do {
          const a = this.prerelease[i];
          const b2 = other.prerelease[i];
          debug("prerelease compare", i, a, b2);
          if (a === void 0 && b2 === void 0) {
            return 0;
          } else if (b2 === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b2) {
            continue;
          } else {
            return compareIdentifiers(a, b2);
          }
        } while (++i);
      }
      compareBuild(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        let i = 0;
        do {
          const a = this.build[i];
          const b2 = other.build[i];
          debug("build compare", i, a, b2);
          if (a === void 0 && b2 === void 0) {
            return 0;
          } else if (b2 === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b2) {
            continue;
          } else {
            return compareIdentifiers(a, b2);
          }
        } while (++i);
      }
      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc(release, identifier, identifierBase) {
        if (release.startsWith("pre")) {
          if (!identifier && identifierBase === false) {
            throw new Error("invalid increment argument: identifier is empty");
          }
          if (identifier) {
            const match = `-${identifier}`.match(this.options.loose ? re[t.PRERELEASELOOSE] : re[t.PRERELEASE]);
            if (!match || match[1] !== identifier) {
              throw new Error(`invalid identifier: ${identifier}`);
            }
          }
        }
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier, identifierBase);
            this.inc("pre", identifier, identifierBase);
            break;
          // If the input is a non-prerelease version, this acts the same as
          // prepatch.
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier, identifierBase);
            }
            this.inc("pre", identifier, identifierBase);
            break;
          case "release":
            if (this.prerelease.length === 0) {
              throw new Error(`version ${this.raw} is not a prerelease`);
            }
            this.prerelease.length = 0;
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          // This probably shouldn't be used publicly.
          // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
          case "pre": {
            const base = Number(identifierBase) ? 1 : 0;
            if (this.prerelease.length === 0) {
              this.prerelease = [base];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === "number") {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                if (identifier === this.prerelease.join(".") && identifierBase === false) {
                  throw new Error("invalid increment argument: identifier already exists");
                }
                this.prerelease.push(base);
              }
            }
            if (identifier) {
              let prerelease = [identifier, base];
              if (identifierBase === false) {
                prerelease = [identifier];
              }
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = prerelease;
                }
              } else {
                this.prerelease = prerelease;
              }
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.raw = this.format();
        if (this.build.length) {
          this.raw += `+${this.build.join(".")}`;
        }
        return this;
      }
    };
    module2.exports = SemVer;
  }
});

// node_modules/semver/functions/parse.js
var require_parse = __commonJS({
  "node_modules/semver/functions/parse.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var parse = (version, options, throwErrors = false) => {
      if (version instanceof SemVer) {
        return version;
      }
      try {
        return new SemVer(version, options);
      } catch (er) {
        if (!throwErrors) {
          return null;
        }
        throw er;
      }
    };
    module2.exports = parse;
  }
});

// node_modules/semver/functions/valid.js
var require_valid = __commonJS({
  "node_modules/semver/functions/valid.js"(exports2, module2) {
    "use strict";
    var parse = require_parse();
    var valid = (version, options) => {
      const v = parse(version, options);
      return v ? v.version : null;
    };
    module2.exports = valid;
  }
});

// node_modules/semver/functions/clean.js
var require_clean = __commonJS({
  "node_modules/semver/functions/clean.js"(exports2, module2) {
    "use strict";
    var parse = require_parse();
    var clean2 = (version, options) => {
      const s = parse(version.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    };
    module2.exports = clean2;
  }
});

// node_modules/semver/functions/inc.js
var require_inc = __commonJS({
  "node_modules/semver/functions/inc.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var inc = (version, release, options, identifier, identifierBase) => {
      if (typeof options === "string") {
        identifierBase = identifier;
        identifier = options;
        options = void 0;
      }
      try {
        return new SemVer(
          version instanceof SemVer ? version.version : version,
          options
        ).inc(release, identifier, identifierBase).version;
      } catch (er) {
        return null;
      }
    };
    module2.exports = inc;
  }
});

// node_modules/semver/functions/diff.js
var require_diff = __commonJS({
  "node_modules/semver/functions/diff.js"(exports2, module2) {
    "use strict";
    var parse = require_parse();
    var diff = (version1, version2) => {
      const v1 = parse(version1, null, true);
      const v2 = parse(version2, null, true);
      const comparison = v1.compare(v2);
      if (comparison === 0) {
        return null;
      }
      const v1Higher = comparison > 0;
      const highVersion = v1Higher ? v1 : v2;
      const lowVersion = v1Higher ? v2 : v1;
      const highHasPre = !!highVersion.prerelease.length;
      const lowHasPre = !!lowVersion.prerelease.length;
      if (lowHasPre && !highHasPre) {
        if (!lowVersion.patch && !lowVersion.minor) {
          return "major";
        }
        if (lowVersion.compareMain(highVersion) === 0) {
          if (lowVersion.minor && !lowVersion.patch) {
            return "minor";
          }
          return "patch";
        }
      }
      const prefix = highHasPre ? "pre" : "";
      if (v1.major !== v2.major) {
        return prefix + "major";
      }
      if (v1.minor !== v2.minor) {
        return prefix + "minor";
      }
      if (v1.patch !== v2.patch) {
        return prefix + "patch";
      }
      return "prerelease";
    };
    module2.exports = diff;
  }
});

// node_modules/semver/functions/major.js
var require_major = __commonJS({
  "node_modules/semver/functions/major.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var major = (a, loose) => new SemVer(a, loose).major;
    module2.exports = major;
  }
});

// node_modules/semver/functions/minor.js
var require_minor = __commonJS({
  "node_modules/semver/functions/minor.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var minor = (a, loose) => new SemVer(a, loose).minor;
    module2.exports = minor;
  }
});

// node_modules/semver/functions/patch.js
var require_patch = __commonJS({
  "node_modules/semver/functions/patch.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var patch = (a, loose) => new SemVer(a, loose).patch;
    module2.exports = patch;
  }
});

// node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS({
  "node_modules/semver/functions/prerelease.js"(exports2, module2) {
    "use strict";
    var parse = require_parse();
    var prerelease = (version, options) => {
      const parsed = parse(version, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    module2.exports = prerelease;
  }
});

// node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "node_modules/semver/functions/compare.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var compare = (a, b2, loose) => new SemVer(a, loose).compare(new SemVer(b2, loose));
    module2.exports = compare;
  }
});

// node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS({
  "node_modules/semver/functions/rcompare.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var rcompare = (a, b2, loose) => compare(b2, a, loose);
    module2.exports = rcompare;
  }
});

// node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS({
  "node_modules/semver/functions/compare-loose.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var compareLoose = (a, b2) => compare(a, b2, true);
    module2.exports = compareLoose;
  }
});

// node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS({
  "node_modules/semver/functions/compare-build.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var compareBuild = (a, b2, loose) => {
      const versionA = new SemVer(a, loose);
      const versionB = new SemVer(b2, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    module2.exports = compareBuild;
  }
});

// node_modules/semver/functions/sort.js
var require_sort = __commonJS({
  "node_modules/semver/functions/sort.js"(exports2, module2) {
    "use strict";
    var compareBuild = require_compare_build();
    var sort = (list, loose) => list.sort((a, b2) => compareBuild(a, b2, loose));
    module2.exports = sort;
  }
});

// node_modules/semver/functions/rsort.js
var require_rsort = __commonJS({
  "node_modules/semver/functions/rsort.js"(exports2, module2) {
    "use strict";
    var compareBuild = require_compare_build();
    var rsort = (list, loose) => list.sort((a, b2) => compareBuild(b2, a, loose));
    module2.exports = rsort;
  }
});

// node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "node_modules/semver/functions/gt.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var gt = (a, b2, loose) => compare(a, b2, loose) > 0;
    module2.exports = gt;
  }
});

// node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  "node_modules/semver/functions/lt.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var lt = (a, b2, loose) => compare(a, b2, loose) < 0;
    module2.exports = lt;
  }
});

// node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "node_modules/semver/functions/eq.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var eq = (a, b2, loose) => compare(a, b2, loose) === 0;
    module2.exports = eq;
  }
});

// node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "node_modules/semver/functions/neq.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var neq = (a, b2, loose) => compare(a, b2, loose) !== 0;
    module2.exports = neq;
  }
});

// node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "node_modules/semver/functions/gte.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var gte = (a, b2, loose) => compare(a, b2, loose) >= 0;
    module2.exports = gte;
  }
});

// node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "node_modules/semver/functions/lte.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var lte = (a, b2, loose) => compare(a, b2, loose) <= 0;
    module2.exports = lte;
  }
});

// node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "node_modules/semver/functions/cmp.js"(exports2, module2) {
    "use strict";
    var eq = require_eq();
    var neq = require_neq();
    var gt = require_gt();
    var gte = require_gte();
    var lt = require_lt();
    var lte = require_lte();
    var cmp = (a, op, b2, loose) => {
      switch (op) {
        case "===":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b2 === "object") {
            b2 = b2.version;
          }
          return a === b2;
        case "!==":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b2 === "object") {
            b2 = b2.version;
          }
          return a !== b2;
        case "":
        case "=":
        case "==":
          return eq(a, b2, loose);
        case "!=":
          return neq(a, b2, loose);
        case ">":
          return gt(a, b2, loose);
        case ">=":
          return gte(a, b2, loose);
        case "<":
          return lt(a, b2, loose);
        case "<=":
          return lte(a, b2, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module2.exports = cmp;
  }
});

// node_modules/semver/functions/coerce.js
var require_coerce = __commonJS({
  "node_modules/semver/functions/coerce.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var parse = require_parse();
    var { safeRe: re, t } = require_re();
    var coerce = (version, options) => {
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version === "number") {
        version = String(version);
      }
      if (typeof version !== "string") {
        return null;
      }
      options = options || {};
      let match = null;
      if (!options.rtl) {
        match = version.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
      } else {
        const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
        let next;
        while ((next = coerceRtlRegex.exec(version)) && (!match || match.index + match[0].length !== version.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
        }
        coerceRtlRegex.lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      const major = match[2];
      const minor = match[3] || "0";
      const patch = match[4] || "0";
      const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : "";
      const build = options.includePrerelease && match[6] ? `+${match[6]}` : "";
      return parse(`${major}.${minor}.${patch}${prerelease}${build}`, options);
    };
    module2.exports = coerce;
  }
});

// node_modules/semver/internal/lrucache.js
var require_lrucache = __commonJS({
  "node_modules/semver/internal/lrucache.js"(exports2, module2) {
    "use strict";
    var LRUCache = class {
      constructor() {
        this.max = 1e3;
        this.map = /* @__PURE__ */ new Map();
      }
      get(key) {
        const value = this.map.get(key);
        if (value === void 0) {
          return void 0;
        } else {
          this.map.delete(key);
          this.map.set(key, value);
          return value;
        }
      }
      delete(key) {
        return this.map.delete(key);
      }
      set(key, value) {
        const deleted = this.delete(key);
        if (!deleted && value !== void 0) {
          if (this.map.size >= this.max) {
            const firstKey = this.map.keys().next().value;
            this.delete(firstKey);
          }
          this.map.set(key, value);
        }
        return this;
      }
    };
    module2.exports = LRUCache;
  }
});

// node_modules/semver/classes/range.js
var require_range = __commonJS({
  "node_modules/semver/classes/range.js"(exports2, module2) {
    "use strict";
    var SPACE_CHARACTERS = /\s+/g;
    var Range = class _Range {
      constructor(range, options) {
        options = parseOptions(options);
        if (range instanceof _Range) {
          if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
            return range;
          } else {
            return new _Range(range.raw, options);
          }
        }
        if (range instanceof Comparator) {
          this.raw = range.value;
          this.set = [[range]];
          this.formatted = void 0;
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range.trim().replace(SPACE_CHARACTERS, " ");
        this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c) => !isNullSet(c[0]));
          if (this.set.length === 0) {
            this.set = [first];
          } else if (this.set.length > 1) {
            for (const c of this.set) {
              if (c.length === 1 && isAny(c[0])) {
                this.set = [c];
                break;
              }
            }
          }
        }
        this.formatted = void 0;
      }
      get range() {
        if (this.formatted === void 0) {
          this.formatted = "";
          for (let i = 0; i < this.set.length; i++) {
            if (i > 0) {
              this.formatted += "||";
            }
            const comps = this.set[i];
            for (let k = 0; k < comps.length; k++) {
              if (k > 0) {
                this.formatted += " ";
              }
              this.formatted += comps[k].toString().trim();
            }
          }
        }
        return this.formatted;
      }
      format() {
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ":" + range;
        const cached = cache.get(memoKey);
        if (cached) {
          return cached;
        }
        const loose = this.options.loose;
        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug("hyphen replace", range);
        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
        debug("comparator trim", range);
        range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
        debug("tilde trim", range);
        range = range.replace(re[t.CARETTRIM], caretTrimReplace);
        debug("caret trim", range);
        let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug("loose invalid filter", comp, this.options);
            return !!comp.match(re[t.COMPARATORLOOSE]);
          });
        }
        debug("range list", rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
          rangeMap.delete("");
        }
        const result = [...rangeMap.values()];
        cache.set(memoKey, result);
        return result;
      }
      intersects(range, options) {
        if (!(range instanceof _Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      // if ANY of the sets match ALL of its comparators, then pass
      test(version) {
        if (!version) {
          return false;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i = 0; i < this.set.length; i++) {
          if (testSet(this.set[i], version, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module2.exports = Range;
    var LRU = require_lrucache();
    var cache = new LRU();
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug = require_debug();
    var SemVer = require_semver();
    var {
      safeRe: re,
      t,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants();
    var isNullSet = (c) => c.value === "<0.0.0-0";
    var isAny = (c) => c.value === "";
    var isSatisfiable = (comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options) => {
      comp = comp.replace(re[t.BUILD], "");
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    };
    var isX = (id2) => !id2 || id2.toLowerCase() === "x" || id2 === "*";
    var replaceTildes = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
    };
    var replaceTilde = (comp, options) => {
      const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("tilde", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        }
        debug("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
    };
    var replaceCaret = (comp, options) => {
      debug("caret", comp, options);
      const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
      const z = options.includePrerelease ? "-0" : "";
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("caret", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          if (M === "0") {
            ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
          } else {
            ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
          }
        }
        debug("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options) => {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
    };
    var replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          if (gtlt === "<") {
            pr = "-0";
          }
          ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        }
        debug("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options) => {
      debug("replaceStars", comp, options);
      return comp.trim().replace(re[t.STAR], "");
    };
    var replaceGTE0 = (comp, options) => {
      debug("replaceGTE0", comp, options);
      return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set2, version, options) => {
      for (let i = 0; i < set2.length; i++) {
        if (!set2[i].test(version)) {
          return false;
        }
      }
      if (version.prerelease.length && !options.includePrerelease) {
        for (let i = 0; i < set2.length; i++) {
          debug(set2[i].semver);
          if (set2[i].semver === Comparator.ANY) {
            continue;
          }
          if (set2[i].semver.prerelease.length > 0) {
            const allowed = set2[i].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "node_modules/semver/classes/comparator.js"(exports2, module2) {
    "use strict";
    var ANY = Symbol("SemVer ANY");
    var Comparator = class _Comparator {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof _Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        comp = comp.trim().split(/\s+/).join(" ");
        debug("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug("comp", this);
      }
      parse(comp) {
        const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const m = comp.match(r);
        if (!m) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== void 0 ? m[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version) {
        debug("Comparator.test", version, this.options.loose);
        if (this.semver === ANY || version === ANY) {
          return true;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof _Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range(this.value, options).test(comp.semver);
        }
        options = parseOptions(options);
        if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
          return false;
        }
        if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
          return false;
        }
        if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
          return true;
        }
        if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
          return true;
        }
        if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
          return true;
        }
        if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
          return true;
        }
        if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
          return true;
        }
        return false;
      }
    };
    module2.exports = Comparator;
    var parseOptions = require_parse_options();
    var { safeRe: re, t } = require_re();
    var cmp = require_cmp();
    var debug = require_debug();
    var SemVer = require_semver();
    var Range = require_range();
  }
});

// node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "node_modules/semver/functions/satisfies.js"(exports2, module2) {
    "use strict";
    var Range = require_range();
    var satisfies = (version, range, options) => {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version);
    };
    module2.exports = satisfies;
  }
});

// node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS({
  "node_modules/semver/ranges/to-comparators.js"(exports2, module2) {
    "use strict";
    var Range = require_range();
    var toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
    module2.exports = toComparators;
  }
});

// node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS({
  "node_modules/semver/ranges/max-satisfying.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var Range = require_range();
    var maxSatisfying = (versions, range, options) => {
      let max = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    };
    module2.exports = maxSatisfying;
  }
});

// node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS({
  "node_modules/semver/ranges/min-satisfying.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var Range = require_range();
    var minSatisfying = (versions, range, options) => {
      let min = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    };
    module2.exports = minSatisfying;
  }
});

// node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS({
  "node_modules/semver/ranges/min-version.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var Range = require_range();
    var gt = require_gt();
    var minVersion = (range, loose) => {
      range = new Range(range, loose);
      let minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let setMin = null;
        comparators.forEach((comparator) => {
          const compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            /* fallthrough */
            case "":
            case ">=":
              if (!setMin || gt(compver, setMin)) {
                setMin = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            /* istanbul ignore next */
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
        if (setMin && (!minver || gt(minver, setMin))) {
          minver = setMin;
        }
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    };
    module2.exports = minVersion;
  }
});

// node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS({
  "node_modules/semver/ranges/valid.js"(exports2, module2) {
    "use strict";
    var Range = require_range();
    var validRange = (range, options) => {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    };
    module2.exports = validRange;
  }
});

// node_modules/semver/ranges/outside.js
var require_outside = __commonJS({
  "node_modules/semver/ranges/outside.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var Range = require_range();
    var satisfies = require_satisfies();
    var gt = require_gt();
    var lt = require_lt();
    var lte = require_lte();
    var gte = require_gte();
    var outside = (version, range, hilo, options) => {
      version = new SemVer(version, options);
      range = new Range(range, options);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version, range, options)) {
        return false;
      }
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }
      return true;
    };
    module2.exports = outside;
  }
});

// node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS({
  "node_modules/semver/ranges/gtr.js"(exports2, module2) {
    "use strict";
    var outside = require_outside();
    var gtr = (version, range, options) => outside(version, range, ">", options);
    module2.exports = gtr;
  }
});

// node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS({
  "node_modules/semver/ranges/ltr.js"(exports2, module2) {
    "use strict";
    var outside = require_outside();
    var ltr = (version, range, options) => outside(version, range, "<", options);
    module2.exports = ltr;
  }
});

// node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS({
  "node_modules/semver/ranges/intersects.js"(exports2, module2) {
    "use strict";
    var Range = require_range();
    var intersects = (r1, r2, options) => {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2, options);
    };
    module2.exports = intersects;
  }
});

// node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS({
  "node_modules/semver/ranges/simplify.js"(exports2, module2) {
    "use strict";
    var satisfies = require_satisfies();
    var compare = require_compare();
    module2.exports = (versions, range, options) => {
      const set2 = [];
      let first = null;
      let prev = null;
      const v = versions.sort((a, b2) => compare(a, b2, options));
      for (const version of v) {
        const included = satisfies(version, range, options);
        if (included) {
          prev = version;
          if (!first) {
            first = version;
          }
        } else {
          if (prev) {
            set2.push([first, prev]);
          }
          prev = null;
          first = null;
        }
      }
      if (first) {
        set2.push([first, null]);
      }
      const ranges = [];
      for (const [min, max] of set2) {
        if (min === max) {
          ranges.push(min);
        } else if (!max && min === v[0]) {
          ranges.push("*");
        } else if (!max) {
          ranges.push(`>=${min}`);
        } else if (min === v[0]) {
          ranges.push(`<=${max}`);
        } else {
          ranges.push(`${min} - ${max}`);
        }
      }
      const simplified = ranges.join(" || ");
      const original = typeof range.raw === "string" ? range.raw : String(range);
      return simplified.length < original.length ? simplified : range;
    };
  }
});

// node_modules/semver/ranges/subset.js
var require_subset = __commonJS({
  "node_modules/semver/ranges/subset.js"(exports2, module2) {
    "use strict";
    var Range = require_range();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var satisfies = require_satisfies();
    var compare = require_compare();
    var subset = (sub, dom, options = {}) => {
      if (sub === dom) {
        return true;
      }
      sub = new Range(sub, options);
      dom = new Range(dom, options);
      let sawNonNull = false;
      OUTER: for (const simpleSub of sub.set) {
        for (const simpleDom of dom.set) {
          const isSub = simpleSubset(simpleSub, simpleDom, options);
          sawNonNull = sawNonNull || isSub !== null;
          if (isSub) {
            continue OUTER;
          }
        }
        if (sawNonNull) {
          return false;
        }
      }
      return true;
    };
    var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
    var minimumVersion = [new Comparator(">=0.0.0")];
    var simpleSubset = (sub, dom, options) => {
      if (sub === dom) {
        return true;
      }
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) {
          return true;
        } else if (options.includePrerelease) {
          sub = minimumVersionWithPreRelease;
        } else {
          sub = minimumVersion;
        }
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease) {
          return true;
        } else {
          dom = minimumVersion;
        }
      }
      const eqSet = /* @__PURE__ */ new Set();
      let gt, lt;
      for (const c of sub) {
        if (c.operator === ">" || c.operator === ">=") {
          gt = higherGT(gt, c, options);
        } else if (c.operator === "<" || c.operator === "<=") {
          lt = lowerLT(lt, c, options);
        } else {
          eqSet.add(c.semver);
        }
      }
      if (eqSet.size > 1) {
        return null;
      }
      let gtltComp;
      if (gt && lt) {
        gtltComp = compare(gt.semver, lt.semver, options);
        if (gtltComp > 0) {
          return null;
        } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
          return null;
        }
      }
      for (const eq of eqSet) {
        if (gt && !satisfies(eq, String(gt), options)) {
          return null;
        }
        if (lt && !satisfies(eq, String(lt), options)) {
          return null;
        }
        for (const c of dom) {
          if (!satisfies(eq, String(c), options)) {
            return false;
          }
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
      let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c of dom) {
        hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
        hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
        if (gt) {
          if (needDomGTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c.operator === ">" || c.operator === ">=") {
            higher = higherGT(gt, c, options);
            if (higher === c && higher !== gt) {
              return false;
            }
          } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options)) {
            return false;
          }
        }
        if (lt) {
          if (needDomLTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c.operator === "<" || c.operator === "<=") {
            lower = lowerLT(lt, c, options);
            if (lower === c && lower !== lt) {
              return false;
            }
          } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options)) {
            return false;
          }
        }
        if (!c.operator && (lt || gt) && gtltComp !== 0) {
          return false;
        }
      }
      if (gt && hasDomLT && !lt && gtltComp !== 0) {
        return false;
      }
      if (lt && hasDomGT && !gt && gtltComp !== 0) {
        return false;
      }
      if (needDomGTPre || needDomLTPre) {
        return false;
      }
      return true;
    };
    var higherGT = (a, b2, options) => {
      if (!a) {
        return b2;
      }
      const comp = compare(a.semver, b2.semver, options);
      return comp > 0 ? a : comp < 0 ? b2 : b2.operator === ">" && a.operator === ">=" ? b2 : a;
    };
    var lowerLT = (a, b2, options) => {
      if (!a) {
        return b2;
      }
      const comp = compare(a.semver, b2.semver, options);
      return comp < 0 ? a : comp > 0 ? b2 : b2.operator === "<" && a.operator === "<=" ? b2 : a;
    };
    module2.exports = subset;
  }
});

// node_modules/semver/index.js
var require_semver2 = __commonJS({
  "node_modules/semver/index.js"(exports2, module2) {
    "use strict";
    var internalRe = require_re();
    var constants = require_constants();
    var SemVer = require_semver();
    var identifiers = require_identifiers();
    var parse = require_parse();
    var valid = require_valid();
    var clean2 = require_clean();
    var inc = require_inc();
    var diff = require_diff();
    var major = require_major();
    var minor = require_minor();
    var patch = require_patch();
    var prerelease = require_prerelease();
    var compare = require_compare();
    var rcompare = require_rcompare();
    var compareLoose = require_compare_loose();
    var compareBuild = require_compare_build();
    var sort = require_sort();
    var rsort = require_rsort();
    var gt = require_gt();
    var lt = require_lt();
    var eq = require_eq();
    var neq = require_neq();
    var gte = require_gte();
    var lte = require_lte();
    var cmp = require_cmp();
    var coerce = require_coerce();
    var Comparator = require_comparator();
    var Range = require_range();
    var satisfies = require_satisfies();
    var toComparators = require_to_comparators();
    var maxSatisfying = require_max_satisfying();
    var minSatisfying = require_min_satisfying();
    var minVersion = require_min_version();
    var validRange = require_valid2();
    var outside = require_outside();
    var gtr = require_gtr();
    var ltr = require_ltr();
    var intersects = require_intersects();
    var simplifyRange = require_simplify();
    var subset = require_subset();
    module2.exports = {
      parse,
      valid,
      clean: clean2,
      inc,
      diff,
      major,
      minor,
      patch,
      prerelease,
      compare,
      rcompare,
      compareLoose,
      compareBuild,
      sort,
      rsort,
      gt,
      lt,
      eq,
      neq,
      gte,
      lte,
      cmp,
      coerce,
      Comparator,
      Range,
      satisfies,
      toComparators,
      maxSatisfying,
      minSatisfying,
      minVersion,
      validRange,
      outside,
      gtr,
      ltr,
      intersects,
      simplifyRange,
      subset,
      SemVer,
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
      RELEASE_TYPES: constants.RELEASE_TYPES,
      compareIdentifiers: identifiers.compareIdentifiers,
      rcompareIdentifiers: identifiers.rcompareIdentifiers
    };
  }
});

// node_modules/@ledgerhq/devices/lib-es/index.js
var import_semver, DeviceModelId, devices, productMap, devicesList, ledgerUSBVendorId, identifyUSBProductId, bluetoothServices, serviceUuidToInfos;
var init_lib_es3 = __esm({
  "node_modules/@ledgerhq/devices/lib-es/index.js"() {
    import_semver = __toESM(require_semver2());
    (function(DeviceModelId2) {
      DeviceModelId2["blue"] = "blue";
      DeviceModelId2["nanoS"] = "nanoS";
      DeviceModelId2["nanoSP"] = "nanoSP";
      DeviceModelId2["nanoX"] = "nanoX";
      DeviceModelId2["stax"] = "stax";
      DeviceModelId2["europa"] = "europa";
      DeviceModelId2["apex"] = "apex";
    })(DeviceModelId || (DeviceModelId = {}));
    devices = {
      [DeviceModelId.blue]: {
        id: DeviceModelId.blue,
        productName: "Ledger\xA0Blue",
        productIdMM: 0,
        legacyUsbProductId: 0,
        usbOnly: true,
        memorySize: 480 * 1024,
        masks: [822083584, 822149120],
        getBlockSize: (_firwareVersion) => 4 * 1024
      },
      [DeviceModelId.nanoS]: {
        id: DeviceModelId.nanoS,
        productName: "Ledger\xA0Nano\xA0S",
        productIdMM: 16,
        legacyUsbProductId: 1,
        usbOnly: true,
        memorySize: 320 * 1024,
        masks: [823132160],
        getBlockSize: (firmwareVersion) => import_semver.default.lt(import_semver.default.coerce(firmwareVersion) ?? "", "2.0.0") ? 4 * 1024 : 2 * 1024
      },
      [DeviceModelId.nanoX]: {
        id: DeviceModelId.nanoX,
        productName: "Ledger\xA0Nano\xA0X",
        productIdMM: 64,
        legacyUsbProductId: 4,
        usbOnly: false,
        memorySize: 2 * 1024 * 1024,
        masks: [855638016],
        getBlockSize: (_firwareVersion) => 4 * 1024,
        bluetoothSpec: [
          {
            serviceUuid: "13d63400-2c97-0004-0000-4c6564676572",
            notifyUuid: "13d63400-2c97-0004-0001-4c6564676572",
            writeUuid: "13d63400-2c97-0004-0002-4c6564676572",
            writeCmdUuid: "13d63400-2c97-0004-0003-4c6564676572"
          }
        ]
      },
      [DeviceModelId.nanoSP]: {
        id: DeviceModelId.nanoSP,
        productName: "Ledger Nano S Plus",
        productIdMM: 80,
        legacyUsbProductId: 5,
        usbOnly: true,
        memorySize: 1533 * 1024,
        masks: [856686592],
        getBlockSize: (_firmwareVersion) => 32
      },
      [DeviceModelId.apex]: {
        id: DeviceModelId.apex,
        productName: "Ledger\xA0Nano\xA0Gen5",
        productIdMM: 128,
        legacyUsbProductId: 8,
        usbOnly: false,
        memorySize: 1533 * 1024,
        masks: [859832320],
        getBlockSize: (_firmwareVersion) => 32,
        bluetoothSpec: [
          {
            serviceUuid: "13d63400-2c97-8004-0000-4c6564676572",
            notifyUuid: "13d63400-2c97-8004-0001-4c6564676572",
            writeUuid: "13d63400-2c97-8004-0002-4c6564676572",
            writeCmdUuid: "13d63400-2c97-8004-0003-4c6564676572"
          }
        ]
      },
      [DeviceModelId.stax]: {
        id: DeviceModelId.stax,
        productName: "Ledger\xA0Stax",
        productIdMM: 96,
        legacyUsbProductId: 6,
        usbOnly: false,
        memorySize: 1533 * 1024,
        masks: [857735168],
        getBlockSize: (_firmwareVersion) => 32,
        bluetoothSpec: [
          {
            serviceUuid: "13d63400-2c97-6004-0000-4c6564676572",
            notifyUuid: "13d63400-2c97-6004-0001-4c6564676572",
            writeUuid: "13d63400-2c97-6004-0002-4c6564676572",
            writeCmdUuid: "13d63400-2c97-6004-0003-4c6564676572"
          }
        ]
      },
      [DeviceModelId.europa]: {
        id: DeviceModelId.europa,
        productName: "Ledger\xA0Flex",
        productIdMM: 112,
        legacyUsbProductId: 7,
        usbOnly: false,
        memorySize: 1533 * 1024,
        masks: [858783744],
        getBlockSize: (_firmwareVersion) => 32,
        bluetoothSpec: [
          {
            serviceUuid: "13d63400-2c97-3004-0000-4c6564676572",
            notifyUuid: "13d63400-2c97-3004-0001-4c6564676572",
            writeUuid: "13d63400-2c97-3004-0002-4c6564676572",
            writeCmdUuid: "13d63400-2c97-3004-0003-4c6564676572"
          }
        ]
      }
    };
    productMap = {
      Blue: DeviceModelId.blue,
      "Nano S": DeviceModelId.nanoS,
      "Nano S Plus": DeviceModelId.nanoSP,
      "Nano X": DeviceModelId.nanoX,
      Stax: DeviceModelId.stax,
      Europa: DeviceModelId.europa
    };
    devicesList = Object.values(devices);
    ledgerUSBVendorId = 11415;
    identifyUSBProductId = (usbProductId) => {
      const legacy = devicesList.find((d) => d.legacyUsbProductId === usbProductId);
      if (legacy)
        return legacy;
      const mm = usbProductId >> 8;
      const deviceModel = devicesList.find((d) => d.productIdMM === mm);
      return deviceModel;
    };
    bluetoothServices = [];
    serviceUuidToInfos = {};
    for (const id2 in devices) {
      const deviceModel = devices[id2];
      const { bluetoothSpec } = deviceModel;
      if (bluetoothSpec) {
        for (let i = 0; i < bluetoothSpec.length; i++) {
          const spec = bluetoothSpec[i];
          bluetoothServices.push(spec.serviceUuid);
          serviceUuidToInfos[spec.serviceUuid] = serviceUuidToInfos[spec.serviceUuid.replace(/-/g, "")] = {
            deviceModel,
            ...spec
          };
        }
      }
    }
  }
});

// node_modules/@ledgerhq/hw-transport-webusb/lib-es/webusb.js
async function requestLedgerDevice() {
  const device = await navigator.usb.requestDevice({
    filters: ledgerDevices
  });
  return device;
}
async function getLedgerDevices() {
  const devices2 = await navigator.usb.getDevices();
  return devices2.filter((d) => d.vendorId === ledgerUSBVendorId);
}
async function getFirstLedgerDevice() {
  const existingDevices = await getLedgerDevices();
  if (existingDevices.length > 0)
    return existingDevices[0];
  return requestLedgerDevice();
}
var ledgerDevices, isSupported;
var init_webusb = __esm({
  "node_modules/@ledgerhq/hw-transport-webusb/lib-es/webusb.js"() {
    init_lib_es3();
    ledgerDevices = [
      {
        vendorId: ledgerUSBVendorId
      }
    ];
    isSupported = () => Promise.resolve(!!navigator && !!navigator.usb && typeof navigator.usb.getDevices === "function");
  }
});

// node_modules/@ledgerhq/hw-transport-webusb/lib-es/TransportWebUSB.js
var TransportWebUSB_exports = {};
__export(TransportWebUSB_exports, {
  default: () => TransportWebUSB
});
async function gracefullyResetDevice(device) {
  try {
    await device.reset();
  } catch (err) {
    console.warn(err);
  }
}
var configurationValue, endpointNumber, TransportWebUSB;
var init_TransportWebUSB = __esm({
  "node_modules/@ledgerhq/hw-transport-webusb/lib-es/TransportWebUSB.js"() {
    init_Transport();
    init_hid_framing();
    init_lib_es3();
    init_lib_es2();
    init_lib_es();
    init_webusb();
    configurationValue = 1;
    endpointNumber = 3;
    TransportWebUSB = class _TransportWebUSB extends Transport {
      device;
      deviceModel;
      channel = Math.floor(Math.random() * 65535);
      packetSize = 64;
      interfaceNumber;
      constructor(device, interfaceNumber) {
        super();
        this.device = device;
        this.interfaceNumber = interfaceNumber;
        this.deviceModel = identifyUSBProductId(device.productId);
      }
      /**
       * Check if WebUSB transport is supported.
       */
      static isSupported = isSupported;
      /**
       * List the WebUSB devices that was previously authorized by the user.
       */
      static list = getLedgerDevices;
      /**
       * Actively listen to WebUSB devices and emit ONE device
       * that was either accepted before, if not it will trigger the native permission UI.
       *
       * Important: it must be called in the context of a UI click!
       */
      static listen = (observer) => {
        let unsubscribed = false;
        getFirstLedgerDevice().then((device) => {
          if (!unsubscribed) {
            const deviceModel = identifyUSBProductId(device.productId);
            observer.next({
              type: "add",
              descriptor: device,
              deviceModel
            });
            observer.complete();
          }
        }, (error) => {
          if (window.DOMException && error instanceof window.DOMException && error.code === 18) {
            observer.error(new TransportWebUSBGestureRequired(error.message));
          } else {
            observer.error(new TransportOpenUserCancelled(error.message));
          }
        });
        function unsubscribe() {
          unsubscribed = true;
        }
        return {
          unsubscribe
        };
      };
      /**
       * Similar to create() except it will always display the device permission (even if some devices are already accepted).
       */
      static async request() {
        const device = await requestLedgerDevice();
        return _TransportWebUSB.open(device);
      }
      /**
       * Similar to create() except it will never display the device permission (it returns a Promise<?Transport>, null if it fails to find a device).
       */
      static async openConnected() {
        const devices2 = await getLedgerDevices();
        if (devices2.length === 0)
          return null;
        return _TransportWebUSB.open(devices2[0]);
      }
      /**
       * Create a Ledger transport with a USBDevice
       */
      static async open(device) {
        await device.open();
        if (device.configuration === null) {
          await device.selectConfiguration(configurationValue);
        }
        await gracefullyResetDevice(device);
        const iface = device.configurations[0].interfaces.find(({ alternates }) => alternates.some((a) => a.interfaceClass === 255));
        if (!iface) {
          throw new TransportInterfaceNotAvailable("No WebUSB interface found for your Ledger device. Please upgrade firmware or contact techsupport.");
        }
        const interfaceNumber = iface.interfaceNumber;
        try {
          await device.claimInterface(interfaceNumber);
        } catch (e) {
          await device.close();
          throw new TransportInterfaceNotAvailable(e.message);
        }
        const transport = new _TransportWebUSB(device, interfaceNumber);
        const onDisconnect = (e) => {
          if (device === e.device) {
            navigator.usb.removeEventListener("disconnect", onDisconnect);
            transport._emitDisconnect(new DisconnectedDevice());
          }
        };
        navigator.usb.addEventListener("disconnect", onDisconnect);
        return transport;
      }
      _disconnectEmitted = false;
      _emitDisconnect = (e) => {
        if (this._disconnectEmitted)
          return;
        this._disconnectEmitted = true;
        this.emit("disconnect", e);
      };
      /**
       * Release the transport device
       */
      async close() {
        await this.exchangeBusyPromise;
        await this.device.releaseInterface(this.interfaceNumber);
        await gracefullyResetDevice(this.device);
        await this.device.close();
      }
      /**
       * Exchange with the device using APDU protocol.
       * @param apdu
       * @returns a promise of apdu response
       */
      async exchange(apdu) {
        const b2 = await this.exchangeAtomicImpl(async () => {
          const { channel, packetSize } = this;
          log("apdu", "=> " + apdu.toString("hex"));
          const framing = hid_framing_default(channel, packetSize);
          const blocks = framing.makeBlocks(apdu);
          for (let i = 0; i < blocks.length; i++) {
            await this.device.transferOut(endpointNumber, blocks[i]);
          }
          let result;
          let acc;
          while (!(result = framing.getReducedResult(acc))) {
            const r = await this.device.transferIn(endpointNumber, packetSize);
            const buffer = Buffer.from(r.data.buffer);
            acc = framing.reduceResponse(acc, buffer);
          }
          log("apdu", "<= " + result.toString("hex"));
          return result;
        }).catch((e) => {
          if (e && e.message && e.message.includes("disconnected")) {
            this._emitDisconnect(e);
            throw new DisconnectedDeviceDuringOperation(e.message);
          }
          throw e;
        });
        return b2;
      }
      setScrambleKey() {
      }
    };
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports2, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "node_modules/base64-js/index.js"(exports2) {
    "use strict";
    exports2.byteLength = byteLength;
    exports2.toByteArray = toByteArray;
    exports2.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }
    var i;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1) validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "node_modules/ieee754/index.js"(exports2) {
    exports2.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports2.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
      }
      buffer[offset + i - d] |= s * 128;
    };
  }
});

// node_modules/buffer/index.js
var require_buffer = __commonJS({
  "node_modules/buffer/index.js"(exports2) {
    "use strict";
    var base64 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports2.Buffer = Buffer2;
    exports2.SlowBuffer = SlowBuffer;
    exports2.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports2.kMaxLength = K_MAX_LENGTH;
    Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    Object.defineProperty(Buffer2.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this)) return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer2.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this)) return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      const buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function Buffer2(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer2.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer2.from(valueOf, encodingOrOffset, length);
      }
      const b2 = fromObject(value);
      if (b2) return b2;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    Buffer2.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer2, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer2.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer2.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer2.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length = byteLength(string, encoding) | 0;
      let buf = createBuffer(length);
      const actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      const length = array.length < 0 ? 0 : checked(array.length) | 0;
      const buf = createBuffer(length);
      for (let i = 0; i < length; i += 1) {
        buf[i] = array[i] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer2.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer2.alloc(+length);
    }
    Buffer2.isBuffer = function isBuffer(b2) {
      return b2 != null && b2._isBuffer === true && b2 !== Buffer2.prototype;
    };
    Buffer2.compare = function compare(a, b2) {
      if (isInstance(a, Uint8Array)) a = Buffer2.from(a, a.offset, a.byteLength);
      if (isInstance(b2, Uint8Array)) b2 = Buffer2.from(b2, b2.offset, b2.byteLength);
      if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b2)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a === b2) return 0;
      let x = a.length;
      let y = b2.length;
      for (let i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b2[i]) {
          x = a[i];
          y = b2[i];
          break;
        }
      }
      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    };
    Buffer2.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer2.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer2.alloc(0);
      }
      let i;
      if (length === void 0) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      const buffer = Buffer2.allocUnsafe(length);
      let pos = 0;
      for (i = 0; i < list.length; ++i) {
        let buf = list[i];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            if (!Buffer2.isBuffer(buf)) buf = Buffer2.from(buf);
            buf.copy(buffer, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer,
              buf,
              pos
            );
          }
        } else if (!Buffer2.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer, pos);
        }
        pos += buf.length;
      }
      return buffer;
    };
    function byteLength(string, encoding) {
      if (Buffer2.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
        );
      }
      const len = string.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0) return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes2(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes2(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding) encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.prototype._isBuffer = true;
    function swap(b2, n, m) {
      const i = b2[n];
      b2[n] = b2[m];
      b2[m] = i;
    }
    Buffer2.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer2.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer2.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer2.prototype.toString = function toString() {
      const length = this.length;
      if (length === 0) return "";
      if (arguments.length === 0) return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
    Buffer2.prototype.equals = function equals(b2) {
      if (!Buffer2.isBuffer(b2)) throw new TypeError("Argument must be a Buffer");
      if (this === b2) return true;
      return Buffer2.compare(this, b2) === 0;
    };
    Buffer2.prototype.inspect = function inspect() {
      let str = "";
      const max = exports2.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max) str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
    }
    Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer2.from(target, target.offset, target.byteLength);
      }
      if (!Buffer2.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target) return 0;
      let x = thisEnd - thisStart;
      let y = end - start;
      const len = Math.min(x, y);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      if (buffer.length === 0) return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
      }
      if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
      }
      if (typeof val === "string") {
        val = Buffer2.from(val, encoding);
      }
      if (Buffer2.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i2) {
        if (indexSize === 1) {
          return buf[i2];
        } else {
          return buf.readUInt16BE(i2 * indexSize);
        }
      }
      let i;
      if (dir) {
        let foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          let found = true;
          for (let j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break;
            }
          }
          if (found) return i;
        }
      }
      return -1;
    }
    Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      const remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      const strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      let i;
      for (i = 0; i < length; ++i) {
        const parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
      }
      return i;
    }
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes2(string, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }
    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }
    Buffer2.prototype.write = function write(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0) encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      const remaining = this.length - offset;
      if (length === void 0 || length > remaining) length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding) encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer2.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      const res = [];
      let i = start;
      while (i < end) {
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      const len = buf.length;
      if (!start || start < 0) start = 0;
      if (!end || end < 0 || end > len) end = len;
      let out = "";
      for (let i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf[i]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      const bytes = buf.slice(start, end);
      let res = "";
      for (let i = 0; i < bytes.length - 1; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res;
    }
    Buffer2.prototype.slice = function slice(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0) start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0) end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start) end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer2.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
      if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      let val = this[offset + --byteLength2];
      let mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    });
    Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    });
    Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let i = byteLength2;
      let mul = 1;
      let val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128)) return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    });
    Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first << 24) + // Overflow
      this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
    });
    Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer2.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
    }
    Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let mul = 1;
      let i = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function wrtBigUInt64LE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      return offset;
    }
    function wrtBigUInt64BE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset + 7] = lo;
      lo = lo >> 8;
      buf[offset + 6] = lo;
      lo = lo >> 8;
      buf[offset + 5] = lo;
      lo = lo >> 8;
      buf[offset + 4] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset + 3] = hi;
      hi = hi >> 8;
      buf[offset + 2] = hi;
      hi = hi >> 8;
      buf[offset + 1] = hi;
      hi = hi >> 8;
      buf[offset] = hi;
      return offset + 8;
    }
    Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = 0;
      let mul = 1;
      let sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      let sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
      if (value < 0) value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0) value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
      if (offset < 0) throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer2.isBuffer(target)) throw new TypeError("argument should be a Buffer");
      if (!start) start = 0;
      if (!end && end !== 0) end = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end > 0 && end < start) end = start;
      if (end === start) return 0;
      if (target.length === 0 || this.length === 0) return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
      if (end < 0) throw new RangeError("sourceEnd out of bounds");
      if (end > this.length) end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    };
    Buffer2.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val) val = 0;
      let i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    var errors = {};
    function E(sym, getMessage, Base) {
      errors[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(name) {
        if (name) {
          return `${name} is outside of buffer bounds`;
        }
        return "Attempt to access memory outside buffer bounds";
      },
      RangeError
    );
    E(
      "ERR_INVALID_ARG_TYPE",
      function(name, actual) {
        return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
      },
      TypeError
    );
    E(
      "ERR_OUT_OF_RANGE",
      function(str, range, input) {
        let msg = `The value of "${str}" is out of range.`;
        let received = input;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        }
        msg += ` It must be ${range}. Received ${received}`;
        return msg;
      },
      RangeError
    );
    function addNumericalSeparator(val) {
      let res = "";
      let i = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i >= start + 4; i -= 3) {
        res = `_${val.slice(i - 3, i)}${res}`;
      }
      return `${val.slice(0, i)}${res}`;
    }
    function checkBounds(buf, offset, byteLength2) {
      validateNumber(offset, "offset");
      if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
        boundsError(offset, buf.length - (byteLength2 + 1));
      }
    }
    function checkIntBI(value, min, max, buf, offset, byteLength2) {
      if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
          if (min === 0 || min === BigInt(0)) {
            range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
          } else {
            range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
          }
        } else {
          range = `>= ${min}${n} and <= ${max}${n}`;
        }
        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
      }
      checkBounds(buf, offset, byteLength2);
    }
    function validateNumber(value, name) {
      if (typeof value !== "number") {
        throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
      }
    }
    function boundsError(value, length, type) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
      }
      if (length < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors.ERR_OUT_OF_RANGE(
        type || "offset",
        `>= ${type ? 1 : 0} and <= ${length}`,
        value
      );
    }
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2) return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes2(string, units) {
      units = units || Infinity;
      let codePoint;
      const length = string.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            } else if (i + 1 === length) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0) break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0) break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0) break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0) break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      let c, hi, lo;
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length) {
      let i;
      for (i = 0; i < length; ++i) {
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
      }
      return i;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      const alphabet = "0123456789abcdef";
      const table = new Array(256);
      for (let i = 0; i < 16; ++i) {
        const i16 = i * 16;
        for (let j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet[i] + alphabet[j];
        }
      }
      return table;
    }();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports2, module2) {
    var buffer = require_buffer();
    var Buffer2 = buffer.Buffer;
    function copyProps2(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps2(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps2(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/isarray/index.js
var require_isarray = __commonJS({
  "node_modules/isarray/index.js"(exports2, module2) {
    var toString = {}.toString;
    module2.exports = Array.isArray || function(arr) {
      return toString.call(arr) == "[object Array]";
    };
  }
});

// node_modules/es-errors/type.js
var require_type = __commonJS({
  "node_modules/es-errors/type.js"(exports2, module2) {
    "use strict";
    module2.exports = TypeError;
  }
});

// node_modules/es-object-atoms/index.js
var require_es_object_atoms = __commonJS({
  "node_modules/es-object-atoms/index.js"(exports2, module2) {
    "use strict";
    module2.exports = Object;
  }
});

// node_modules/es-errors/index.js
var require_es_errors = __commonJS({
  "node_modules/es-errors/index.js"(exports2, module2) {
    "use strict";
    module2.exports = Error;
  }
});

// node_modules/es-errors/eval.js
var require_eval = __commonJS({
  "node_modules/es-errors/eval.js"(exports2, module2) {
    "use strict";
    module2.exports = EvalError;
  }
});

// node_modules/es-errors/range.js
var require_range2 = __commonJS({
  "node_modules/es-errors/range.js"(exports2, module2) {
    "use strict";
    module2.exports = RangeError;
  }
});

// node_modules/es-errors/ref.js
var require_ref = __commonJS({
  "node_modules/es-errors/ref.js"(exports2, module2) {
    "use strict";
    module2.exports = ReferenceError;
  }
});

// node_modules/es-errors/syntax.js
var require_syntax = __commonJS({
  "node_modules/es-errors/syntax.js"(exports2, module2) {
    "use strict";
    module2.exports = SyntaxError;
  }
});

// node_modules/es-errors/uri.js
var require_uri = __commonJS({
  "node_modules/es-errors/uri.js"(exports2, module2) {
    "use strict";
    module2.exports = URIError;
  }
});

// node_modules/math-intrinsics/abs.js
var require_abs = __commonJS({
  "node_modules/math-intrinsics/abs.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.abs;
  }
});

// node_modules/math-intrinsics/floor.js
var require_floor = __commonJS({
  "node_modules/math-intrinsics/floor.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.floor;
  }
});

// node_modules/math-intrinsics/max.js
var require_max = __commonJS({
  "node_modules/math-intrinsics/max.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.max;
  }
});

// node_modules/math-intrinsics/min.js
var require_min = __commonJS({
  "node_modules/math-intrinsics/min.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.min;
  }
});

// node_modules/math-intrinsics/pow.js
var require_pow = __commonJS({
  "node_modules/math-intrinsics/pow.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.pow;
  }
});

// node_modules/math-intrinsics/round.js
var require_round = __commonJS({
  "node_modules/math-intrinsics/round.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.round;
  }
});

// node_modules/math-intrinsics/isNaN.js
var require_isNaN = __commonJS({
  "node_modules/math-intrinsics/isNaN.js"(exports2, module2) {
    "use strict";
    module2.exports = Number.isNaN || function isNaN2(a) {
      return a !== a;
    };
  }
});

// node_modules/math-intrinsics/sign.js
var require_sign = __commonJS({
  "node_modules/math-intrinsics/sign.js"(exports2, module2) {
    "use strict";
    var $isNaN = require_isNaN();
    module2.exports = function sign(number) {
      if ($isNaN(number) || number === 0) {
        return number;
      }
      return number < 0 ? -1 : 1;
    };
  }
});

// node_modules/gopd/gOPD.js
var require_gOPD = __commonJS({
  "node_modules/gopd/gOPD.js"(exports2, module2) {
    "use strict";
    module2.exports = Object.getOwnPropertyDescriptor;
  }
});

// node_modules/gopd/index.js
var require_gopd = __commonJS({
  "node_modules/gopd/index.js"(exports2, module2) {
    "use strict";
    var $gOPD = require_gOPD();
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e) {
        $gOPD = null;
      }
    }
    module2.exports = $gOPD;
  }
});

// node_modules/es-define-property/index.js
var require_es_define_property = __commonJS({
  "node_modules/es-define-property/index.js"(exports2, module2) {
    "use strict";
    var $defineProperty = Object.defineProperty || false;
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = false;
      }
    }
    module2.exports = $defineProperty;
  }
});

// node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "node_modules/has-symbols/shams.js"(exports2, module2) {
    "use strict";
    module2.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (var _ in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = (
          /** @type {PropertyDescriptor} */
          Object.getOwnPropertyDescriptor(obj, sym)
        );
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "node_modules/has-symbols/index.js"(exports2, module2) {
    "use strict";
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module2.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// node_modules/get-proto/Reflect.getPrototypeOf.js
var require_Reflect_getPrototypeOf = __commonJS({
  "node_modules/get-proto/Reflect.getPrototypeOf.js"(exports2, module2) {
    "use strict";
    module2.exports = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
  }
});

// node_modules/get-proto/Object.getPrototypeOf.js
var require_Object_getPrototypeOf = __commonJS({
  "node_modules/get-proto/Object.getPrototypeOf.js"(exports2, module2) {
    "use strict";
    var $Object = require_es_object_atoms();
    module2.exports = $Object.getPrototypeOf || null;
  }
});

// node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "node_modules/function-bind/implementation.js"(exports2, module2) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var toStr = Object.prototype.toString;
    var max = Math.max;
    var funcType = "[object Function]";
    var concatty = function concatty2(a, b2) {
      var arr = [];
      for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
      }
      for (var j = 0; j < b2.length; j += 1) {
        arr[j + a.length] = b2[j];
      }
      return arr;
    };
    var slicy = function slicy2(arrLike, offset) {
      var arr = [];
      for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
      }
      return arr;
    };
    var joiny = function(arr, joiner) {
      var str = "";
      for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
          str += joiner;
        }
      }
      return str;
    };
    module2.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slicy(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            concatty(args, arguments)
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        }
        return target.apply(
          that,
          concatty(args, arguments)
        );
      };
      var boundLength = max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = "$" + i;
      }
      bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "node_modules/function-bind/index.js"(exports2, module2) {
    "use strict";
    var implementation = require_implementation();
    module2.exports = Function.prototype.bind || implementation;
  }
});

// node_modules/call-bind-apply-helpers/functionCall.js
var require_functionCall = __commonJS({
  "node_modules/call-bind-apply-helpers/functionCall.js"(exports2, module2) {
    "use strict";
    module2.exports = Function.prototype.call;
  }
});

// node_modules/call-bind-apply-helpers/functionApply.js
var require_functionApply = __commonJS({
  "node_modules/call-bind-apply-helpers/functionApply.js"(exports2, module2) {
    "use strict";
    module2.exports = Function.prototype.apply;
  }
});

// node_modules/call-bind-apply-helpers/reflectApply.js
var require_reflectApply = __commonJS({
  "node_modules/call-bind-apply-helpers/reflectApply.js"(exports2, module2) {
    "use strict";
    module2.exports = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
  }
});

// node_modules/call-bind-apply-helpers/actualApply.js
var require_actualApply = __commonJS({
  "node_modules/call-bind-apply-helpers/actualApply.js"(exports2, module2) {
    "use strict";
    var bind = require_function_bind();
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var $reflectApply = require_reflectApply();
    module2.exports = $reflectApply || bind.call($call, $apply);
  }
});

// node_modules/call-bind-apply-helpers/index.js
var require_call_bind_apply_helpers = __commonJS({
  "node_modules/call-bind-apply-helpers/index.js"(exports2, module2) {
    "use strict";
    var bind = require_function_bind();
    var $TypeError = require_type();
    var $call = require_functionCall();
    var $actualApply = require_actualApply();
    module2.exports = function callBindBasic(args) {
      if (args.length < 1 || typeof args[0] !== "function") {
        throw new $TypeError("a function is required");
      }
      return $actualApply(bind, $call, args);
    };
  }
});

// node_modules/dunder-proto/get.js
var require_get = __commonJS({
  "node_modules/dunder-proto/get.js"(exports2, module2) {
    "use strict";
    var callBind = require_call_bind_apply_helpers();
    var gOPD = require_gopd();
    var hasProtoAccessor;
    try {
      hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */
      [].__proto__ === Array.prototype;
    } catch (e) {
      if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") {
        throw e;
      }
    }
    var desc = !!hasProtoAccessor && gOPD && gOPD(
      Object.prototype,
      /** @type {keyof typeof Object.prototype} */
      "__proto__"
    );
    var $Object = Object;
    var $getPrototypeOf = $Object.getPrototypeOf;
    module2.exports = desc && typeof desc.get === "function" ? callBind([desc.get]) : typeof $getPrototypeOf === "function" ? (
      /** @type {import('./get')} */
      function getDunder(value) {
        return $getPrototypeOf(value == null ? value : $Object(value));
      }
    ) : false;
  }
});

// node_modules/get-proto/index.js
var require_get_proto = __commonJS({
  "node_modules/get-proto/index.js"(exports2, module2) {
    "use strict";
    var reflectGetProto = require_Reflect_getPrototypeOf();
    var originalGetProto = require_Object_getPrototypeOf();
    var getDunderProto = require_get();
    module2.exports = reflectGetProto ? function getProto(O) {
      return reflectGetProto(O);
    } : originalGetProto ? function getProto(O) {
      if (!O || typeof O !== "object" && typeof O !== "function") {
        throw new TypeError("getProto: not an object");
      }
      return originalGetProto(O);
    } : getDunderProto ? function getProto(O) {
      return getDunderProto(O);
    } : null;
  }
});

// node_modules/hasown/index.js
var require_hasown = __commonJS({
  "node_modules/hasown/index.js"(exports2, module2) {
    "use strict";
    var call = Function.prototype.call;
    var $hasOwn = Object.prototype.hasOwnProperty;
    var bind = require_function_bind();
    module2.exports = bind.call(call, $hasOwn);
  }
});

// node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "node_modules/get-intrinsic/index.js"(exports2, module2) {
    "use strict";
    var undefined2;
    var $Object = require_es_object_atoms();
    var $Error = require_es_errors();
    var $EvalError = require_eval();
    var $RangeError = require_range2();
    var $ReferenceError = require_ref();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var $URIError = require_uri();
    var abs = require_abs();
    var floor = require_floor();
    var max = require_max();
    var min = require_min();
    var pow = require_pow();
    var round = require_round();
    var sign = require_sign();
    var $Function = Function;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e) {
      }
    };
    var $gOPD = require_gopd();
    var $defineProperty = require_es_define_property();
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var getProto = require_get_proto();
    var $ObjectGPO = require_Object_getPrototypeOf();
    var $ReflectGPO = require_Reflect_getPrototypeOf();
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      __proto__: null,
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": $Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": $EvalError,
      "%Float16Array%": typeof Float16Array === "undefined" ? undefined2 : Float16Array,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": $Object,
      "%Object.getOwnPropertyDescriptor%": $gOPD,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": $RangeError,
      "%ReferenceError%": $ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": $URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet,
      "%Function.prototype.call%": $call,
      "%Function.prototype.apply%": $apply,
      "%Object.defineProperty%": $defineProperty,
      "%Object.getPrototypeOf%": $ObjectGPO,
      "%Math.abs%": abs,
      "%Math.floor%": floor,
      "%Math.max%": max,
      "%Math.min%": min,
      "%Math.pow%": pow,
      "%Math.round%": round,
      "%Math.sign%": sign,
      "%Reflect.getPrototypeOf%": $ReflectGPO
    };
    if (getProto) {
      try {
        null.error;
      } catch (e) {
        errorProto = getProto(getProto(e));
        INTRINSICS["%Error.prototype%"] = errorProto;
      }
    }
    var errorProto;
    var doEval = function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen && getProto) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      __proto__: null,
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind();
    var hasOwn = require_hasown();
    var $concat = bind.call($call, Array.prototype.concat);
    var $spliceApply = bind.call($apply, Array.prototype.splice);
    var $replace = bind.call($call, String.prototype.replace);
    var $strSlice = bind.call($call, String.prototype.slice);
    var $exec = bind.call($call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string) {
      var first = $strSlice(string, 0, 1);
      var last = $strSlice(string, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
      var intrinsicName = name;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    };
    module2.exports = function GetIntrinsic(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i = 1, isOwn = true; i < parts.length; i += 1) {
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
            }
            return void 0;
          }
          if ($gOPD && i + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});

// node_modules/call-bound/index.js
var require_call_bound = __commonJS({
  "node_modules/call-bound/index.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBindBasic = require_call_bind_apply_helpers();
    var $indexOf = callBindBasic([GetIntrinsic("%String.prototype.indexOf%")]);
    module2.exports = function callBoundIntrinsic(name, allowMissing) {
      var intrinsic = (
        /** @type {(this: unknown, ...args: unknown[]) => unknown} */
        GetIntrinsic(name, !!allowMissing)
      );
      if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
        return callBindBasic(
          /** @type {const} */
          [intrinsic]
        );
      }
      return intrinsic;
    };
  }
});

// node_modules/is-callable/index.js
var require_is_callable = __commonJS({
  "node_modules/is-callable/index.js"(exports2, module2) {
    "use strict";
    var fnToStr = Function.prototype.toString;
    var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
    var badArrayLike;
    var isCallableMarker;
    if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") {
      try {
        badArrayLike = Object.defineProperty({}, "length", {
          get: function() {
            throw isCallableMarker;
          }
        });
        isCallableMarker = {};
        reflectApply(function() {
          throw 42;
        }, null, badArrayLike);
      } catch (_) {
        if (_ !== isCallableMarker) {
          reflectApply = null;
        }
      }
    } else {
      reflectApply = null;
    }
    var constructorRegex = /^\s*class\b/;
    var isES6ClassFn = function isES6ClassFunction(value) {
      try {
        var fnStr = fnToStr.call(value);
        return constructorRegex.test(fnStr);
      } catch (e) {
        return false;
      }
    };
    var tryFunctionObject = function tryFunctionToStr(value) {
      try {
        if (isES6ClassFn(value)) {
          return false;
        }
        fnToStr.call(value);
        return true;
      } catch (e) {
        return false;
      }
    };
    var toStr = Object.prototype.toString;
    var objectClass = "[object Object]";
    var fnClass = "[object Function]";
    var genClass = "[object GeneratorFunction]";
    var ddaClass = "[object HTMLAllCollection]";
    var ddaClass2 = "[object HTML document.all class]";
    var ddaClass3 = "[object HTMLCollection]";
    var hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag;
    var isIE68 = !(0 in [,]);
    var isDDA = function isDocumentDotAll() {
      return false;
    };
    if (typeof document === "object") {
      all = document.all;
      if (toStr.call(all) === toStr.call(document.all)) {
        isDDA = function isDocumentDotAll(value) {
          if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) {
            try {
              var str = toStr.call(value);
              return (str === ddaClass || str === ddaClass2 || str === ddaClass3 || str === objectClass) && value("") == null;
            } catch (e) {
            }
          }
          return false;
        };
      }
    }
    var all;
    module2.exports = reflectApply ? function isCallable(value) {
      if (isDDA(value)) {
        return true;
      }
      if (!value) {
        return false;
      }
      if (typeof value !== "function" && typeof value !== "object") {
        return false;
      }
      try {
        reflectApply(value, null, badArrayLike);
      } catch (e) {
        if (e !== isCallableMarker) {
          return false;
        }
      }
      return !isES6ClassFn(value) && tryFunctionObject(value);
    } : function isCallable(value) {
      if (isDDA(value)) {
        return true;
      }
      if (!value) {
        return false;
      }
      if (typeof value !== "function" && typeof value !== "object") {
        return false;
      }
      if (hasToStringTag) {
        return tryFunctionObject(value);
      }
      if (isES6ClassFn(value)) {
        return false;
      }
      var strClass = toStr.call(value);
      if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
        return false;
      }
      return tryFunctionObject(value);
    };
  }
});

// node_modules/for-each/index.js
var require_for_each = __commonJS({
  "node_modules/for-each/index.js"(exports2, module2) {
    "use strict";
    var isCallable = require_is_callable();
    var toStr = Object.prototype.toString;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var forEachArray = function forEachArray2(array, iterator, receiver) {
      for (var i = 0, len = array.length; i < len; i++) {
        if (hasOwnProperty.call(array, i)) {
          if (receiver == null) {
            iterator(array[i], i, array);
          } else {
            iterator.call(receiver, array[i], i, array);
          }
        }
      }
    };
    var forEachString = function forEachString2(string, iterator, receiver) {
      for (var i = 0, len = string.length; i < len; i++) {
        if (receiver == null) {
          iterator(string.charAt(i), i, string);
        } else {
          iterator.call(receiver, string.charAt(i), i, string);
        }
      }
    };
    var forEachObject = function forEachObject2(object, iterator, receiver) {
      for (var k in object) {
        if (hasOwnProperty.call(object, k)) {
          if (receiver == null) {
            iterator(object[k], k, object);
          } else {
            iterator.call(receiver, object[k], k, object);
          }
        }
      }
    };
    function isArray(x) {
      return toStr.call(x) === "[object Array]";
    }
    module2.exports = function forEach(list, iterator, thisArg) {
      if (!isCallable(iterator)) {
        throw new TypeError("iterator must be a function");
      }
      var receiver;
      if (arguments.length >= 3) {
        receiver = thisArg;
      }
      if (isArray(list)) {
        forEachArray(list, iterator, receiver);
      } else if (typeof list === "string") {
        forEachString(list, iterator, receiver);
      } else {
        forEachObject(list, iterator, receiver);
      }
    };
  }
});

// node_modules/possible-typed-array-names/index.js
var require_possible_typed_array_names = __commonJS({
  "node_modules/possible-typed-array-names/index.js"(exports2, module2) {
    "use strict";
    module2.exports = [
      "Float16Array",
      "Float32Array",
      "Float64Array",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "BigInt64Array",
      "BigUint64Array"
    ];
  }
});

// node_modules/available-typed-arrays/index.js
var require_available_typed_arrays = __commonJS({
  "node_modules/available-typed-arrays/index.js"(exports2, module2) {
    "use strict";
    var possibleNames = require_possible_typed_array_names();
    var g = typeof globalThis === "undefined" ? globalThis : globalThis;
    module2.exports = function availableTypedArrays() {
      var out = [];
      for (var i = 0; i < possibleNames.length; i++) {
        if (typeof g[possibleNames[i]] === "function") {
          out[out.length] = possibleNames[i];
        }
      }
      return out;
    };
  }
});

// node_modules/define-data-property/index.js
var require_define_data_property = __commonJS({
  "node_modules/define-data-property/index.js"(exports2, module2) {
    "use strict";
    var $defineProperty = require_es_define_property();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var gopd = require_gopd();
    module2.exports = function defineDataProperty(obj, property, value) {
      if (!obj || typeof obj !== "object" && typeof obj !== "function") {
        throw new $TypeError("`obj` must be an object or a function`");
      }
      if (typeof property !== "string" && typeof property !== "symbol") {
        throw new $TypeError("`property` must be a string or a symbol`");
      }
      if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
        throw new $TypeError("`nonEnumerable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
        throw new $TypeError("`nonWritable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
        throw new $TypeError("`nonConfigurable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
        throw new $TypeError("`loose`, if provided, must be a boolean");
      }
      var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
      var nonWritable = arguments.length > 4 ? arguments[4] : null;
      var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
      var loose = arguments.length > 6 ? arguments[6] : false;
      var desc = !!gopd && gopd(obj, property);
      if ($defineProperty) {
        $defineProperty(obj, property, {
          configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
          enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
          value,
          writable: nonWritable === null && desc ? desc.writable : !nonWritable
        });
      } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
        obj[property] = value;
      } else {
        throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
      }
    };
  }
});

// node_modules/has-property-descriptors/index.js
var require_has_property_descriptors = __commonJS({
  "node_modules/has-property-descriptors/index.js"(exports2, module2) {
    "use strict";
    var $defineProperty = require_es_define_property();
    var hasPropertyDescriptors = function hasPropertyDescriptors2() {
      return !!$defineProperty;
    };
    hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
      if (!$defineProperty) {
        return null;
      }
      try {
        return $defineProperty([], "length", { value: 1 }).length !== 1;
      } catch (e) {
        return true;
      }
    };
    module2.exports = hasPropertyDescriptors;
  }
});

// node_modules/set-function-length/index.js
var require_set_function_length = __commonJS({
  "node_modules/set-function-length/index.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var define2 = require_define_data_property();
    var hasDescriptors = require_has_property_descriptors()();
    var gOPD = require_gopd();
    var $TypeError = require_type();
    var $floor = GetIntrinsic("%Math.floor%");
    module2.exports = function setFunctionLength(fn, length) {
      if (typeof fn !== "function") {
        throw new $TypeError("`fn` is not a function");
      }
      if (typeof length !== "number" || length < 0 || length > 4294967295 || $floor(length) !== length) {
        throw new $TypeError("`length` must be a positive 32-bit integer");
      }
      var loose = arguments.length > 2 && !!arguments[2];
      var functionLengthIsConfigurable = true;
      var functionLengthIsWritable = true;
      if ("length" in fn && gOPD) {
        var desc = gOPD(fn, "length");
        if (desc && !desc.configurable) {
          functionLengthIsConfigurable = false;
        }
        if (desc && !desc.writable) {
          functionLengthIsWritable = false;
        }
      }
      if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
        if (hasDescriptors) {
          define2(
            /** @type {Parameters<define>[0]} */
            fn,
            "length",
            length,
            true,
            true
          );
        } else {
          define2(
            /** @type {Parameters<define>[0]} */
            fn,
            "length",
            length
          );
        }
      }
      return fn;
    };
  }
});

// node_modules/call-bind-apply-helpers/applyBind.js
var require_applyBind = __commonJS({
  "node_modules/call-bind-apply-helpers/applyBind.js"(exports2, module2) {
    "use strict";
    var bind = require_function_bind();
    var $apply = require_functionApply();
    var actualApply = require_actualApply();
    module2.exports = function applyBind() {
      return actualApply(bind, $apply, arguments);
    };
  }
});

// node_modules/call-bind/index.js
var require_call_bind = __commonJS({
  "node_modules/call-bind/index.js"(exports2, module2) {
    "use strict";
    var setFunctionLength = require_set_function_length();
    var $defineProperty = require_es_define_property();
    var callBindBasic = require_call_bind_apply_helpers();
    var applyBind = require_applyBind();
    module2.exports = function callBind(originalFunction) {
      var func = callBindBasic(arguments);
      var adjustedLength = originalFunction.length - (arguments.length - 1);
      return setFunctionLength(
        func,
        1 + (adjustedLength > 0 ? adjustedLength : 0),
        true
      );
    };
    if ($defineProperty) {
      $defineProperty(module2.exports, "apply", { value: applyBind });
    } else {
      module2.exports.apply = applyBind;
    }
  }
});

// node_modules/has-tostringtag/shams.js
var require_shams2 = __commonJS({
  "node_modules/has-tostringtag/shams.js"(exports2, module2) {
    "use strict";
    var hasSymbols = require_shams();
    module2.exports = function hasToStringTagShams() {
      return hasSymbols() && !!Symbol.toStringTag;
    };
  }
});

// node_modules/which-typed-array/index.js
var require_which_typed_array = __commonJS({
  "node_modules/which-typed-array/index.js"(exports2, module2) {
    "use strict";
    var forEach = require_for_each();
    var availableTypedArrays = require_available_typed_arrays();
    var callBind = require_call_bind();
    var callBound = require_call_bound();
    var gOPD = require_gopd();
    var getProto = require_get_proto();
    var $toString = callBound("Object.prototype.toString");
    var hasToStringTag = require_shams2()();
    var g = typeof globalThis === "undefined" ? globalThis : globalThis;
    var typedArrays = availableTypedArrays();
    var $slice = callBound("String.prototype.slice");
    var $indexOf = callBound("Array.prototype.indexOf", true) || function indexOf(array, value) {
      for (var i = 0; i < array.length; i += 1) {
        if (array[i] === value) {
          return i;
        }
      }
      return -1;
    };
    var cache = { __proto__: null };
    if (hasToStringTag && gOPD && getProto) {
      forEach(typedArrays, function(typedArray) {
        var arr = new g[typedArray]();
        if (Symbol.toStringTag in arr && getProto) {
          var proto = getProto(arr);
          var descriptor = gOPD(proto, Symbol.toStringTag);
          if (!descriptor && proto) {
            var superProto = getProto(proto);
            descriptor = gOPD(superProto, Symbol.toStringTag);
          }
          cache["$" + typedArray] = callBind(descriptor.get);
        }
      });
    } else {
      forEach(typedArrays, function(typedArray) {
        var arr = new g[typedArray]();
        var fn = arr.slice || arr.set;
        if (fn) {
          cache[
            /** @type {`$${import('.').TypedArrayName}`} */
            "$" + typedArray
          ] = /** @type {import('./types').BoundSlice | import('./types').BoundSet} */
          // @ts-expect-error TODO FIXME
          callBind(fn);
        }
      });
    }
    var tryTypedArrays = function tryAllTypedArrays(value) {
      var found = false;
      forEach(
        /** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */
        cache,
        /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
        function(getter, typedArray) {
          if (!found) {
            try {
              if ("$" + getter(value) === typedArray) {
                found = /** @type {import('.').TypedArrayName} */
                $slice(typedArray, 1);
              }
            } catch (e) {
            }
          }
        }
      );
      return found;
    };
    var trySlices = function tryAllSlices(value) {
      var found = false;
      forEach(
        /** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */
        cache,
        /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
        function(getter, name) {
          if (!found) {
            try {
              getter(value);
              found = /** @type {import('.').TypedArrayName} */
              $slice(name, 1);
            } catch (e) {
            }
          }
        }
      );
      return found;
    };
    module2.exports = function whichTypedArray(value) {
      if (!value || typeof value !== "object") {
        return false;
      }
      if (!hasToStringTag) {
        var tag = $slice($toString(value), 8, -1);
        if ($indexOf(typedArrays, tag) > -1) {
          return tag;
        }
        if (tag !== "Object") {
          return false;
        }
        return trySlices(value);
      }
      if (!gOPD) {
        return null;
      }
      return tryTypedArrays(value);
    };
  }
});

// node_modules/is-typed-array/index.js
var require_is_typed_array = __commonJS({
  "node_modules/is-typed-array/index.js"(exports2, module2) {
    "use strict";
    var whichTypedArray = require_which_typed_array();
    module2.exports = function isTypedArray(value) {
      return !!whichTypedArray(value);
    };
  }
});

// node_modules/typed-array-buffer/index.js
var require_typed_array_buffer = __commonJS({
  "node_modules/typed-array-buffer/index.js"(exports2, module2) {
    "use strict";
    var $TypeError = require_type();
    var callBound = require_call_bound();
    var $typedArrayBuffer = callBound("TypedArray.prototype.buffer", true);
    var isTypedArray = require_is_typed_array();
    module2.exports = $typedArrayBuffer || function typedArrayBuffer(x) {
      if (!isTypedArray(x)) {
        throw new $TypeError("Not a Typed Array");
      }
      return x.buffer;
    };
  }
});

// node_modules/to-buffer/index.js
var require_to_buffer = __commonJS({
  "node_modules/to-buffer/index.js"(exports2, module2) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var isArray = require_isarray();
    var typedArrayBuffer = require_typed_array_buffer();
    var isView = ArrayBuffer.isView || function isView2(obj) {
      try {
        typedArrayBuffer(obj);
        return true;
      } catch (e) {
        return false;
      }
    };
    var useUint8Array = typeof Uint8Array !== "undefined";
    var useArrayBuffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined";
    var useFromArrayBuffer = useArrayBuffer && (Buffer2.prototype instanceof Uint8Array || Buffer2.TYPED_ARRAY_SUPPORT);
    module2.exports = function toBuffer(data, encoding) {
      if (Buffer2.isBuffer(data)) {
        if (data.constructor && !("isBuffer" in data)) {
          return Buffer2.from(data);
        }
        return data;
      }
      if (typeof data === "string") {
        return Buffer2.from(data, encoding);
      }
      if (useArrayBuffer && isView(data)) {
        if (data.byteLength === 0) {
          return Buffer2.alloc(0);
        }
        if (useFromArrayBuffer) {
          var res = Buffer2.from(data.buffer, data.byteOffset, data.byteLength);
          if (res.byteLength === data.byteLength) {
            return res;
          }
        }
        var uint8 = data instanceof Uint8Array ? data : new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
        var result = Buffer2.from(uint8);
        if (result.length === data.byteLength) {
          return result;
        }
      }
      if (useUint8Array && data instanceof Uint8Array) {
        return Buffer2.from(data);
      }
      var isArr = isArray(data);
      if (isArr) {
        for (var i = 0; i < data.length; i += 1) {
          var x = data[i];
          if (typeof x !== "number" || x < 0 || x > 255 || ~~x !== x) {
            throw new RangeError("Array items must be numbers in the range 0-255.");
          }
        }
      }
      if (isArr || Buffer2.isBuffer(data) && data.constructor && typeof data.constructor.isBuffer === "function" && data.constructor.isBuffer(data)) {
        return Buffer2.from(data);
      }
      throw new TypeError('The "data" argument must be a string, an Array, a Buffer, a Uint8Array, or a DataView.');
    };
  }
});

// node_modules/hash-base/to-buffer.js
var require_to_buffer2 = __commonJS({
  "node_modules/hash-base/to-buffer.js"(exports2, module2) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var toBuffer = require_to_buffer();
    var useUint8Array = typeof Uint8Array !== "undefined";
    var useArrayBuffer = useUint8Array && typeof ArrayBuffer !== "undefined";
    var isView = useArrayBuffer && ArrayBuffer.isView;
    module2.exports = function(thing, encoding) {
      if (typeof thing === "string" || Buffer2.isBuffer(thing) || useUint8Array && thing instanceof Uint8Array || isView && isView(thing)) {
        return toBuffer(thing, encoding);
      }
      throw new TypeError('The "data" argument must be a string, a Buffer, a Uint8Array, or a DataView');
    };
  }
});

// node_modules/process-nextick-args/index.js
var require_process_nextick_args = __commonJS({
  "node_modules/process-nextick-args/index.js"(exports2, module2) {
    "use strict";
    if (typeof process === "undefined" || !process.version || process.version.indexOf("v0.") === 0 || process.version.indexOf("v1.") === 0 && process.version.indexOf("v1.8.") !== 0) {
      module2.exports = { nextTick };
    } else {
      module2.exports = process;
    }
    function nextTick(fn, arg1, arg2, arg3) {
      if (typeof fn !== "function") {
        throw new TypeError('"callback" argument must be a function');
      }
      var len = arguments.length;
      var args, i;
      switch (len) {
        case 0:
        case 1:
          return process.nextTick(fn);
        case 2:
          return process.nextTick(function afterTickOne() {
            fn.call(null, arg1);
          });
        case 3:
          return process.nextTick(function afterTickTwo() {
            fn.call(null, arg1, arg2);
          });
        case 4:
          return process.nextTick(function afterTickThree() {
            fn.call(null, arg1, arg2, arg3);
          });
        default:
          args = new Array(len - 1);
          i = 0;
          while (i < args.length) {
            args[i++] = arguments[i];
          }
          return process.nextTick(function afterTick() {
            fn.apply(null, args);
          });
      }
    }
  }
});

// node_modules/hash-base/node_modules/isarray/index.js
var require_isarray2 = __commonJS({
  "node_modules/hash-base/node_modules/isarray/index.js"(exports2, module2) {
    var toString = {}.toString;
    module2.exports = Array.isArray || function(arr) {
      return toString.call(arr) == "[object Array]";
    };
  }
});

// node_modules/hash-base/node_modules/readable-stream/lib/internal/streams/stream-browser.js
var require_stream_browser = __commonJS({
  "node_modules/hash-base/node_modules/readable-stream/lib/internal/streams/stream-browser.js"(exports2, module2) {
    module2.exports = require_events().EventEmitter;
  }
});

// node_modules/hash-base/node_modules/readable-stream/node_modules/safe-buffer/index.js
var require_safe_buffer2 = __commonJS({
  "node_modules/hash-base/node_modules/readable-stream/node_modules/safe-buffer/index.js"(exports2, module2) {
    var buffer = require_buffer();
    var Buffer2 = buffer.Buffer;
    function copyProps2(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps2(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    copyProps2(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/core-util-is/lib/util.js
var require_util = __commonJS({
  "node_modules/core-util-is/lib/util.js"(exports2) {
    function isArray(arg) {
      if (Array.isArray) {
        return Array.isArray(arg);
      }
      return objectToString(arg) === "[object Array]";
    }
    exports2.isArray = isArray;
    function isBoolean(arg) {
      return typeof arg === "boolean";
    }
    exports2.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports2.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports2.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === "number";
    }
    exports2.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === "string";
    }
    exports2.isString = isString;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    exports2.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports2.isUndefined = isUndefined;
    function isRegExp(re) {
      return objectToString(re) === "[object RegExp]";
    }
    exports2.isRegExp = isRegExp;
    function isObject2(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports2.isObject = isObject2;
    function isDate(d) {
      return objectToString(d) === "[object Date]";
    }
    exports2.isDate = isDate;
    function isError(e) {
      return objectToString(e) === "[object Error]" || e instanceof Error;
    }
    exports2.isError = isError;
    function isFunction(arg) {
      return typeof arg === "function";
    }
    exports2.isFunction = isFunction;
    function isPrimitive(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
      typeof arg === "undefined";
    }
    exports2.isPrimitive = isPrimitive;
    exports2.isBuffer = require_buffer().Buffer.isBuffer;
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
  }
});

// (disabled):util
var require_util2 = __commonJS({
  "(disabled):util"() {
  }
});

// node_modules/hash-base/node_modules/readable-stream/lib/internal/streams/BufferList.js
var require_BufferList = __commonJS({
  "node_modules/hash-base/node_modules/readable-stream/lib/internal/streams/BufferList.js"(exports2, module2) {
    "use strict";
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var Buffer2 = require_safe_buffer2().Buffer;
    var util = require_util2();
    function copyBuffer(src, target, offset) {
      src.copy(target, offset);
    }
    module2.exports = function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      BufferList.prototype.push = function push(v) {
        var entry = { data: v, next: null };
        if (this.length > 0) this.tail.next = entry;
        else this.head = entry;
        this.tail = entry;
        ++this.length;
      };
      BufferList.prototype.unshift = function unshift(v) {
        var entry = { data: v, next: this.head };
        if (this.length === 0) this.tail = entry;
        this.head = entry;
        ++this.length;
      };
      BufferList.prototype.shift = function shift() {
        if (this.length === 0) return;
        var ret = this.head.data;
        if (this.length === 1) this.head = this.tail = null;
        else this.head = this.head.next;
        --this.length;
        return ret;
      };
      BufferList.prototype.clear = function clear() {
        this.head = this.tail = null;
        this.length = 0;
      };
      BufferList.prototype.join = function join(s) {
        if (this.length === 0) return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next) {
          ret += s + p.data;
        }
        return ret;
      };
      BufferList.prototype.concat = function concat(n) {
        if (this.length === 0) return Buffer2.alloc(0);
        var ret = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      };
      return BufferList;
    }();
    if (util && util.inspect && util.inspect.custom) {
      module2.exports.prototype[util.inspect.custom] = function() {
        var obj = util.inspect({ length: this.length });
        return this.constructor.name + " " + obj;
      };
    }
  }
});

// node_modules/hash-base/node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "node_modules/hash-base/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            pna.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            pna.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            pna.nextTick(emitErrorNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            pna.nextTick(emitErrorNT, _this, err2);
          }
        } else if (cb) {
          cb(err2);
        }
      });
      return this;
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    module2.exports = {
      destroy,
      undestroy
    };
  }
});

// node_modules/util-deprecate/browser.js
var require_browser = __commonJS({
  "node_modules/util-deprecate/browser.js"(exports2, module2) {
    module2.exports = deprecate;
    function deprecate(fn, msg) {
      if (config("noDeprecation")) {
        return fn;
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (config("throwDeprecation")) {
            throw new Error(msg);
          } else if (config("traceDeprecation")) {
            console.trace(msg);
          } else {
            console.warn(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }
      return deprecated;
    }
    function config(name) {
      try {
        if (!globalThis.localStorage) return false;
      } catch (_) {
        return false;
      }
      var val = globalThis.localStorage[name];
      if (null == val) return false;
      return String(val).toLowerCase() === "true";
    }
  }
});

// node_modules/hash-base/node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  "node_modules/hash-base/node_modules/readable-stream/lib/_stream_writable.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    module2.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var asyncWrite = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
    var Duplex;
    Writable.WritableState = WritableState;
    var util = Object.create(require_util());
    util.inherits = require_inherits_browser();
    var internalUtil = {
      deprecate: require_browser()
    };
    var Stream = require_stream_browser();
    var Buffer2 = require_safe_buffer2().Buffer;
    var OurUint8Array = (typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy();
    util.inherits(Writable, Stream);
    function nop() {
    }
    function WritableState(options, stream) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      var isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
      var hwm = options.highWaterMark;
      var writableHwm = options.writableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0) this.highWaterMark = hwm;
      else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;
      else this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function(object) {
          if (realHasInstance.call(this, object)) return true;
          if (this !== Writable) return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function(object) {
        return object instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
        return new Writable(options);
      }
      this._writableState = new WritableState(options, this);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function") this._write = options.write;
        if (typeof options.writev === "function") this._writev = options.writev;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
        if (typeof options.final === "function") this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      this.emit("error", new Error("Cannot pipe, not readable"));
    };
    function writeAfterEnd(stream, cb) {
      var er = new Error("write after end");
      stream.emit("error", er);
      pna.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var valid = true;
      var er = false;
      if (chunk === null) {
        er = new TypeError("May not write null values to stream");
      } else if (typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      if (er) {
        stream.emit("error", er);
        pna.nextTick(cb, er);
        valid = false;
      }
      return valid;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf) encoding = "buffer";
      else if (!encoding) encoding = state.defaultEncoding;
      if (typeof cb !== "function") cb = nop;
      if (state.ended) writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      var state = this._writableState;
      state.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string") encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret) state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (writev) stream._writev(chunk, state.onwrite);
      else stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        pna.nextTick(cb, er);
        pna.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      onwriteStateUpdate(state);
      if (er) onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state);
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          asyncWrite(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished) onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf) allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null) state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error("_write() is not implemented"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending) endWritable(this, state, cb);
    };
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          stream.emit("error", err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function") {
          state.pendingcb++;
          state.finalCalled = true;
          pna.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished) pna.nextTick(cb);
        else stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      get: function() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      this.end();
      cb(err);
    };
  }
});

// node_modules/hash-base/node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  "node_modules/hash-base/node_modules/readable-stream/lib/_stream_duplex.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj) {
        keys2.push(key);
      }
      return keys2;
    };
    module2.exports = Duplex;
    var util = Object.create(require_util());
    util.inherits = require_inherits_browser();
    var Readable = require_stream_readable();
    var Writable = require_stream_writable();
    util.inherits(Duplex, Readable);
    {
      keys = objectKeys(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v;
    function Duplex(options) {
      if (!(this instanceof Duplex)) return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      if (options && options.readable === false) this.readable = false;
      if (options && options.writable === false) this.writable = false;
      this.allowHalfOpen = true;
      if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
      this.once("end", onend);
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function onend() {
      if (this.allowHalfOpen || this._writableState.ended) return;
      pna.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
    Duplex.prototype._destroy = function(err, cb) {
      this.push(null);
      this.end();
      pna.nextTick(cb, err);
    };
  }
});

// node_modules/hash-base/node_modules/string_decoder/node_modules/safe-buffer/index.js
var require_safe_buffer3 = __commonJS({
  "node_modules/hash-base/node_modules/string_decoder/node_modules/safe-buffer/index.js"(exports2, module2) {
    var buffer = require_buffer();
    var Buffer2 = buffer.Buffer;
    function copyProps2(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps2(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    copyProps2(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/hash-base/node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS({
  "node_modules/hash-base/node_modules/string_decoder/lib/string_decoder.js"(exports2) {
    "use strict";
    var Buffer2 = require_safe_buffer3().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc) return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried) return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports2.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0) return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0) return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127) return 0;
      else if (byte >> 5 === 6) return 2;
      else if (byte >> 4 === 14) return 3;
      else if (byte >> 3 === 30) return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i) return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2) return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2) return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2) nb = 0;
          else self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0) return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed) return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) return r + "\uFFFD";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0) return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// node_modules/hash-base/node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  "node_modules/hash-base/node_modules/readable-stream/lib/_stream_readable.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    module2.exports = Readable;
    var isArray = require_isarray2();
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = require_events().EventEmitter;
    var EElistenerCount = function(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream_browser();
    var Buffer2 = require_safe_buffer2().Buffer;
    var OurUint8Array = (typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var util = Object.create(require_util());
    util.inherits = require_inherits_browser();
    var debugUtil = require_util2();
    var debug = void 0;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function() {
      };
    }
    var BufferList = require_BufferList();
    var destroyImpl = require_destroy();
    var StringDecoder;
    util.inherits(Readable, Stream);
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
      else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);
      else emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      var isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
      var hwm = options.highWaterMark;
      var readableHwm = options.readableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0) this.highWaterMark = hwm;
      else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;
      else this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder) StringDecoder = require_string_decoder().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!(this instanceof Readable)) return new Readable(options);
      this._readableState = new ReadableState(options, this);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function") this._read = options.read;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      this.push(null);
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck) er = chunkInvalid(state, chunk);
        if (er) {
          stream.emit("error", er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted) stream.emit("error", new Error("stream.unshift() after end event"));
            else addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            stream.emit("error", new Error("stream.push() after EOF"));
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);
              else maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
        }
      }
      return needMoreData(state);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        stream.emit("data", chunk);
        stream.read(0);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront) state.buffer.unshift(chunk);
        else state.buffer.push(chunk);
        if (state.needReadable) emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      return er;
    }
    function needMoreData(state) {
      return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder) StringDecoder = require_string_decoder().StringDecoder;
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    };
    var MAX_HWM = 8388608;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended) return 0;
      if (state.objectMode) return 1;
      if (n !== n) {
        if (state.flowing && state.length) return state.buffer.head.data.length;
        else return state.length;
      }
      if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length) return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0) state.emittedReadable = false;
      if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended) endReadable(this);
        else emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0) endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0) state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading) n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0) ret = fromList(n, state);
      else ret = null;
      if (ret === null) {
        state.needReadable = true;
        n = 0;
      } else {
        state.length -= n;
      }
      if (state.length === 0) {
        if (!state.ended) state.needReadable = true;
        if (nOrig !== n && state.ended) endReadable(this);
      }
      if (ret !== null) this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      if (state.ended) return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      emitReadable(stream);
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        if (state.sync) pna.nextTick(emitReadable_, stream);
        else emitReadable_(stream);
      }
    }
    function emitReadable_(stream) {
      debug("emit readable");
      stream.emit("readable");
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        pna.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      var len = state.length;
      while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
        else len = state.length;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      this.emit("error", new Error("_read() is not implemented"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted) pna.nextTick(endFn);
      else src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
      }
      var increasedAwaitDrain = false;
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        increasedAwaitDrain = false;
        var ret = dest.write(chunk);
        if (false === ret && !increasedAwaitDrain) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
            increasedAwaitDrain = true;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0) dest.emit("error", er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain) state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = { hasUnpiped: false };
      if (state.pipesCount === 0) return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes) return this;
        if (!dest) dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest) dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++) {
          dests[i].emit("unpipe", this, { hasUnpiped: false });
        }
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1) return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1) state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      if (ev === "data") {
        if (this._readableState.flowing !== false) this.resume();
      } else if (ev === "readable") {
        var state = this._readableState;
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.emittedReadable = false;
          if (!state.reading) {
            pna.nextTick(nReadingNextTick, this);
          } else if (state.length) {
            emitReadable(this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = true;
        resume(this, state);
      }
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        pna.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      if (!state.reading) {
        debug("resume read 0");
        stream.read(0);
      }
      state.resumeScheduled = false;
      state.awaitDrain = 0;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading) stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (false !== this._readableState.flowing) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null) {
      }
    }
    Readable.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length) _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder) chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0)) return;
        else if (!state.objectMode && (!chunk || !chunk.length)) return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = /* @__PURE__ */ function(method) {
            return function() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._readableState.highWaterMark;
      }
    });
    Readable._fromList = fromList;
    function fromList(n, state) {
      if (state.length === 0) return null;
      var ret;
      if (state.objectMode) ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder) ret = state.buffer.join("");
        else if (state.buffer.length === 1) ret = state.buffer.head.data;
        else ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = fromListPartial(n, state.buffer, state.decoder);
      }
      return ret;
    }
    function fromListPartial(n, list, hasStrings) {
      var ret;
      if (n < list.head.data.length) {
        ret = list.head.data.slice(0, n);
        list.head.data = list.head.data.slice(n);
      } else if (n === list.head.data.length) {
        ret = list.shift();
      } else {
        ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
      }
      return ret;
    }
    function copyFromBufferString(n, list) {
      var p = list.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;
      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;
        else ret += str.slice(0, n);
        n -= nb;
        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next) list.head = p.next;
            else list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = str.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret;
    }
    function copyFromBuffer(n, list) {
      var ret = Buffer2.allocUnsafe(n);
      var p = list.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;
      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;
        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next) list.head = p.next;
            else list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = buf.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');
      if (!state.endEmitted) {
        state.ended = true;
        pna.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
      }
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) return i;
      }
      return -1;
    }
  }
});

// node_modules/hash-base/node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  "node_modules/hash-base/node_modules/readable-stream/lib/_stream_transform.js"(exports2, module2) {
    "use strict";
    module2.exports = Transform;
    var Duplex = require_stream_duplex();
    var util = Object.create(require_util());
    util.inherits = require_inherits_browser();
    util.inherits(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (!cb) {
        return this.emit("error", new Error("write callback called multiple times"));
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform)) return new Transform(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function") this._transform = options.transform;
        if (typeof options.flush === "function") this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function") {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      throw new Error("_transform() is not implemented");
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      var _this2 = this;
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
        _this2.emit("close");
      });
    };
    function done(stream, er, data) {
      if (er) return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length) throw new Error("Calling transform done when ws.length != 0");
      if (stream._transformState.transforming) throw new Error("Calling transform done when still transforming");
      return stream.push(null);
    }
  }
});

// node_modules/hash-base/node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  "node_modules/hash-base/node_modules/readable-stream/lib/_stream_passthrough.js"(exports2, module2) {
    "use strict";
    module2.exports = PassThrough;
    var Transform = require_stream_transform();
    var util = Object.create(require_util());
    util.inherits = require_inherits_browser();
    util.inherits(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough)) return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/hash-base/node_modules/readable-stream/readable-browser.js
var require_readable_browser = __commonJS({
  "node_modules/hash-base/node_modules/readable-stream/readable-browser.js"(exports2, module2) {
    exports2 = module2.exports = require_stream_readable();
    exports2.Stream = exports2;
    exports2.Readable = exports2;
    exports2.Writable = require_stream_writable();
    exports2.Duplex = require_stream_duplex();
    exports2.Transform = require_stream_transform();
    exports2.PassThrough = require_stream_passthrough();
  }
});

// node_modules/hash-base/index.js
var require_hash_base = __commonJS({
  "node_modules/hash-base/index.js"(exports2, module2) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var toBuffer = require_to_buffer2();
    var Transform = require_readable_browser().Transform;
    var inherits = require_inherits_browser();
    function HashBase(blockSize) {
      Transform.call(this);
      this._block = Buffer2.allocUnsafe(blockSize);
      this._blockSize = blockSize;
      this._blockOffset = 0;
      this._length = [0, 0, 0, 0];
      this._finalized = false;
    }
    inherits(HashBase, Transform);
    HashBase.prototype._transform = function(chunk, encoding, callback) {
      var error = null;
      try {
        this.update(chunk, encoding);
      } catch (err) {
        error = err;
      }
      callback(error);
    };
    HashBase.prototype._flush = function(callback) {
      var error = null;
      try {
        this.push(this.digest());
      } catch (err) {
        error = err;
      }
      callback(error);
    };
    HashBase.prototype.update = function(data, encoding) {
      if (this._finalized) {
        throw new Error("Digest already called");
      }
      var dataBuffer = toBuffer(data, encoding);
      var block = this._block;
      var offset = 0;
      while (this._blockOffset + dataBuffer.length - offset >= this._blockSize) {
        for (var i = this._blockOffset; i < this._blockSize; ) {
          block[i] = dataBuffer[offset];
          i += 1;
          offset += 1;
        }
        this._update();
        this._blockOffset = 0;
      }
      while (offset < dataBuffer.length) {
        block[this._blockOffset] = dataBuffer[offset];
        this._blockOffset += 1;
        offset += 1;
      }
      for (var j = 0, carry = dataBuffer.length * 8; carry > 0; ++j) {
        this._length[j] += carry;
        carry = this._length[j] / 4294967296 | 0;
        if (carry > 0) {
          this._length[j] -= 4294967296 * carry;
        }
      }
      return this;
    };
    HashBase.prototype._update = function() {
      throw new Error("_update is not implemented");
    };
    HashBase.prototype.digest = function(encoding) {
      if (this._finalized) {
        throw new Error("Digest already called");
      }
      this._finalized = true;
      var digest = this._digest();
      if (encoding !== void 0) {
        digest = digest.toString(encoding);
      }
      this._block.fill(0);
      this._blockOffset = 0;
      for (var i = 0; i < 4; ++i) {
        this._length[i] = 0;
      }
      return digest;
    };
    HashBase.prototype._digest = function() {
      throw new Error("_digest is not implemented");
    };
    module2.exports = HashBase;
  }
});

// node_modules/md5.js/index.js
var require_md5 = __commonJS({
  "node_modules/md5.js/index.js"(exports2, module2) {
    "use strict";
    var inherits = require_inherits_browser();
    var HashBase = require_hash_base();
    var Buffer2 = require_safe_buffer().Buffer;
    var ARRAY16 = new Array(16);
    function MD5() {
      HashBase.call(this, 64);
      this._a = 1732584193;
      this._b = 4023233417;
      this._c = 2562383102;
      this._d = 271733878;
    }
    inherits(MD5, HashBase);
    MD5.prototype._update = function() {
      var M = ARRAY16;
      for (var i = 0; i < 16; ++i) M[i] = this._block.readInt32LE(i * 4);
      var a = this._a;
      var b2 = this._b;
      var c = this._c;
      var d = this._d;
      a = fnF(a, b2, c, d, M[0], 3614090360, 7);
      d = fnF(d, a, b2, c, M[1], 3905402710, 12);
      c = fnF(c, d, a, b2, M[2], 606105819, 17);
      b2 = fnF(b2, c, d, a, M[3], 3250441966, 22);
      a = fnF(a, b2, c, d, M[4], 4118548399, 7);
      d = fnF(d, a, b2, c, M[5], 1200080426, 12);
      c = fnF(c, d, a, b2, M[6], 2821735955, 17);
      b2 = fnF(b2, c, d, a, M[7], 4249261313, 22);
      a = fnF(a, b2, c, d, M[8], 1770035416, 7);
      d = fnF(d, a, b2, c, M[9], 2336552879, 12);
      c = fnF(c, d, a, b2, M[10], 4294925233, 17);
      b2 = fnF(b2, c, d, a, M[11], 2304563134, 22);
      a = fnF(a, b2, c, d, M[12], 1804603682, 7);
      d = fnF(d, a, b2, c, M[13], 4254626195, 12);
      c = fnF(c, d, a, b2, M[14], 2792965006, 17);
      b2 = fnF(b2, c, d, a, M[15], 1236535329, 22);
      a = fnG(a, b2, c, d, M[1], 4129170786, 5);
      d = fnG(d, a, b2, c, M[6], 3225465664, 9);
      c = fnG(c, d, a, b2, M[11], 643717713, 14);
      b2 = fnG(b2, c, d, a, M[0], 3921069994, 20);
      a = fnG(a, b2, c, d, M[5], 3593408605, 5);
      d = fnG(d, a, b2, c, M[10], 38016083, 9);
      c = fnG(c, d, a, b2, M[15], 3634488961, 14);
      b2 = fnG(b2, c, d, a, M[4], 3889429448, 20);
      a = fnG(a, b2, c, d, M[9], 568446438, 5);
      d = fnG(d, a, b2, c, M[14], 3275163606, 9);
      c = fnG(c, d, a, b2, M[3], 4107603335, 14);
      b2 = fnG(b2, c, d, a, M[8], 1163531501, 20);
      a = fnG(a, b2, c, d, M[13], 2850285829, 5);
      d = fnG(d, a, b2, c, M[2], 4243563512, 9);
      c = fnG(c, d, a, b2, M[7], 1735328473, 14);
      b2 = fnG(b2, c, d, a, M[12], 2368359562, 20);
      a = fnH(a, b2, c, d, M[5], 4294588738, 4);
      d = fnH(d, a, b2, c, M[8], 2272392833, 11);
      c = fnH(c, d, a, b2, M[11], 1839030562, 16);
      b2 = fnH(b2, c, d, a, M[14], 4259657740, 23);
      a = fnH(a, b2, c, d, M[1], 2763975236, 4);
      d = fnH(d, a, b2, c, M[4], 1272893353, 11);
      c = fnH(c, d, a, b2, M[7], 4139469664, 16);
      b2 = fnH(b2, c, d, a, M[10], 3200236656, 23);
      a = fnH(a, b2, c, d, M[13], 681279174, 4);
      d = fnH(d, a, b2, c, M[0], 3936430074, 11);
      c = fnH(c, d, a, b2, M[3], 3572445317, 16);
      b2 = fnH(b2, c, d, a, M[6], 76029189, 23);
      a = fnH(a, b2, c, d, M[9], 3654602809, 4);
      d = fnH(d, a, b2, c, M[12], 3873151461, 11);
      c = fnH(c, d, a, b2, M[15], 530742520, 16);
      b2 = fnH(b2, c, d, a, M[2], 3299628645, 23);
      a = fnI(a, b2, c, d, M[0], 4096336452, 6);
      d = fnI(d, a, b2, c, M[7], 1126891415, 10);
      c = fnI(c, d, a, b2, M[14], 2878612391, 15);
      b2 = fnI(b2, c, d, a, M[5], 4237533241, 21);
      a = fnI(a, b2, c, d, M[12], 1700485571, 6);
      d = fnI(d, a, b2, c, M[3], 2399980690, 10);
      c = fnI(c, d, a, b2, M[10], 4293915773, 15);
      b2 = fnI(b2, c, d, a, M[1], 2240044497, 21);
      a = fnI(a, b2, c, d, M[8], 1873313359, 6);
      d = fnI(d, a, b2, c, M[15], 4264355552, 10);
      c = fnI(c, d, a, b2, M[6], 2734768916, 15);
      b2 = fnI(b2, c, d, a, M[13], 1309151649, 21);
      a = fnI(a, b2, c, d, M[4], 4149444226, 6);
      d = fnI(d, a, b2, c, M[11], 3174756917, 10);
      c = fnI(c, d, a, b2, M[2], 718787259, 15);
      b2 = fnI(b2, c, d, a, M[9], 3951481745, 21);
      this._a = this._a + a | 0;
      this._b = this._b + b2 | 0;
      this._c = this._c + c | 0;
      this._d = this._d + d | 0;
    };
    MD5.prototype._digest = function() {
      this._block[this._blockOffset++] = 128;
      if (this._blockOffset > 56) {
        this._block.fill(0, this._blockOffset, 64);
        this._update();
        this._blockOffset = 0;
      }
      this._block.fill(0, this._blockOffset, 56);
      this._block.writeUInt32LE(this._length[0], 56);
      this._block.writeUInt32LE(this._length[1], 60);
      this._update();
      var buffer = Buffer2.allocUnsafe(16);
      buffer.writeInt32LE(this._a, 0);
      buffer.writeInt32LE(this._b, 4);
      buffer.writeInt32LE(this._c, 8);
      buffer.writeInt32LE(this._d, 12);
      return buffer;
    };
    function rotl2(x, n) {
      return x << n | x >>> 32 - n;
    }
    function fnF(a, b2, c, d, m, k, s) {
      return rotl2(a + (b2 & c | ~b2 & d) + m + k | 0, s) + b2 | 0;
    }
    function fnG(a, b2, c, d, m, k, s) {
      return rotl2(a + (b2 & d | c & ~d) + m + k | 0, s) + b2 | 0;
    }
    function fnH(a, b2, c, d, m, k, s) {
      return rotl2(a + (b2 ^ c ^ d) + m + k | 0, s) + b2 | 0;
    }
    function fnI(a, b2, c, d, m, k, s) {
      return rotl2(a + (c ^ (b2 | ~d)) + m + k | 0, s) + b2 | 0;
    }
    module2.exports = MD5;
  }
});

// node_modules/ripemd160/index.js
var require_ripemd160 = __commonJS({
  "node_modules/ripemd160/index.js"(exports2, module2) {
    "use strict";
    var Buffer2 = require_buffer().Buffer;
    var inherits = require_inherits_browser();
    var HashBase = require_hash_base();
    var ARRAY16 = new Array(16);
    var zl = [
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      7,
      4,
      13,
      1,
      10,
      6,
      15,
      3,
      12,
      0,
      9,
      5,
      2,
      14,
      11,
      8,
      3,
      10,
      14,
      4,
      9,
      15,
      8,
      1,
      2,
      7,
      0,
      6,
      13,
      11,
      5,
      12,
      1,
      9,
      11,
      10,
      0,
      8,
      12,
      4,
      13,
      3,
      7,
      15,
      14,
      5,
      6,
      2,
      4,
      0,
      5,
      9,
      7,
      12,
      2,
      10,
      14,
      1,
      3,
      8,
      11,
      6,
      15,
      13
    ];
    var zr = [
      5,
      14,
      7,
      0,
      9,
      2,
      11,
      4,
      13,
      6,
      15,
      8,
      1,
      10,
      3,
      12,
      6,
      11,
      3,
      7,
      0,
      13,
      5,
      10,
      14,
      15,
      8,
      12,
      4,
      9,
      1,
      2,
      15,
      5,
      1,
      3,
      7,
      14,
      6,
      9,
      11,
      8,
      12,
      2,
      10,
      0,
      4,
      13,
      8,
      6,
      4,
      1,
      3,
      11,
      15,
      0,
      5,
      12,
      2,
      13,
      9,
      7,
      10,
      14,
      12,
      15,
      10,
      4,
      1,
      5,
      8,
      7,
      6,
      2,
      13,
      14,
      0,
      3,
      9,
      11
    ];
    var sl = [
      11,
      14,
      15,
      12,
      5,
      8,
      7,
      9,
      11,
      13,
      14,
      15,
      6,
      7,
      9,
      8,
      7,
      6,
      8,
      13,
      11,
      9,
      7,
      15,
      7,
      12,
      15,
      9,
      11,
      7,
      13,
      12,
      11,
      13,
      6,
      7,
      14,
      9,
      13,
      15,
      14,
      8,
      13,
      6,
      5,
      12,
      7,
      5,
      11,
      12,
      14,
      15,
      14,
      15,
      9,
      8,
      9,
      14,
      5,
      6,
      8,
      6,
      5,
      12,
      9,
      15,
      5,
      11,
      6,
      8,
      13,
      12,
      5,
      12,
      13,
      14,
      11,
      8,
      5,
      6
    ];
    var sr = [
      8,
      9,
      9,
      11,
      13,
      15,
      15,
      5,
      7,
      7,
      8,
      11,
      14,
      14,
      12,
      6,
      9,
      13,
      15,
      7,
      12,
      8,
      9,
      11,
      7,
      7,
      12,
      7,
      6,
      15,
      13,
      11,
      9,
      7,
      15,
      11,
      8,
      6,
      6,
      14,
      12,
      13,
      5,
      14,
      13,
      13,
      7,
      5,
      15,
      5,
      8,
      11,
      14,
      14,
      6,
      14,
      6,
      9,
      12,
      9,
      12,
      5,
      15,
      8,
      8,
      5,
      12,
      9,
      12,
      5,
      14,
      6,
      8,
      13,
      6,
      5,
      15,
      13,
      11,
      11
    ];
    var hl = [0, 1518500249, 1859775393, 2400959708, 2840853838];
    var hr = [1352829926, 1548603684, 1836072691, 2053994217, 0];
    function rotl2(x, n) {
      return x << n | x >>> 32 - n;
    }
    function fn1(a, b2, c, d, e, m, k, s) {
      return rotl2(a + (b2 ^ c ^ d) + m + k | 0, s) + e | 0;
    }
    function fn2(a, b2, c, d, e, m, k, s) {
      return rotl2(a + (b2 & c | ~b2 & d) + m + k | 0, s) + e | 0;
    }
    function fn3(a, b2, c, d, e, m, k, s) {
      return rotl2(a + ((b2 | ~c) ^ d) + m + k | 0, s) + e | 0;
    }
    function fn4(a, b2, c, d, e, m, k, s) {
      return rotl2(a + (b2 & d | c & ~d) + m + k | 0, s) + e | 0;
    }
    function fn5(a, b2, c, d, e, m, k, s) {
      return rotl2(a + (b2 ^ (c | ~d)) + m + k | 0, s) + e | 0;
    }
    function RIPEMD1602() {
      HashBase.call(this, 64);
      this._a = 1732584193;
      this._b = 4023233417;
      this._c = 2562383102;
      this._d = 271733878;
      this._e = 3285377520;
    }
    inherits(RIPEMD1602, HashBase);
    RIPEMD1602.prototype._update = function() {
      var words = ARRAY16;
      for (var j = 0; j < 16; ++j) {
        words[j] = this._block.readInt32LE(j * 4);
      }
      var al = this._a | 0;
      var bl = this._b | 0;
      var cl = this._c | 0;
      var dl = this._d | 0;
      var el = this._e | 0;
      var ar = this._a | 0;
      var br = this._b | 0;
      var cr = this._c | 0;
      var dr = this._d | 0;
      var er = this._e | 0;
      for (var i = 0; i < 80; i += 1) {
        var tl;
        var tr;
        if (i < 16) {
          tl = fn1(al, bl, cl, dl, el, words[zl[i]], hl[0], sl[i]);
          tr = fn5(ar, br, cr, dr, er, words[zr[i]], hr[0], sr[i]);
        } else if (i < 32) {
          tl = fn2(al, bl, cl, dl, el, words[zl[i]], hl[1], sl[i]);
          tr = fn4(ar, br, cr, dr, er, words[zr[i]], hr[1], sr[i]);
        } else if (i < 48) {
          tl = fn3(al, bl, cl, dl, el, words[zl[i]], hl[2], sl[i]);
          tr = fn3(ar, br, cr, dr, er, words[zr[i]], hr[2], sr[i]);
        } else if (i < 64) {
          tl = fn4(al, bl, cl, dl, el, words[zl[i]], hl[3], sl[i]);
          tr = fn2(ar, br, cr, dr, er, words[zr[i]], hr[3], sr[i]);
        } else {
          tl = fn5(al, bl, cl, dl, el, words[zl[i]], hl[4], sl[i]);
          tr = fn1(ar, br, cr, dr, er, words[zr[i]], hr[4], sr[i]);
        }
        al = el;
        el = dl;
        dl = rotl2(cl, 10);
        cl = bl;
        bl = tl;
        ar = er;
        er = dr;
        dr = rotl2(cr, 10);
        cr = br;
        br = tr;
      }
      var t = this._b + cl + dr | 0;
      this._b = this._c + dl + er | 0;
      this._c = this._d + el + ar | 0;
      this._d = this._e + al + br | 0;
      this._e = this._a + bl + cr | 0;
      this._a = t;
    };
    RIPEMD1602.prototype._digest = function() {
      this._block[this._blockOffset] = 128;
      this._blockOffset += 1;
      if (this._blockOffset > 56) {
        this._block.fill(0, this._blockOffset, 64);
        this._update();
        this._blockOffset = 0;
      }
      this._block.fill(0, this._blockOffset, 56);
      this._block.writeUInt32LE(this._length[0], 56);
      this._block.writeUInt32LE(this._length[1], 60);
      this._update();
      var buffer = Buffer2.alloc ? Buffer2.alloc(20) : new Buffer2(20);
      buffer.writeInt32LE(this._a, 0);
      buffer.writeInt32LE(this._b, 4);
      buffer.writeInt32LE(this._c, 8);
      buffer.writeInt32LE(this._d, 12);
      buffer.writeInt32LE(this._e, 16);
      return buffer;
    };
    module2.exports = RIPEMD1602;
  }
});

// node_modules/sha.js/hash.js
var require_hash = __commonJS({
  "node_modules/sha.js/hash.js"(exports2, module2) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var toBuffer = require_to_buffer();
    function Hash2(blockSize, finalSize) {
      this._block = Buffer2.alloc(blockSize);
      this._finalSize = finalSize;
      this._blockSize = blockSize;
      this._len = 0;
    }
    Hash2.prototype.update = function(data, enc) {
      data = toBuffer(data, enc || "utf8");
      var block = this._block;
      var blockSize = this._blockSize;
      var length = data.length;
      var accum = this._len;
      for (var offset = 0; offset < length; ) {
        var assigned = accum % blockSize;
        var remainder = Math.min(length - offset, blockSize - assigned);
        for (var i = 0; i < remainder; i++) {
          block[assigned + i] = data[offset + i];
        }
        accum += remainder;
        offset += remainder;
        if (accum % blockSize === 0) {
          this._update(block);
        }
      }
      this._len += length;
      return this;
    };
    Hash2.prototype.digest = function(enc) {
      var rem = this._len % this._blockSize;
      this._block[rem] = 128;
      this._block.fill(0, rem + 1);
      if (rem >= this._finalSize) {
        this._update(this._block);
        this._block.fill(0);
      }
      var bits = this._len * 8;
      if (bits <= 4294967295) {
        this._block.writeUInt32BE(bits, this._blockSize - 4);
      } else {
        var lowBits = (bits & 4294967295) >>> 0;
        var highBits = (bits - lowBits) / 4294967296;
        this._block.writeUInt32BE(highBits, this._blockSize - 8);
        this._block.writeUInt32BE(lowBits, this._blockSize - 4);
      }
      this._update(this._block);
      var hash = this._hash();
      return enc ? hash.toString(enc) : hash;
    };
    Hash2.prototype._update = function() {
      throw new Error("_update must be implemented by subclass");
    };
    module2.exports = Hash2;
  }
});

// node_modules/sha.js/sha.js
var require_sha = __commonJS({
  "node_modules/sha.js/sha.js"(exports2, module2) {
    "use strict";
    var inherits = require_inherits_browser();
    var Hash2 = require_hash();
    var Buffer2 = require_safe_buffer().Buffer;
    var K = [
      1518500249,
      1859775393,
      2400959708 | 0,
      3395469782 | 0
    ];
    var W = new Array(80);
    function Sha() {
      this.init();
      this._w = W;
      Hash2.call(this, 64, 56);
    }
    inherits(Sha, Hash2);
    Sha.prototype.init = function() {
      this._a = 1732584193;
      this._b = 4023233417;
      this._c = 2562383102;
      this._d = 271733878;
      this._e = 3285377520;
      return this;
    };
    function rotl5(num) {
      return num << 5 | num >>> 27;
    }
    function rotl30(num) {
      return num << 30 | num >>> 2;
    }
    function ft(s, b2, c, d) {
      if (s === 0) {
        return b2 & c | ~b2 & d;
      }
      if (s === 2) {
        return b2 & c | b2 & d | c & d;
      }
      return b2 ^ c ^ d;
    }
    Sha.prototype._update = function(M) {
      var w = this._w;
      var a = this._a | 0;
      var b2 = this._b | 0;
      var c = this._c | 0;
      var d = this._d | 0;
      var e = this._e | 0;
      for (var i = 0; i < 16; ++i) {
        w[i] = M.readInt32BE(i * 4);
      }
      for (; i < 80; ++i) {
        w[i] = w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16];
      }
      for (var j = 0; j < 80; ++j) {
        var s = ~~(j / 20);
        var t = rotl5(a) + ft(s, b2, c, d) + e + w[j] + K[s] | 0;
        e = d;
        d = c;
        c = rotl30(b2);
        b2 = a;
        a = t;
      }
      this._a = a + this._a | 0;
      this._b = b2 + this._b | 0;
      this._c = c + this._c | 0;
      this._d = d + this._d | 0;
      this._e = e + this._e | 0;
    };
    Sha.prototype._hash = function() {
      var H2 = Buffer2.allocUnsafe(20);
      H2.writeInt32BE(this._a | 0, 0);
      H2.writeInt32BE(this._b | 0, 4);
      H2.writeInt32BE(this._c | 0, 8);
      H2.writeInt32BE(this._d | 0, 12);
      H2.writeInt32BE(this._e | 0, 16);
      return H2;
    };
    module2.exports = Sha;
  }
});

// node_modules/sha.js/sha1.js
var require_sha1 = __commonJS({
  "node_modules/sha.js/sha1.js"(exports2, module2) {
    "use strict";
    var inherits = require_inherits_browser();
    var Hash2 = require_hash();
    var Buffer2 = require_safe_buffer().Buffer;
    var K = [
      1518500249,
      1859775393,
      2400959708 | 0,
      3395469782 | 0
    ];
    var W = new Array(80);
    function Sha1() {
      this.init();
      this._w = W;
      Hash2.call(this, 64, 56);
    }
    inherits(Sha1, Hash2);
    Sha1.prototype.init = function() {
      this._a = 1732584193;
      this._b = 4023233417;
      this._c = 2562383102;
      this._d = 271733878;
      this._e = 3285377520;
      return this;
    };
    function rotl1(num) {
      return num << 1 | num >>> 31;
    }
    function rotl5(num) {
      return num << 5 | num >>> 27;
    }
    function rotl30(num) {
      return num << 30 | num >>> 2;
    }
    function ft(s, b2, c, d) {
      if (s === 0) {
        return b2 & c | ~b2 & d;
      }
      if (s === 2) {
        return b2 & c | b2 & d | c & d;
      }
      return b2 ^ c ^ d;
    }
    Sha1.prototype._update = function(M) {
      var w = this._w;
      var a = this._a | 0;
      var b2 = this._b | 0;
      var c = this._c | 0;
      var d = this._d | 0;
      var e = this._e | 0;
      for (var i = 0; i < 16; ++i) {
        w[i] = M.readInt32BE(i * 4);
      }
      for (; i < 80; ++i) {
        w[i] = rotl1(w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16]);
      }
      for (var j = 0; j < 80; ++j) {
        var s = ~~(j / 20);
        var t = rotl5(a) + ft(s, b2, c, d) + e + w[j] + K[s] | 0;
        e = d;
        d = c;
        c = rotl30(b2);
        b2 = a;
        a = t;
      }
      this._a = a + this._a | 0;
      this._b = b2 + this._b | 0;
      this._c = c + this._c | 0;
      this._d = d + this._d | 0;
      this._e = e + this._e | 0;
    };
    Sha1.prototype._hash = function() {
      var H2 = Buffer2.allocUnsafe(20);
      H2.writeInt32BE(this._a | 0, 0);
      H2.writeInt32BE(this._b | 0, 4);
      H2.writeInt32BE(this._c | 0, 8);
      H2.writeInt32BE(this._d | 0, 12);
      H2.writeInt32BE(this._e | 0, 16);
      return H2;
    };
    module2.exports = Sha1;
  }
});

// node_modules/sha.js/sha256.js
var require_sha256 = __commonJS({
  "node_modules/sha.js/sha256.js"(exports2, module2) {
    "use strict";
    var inherits = require_inherits_browser();
    var Hash2 = require_hash();
    var Buffer2 = require_safe_buffer().Buffer;
    var K = [
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ];
    var W = new Array(64);
    function Sha256() {
      this.init();
      this._w = W;
      Hash2.call(this, 64, 56);
    }
    inherits(Sha256, Hash2);
    Sha256.prototype.init = function() {
      this._a = 1779033703;
      this._b = 3144134277;
      this._c = 1013904242;
      this._d = 2773480762;
      this._e = 1359893119;
      this._f = 2600822924;
      this._g = 528734635;
      this._h = 1541459225;
      return this;
    };
    function ch(x, y, z) {
      return z ^ x & (y ^ z);
    }
    function maj(x, y, z) {
      return x & y | z & (x | y);
    }
    function sigma0(x) {
      return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10);
    }
    function sigma1(x) {
      return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7);
    }
    function gamma0(x) {
      return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ x >>> 3;
    }
    function gamma1(x) {
      return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ x >>> 10;
    }
    Sha256.prototype._update = function(M) {
      var w = this._w;
      var a = this._a | 0;
      var b2 = this._b | 0;
      var c = this._c | 0;
      var d = this._d | 0;
      var e = this._e | 0;
      var f = this._f | 0;
      var g = this._g | 0;
      var h = this._h | 0;
      for (var i = 0; i < 16; ++i) {
        w[i] = M.readInt32BE(i * 4);
      }
      for (; i < 64; ++i) {
        w[i] = gamma1(w[i - 2]) + w[i - 7] + gamma0(w[i - 15]) + w[i - 16] | 0;
      }
      for (var j = 0; j < 64; ++j) {
        var T1 = h + sigma1(e) + ch(e, f, g) + K[j] + w[j] | 0;
        var T2 = sigma0(a) + maj(a, b2, c) | 0;
        h = g;
        g = f;
        f = e;
        e = d + T1 | 0;
        d = c;
        c = b2;
        b2 = a;
        a = T1 + T2 | 0;
      }
      this._a = a + this._a | 0;
      this._b = b2 + this._b | 0;
      this._c = c + this._c | 0;
      this._d = d + this._d | 0;
      this._e = e + this._e | 0;
      this._f = f + this._f | 0;
      this._g = g + this._g | 0;
      this._h = h + this._h | 0;
    };
    Sha256.prototype._hash = function() {
      var H2 = Buffer2.allocUnsafe(32);
      H2.writeInt32BE(this._a, 0);
      H2.writeInt32BE(this._b, 4);
      H2.writeInt32BE(this._c, 8);
      H2.writeInt32BE(this._d, 12);
      H2.writeInt32BE(this._e, 16);
      H2.writeInt32BE(this._f, 20);
      H2.writeInt32BE(this._g, 24);
      H2.writeInt32BE(this._h, 28);
      return H2;
    };
    module2.exports = Sha256;
  }
});

// node_modules/sha.js/sha224.js
var require_sha224 = __commonJS({
  "node_modules/sha.js/sha224.js"(exports2, module2) {
    "use strict";
    var inherits = require_inherits_browser();
    var Sha256 = require_sha256();
    var Hash2 = require_hash();
    var Buffer2 = require_safe_buffer().Buffer;
    var W = new Array(64);
    function Sha224() {
      this.init();
      this._w = W;
      Hash2.call(this, 64, 56);
    }
    inherits(Sha224, Sha256);
    Sha224.prototype.init = function() {
      this._a = 3238371032;
      this._b = 914150663;
      this._c = 812702999;
      this._d = 4144912697;
      this._e = 4290775857;
      this._f = 1750603025;
      this._g = 1694076839;
      this._h = 3204075428;
      return this;
    };
    Sha224.prototype._hash = function() {
      var H2 = Buffer2.allocUnsafe(28);
      H2.writeInt32BE(this._a, 0);
      H2.writeInt32BE(this._b, 4);
      H2.writeInt32BE(this._c, 8);
      H2.writeInt32BE(this._d, 12);
      H2.writeInt32BE(this._e, 16);
      H2.writeInt32BE(this._f, 20);
      H2.writeInt32BE(this._g, 24);
      return H2;
    };
    module2.exports = Sha224;
  }
});

// node_modules/sha.js/sha512.js
var require_sha512 = __commonJS({
  "node_modules/sha.js/sha512.js"(exports2, module2) {
    "use strict";
    var inherits = require_inherits_browser();
    var Hash2 = require_hash();
    var Buffer2 = require_safe_buffer().Buffer;
    var K = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    var W = new Array(160);
    function Sha512() {
      this.init();
      this._w = W;
      Hash2.call(this, 128, 112);
    }
    inherits(Sha512, Hash2);
    Sha512.prototype.init = function() {
      this._ah = 1779033703;
      this._bh = 3144134277;
      this._ch = 1013904242;
      this._dh = 2773480762;
      this._eh = 1359893119;
      this._fh = 2600822924;
      this._gh = 528734635;
      this._hh = 1541459225;
      this._al = 4089235720;
      this._bl = 2227873595;
      this._cl = 4271175723;
      this._dl = 1595750129;
      this._el = 2917565137;
      this._fl = 725511199;
      this._gl = 4215389547;
      this._hl = 327033209;
      return this;
    };
    function Ch(x, y, z) {
      return z ^ x & (y ^ z);
    }
    function maj(x, y, z) {
      return x & y | z & (x | y);
    }
    function sigma0(x, xl) {
      return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25);
    }
    function sigma1(x, xl) {
      return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23);
    }
    function Gamma0(x, xl) {
      return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ x >>> 7;
    }
    function Gamma0l(x, xl) {
      return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25);
    }
    function Gamma1(x, xl) {
      return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ x >>> 6;
    }
    function Gamma1l(x, xl) {
      return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26);
    }
    function getCarry(a, b2) {
      return a >>> 0 < b2 >>> 0 ? 1 : 0;
    }
    Sha512.prototype._update = function(M) {
      var w = this._w;
      var ah = this._ah | 0;
      var bh = this._bh | 0;
      var ch = this._ch | 0;
      var dh = this._dh | 0;
      var eh = this._eh | 0;
      var fh = this._fh | 0;
      var gh = this._gh | 0;
      var hh = this._hh | 0;
      var al = this._al | 0;
      var bl = this._bl | 0;
      var cl = this._cl | 0;
      var dl = this._dl | 0;
      var el = this._el | 0;
      var fl = this._fl | 0;
      var gl = this._gl | 0;
      var hl = this._hl | 0;
      for (var i = 0; i < 32; i += 2) {
        w[i] = M.readInt32BE(i * 4);
        w[i + 1] = M.readInt32BE(i * 4 + 4);
      }
      for (; i < 160; i += 2) {
        var xh = w[i - 15 * 2];
        var xl = w[i - 15 * 2 + 1];
        var gamma0 = Gamma0(xh, xl);
        var gamma0l = Gamma0l(xl, xh);
        xh = w[i - 2 * 2];
        xl = w[i - 2 * 2 + 1];
        var gamma1 = Gamma1(xh, xl);
        var gamma1l = Gamma1l(xl, xh);
        var Wi7h = w[i - 7 * 2];
        var Wi7l = w[i - 7 * 2 + 1];
        var Wi16h = w[i - 16 * 2];
        var Wi16l = w[i - 16 * 2 + 1];
        var Wil = gamma0l + Wi7l | 0;
        var Wih = gamma0 + Wi7h + getCarry(Wil, gamma0l) | 0;
        Wil = Wil + gamma1l | 0;
        Wih = Wih + gamma1 + getCarry(Wil, gamma1l) | 0;
        Wil = Wil + Wi16l | 0;
        Wih = Wih + Wi16h + getCarry(Wil, Wi16l) | 0;
        w[i] = Wih;
        w[i + 1] = Wil;
      }
      for (var j = 0; j < 160; j += 2) {
        Wih = w[j];
        Wil = w[j + 1];
        var majh = maj(ah, bh, ch);
        var majl = maj(al, bl, cl);
        var sigma0h = sigma0(ah, al);
        var sigma0l = sigma0(al, ah);
        var sigma1h = sigma1(eh, el);
        var sigma1l = sigma1(el, eh);
        var Kih = K[j];
        var Kil = K[j + 1];
        var chh = Ch(eh, fh, gh);
        var chl = Ch(el, fl, gl);
        var t1l = hl + sigma1l | 0;
        var t1h = hh + sigma1h + getCarry(t1l, hl) | 0;
        t1l = t1l + chl | 0;
        t1h = t1h + chh + getCarry(t1l, chl) | 0;
        t1l = t1l + Kil | 0;
        t1h = t1h + Kih + getCarry(t1l, Kil) | 0;
        t1l = t1l + Wil | 0;
        t1h = t1h + Wih + getCarry(t1l, Wil) | 0;
        var t2l = sigma0l + majl | 0;
        var t2h = sigma0h + majh + getCarry(t2l, sigma0l) | 0;
        hh = gh;
        hl = gl;
        gh = fh;
        gl = fl;
        fh = eh;
        fl = el;
        el = dl + t1l | 0;
        eh = dh + t1h + getCarry(el, dl) | 0;
        dh = ch;
        dl = cl;
        ch = bh;
        cl = bl;
        bh = ah;
        bl = al;
        al = t1l + t2l | 0;
        ah = t1h + t2h + getCarry(al, t1l) | 0;
      }
      this._al = this._al + al | 0;
      this._bl = this._bl + bl | 0;
      this._cl = this._cl + cl | 0;
      this._dl = this._dl + dl | 0;
      this._el = this._el + el | 0;
      this._fl = this._fl + fl | 0;
      this._gl = this._gl + gl | 0;
      this._hl = this._hl + hl | 0;
      this._ah = this._ah + ah + getCarry(this._al, al) | 0;
      this._bh = this._bh + bh + getCarry(this._bl, bl) | 0;
      this._ch = this._ch + ch + getCarry(this._cl, cl) | 0;
      this._dh = this._dh + dh + getCarry(this._dl, dl) | 0;
      this._eh = this._eh + eh + getCarry(this._el, el) | 0;
      this._fh = this._fh + fh + getCarry(this._fl, fl) | 0;
      this._gh = this._gh + gh + getCarry(this._gl, gl) | 0;
      this._hh = this._hh + hh + getCarry(this._hl, hl) | 0;
    };
    Sha512.prototype._hash = function() {
      var H2 = Buffer2.allocUnsafe(64);
      function writeInt64BE(h, l, offset) {
        H2.writeInt32BE(h, offset);
        H2.writeInt32BE(l, offset + 4);
      }
      writeInt64BE(this._ah, this._al, 0);
      writeInt64BE(this._bh, this._bl, 8);
      writeInt64BE(this._ch, this._cl, 16);
      writeInt64BE(this._dh, this._dl, 24);
      writeInt64BE(this._eh, this._el, 32);
      writeInt64BE(this._fh, this._fl, 40);
      writeInt64BE(this._gh, this._gl, 48);
      writeInt64BE(this._hh, this._hl, 56);
      return H2;
    };
    module2.exports = Sha512;
  }
});

// node_modules/sha.js/sha384.js
var require_sha384 = __commonJS({
  "node_modules/sha.js/sha384.js"(exports2, module2) {
    "use strict";
    var inherits = require_inherits_browser();
    var SHA512 = require_sha512();
    var Hash2 = require_hash();
    var Buffer2 = require_safe_buffer().Buffer;
    var W = new Array(160);
    function Sha384() {
      this.init();
      this._w = W;
      Hash2.call(this, 128, 112);
    }
    inherits(Sha384, SHA512);
    Sha384.prototype.init = function() {
      this._ah = 3418070365;
      this._bh = 1654270250;
      this._ch = 2438529370;
      this._dh = 355462360;
      this._eh = 1731405415;
      this._fh = 2394180231;
      this._gh = 3675008525;
      this._hh = 1203062813;
      this._al = 3238371032;
      this._bl = 914150663;
      this._cl = 812702999;
      this._dl = 4144912697;
      this._el = 4290775857;
      this._fl = 1750603025;
      this._gl = 1694076839;
      this._hl = 3204075428;
      return this;
    };
    Sha384.prototype._hash = function() {
      var H2 = Buffer2.allocUnsafe(48);
      function writeInt64BE(h, l, offset) {
        H2.writeInt32BE(h, offset);
        H2.writeInt32BE(l, offset + 4);
      }
      writeInt64BE(this._ah, this._al, 0);
      writeInt64BE(this._bh, this._bl, 8);
      writeInt64BE(this._ch, this._cl, 16);
      writeInt64BE(this._dh, this._dl, 24);
      writeInt64BE(this._eh, this._el, 32);
      writeInt64BE(this._fh, this._fl, 40);
      return H2;
    };
    module2.exports = Sha384;
  }
});

// node_modules/sha.js/index.js
var require_sha2 = __commonJS({
  "node_modules/sha.js/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function SHA(algorithm) {
      var alg = algorithm.toLowerCase();
      var Algorithm = module2.exports[alg];
      if (!Algorithm) {
        throw new Error(alg + " is not supported (we accept pull requests)");
      }
      return new Algorithm();
    };
    module2.exports.sha = require_sha();
    module2.exports.sha1 = require_sha1();
    module2.exports.sha224 = require_sha224();
    module2.exports.sha256 = require_sha256();
    module2.exports.sha384 = require_sha384();
    module2.exports.sha512 = require_sha512();
  }
});

// node_modules/readable-stream/lib/internal/streams/stream-browser.js
var require_stream_browser2 = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/stream-browser.js"(exports2, module2) {
    module2.exports = require_events().EventEmitter;
  }
});

// node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports2, module2) {
    "use strict";
    function ownKeys2(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys2(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var _require = require_buffer();
    var Buffer2 = _require.Buffer;
    var _require2 = require_util2();
    var inspect = _require2.inspect;
    var custom = inspect && inspect.custom || "inspect";
    function copyBuffer(src, target, offset) {
      Buffer2.prototype.copy.call(src, target, offset);
    }
    module2.exports = /* @__PURE__ */ function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      _createClass(BufferList, [{
        key: "push",
        value: function push(v) {
          var entry = {
            data: v,
            next: null
          };
          if (this.length > 0) this.tail.next = entry;
          else this.head = entry;
          this.tail = entry;
          ++this.length;
        }
      }, {
        key: "unshift",
        value: function unshift(v) {
          var entry = {
            data: v,
            next: this.head
          };
          if (this.length === 0) this.tail = entry;
          this.head = entry;
          ++this.length;
        }
      }, {
        key: "shift",
        value: function shift() {
          if (this.length === 0) return;
          var ret = this.head.data;
          if (this.length === 1) this.head = this.tail = null;
          else this.head = this.head.next;
          --this.length;
          return ret;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.head = this.tail = null;
          this.length = 0;
        }
      }, {
        key: "join",
        value: function join(s) {
          if (this.length === 0) return "";
          var p = this.head;
          var ret = "" + p.data;
          while (p = p.next) ret += s + p.data;
          return ret;
        }
      }, {
        key: "concat",
        value: function concat(n) {
          if (this.length === 0) return Buffer2.alloc(0);
          var ret = Buffer2.allocUnsafe(n >>> 0);
          var p = this.head;
          var i = 0;
          while (p) {
            copyBuffer(p.data, ret, i);
            i += p.data.length;
            p = p.next;
          }
          return ret;
        }
        // Consumes a specified amount of bytes or characters from the buffered data.
      }, {
        key: "consume",
        value: function consume(n, hasStrings) {
          var ret;
          if (n < this.head.data.length) {
            ret = this.head.data.slice(0, n);
            this.head.data = this.head.data.slice(n);
          } else if (n === this.head.data.length) {
            ret = this.shift();
          } else {
            ret = hasStrings ? this._getString(n) : this._getBuffer(n);
          }
          return ret;
        }
      }, {
        key: "first",
        value: function first() {
          return this.head.data;
        }
        // Consumes a specified amount of characters from the buffered data.
      }, {
        key: "_getString",
        value: function _getString(n) {
          var p = this.head;
          var c = 1;
          var ret = p.data;
          n -= ret.length;
          while (p = p.next) {
            var str = p.data;
            var nb = n > str.length ? str.length : n;
            if (nb === str.length) ret += str;
            else ret += str.slice(0, n);
            n -= nb;
            if (n === 0) {
              if (nb === str.length) {
                ++c;
                if (p.next) this.head = p.next;
                else this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = str.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
        // Consumes a specified amount of bytes from the buffered data.
      }, {
        key: "_getBuffer",
        value: function _getBuffer(n) {
          var ret = Buffer2.allocUnsafe(n);
          var p = this.head;
          var c = 1;
          p.data.copy(ret);
          n -= p.data.length;
          while (p = p.next) {
            var buf = p.data;
            var nb = n > buf.length ? buf.length : n;
            buf.copy(ret, ret.length - n, 0, nb);
            n -= nb;
            if (n === 0) {
              if (nb === buf.length) {
                ++c;
                if (p.next) this.head = p.next;
                else this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = buf.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
        // Make sure the linked list only shows the minimal necessary information.
      }, {
        key: custom,
        value: function value(_, options) {
          return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
            // Only inspect one level.
            depth: 0,
            // It should not recurse.
            customInspect: false
          }));
        }
      }]);
      return BufferList;
    }();
  }
});

// node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy2 = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/destroy.js"(exports2, module2) {
    "use strict";
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            process.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            process.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else {
            process.nextTick(emitCloseNT, _this);
          }
        } else if (cb) {
          process.nextTick(emitCloseNT, _this);
          cb(err2);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      });
      return this;
    }
    function emitErrorAndCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      if (self2._writableState && !self2._writableState.emitClose) return;
      if (self2._readableState && !self2._readableState.emitClose) return;
      self2.emit("close");
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    function errorOrDestroy(stream, err) {
      var rState = stream._readableState;
      var wState = stream._writableState;
      if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);
      else stream.emit("error", err);
    }
    module2.exports = {
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// node_modules/readable-stream/errors-browser.js
var require_errors_browser = __commonJS({
  "node_modules/readable-stream/errors-browser.js"(exports2, module2) {
    "use strict";
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }
    var codes = {};
    function createErrorType(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      var NodeError = /* @__PURE__ */ function(_Base) {
        _inheritsLoose(NodeError2, _Base);
        function NodeError2(arg1, arg2, arg3) {
          return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
        }
        return NodeError2;
      }(Base);
      NodeError.prototype.name = Base.name;
      NodeError.prototype.code = code;
      codes[code] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        var len = expected.length;
        expected = expected.map(function(i) {
          return String(i);
        });
        if (len > 2) {
          return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
        } else if (len === 2) {
          return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
        } else {
          return "of ".concat(thing, " ").concat(expected[0]);
        }
      } else {
        return "of ".concat(thing, " ").concat(String(expected));
      }
    }
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
      return 'The value "' + value + '" is invalid for option "' + name + '"';
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
      var determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      var msg;
      if (endsWith(name, " argument")) {
        msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      } else {
        var type = includes(name, ".") ? "property" : "argument";
        msg = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      }
      msg += ". Received type ".concat(typeof actual);
      return msg;
    }, TypeError);
    createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
      return "The " + name + " method is not implemented";
    });
    createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    createErrorType("ERR_STREAM_DESTROYED", function(name) {
      return "Cannot call " + name + " after a stream was destroyed";
    });
    createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
      return "Unknown encoding: " + arg;
    }, TypeError);
    createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    module2.exports.codes = codes;
  }
});

// node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/state.js"(exports2, module2) {
    "use strict";
    var ERR_INVALID_OPT_VALUE = require_errors_browser().codes.ERR_INVALID_OPT_VALUE;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name = isDuplex ? duplexKey : "highWaterMark";
          throw new ERR_INVALID_OPT_VALUE(name, hwm);
        }
        return Math.floor(hwm);
      }
      return state.objectMode ? 16 : 16 * 1024;
    }
    module2.exports = {
      getHighWaterMark
    };
  }
});

// node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable2 = __commonJS({
  "node_modules/readable-stream/lib/_stream_writable.js"(exports2, module2) {
    "use strict";
    module2.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var Duplex;
    Writable.WritableState = WritableState;
    var internalUtil = {
      deprecate: require_browser()
    };
    var Stream = require_stream_browser2();
    var Buffer2 = require_buffer().Buffer;
    var OurUint8Array = (typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy2();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors_browser().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
    var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
    var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    require_inherits_browser()(Writable, Stream);
    function nop() {
    }
    function WritableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex2();
      options = options || {};
      if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function writableStateBufferGetter() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function value(object) {
          if (realHasInstance.call(this, object)) return true;
          if (this !== Writable) return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function realHasInstance2(object) {
        return object instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex2();
      var isDuplex = this instanceof Duplex;
      if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
      this._writableState = new WritableState(options, this, isDuplex);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function") this._write = options.write;
        if (typeof options.writev === "function") this._writev = options.writev;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
        if (typeof options.final === "function") this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function writeAfterEnd(stream, cb) {
      var er = new ERR_STREAM_WRITE_AFTER_END();
      errorOrDestroy(stream, er);
      process.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var er;
      if (chunk === null) {
        er = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== "string" && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
      }
      if (er) {
        errorOrDestroy(stream, er);
        process.nextTick(cb, er);
        return false;
      }
      return true;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf) encoding = "buffer";
      else if (!encoding) encoding = state.defaultEncoding;
      if (typeof cb !== "function") cb = nop;
      if (state.ending) writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string") encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get2() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get2() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret) state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev) stream._writev(chunk, state.onwrite);
      else stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        process.nextTick(cb, er);
        process.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      if (typeof cb !== "function") throw new ERR_MULTIPLE_CALLBACK();
      onwriteStateUpdate(state);
      if (er) onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state) || stream.destroyed;
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          process.nextTick(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished) onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf) allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null) state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending) endWritable(this, state, cb);
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get2() {
        return this._writableState.length;
      }
    });
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          errorOrDestroy(stream, err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.pendingcb++;
          state.finalCalled = true;
          process.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
          if (state.autoDestroy) {
            var rState = stream._readableState;
            if (!rState || rState.autoDestroy && rState.endEmitted) {
              stream.destroy();
            }
          }
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished) process.nextTick(cb);
        else stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get2() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function set2(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
  }
});

// node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex2 = __commonJS({
  "node_modules/readable-stream/lib/_stream_duplex.js"(exports2, module2) {
    "use strict";
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj) keys2.push(key);
      return keys2;
    };
    module2.exports = Duplex;
    var Readable = require_stream_readable2();
    var Writable = require_stream_writable2();
    require_inherits_browser()(Duplex, Readable);
    {
      keys = objectKeys(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v;
    function Duplex(options) {
      if (!(this instanceof Duplex)) return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      this.allowHalfOpen = true;
      if (options) {
        if (options.readable === false) this.readable = false;
        if (options.writable === false) this.writable = false;
        if (options.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once("end", onend);
        }
      }
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get2() {
        return this._writableState.highWaterMark;
      }
    });
    Object.defineProperty(Duplex.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get2() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    Object.defineProperty(Duplex.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get2() {
        return this._writableState.length;
      }
    });
    function onend() {
      if (this._writableState.ended) return;
      process.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get2() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function set2(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
  }
});

// node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder2 = __commonJS({
  "node_modules/string_decoder/lib/string_decoder.js"(exports2) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc) return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried) return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports2.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0) return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0) return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127) return 0;
      else if (byte >> 5 === 6) return 2;
      else if (byte >> 4 === 14) return 3;
      else if (byte >> 3 === 30) return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i) return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2) return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2) return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2) nb = 0;
          else self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0) return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed) return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) return r + "\uFFFD";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0) return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports2, module2) {
    "use strict";
    var ERR_STREAM_PREMATURE_CLOSE = require_errors_browser().codes.ERR_STREAM_PREMATURE_CLOSE;
    function once(callback) {
      var called = false;
      return function() {
        if (called) return;
        called = true;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        callback.apply(this, args);
      };
    }
    function noop() {
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function eos(stream, opts, callback) {
      if (typeof opts === "function") return eos(stream, null, opts);
      if (!opts) opts = {};
      callback = once(callback || noop);
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var onlegacyfinish = function onlegacyfinish2() {
        if (!stream.writable) onfinish();
      };
      var writableEnded = stream._writableState && stream._writableState.finished;
      var onfinish = function onfinish2() {
        writable = false;
        writableEnded = true;
        if (!readable) callback.call(stream);
      };
      var readableEnded = stream._readableState && stream._readableState.endEmitted;
      var onend = function onend2() {
        readable = false;
        readableEnded = true;
        if (!writable) callback.call(stream);
      };
      var onerror = function onerror2(err) {
        callback.call(stream, err);
      };
      var onclose = function onclose2() {
        var err;
        if (readable && !readableEnded) {
          if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
          if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
      };
      var onrequest = function onrequest2() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req) onrequest();
        else stream.on("request", onrequest);
      } else if (writable && !stream._writableState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false) stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req) stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    }
    module2.exports = eos;
  }
});

// node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports2, module2) {
    "use strict";
    var _Object$setPrototypeO;
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var finished = require_end_of_stream();
    var kLastResolve = Symbol("lastResolve");
    var kLastReject = Symbol("lastReject");
    var kError = Symbol("error");
    var kEnded = Symbol("ended");
    var kLastPromise = Symbol("lastPromise");
    var kHandlePromise = Symbol("handlePromise");
    var kStream = Symbol("stream");
    function createIterResult(value, done) {
      return {
        value,
        done
      };
    }
    function readAndResolve(iter) {
      var resolve = iter[kLastResolve];
      if (resolve !== null) {
        var data = iter[kStream].read();
        if (data !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve(createIterResult(data, false));
        }
      }
    }
    function onReadable(iter) {
      process.nextTick(readAndResolve, iter);
    }
    function wrapForNext(lastPromise, iter) {
      return function(resolve, reject) {
        lastPromise.then(function() {
          if (iter[kEnded]) {
            resolve(createIterResult(void 0, true));
            return;
          }
          iter[kHandlePromise](resolve, reject);
        }, reject);
      };
    }
    var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
    });
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
      get stream() {
        return this[kStream];
      },
      next: function next() {
        var _this = this;
        var error = this[kError];
        if (error !== null) {
          return Promise.reject(error);
        }
        if (this[kEnded]) {
          return Promise.resolve(createIterResult(void 0, true));
        }
        if (this[kStream].destroyed) {
          return new Promise(function(resolve, reject) {
            process.nextTick(function() {
              if (_this[kError]) {
                reject(_this[kError]);
              } else {
                resolve(createIterResult(void 0, true));
              }
            });
          });
        }
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) {
          promise = new Promise(wrapForNext(lastPromise, this));
        } else {
          var data = this[kStream].read();
          if (data !== null) {
            return Promise.resolve(createIterResult(data, false));
          }
          promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
      }
    }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
      return this;
    }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
      var _this2 = this;
      return new Promise(function(resolve, reject) {
        _this2[kStream].destroy(null, function(err) {
          if (err) {
            reject(err);
            return;
          }
          resolve(createIterResult(void 0, true));
        });
      });
    }), _Object$setPrototypeO), AsyncIteratorPrototype);
    var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
      var _Object$create;
      var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream,
        writable: true
      }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
      }), _defineProperty(_Object$create, kHandlePromise, {
        value: function value(resolve, reject) {
          var data = iterator[kStream].read();
          if (data) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve(createIterResult(data, false));
          } else {
            iterator[kLastResolve] = resolve;
            iterator[kLastReject] = reject;
          }
        },
        writable: true
      }), _Object$create));
      iterator[kLastPromise] = null;
      finished(stream, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var reject = iterator[kLastReject];
          if (reject !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            reject(err);
          }
          iterator[kError] = err;
          return;
        }
        var resolve = iterator[kLastResolve];
        if (resolve !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve(createIterResult(void 0, true));
        }
        iterator[kEnded] = true;
      });
      stream.on("readable", onReadable.bind(null, iterator));
      return iterator;
    };
    module2.exports = createReadableStreamAsyncIterator;
  }
});

// node_modules/readable-stream/lib/internal/streams/from-browser.js
var require_from_browser = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/from-browser.js"(exports2, module2) {
    module2.exports = function() {
      throw new Error("Readable.from is not available in the browser");
    };
  }
});

// node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable2 = __commonJS({
  "node_modules/readable-stream/lib/_stream_readable.js"(exports2, module2) {
    "use strict";
    module2.exports = Readable;
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = require_events().EventEmitter;
    var EElistenerCount = function EElistenerCount2(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream_browser2();
    var Buffer2 = require_buffer().Buffer;
    var OurUint8Array = (typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var debugUtil = require_util2();
    var debug;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function debug2() {
      };
    }
    var BufferList = require_buffer_list();
    var destroyImpl = require_destroy2();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors_browser().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    var StringDecoder;
    var createReadableStreamAsyncIterator;
    var from;
    require_inherits_browser()(Readable, Stream);
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);
      else emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex2();
      options = options || {};
      if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder) StringDecoder = require_string_decoder2().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      Duplex = Duplex || require_stream_duplex2();
      if (!(this instanceof Readable)) return new Readable(options);
      var isDuplex = this instanceof Duplex;
      this._readableState = new ReadableState(options, this, isDuplex);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function") this._read = options.read;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get2() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function set2(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      debug("readableAddChunk", chunk);
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck) er = chunkInvalid(state, chunk);
        if (er) {
          errorOrDestroy(stream, er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state.destroyed) {
            return false;
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);
              else maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
          maybeReadMore(stream, state);
        }
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront) state.buffer.unshift(chunk);
        else state.buffer.push(chunk);
        if (state.needReadable) emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      return er;
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder) StringDecoder = require_string_decoder2().StringDecoder;
      var decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      var p = this._readableState.buffer.head;
      var content = "";
      while (p !== null) {
        content += decoder.write(p.data);
        p = p.next;
      }
      this._readableState.buffer.clear();
      if (content !== "") this._readableState.buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended) return 0;
      if (state.objectMode) return 1;
      if (n !== n) {
        if (state.flowing && state.length) return state.buffer.head.data.length;
        else return state.length;
      }
      if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length) return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0) state.emittedReadable = false;
      if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended) endReadable(this);
        else emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0) endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0) state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading) n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0) ret = fromList(n, state);
      else ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
      } else {
        state.length -= n;
        state.awaitDrain = 0;
      }
      if (state.length === 0) {
        if (!state.ended) state.needReadable = true;
        if (nOrig !== n && state.ended) endReadable(this);
      }
      if (ret !== null) this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      debug("onEofChunk");
      if (state.ended) return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        if (!state.emittedReadable) {
          state.emittedReadable = true;
          emitReadable_(stream);
        }
      }
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      debug("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        process.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      var state = stream._readableState;
      debug("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        var len = state.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted) process.nextTick(endFn);
      else src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        var ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0) errorOrDestroy(dest, er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain) state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipesCount === 0) return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes) return this;
        if (!dest) dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest) dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++) dests[i].emit("unpipe", this, {
          hasUnpiped: false
        });
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1) return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1) state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      var state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false) this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.removeListener = function(ev, fn) {
      var res = Stream.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable.prototype.removeAllListeners = function(ev) {
      var res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      var state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && !state.paused) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      }
    }
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state.paused = false;
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      debug("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading) stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState.paused = true;
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null) ;
    }
    Readable.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length) _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder) chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0)) return;
        else if (!state.objectMode && (!chunk || !chunk.length)) return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = /* @__PURE__ */ function methodWrap(method) {
            return function methodWrapReturnFunction() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    if (typeof Symbol === "function") {
      Readable.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === void 0) {
          createReadableStreamAsyncIterator = require_async_iterator();
        }
        return createReadableStreamAsyncIterator(this);
      };
    }
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get2() {
        return this._readableState.highWaterMark;
      }
    });
    Object.defineProperty(Readable.prototype, "readableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get2() {
        return this._readableState && this._readableState.buffer;
      }
    });
    Object.defineProperty(Readable.prototype, "readableFlowing", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get2() {
        return this._readableState.flowing;
      },
      set: function set2(state) {
        if (this._readableState) {
          this._readableState.flowing = state;
        }
      }
    });
    Readable._fromList = fromList;
    Object.defineProperty(Readable.prototype, "readableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get2() {
        return this._readableState.length;
      }
    });
    function fromList(n, state) {
      if (state.length === 0) return null;
      var ret;
      if (state.objectMode) ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder) ret = state.buffer.join("");
        else if (state.buffer.length === 1) ret = state.buffer.first();
        else ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n, state.decoder);
      }
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      debug("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      debug("endReadableNT", state.endEmitted, state.length);
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
        if (state.autoDestroy) {
          var wState = stream._writableState;
          if (!wState || wState.autoDestroy && wState.finished) {
            stream.destroy();
          }
        }
      }
    }
    if (typeof Symbol === "function") {
      Readable.from = function(iterable, opts) {
        if (from === void 0) {
          from = require_from_browser();
        }
        return from(Readable, iterable, opts);
      };
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) return i;
      }
      return -1;
    }
  }
});

// node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform2 = __commonJS({
  "node_modules/readable-stream/lib/_stream_transform.js"(exports2, module2) {
    "use strict";
    module2.exports = Transform;
    var _require$codes = require_errors_browser().codes;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
    var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
    var Duplex = require_stream_duplex2();
    require_inherits_browser()(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (cb === null) {
        return this.emit("error", new ERR_MULTIPLE_CALLBACK());
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform)) return new Transform(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function") this._transform = options.transform;
        if (typeof options.flush === "function") this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function" && !this._readableState.destroyed) {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
      });
    };
    function done(stream, er, data) {
      if (er) return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream.push(null);
    }
  }
});

// node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough2 = __commonJS({
  "node_modules/readable-stream/lib/_stream_passthrough.js"(exports2, module2) {
    "use strict";
    module2.exports = PassThrough;
    var Transform = require_stream_transform2();
    require_inherits_browser()(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough)) return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports2, module2) {
    "use strict";
    var eos;
    function once(callback) {
      var called = false;
      return function() {
        if (called) return;
        called = true;
        callback.apply(void 0, arguments);
      };
    }
    var _require$codes = require_errors_browser().codes;
    var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    function noop(err) {
      if (err) throw err;
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function destroyer(stream, reading, writing, callback) {
      callback = once(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      if (eos === void 0) eos = require_end_of_stream();
      eos(stream, {
        readable: reading,
        writable: writing
      }, function(err) {
        if (err) return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed) return;
        if (destroyed) return;
        destroyed = true;
        if (isRequest(stream)) return stream.abort();
        if (typeof stream.destroy === "function") return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
      };
    }
    function call(fn) {
      fn();
    }
    function pipe(from, to) {
      return from.pipe(to);
    }
    function popCallback(streams) {
      if (!streams.length) return noop;
      if (typeof streams[streams.length - 1] !== "function") return noop;
      return streams.pop();
    }
    function pipeline() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
      }
      var callback = popCallback(streams);
      if (Array.isArray(streams[0])) streams = streams[0];
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      var error;
      var destroys = streams.map(function(stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error) error = err;
          if (err) destroys.forEach(call);
          if (reading) return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe);
    }
    module2.exports = pipeline;
  }
});

// node_modules/stream-browserify/index.js
var require_stream_browserify = __commonJS({
  "node_modules/stream-browserify/index.js"(exports2, module2) {
    module2.exports = Stream;
    var EE = require_events().EventEmitter;
    var inherits = require_inherits_browser();
    inherits(Stream, EE);
    Stream.Readable = require_stream_readable2();
    Stream.Writable = require_stream_writable2();
    Stream.Duplex = require_stream_duplex2();
    Stream.Transform = require_stream_transform2();
    Stream.PassThrough = require_stream_passthrough2();
    Stream.finished = require_end_of_stream();
    Stream.pipeline = require_pipeline();
    Stream.Stream = Stream;
    function Stream() {
      EE.call(this);
    }
    Stream.prototype.pipe = function(dest, options) {
      var source = this;
      function ondata(chunk) {
        if (dest.writable) {
          if (false === dest.write(chunk) && source.pause) {
            source.pause();
          }
        }
      }
      source.on("data", ondata);
      function ondrain() {
        if (source.readable && source.resume) {
          source.resume();
        }
      }
      dest.on("drain", ondrain);
      if (!dest._isStdio && (!options || options.end !== false)) {
        source.on("end", onend);
        source.on("close", onclose);
      }
      var didOnEnd = false;
      function onend() {
        if (didOnEnd) return;
        didOnEnd = true;
        dest.end();
      }
      function onclose() {
        if (didOnEnd) return;
        didOnEnd = true;
        if (typeof dest.destroy === "function") dest.destroy();
      }
      function onerror(er) {
        cleanup();
        if (EE.listenerCount(this, "error") === 0) {
          throw er;
        }
      }
      source.on("error", onerror);
      dest.on("error", onerror);
      function cleanup() {
        source.removeListener("data", ondata);
        dest.removeListener("drain", ondrain);
        source.removeListener("end", onend);
        source.removeListener("close", onclose);
        source.removeListener("error", onerror);
        dest.removeListener("error", onerror);
        source.removeListener("end", cleanup);
        source.removeListener("close", cleanup);
        dest.removeListener("close", cleanup);
      }
      source.on("end", cleanup);
      source.on("close", cleanup);
      dest.on("close", cleanup);
      dest.emit("pipe", source);
      return dest;
    };
  }
});

// node_modules/cipher-base/index.js
var require_cipher_base = __commonJS({
  "node_modules/cipher-base/index.js"(exports2, module2) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var Transform = require_stream_browserify().Transform;
    var StringDecoder = require_string_decoder2().StringDecoder;
    var inherits = require_inherits_browser();
    var toBuffer = require_to_buffer();
    function CipherBase(hashMode) {
      Transform.call(this);
      this.hashMode = typeof hashMode === "string";
      if (this.hashMode) {
        this[hashMode] = this._finalOrDigest;
      } else {
        this["final"] = this._finalOrDigest;
      }
      if (this._final) {
        this.__final = this._final;
        this._final = null;
      }
      this._decoder = null;
      this._encoding = null;
    }
    inherits(CipherBase, Transform);
    CipherBase.prototype.update = function(data, inputEnc, outputEnc) {
      var bufferData = toBuffer(data, inputEnc);
      var outData = this._update(bufferData);
      if (this.hashMode) {
        return this;
      }
      if (outputEnc) {
        outData = this._toString(outData, outputEnc);
      }
      return outData;
    };
    CipherBase.prototype.setAutoPadding = function() {
    };
    CipherBase.prototype.getAuthTag = function() {
      throw new Error("trying to get auth tag in unsupported state");
    };
    CipherBase.prototype.setAuthTag = function() {
      throw new Error("trying to set auth tag in unsupported state");
    };
    CipherBase.prototype.setAAD = function() {
      throw new Error("trying to set aad in unsupported state");
    };
    CipherBase.prototype._transform = function(data, _, next) {
      var err;
      try {
        if (this.hashMode) {
          this._update(data);
        } else {
          this.push(this._update(data));
        }
      } catch (e) {
        err = e;
      } finally {
        next(err);
      }
    };
    CipherBase.prototype._flush = function(done) {
      var err;
      try {
        this.push(this.__final());
      } catch (e) {
        err = e;
      }
      done(err);
    };
    CipherBase.prototype._finalOrDigest = function(outputEnc) {
      var outData = this.__final() || Buffer2.alloc(0);
      if (outputEnc) {
        outData = this._toString(outData, outputEnc, true);
      }
      return outData;
    };
    CipherBase.prototype._toString = function(value, enc, fin) {
      if (!this._decoder) {
        this._decoder = new StringDecoder(enc);
        this._encoding = enc;
      }
      if (this._encoding !== enc) {
        throw new Error("can\u2019t switch encodings");
      }
      var out = this._decoder.write(value);
      if (fin) {
        out += this._decoder.end();
      }
      return out;
    };
    module2.exports = CipherBase;
  }
});

// node_modules/create-hash/browser.js
var require_browser2 = __commonJS({
  "node_modules/create-hash/browser.js"(exports2, module2) {
    "use strict";
    var inherits = require_inherits_browser();
    var MD5 = require_md5();
    var RIPEMD1602 = require_ripemd160();
    var sha = require_sha2();
    var Base = require_cipher_base();
    function Hash2(hash) {
      Base.call(this, "digest");
      this._hash = hash;
    }
    inherits(Hash2, Base);
    Hash2.prototype._update = function(data) {
      this._hash.update(data);
    };
    Hash2.prototype._final = function() {
      return this._hash.digest();
    };
    module2.exports = function createHash(alg) {
      alg = alg.toLowerCase();
      if (alg === "md5") return new MD5();
      if (alg === "rmd160" || alg === "ripemd160") return new RIPEMD1602();
      return new Hash2(sha(alg));
    };
  }
});

// node_modules/create-hmac/legacy.js
var require_legacy = __commonJS({
  "node_modules/create-hmac/legacy.js"(exports2, module2) {
    "use strict";
    var inherits = require_inherits_browser();
    var Buffer2 = require_safe_buffer().Buffer;
    var Base = require_cipher_base();
    var ZEROS = Buffer2.alloc(128);
    var blocksize = 64;
    function Hmac(alg, key) {
      Base.call(this, "digest");
      if (typeof key === "string") {
        key = Buffer2.from(key);
      }
      this._alg = alg;
      this._key = key;
      if (key.length > blocksize) {
        key = alg(key);
      } else if (key.length < blocksize) {
        key = Buffer2.concat([key, ZEROS], blocksize);
      }
      var ipad = this._ipad = Buffer2.allocUnsafe(blocksize);
      var opad = this._opad = Buffer2.allocUnsafe(blocksize);
      for (var i = 0; i < blocksize; i++) {
        ipad[i] = key[i] ^ 54;
        opad[i] = key[i] ^ 92;
      }
      this._hash = [ipad];
    }
    inherits(Hmac, Base);
    Hmac.prototype._update = function(data) {
      this._hash.push(data);
    };
    Hmac.prototype._final = function() {
      var h = this._alg(Buffer2.concat(this._hash));
      return this._alg(Buffer2.concat([this._opad, h]));
    };
    module2.exports = Hmac;
  }
});

// node_modules/create-hash/md5.js
var require_md52 = __commonJS({
  "node_modules/create-hash/md5.js"(exports2, module2) {
    var MD5 = require_md5();
    module2.exports = function(buffer) {
      return new MD5().update(buffer).digest();
    };
  }
});

// node_modules/create-hmac/browser.js
var require_browser3 = __commonJS({
  "node_modules/create-hmac/browser.js"(exports2, module2) {
    "use strict";
    var inherits = require_inherits_browser();
    var Legacy = require_legacy();
    var Base = require_cipher_base();
    var Buffer2 = require_safe_buffer().Buffer;
    var md5 = require_md52();
    var RIPEMD1602 = require_ripemd160();
    var sha = require_sha2();
    var ZEROS = Buffer2.alloc(128);
    function Hmac(alg, key) {
      Base.call(this, "digest");
      if (typeof key === "string") {
        key = Buffer2.from(key);
      }
      var blocksize = alg === "sha512" || alg === "sha384" ? 128 : 64;
      this._alg = alg;
      this._key = key;
      if (key.length > blocksize) {
        var hash = alg === "rmd160" ? new RIPEMD1602() : sha(alg);
        key = hash.update(key).digest();
      } else if (key.length < blocksize) {
        key = Buffer2.concat([key, ZEROS], blocksize);
      }
      var ipad = this._ipad = Buffer2.allocUnsafe(blocksize);
      var opad = this._opad = Buffer2.allocUnsafe(blocksize);
      for (var i = 0; i < blocksize; i++) {
        ipad[i] = key[i] ^ 54;
        opad[i] = key[i] ^ 92;
      }
      this._hash = alg === "rmd160" ? new RIPEMD1602() : sha(alg);
      this._hash.update(ipad);
    }
    inherits(Hmac, Base);
    Hmac.prototype._update = function(data) {
      this._hash.update(data);
    };
    Hmac.prototype._final = function() {
      var h = this._hash.digest();
      var hash = this._alg === "rmd160" ? new RIPEMD1602() : sha(this._alg);
      return hash.update(this._opad).update(h).digest();
    };
    module2.exports = function createHmac(alg, key) {
      alg = alg.toLowerCase();
      if (alg === "rmd160" || alg === "ripemd160") {
        return new Hmac("rmd160", key);
      }
      if (alg === "md5") {
        return new Legacy(md5, key);
      }
      return new Hmac(alg, key);
    };
  }
});

// node_modules/bip32/src/crypto.js
var require_crypto = __commonJS({
  "node_modules/bip32/src/crypto.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var createHash = require_browser2();
    var createHmac = require_browser3();
    function hash1602(buffer) {
      const sha256Hash = createHash("sha256").update(buffer).digest();
      try {
        return createHash("rmd160").update(sha256Hash).digest();
      } catch (err) {
        return createHash("ripemd160").update(sha256Hash).digest();
      }
    }
    exports2.hash160 = hash1602;
    function hmacSHA512(key, data) {
      return createHmac("sha512", key).update(data).digest();
    }
    exports2.hmacSHA512 = hmacSHA512;
  }
});

// node_modules/base-x/src/index.js
var require_src = __commonJS({
  "node_modules/base-x/src/index.js"(exports2, module2) {
    "use strict";
    var _Buffer = require_safe_buffer().Buffer;
    function base(ALPHABET) {
      if (ALPHABET.length >= 255) {
        throw new TypeError("Alphabet too long");
      }
      var BASE_MAP = new Uint8Array(256);
      for (var j = 0; j < BASE_MAP.length; j++) {
        BASE_MAP[j] = 255;
      }
      for (var i = 0; i < ALPHABET.length; i++) {
        var x = ALPHABET.charAt(i);
        var xc = x.charCodeAt(0);
        if (BASE_MAP[xc] !== 255) {
          throw new TypeError(x + " is ambiguous");
        }
        BASE_MAP[xc] = i;
      }
      var BASE = ALPHABET.length;
      var LEADER = ALPHABET.charAt(0);
      var FACTOR = Math.log(BASE) / Math.log(256);
      var iFACTOR = Math.log(256) / Math.log(BASE);
      function encode(source) {
        if (Array.isArray(source) || source instanceof Uint8Array) {
          source = _Buffer.from(source);
        }
        if (!_Buffer.isBuffer(source)) {
          throw new TypeError("Expected Buffer");
        }
        if (source.length === 0) {
          return "";
        }
        var zeroes = 0;
        var length = 0;
        var pbegin = 0;
        var pend = source.length;
        while (pbegin !== pend && source[pbegin] === 0) {
          pbegin++;
          zeroes++;
        }
        var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size);
        while (pbegin !== pend) {
          var carry = source[pbegin];
          var i2 = 0;
          for (var it1 = size - 1; (carry !== 0 || i2 < length) && it1 !== -1; it1--, i2++) {
            carry += 256 * b58[it1] >>> 0;
            b58[it1] = carry % BASE >>> 0;
            carry = carry / BASE >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length = i2;
          pbegin++;
        }
        var it2 = size - length;
        while (it2 !== size && b58[it2] === 0) {
          it2++;
        }
        var str = LEADER.repeat(zeroes);
        for (; it2 < size; ++it2) {
          str += ALPHABET.charAt(b58[it2]);
        }
        return str;
      }
      function decodeUnsafe(source) {
        if (typeof source !== "string") {
          throw new TypeError("Expected String");
        }
        if (source.length === 0) {
          return _Buffer.alloc(0);
        }
        var psz = 0;
        var zeroes = 0;
        var length = 0;
        while (source[psz] === LEADER) {
          zeroes++;
          psz++;
        }
        var size = (source.length - psz) * FACTOR + 1 >>> 0;
        var b256 = new Uint8Array(size);
        while (psz < source.length) {
          var charCode = source.charCodeAt(psz);
          if (charCode > 255) {
            return;
          }
          var carry = BASE_MAP[charCode];
          if (carry === 255) {
            return;
          }
          var i2 = 0;
          for (var it3 = size - 1; (carry !== 0 || i2 < length) && it3 !== -1; it3--, i2++) {
            carry += BASE * b256[it3] >>> 0;
            b256[it3] = carry % 256 >>> 0;
            carry = carry / 256 >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length = i2;
          psz++;
        }
        var it4 = size - length;
        while (it4 !== size && b256[it4] === 0) {
          it4++;
        }
        var vch = _Buffer.allocUnsafe(zeroes + (size - it4));
        vch.fill(0, 0, zeroes);
        var j2 = zeroes;
        while (it4 !== size) {
          vch[j2++] = b256[it4++];
        }
        return vch;
      }
      function decode(string) {
        var buffer = decodeUnsafe(string);
        if (buffer) {
          return buffer;
        }
        throw new Error("Non-base" + BASE + " character");
      }
      return {
        encode,
        decodeUnsafe,
        decode
      };
    }
    module2.exports = base;
  }
});

// node_modules/bs58/index.js
var require_bs58 = __commonJS({
  "node_modules/bs58/index.js"(exports2, module2) {
    var basex = require_src();
    var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    module2.exports = basex(ALPHABET);
  }
});

// node_modules/bs58check/base.js
var require_base = __commonJS({
  "node_modules/bs58check/base.js"(exports2, module2) {
    "use strict";
    var base58 = require_bs58();
    var Buffer2 = require_safe_buffer().Buffer;
    module2.exports = function(checksumFn) {
      function encode(payload) {
        var checksum = checksumFn(payload);
        return base58.encode(Buffer2.concat([
          payload,
          checksum
        ], payload.length + 4));
      }
      function decodeRaw(buffer) {
        var payload = buffer.slice(0, -4);
        var checksum = buffer.slice(-4);
        var newChecksum = checksumFn(payload);
        if (checksum[0] ^ newChecksum[0] | checksum[1] ^ newChecksum[1] | checksum[2] ^ newChecksum[2] | checksum[3] ^ newChecksum[3]) return;
        return payload;
      }
      function decodeUnsafe(string) {
        var buffer = base58.decodeUnsafe(string);
        if (!buffer) return;
        return decodeRaw(buffer);
      }
      function decode(string) {
        var buffer = base58.decode(string);
        var payload = decodeRaw(buffer, checksumFn);
        if (!payload) throw new Error("Invalid checksum");
        return payload;
      }
      return {
        encode,
        decode,
        decodeUnsafe
      };
    };
  }
});

// node_modules/bs58check/index.js
var require_bs58check = __commonJS({
  "node_modules/bs58check/index.js"(exports2, module2) {
    "use strict";
    var createHash = require_browser2();
    var bs58checkBase = require_base();
    function sha256x2(buffer) {
      var tmp = createHash("sha256").update(buffer).digest();
      return createHash("sha256").update(tmp).digest();
    }
    module2.exports = bs58checkBase(sha256x2);
  }
});

// node_modules/tiny-secp256k1/node_modules/bn.js/lib/bn.js
var require_bn = __commonJS({
  "node_modules/tiny-secp256k1/node_modules/bn.js/lib/bn.js"(exports2, module2) {
    (function(module3, exports3) {
      "use strict";
      function assert(val, msg) {
        if (!val) throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN(number, base, endian) {
        if (BN.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base === "le" || base === "be") {
            endian = base;
            base = 10;
          }
          this._init(number || 0, base || 10, endian || "be");
        }
      }
      if (typeof module3 === "object") {
        module3.exports = BN;
      } else {
        exports3.BN = BN;
      }
      BN.BN = BN;
      BN.wordSize = 26;
      var Buffer2;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer2 = window.Buffer;
        } else {
          Buffer2 = require_buffer().Buffer;
        }
      } catch (e) {
      }
      BN.isBN = function isBN(num) {
        if (num instanceof BN) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      };
      BN.max = function max(left, right) {
        if (left.cmp(right) > 0) return left;
        return right;
      };
      BN.min = function min(left, right) {
        if (left.cmp(right) < 0) return left;
        return right;
      };
      BN.prototype._init = function init(number, base, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base, endian);
        }
        if (base === "hex") {
          base = 16;
        }
        assert(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base, endian);
            }
          }
        }
      };
      BN.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le") return;
        this._initArray(this.toArray(), base, endian);
      };
      BN.prototype._initArray = function _initArray(number, base, endian) {
        assert(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j, w;
        var off = 0;
        if (endian === "be") {
          for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
            w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === "le") {
          for (i = 0, j = 0; i < number.length; i += 3) {
            w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this.strip();
      };
      function parseHex4Bits(string, index) {
        var c = string.charCodeAt(index);
        if (c >= 65 && c <= 70) {
          return c - 55;
        } else if (c >= 97 && c <= 102) {
          return c - 87;
        } else {
          return c - 48 & 15;
        }
      }
      function parseHexByte(string, lowerBound, index) {
        var r = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) {
          r |= parseHex4Bits(string, index - 1) << 4;
        }
        return r;
      }
      BN.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var off = 0;
        var j = 0;
        var w;
        if (endian === "be") {
          for (i = number.length - 1; i >= start; i -= 2) {
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r *= mul;
          if (c >= 49) {
            r += c - 49 + 10;
          } else if (c >= 17) {
            r += c - 17 + 10;
          } else {
            r += c;
          }
        }
        return r;
      }
      BN.prototype._parseBase = function _parseBase(number, base, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod3 = total % limbLen;
        var end = Math.min(total, total - mod3) + start;
        var word = 0;
        for (var i = start; i < end; i += limbLen) {
          word = parseBase(number, i, i + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod3 !== 0) {
          var pow = 1;
          word = parseBase(number, i, number.length, base);
          for (i = 0; i < mod3; i++) {
            pow *= base;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this.strip();
      };
      BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          dest.words[i] = this.words[i];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN.prototype.clone = function clone() {
        var r = new BN(null);
        this.copy(r);
        return r;
      };
      BN.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN.prototype.toString = function toString(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = this.words[i];
            var word = ((w << off | carry) & 16777215).toString(16);
            carry = w >>> 24 - off & 16777215;
            off += 2;
            if (off >= 26) {
              off -= 26;
              i--;
            }
            if (carry !== 0 || i !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r = c.modn(groupBase).toString(base);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
              out = zeros[groupSize - r.length] + r + out;
            } else {
              out = r + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert(false, "Base should be between 2 and 36");
      };
      BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN.prototype.toJSON = function toJSON() {
        return this.toString(16);
      };
      BN.prototype.toBuffer = function toBuffer(endian, length) {
        assert(typeof Buffer2 !== "undefined");
        return this.toArrayLike(Buffer2, endian, length);
      };
      BN.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b2, i;
        var q = this.clone();
        if (!littleEndian) {
          for (i = 0; i < reqLength - byteLength; i++) {
            res[i] = 0;
          }
          for (i = 0; !q.isZero(); i++) {
            b2 = q.andln(255);
            q.iushrn(8);
            res[reqLength - i - 1] = b2;
          }
        } else {
          for (i = 0; !q.isZero(); i++) {
            b2 = q.andln(255);
            q.iushrn(8);
            res[i] = b2;
          }
          for (; i < reqLength; i++) {
            res[i] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      } else {
        BN.prototype._countBits = function _countBits(w) {
          var t = w;
          var r = 0;
          if (t >= 4096) {
            r += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r += 2;
            t >>>= 2;
          }
          return r + t;
        };
      }
      BN.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0) return 26;
        var t = w;
        var r = 0;
        if ((t & 8191) === 0) {
          r += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r++;
        }
        return r;
      };
      BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0; bit < w.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w;
      }
      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero()) return 0;
        var r = 0;
        for (var i = 0; i < this.length; i++) {
          var b2 = this._zeroBits(this.words[i]);
          r += b2;
          if (b2 !== 26) break;
        }
        return r;
      };
      BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i = 0; i < num.length; i++) {
          this.words[i] = this.words[i] | num.words[i];
        }
        return this.strip();
      };
      BN.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN.prototype.or = function or(num) {
        if (this.length > num.length) return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN.prototype.uor = function uor(num) {
        if (this.length > num.length) return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN.prototype.iuand = function iuand(num) {
        var b2;
        if (this.length > num.length) {
          b2 = num;
        } else {
          b2 = this;
        }
        for (var i = 0; i < b2.length; i++) {
          this.words[i] = this.words[i] & num.words[i];
        }
        this.length = b2.length;
        return this.strip();
      };
      BN.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN.prototype.and = function and(num) {
        if (this.length > num.length) return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN.prototype.uand = function uand(num) {
        if (this.length > num.length) return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN.prototype.iuxor = function iuxor(num) {
        var a;
        var b2;
        if (this.length > num.length) {
          a = this;
          b2 = num;
        } else {
          a = num;
          b2 = this;
        }
        for (var i = 0; i < b2.length; i++) {
          this.words[i] = a.words[i] ^ b2.words[i];
        }
        if (this !== a) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = a.length;
        return this.strip();
      };
      BN.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN.prototype.xor = function xor(num) {
        if (this.length > num.length) return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length) return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i = 0; i < bytesNeeded; i++) {
          this.words[i] = ~this.words[i] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN.prototype.iadd = function iadd(num) {
        var r;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r = this.isub(num);
          num.negative = 1;
          return r._normSign();
        }
        var a, b2;
        if (this.length > num.length) {
          a = this;
          b2 = num;
        } else {
          a = num;
          b2 = this;
        }
        var carry = 0;
        for (var i = 0; i < b2.length; i++) {
          r = (a.words[i] | 0) + (b2.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        return this;
      };
      BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length) return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          num.negative = 1;
          return r._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a, b2;
        if (cmp > 0) {
          a = this;
          b2 = num;
        } else {
          a = num;
          b2 = this;
        }
        var carry = 0;
        for (var i = 0; i < b2.length; i++) {
          r = (a.words[i] | 0) - (b2.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        if (carry === 0 && i < a.length && a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = Math.max(this.length, i);
        if (a !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a = self2.words[0] | 0;
        var b2 = num.words[0] | 0;
        var r = a * b2;
        var lo = r & 67108863;
        var carry = r / 67108864 | 0;
        out.words[0] = lo;
        for (var k = 1; k < len; k++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j | 0;
            a = self2.words[i] | 0;
            b2 = num.words[j] | 0;
            r = a * b2 + rword;
            ncarry += r / 67108864 | 0;
            rword = r & 67108863;
          }
          out.words[k] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a = self2.words;
        var b2 = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 8191;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b2[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b2[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b22 = b2[2] | 0;
        var bl2 = b22 & 8191;
        var bh2 = b22 >>> 13;
        var b3 = b2[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b2[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b2[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b2[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b2[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b2[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b2[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
          o[19] = c;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k = 0; k < out.length - 1; k++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j;
            var a = self2.words[i] | 0;
            var b2 = num.words[j] | 0;
            var r = a * b2;
            var lo = r & 67108863;
            ncarry = ncarry + (r / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x, y) {
        this.x = x;
        this.y = y;
      }
      FFTM.prototype.makeRBT = function makeRBT(N) {
        var t = new Array(N);
        var l = BN.prototype._countBits(N) - 1;
        for (var i = 0; i < N; i++) {
          t[i] = this.revBin(i, l, N);
        }
        return t;
      };
      FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1) return x;
        var rb = 0;
        for (var i = 0; i < l; i++) {
          rb |= (x & 1) << l - i - 1;
          x >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for (var i = 0; i < N; i++) {
          rtws[i] = rws[rbt[i]];
          itws[i] = iws[rbt[i]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for (var s = 1; s < N; s <<= 1) {
          var l = s << 1;
          var rtwdf = Math.cos(2 * Math.PI / l);
          var itwdf = Math.sin(2 * Math.PI / l);
          for (var p = 0; p < N; p += l) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j = 0; j < s; j++) {
              var re = rtws[p + j];
              var ie = itws[p + j];
              var ro = rtws[p + j + s];
              var io = itws[p + j + s];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p + j] = re + ro;
              itws[p + j] = ie + io;
              rtws[p + j + s] = re - ro;
              itws[p + j + s] = ie - io;
              if (j !== l) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N = Math.max(m, n) | 1;
        var odd = N & 1;
        var i = 0;
        for (N = N / 2 | 0; N; N = N >>> 1) {
          i++;
        }
        return 1 << i + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1) return;
        for (var i = 0; i < N / 2; i++) {
          var t = rws[i];
          rws[i] = rws[N - i - 1];
          rws[N - i - 1] = t;
          t = iws[i];
          iws[i] = -iws[N - i - 1];
          iws[N - i - 1] = -t;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;
        for (var i = 0; i < N / 2; i++) {
          var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
          ws[i] = w & 67108863;
          if (w < 67108864) {
            carry = 0;
          } else {
            carry = w / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
        var carry = 0;
        for (var i = 0; i < len; i++) {
          carry = carry + (ws[i] | 0);
          rws[2 * i] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i = 2 * len; i < N; ++i) {
          rws[i] = 0;
        }
        assert(carry === 0);
        assert((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for (var i = 0; i < N; i++) {
          ph[i] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N);
        var _ = this.stub(N);
        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
        var rmws = out.words;
        rmws.length = N;
        this.convert13b(x.words, x.length, rws, N);
        this.convert13b(y.words, y.length, nrws, N);
        this.transform(rws, _, rwst, iwst, N, rbt);
        this.transform(nrws, _, nrwst, niwst, N, rbt);
        for (var i = 0; i < N; i++) {
          var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
          iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
          rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _, N, rbt);
        this.conjugate(rmws, _, N);
        this.normalize13b(rmws, N);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out.strip();
      };
      BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN.prototype.imuln = function imuln(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w = (this.words[i] | 0) * num;
          var lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        this.length = num === 0 ? 1 : this.length;
        return this;
      };
      BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0) return new BN(1);
        var res = this;
        for (var i = 0; i < w.length; i++, res = res.sqr()) {
          if (w[i] !== 0) break;
        }
        if (++i < w.length) {
          for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
            if (w[i] === 0) continue;
            res = res.mul(q);
          }
        }
        return res;
      };
      BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 67108863 >>> 26 - r << 26 - r;
        var i;
        if (r !== 0) {
          var carry = 0;
          for (i = 0; i < this.length; i++) {
            var newCarry = this.words[i] & carryMask;
            var c = (this.words[i] | 0) - newCarry << r;
            this.words[i] = c | carry;
            carry = newCarry >>> 26 - r;
          }
          if (carry) {
            this.words[i] = carry;
            this.length++;
          }
        }
        if (s !== 0) {
          for (i = this.length - 1; i >= 0; i--) {
            this.words[i + s] = this.words[i];
          }
          for (i = 0; i < s; i++) {
            this.words[i] = 0;
          }
          this.length += s;
        }
        return this.strip();
      };
      BN.prototype.ishln = function ishln(bits) {
        assert(this.negative === 0);
        return this.iushln(bits);
      };
      BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) {
          h = (hint - hint % 26) / 26;
        } else {
          h = 0;
        }
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r << r;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        if (maskedWords) {
          for (var i = 0; i < s; i++) {
            maskedWords.words[i] = this.words[i];
          }
          maskedWords.length = s;
        }
        if (s === 0) {
        } else if (this.length > s) {
          this.length -= s;
          for (i = 0; i < this.length; i++) {
            this.words[i] = this.words[i + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
          var word = this.words[i] | 0;
          this.words[i] = carry << 26 - r | word >>> r;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) return false;
        var w = this.words[s];
        return !!(w & q);
      };
      BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) {
          return this;
        }
        if (r !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
        if (r !== 0) {
          var mask = 67108863 ^ 67108863 >>> r << r;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0) return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
          this.words[i] -= 67108864;
          if (i === this.length - 1) {
            this.words[i + 1] = 1;
          } else {
            this.words[i + 1]++;
          }
        }
        this.length = Math.max(this.length, i + 1);
        return this;
      };
      BN.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0) return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i = 0; i < this.length && this.words[i] < 0; i++) {
            this.words[i] += 67108864;
            this.words[i + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i;
        this._expand(len);
        var w;
        var carry = 0;
        for (i = 0; i < num.length; i++) {
          w = (this.words[i + shift] | 0) + carry;
          var right = (num.words[i] | 0) * mul;
          w -= right & 67108863;
          carry = (w >> 26) - (right / 67108864 | 0);
          this.words[i + shift] = w & 67108863;
        }
        for (; i < this.length - shift; i++) {
          w = (this.words[i + shift] | 0) + carry;
          carry = w >> 26;
          this.words[i + shift] = w & 67108863;
        }
        if (carry === 0) return this.strip();
        assert(carry === -1);
        carry = 0;
        for (i = 0; i < this.length; i++) {
          w = -(this.words[i] | 0) + carry;
          carry = w >> 26;
          this.words[i] = w & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b2 = num;
        var bhi = b2.words[b2.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b2 = b2.ushln(shift);
          a.iushln(shift);
          bhi = b2.words[b2.length - 1] | 0;
        }
        var m = a.length - b2.length;
        var q;
        if (mode !== "mod") {
          q = new BN(null);
          q.length = m + 1;
          q.words = new Array(q.length);
          for (var i = 0; i < q.length; i++) {
            q.words[i] = 0;
          }
        }
        var diff = a.clone()._ishlnsubmul(b2, 1, m);
        if (diff.negative === 0) {
          a = diff;
          if (q) {
            q.words[m] = 1;
          }
        }
        for (var j = m - 1; j >= 0; j--) {
          var qj = (a.words[b2.length + j] | 0) * 67108864 + (a.words[b2.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a._ishlnsubmul(b2, qj, j);
          while (a.negative !== 0) {
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b2, 1, j);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q) {
            q.words[j] = qj;
          }
        }
        if (q) {
          q.strip();
        }
        a.strip();
        if (mode !== "div" && shift !== 0) {
          a.iushrn(shift);
        }
        return {
          div: q || null,
          mod: a
        };
      };
      BN.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN(0),
            mod: new BN(0)
          };
        }
        var div, mod3, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod3 = res.mod.neg();
            if (positive && mod3.negative !== 0) {
              mod3.iadd(num);
            }
          }
          return {
            div,
            mod: mod3
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod3 = res.mod.neg();
            if (positive && mod3.negative !== 0) {
              mod3.isub(num);
            }
          }
          return {
            div: res.div,
            mod: mod3
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN.prototype.mod = function mod3(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero()) return dm.div;
        var mod3 = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod3.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN.prototype.modn = function modn(num) {
        assert(num <= 67108863);
        var p = (1 << 26) % num;
        var acc = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          acc = (p * acc + (this.words[i] | 0)) % num;
        }
        return acc;
      };
      BN.prototype.idivn = function idivn(num) {
        assert(num <= 67108863);
        var carry = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var w = (this.words[i] | 0) + carry * 67108864;
          this.words[i] = w / num | 0;
          carry = w % num;
        }
        return this.strip();
      };
      BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN.prototype.egcd = function egcd(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) {
          x = x.umod(p);
        } else {
          x = x.clone();
        }
        var A = new BN(1);
        var B = new BN(0);
        var C = new BN(0);
        var D = new BN(1);
        var g = 0;
        while (x.isEven() && y.isEven()) {
          x.iushrn(1);
          y.iushrn(1);
          ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while (!x.isZero()) {
          for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1) ;
          if (i > 0) {
            x.iushrn(i);
            while (i-- > 0) {
              if (A.isOdd() || B.isOdd()) {
                A.iadd(yp);
                B.isub(xp);
              }
              A.iushrn(1);
              B.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) ;
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }
              C.iushrn(1);
              D.iushrn(1);
            }
          }
          if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
          } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
          }
        }
        return {
          a: C,
          b: D,
          gcd: y.iushln(g)
        };
      };
      BN.prototype._invmp = function _invmp(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var a = this;
        var b2 = p.clone();
        if (a.negative !== 0) {
          a = a.umod(p);
        } else {
          a = a.clone();
        }
        var x1 = new BN(1);
        var x2 = new BN(0);
        var delta = b2.clone();
        while (a.cmpn(1) > 0 && b2.cmpn(1) > 0) {
          for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1) ;
          if (i > 0) {
            a.iushrn(i);
            while (i-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (b2.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) ;
          if (j > 0) {
            b2.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a.cmp(b2) >= 0) {
            a.isub(b2);
            x1.isub(x2);
          } else {
            b2.isub(a);
            x2.isub(x1);
          }
        }
        var res;
        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }
        return res;
      };
      BN.prototype.gcd = function gcd(num) {
        if (this.isZero()) return num.abs();
        if (num.isZero()) return this.abs();
        var a = this.clone();
        var b2 = num.clone();
        a.negative = 0;
        b2.negative = 0;
        for (var shift = 0; a.isEven() && b2.isEven(); shift++) {
          a.iushrn(1);
          b2.iushrn(1);
        }
        do {
          while (a.isEven()) {
            a.iushrn(1);
          }
          while (b2.isEven()) {
            b2.iushrn(1);
          }
          var r = a.cmp(b2);
          if (r < 0) {
            var t = a;
            a = b2;
            b2 = t;
          } else if (r === 0 || b2.cmpn(1) === 0) {
            break;
          }
          a.isub(b2);
        } while (true);
        return b2.iushln(shift);
      };
      BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q;
          return this;
        }
        var carry = q;
        for (var i = s; carry !== 0 && i < this.length; i++) {
          var w = this.words[i] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 67108863;
          this.words[i] = w;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative) return -1;
        if (this.negative === 0 && negative) return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert(num <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0) return -1;
        if (this.negative === 0 && num.negative !== 0) return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length) return 1;
        if (this.length < num.length) return -1;
        var res = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var a = this.words[i] | 0;
          var b2 = num.words[i] | 0;
          if (a === b2) continue;
          if (a < b2) {
            res = -1;
          } else if (a > b2) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN.red = function red(num) {
        return new Red(num);
      };
      BN.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p) {
        this.name = name;
        this.p = new BN(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r = num;
        var rlen;
        do {
          this.split(r, this.tmp);
          r = this.imulK(r);
          r = r.iadd(this.tmp);
          rlen = r.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
          r.words[0] = 0;
          r.length = 1;
        } else if (cmp > 0) {
          r.isub(this.p);
        } else {
          if (r.strip !== void 0) {
            r.strip();
          } else {
            r._strip();
          }
        }
        return r;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i = 0; i < outLen; i++) {
          output.words[i] = input.words[i];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i = 10; i < input.length; i++) {
          var next = input.words[i] | 0;
          input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i = 0; i < num.length; i++) {
          var w = num.words[i] | 0;
          lo += w * 977;
          num.words[i] = lo & 67108863;
          lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i = 0; i < num.length; i++) {
          var hi = (num.words[i] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN._prime = function prime(name) {
        if (primes[name]) return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert(m.gtn(1), "modulus must be greater than 1");
          this.m = m;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, "red works only with positives");
        assert(a.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a, b2) {
        assert((a.negative | b2.negative) === 0, "red works only with positives");
        assert(
          a.red && a.red === b2.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a) {
        if (this.prime) return this.prime.ireduce(a)._forceRed(this);
        return a.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
          return a.clone();
        }
        return this.m.sub(a)._forceRed(this);
      };
      Red.prototype.add = function add(a, b2) {
        this._verify2(a, b2);
        var res = a.add(b2);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a, b2) {
        this._verify2(a, b2);
        var res = a.iadd(b2);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a, b2) {
        this._verify2(a, b2);
        var res = a.sub(b2);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a, b2) {
        this._verify2(a, b2);
        var res = a.isub(b2);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
      };
      Red.prototype.imul = function imul(a, b2) {
        this._verify2(a, b2);
        return this.imod(a.imul(b2));
      };
      Red.prototype.mul = function mul(a, b2) {
        this._verify2(a, b2);
        return this.imod(a.mul(b2));
      };
      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };
      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };
      Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero()) return a.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a, pow);
        }
        var q = this.m.subn(1);
        var s = 0;
        while (!q.isZero() && q.andln(1) === 0) {
          s++;
          q.iushrn(1);
        }
        assert(!q.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }
        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i = 0; tmp.cmp(one) !== 0; i++) {
            tmp = tmp.redSqr();
          }
          assert(i < m);
          var b2 = this.pow(c, new BN(1).iushln(m - i - 1));
          r = r.redMul(b2);
          c = b2.redSqr();
          t = t.redMul(c);
          m = i;
        }
        return r;
      };
      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a, num) {
        if (num.isZero()) return new BN(1).toRed(this);
        if (num.cmpn(1) === 0) return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a;
        for (var i = 2; i < wnd.length; i++) {
          wnd[i] = this.mul(wnd[i - 1], a);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i = num.length - 1; i >= 0; i--) {
          var word = num.words[i];
          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
      };
      Mont.prototype.imul = function imul(a, b2) {
        if (a.isZero() || b2.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }
        var t = a.imul(b2);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a, b2) {
        if (a.isZero() || b2.isZero()) return new BN(0)._forceRed(this);
        var t = a.mul(b2);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module2 === "undefined" || module2, exports2);
  }
});

// node_modules/elliptic/package.json
var require_package = __commonJS({
  "node_modules/elliptic/package.json"(exports2, module2) {
    module2.exports = {
      name: "elliptic",
      version: "6.6.1",
      description: "EC cryptography",
      main: "lib/elliptic.js",
      files: [
        "lib"
      ],
      scripts: {
        lint: "eslint lib test",
        "lint:fix": "npm run lint -- --fix",
        unit: "istanbul test _mocha --reporter=spec test/index.js",
        test: "npm run lint && npm run unit",
        version: "grunt dist && git add dist/"
      },
      repository: {
        type: "git",
        url: "git@github.com:indutny/elliptic"
      },
      keywords: [
        "EC",
        "Elliptic",
        "curve",
        "Cryptography"
      ],
      author: "Fedor Indutny <fedor@indutny.com>",
      license: "MIT",
      bugs: {
        url: "https://github.com/indutny/elliptic/issues"
      },
      homepage: "https://github.com/indutny/elliptic",
      devDependencies: {
        brfs: "^2.0.2",
        coveralls: "^3.1.0",
        eslint: "^7.6.0",
        grunt: "^1.2.1",
        "grunt-browserify": "^5.3.0",
        "grunt-cli": "^1.3.2",
        "grunt-contrib-connect": "^3.0.0",
        "grunt-contrib-copy": "^1.0.0",
        "grunt-contrib-uglify": "^5.0.0",
        "grunt-mocha-istanbul": "^5.0.2",
        "grunt-saucelabs": "^9.0.1",
        istanbul: "^0.4.5",
        mocha: "^8.0.1"
      },
      dependencies: {
        "bn.js": "^4.11.9",
        brorand: "^1.1.0",
        "hash.js": "^1.0.0",
        "hmac-drbg": "^1.0.1",
        inherits: "^2.0.4",
        "minimalistic-assert": "^1.0.1",
        "minimalistic-crypto-utils": "^1.0.1"
      }
    };
  }
});

// node_modules/elliptic/node_modules/bn.js/lib/bn.js
var require_bn2 = __commonJS({
  "node_modules/elliptic/node_modules/bn.js/lib/bn.js"(exports2, module2) {
    (function(module3, exports3) {
      "use strict";
      function assert(val, msg) {
        if (!val) throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN(number, base, endian) {
        if (BN.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base === "le" || base === "be") {
            endian = base;
            base = 10;
          }
          this._init(number || 0, base || 10, endian || "be");
        }
      }
      if (typeof module3 === "object") {
        module3.exports = BN;
      } else {
        exports3.BN = BN;
      }
      BN.BN = BN;
      BN.wordSize = 26;
      var Buffer2;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer2 = window.Buffer;
        } else {
          Buffer2 = require_buffer().Buffer;
        }
      } catch (e) {
      }
      BN.isBN = function isBN(num) {
        if (num instanceof BN) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      };
      BN.max = function max(left, right) {
        if (left.cmp(right) > 0) return left;
        return right;
      };
      BN.min = function min(left, right) {
        if (left.cmp(right) < 0) return left;
        return right;
      };
      BN.prototype._init = function init(number, base, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base, endian);
        }
        if (base === "hex") {
          base = 16;
        }
        assert(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base, endian);
            }
          }
        }
      };
      BN.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le") return;
        this._initArray(this.toArray(), base, endian);
      };
      BN.prototype._initArray = function _initArray(number, base, endian) {
        assert(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j, w;
        var off = 0;
        if (endian === "be") {
          for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
            w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === "le") {
          for (i = 0, j = 0; i < number.length; i += 3) {
            w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this.strip();
      };
      function parseHex4Bits(string, index) {
        var c = string.charCodeAt(index);
        if (c >= 65 && c <= 70) {
          return c - 55;
        } else if (c >= 97 && c <= 102) {
          return c - 87;
        } else {
          return c - 48 & 15;
        }
      }
      function parseHexByte(string, lowerBound, index) {
        var r = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) {
          r |= parseHex4Bits(string, index - 1) << 4;
        }
        return r;
      }
      BN.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var off = 0;
        var j = 0;
        var w;
        if (endian === "be") {
          for (i = number.length - 1; i >= start; i -= 2) {
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r *= mul;
          if (c >= 49) {
            r += c - 49 + 10;
          } else if (c >= 17) {
            r += c - 17 + 10;
          } else {
            r += c;
          }
        }
        return r;
      }
      BN.prototype._parseBase = function _parseBase(number, base, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod3 = total % limbLen;
        var end = Math.min(total, total - mod3) + start;
        var word = 0;
        for (var i = start; i < end; i += limbLen) {
          word = parseBase(number, i, i + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod3 !== 0) {
          var pow = 1;
          word = parseBase(number, i, number.length, base);
          for (i = 0; i < mod3; i++) {
            pow *= base;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this.strip();
      };
      BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          dest.words[i] = this.words[i];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN.prototype.clone = function clone() {
        var r = new BN(null);
        this.copy(r);
        return r;
      };
      BN.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN.prototype.toString = function toString(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = this.words[i];
            var word = ((w << off | carry) & 16777215).toString(16);
            carry = w >>> 24 - off & 16777215;
            off += 2;
            if (off >= 26) {
              off -= 26;
              i--;
            }
            if (carry !== 0 || i !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r = c.modn(groupBase).toString(base);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
              out = zeros[groupSize - r.length] + r + out;
            } else {
              out = r + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert(false, "Base should be between 2 and 36");
      };
      BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN.prototype.toJSON = function toJSON() {
        return this.toString(16);
      };
      BN.prototype.toBuffer = function toBuffer(endian, length) {
        assert(typeof Buffer2 !== "undefined");
        return this.toArrayLike(Buffer2, endian, length);
      };
      BN.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b2, i;
        var q = this.clone();
        if (!littleEndian) {
          for (i = 0; i < reqLength - byteLength; i++) {
            res[i] = 0;
          }
          for (i = 0; !q.isZero(); i++) {
            b2 = q.andln(255);
            q.iushrn(8);
            res[reqLength - i - 1] = b2;
          }
        } else {
          for (i = 0; !q.isZero(); i++) {
            b2 = q.andln(255);
            q.iushrn(8);
            res[i] = b2;
          }
          for (; i < reqLength; i++) {
            res[i] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      } else {
        BN.prototype._countBits = function _countBits(w) {
          var t = w;
          var r = 0;
          if (t >= 4096) {
            r += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r += 2;
            t >>>= 2;
          }
          return r + t;
        };
      }
      BN.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0) return 26;
        var t = w;
        var r = 0;
        if ((t & 8191) === 0) {
          r += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r++;
        }
        return r;
      };
      BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0; bit < w.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w;
      }
      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero()) return 0;
        var r = 0;
        for (var i = 0; i < this.length; i++) {
          var b2 = this._zeroBits(this.words[i]);
          r += b2;
          if (b2 !== 26) break;
        }
        return r;
      };
      BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i = 0; i < num.length; i++) {
          this.words[i] = this.words[i] | num.words[i];
        }
        return this.strip();
      };
      BN.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN.prototype.or = function or(num) {
        if (this.length > num.length) return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN.prototype.uor = function uor(num) {
        if (this.length > num.length) return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN.prototype.iuand = function iuand(num) {
        var b2;
        if (this.length > num.length) {
          b2 = num;
        } else {
          b2 = this;
        }
        for (var i = 0; i < b2.length; i++) {
          this.words[i] = this.words[i] & num.words[i];
        }
        this.length = b2.length;
        return this.strip();
      };
      BN.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN.prototype.and = function and(num) {
        if (this.length > num.length) return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN.prototype.uand = function uand(num) {
        if (this.length > num.length) return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN.prototype.iuxor = function iuxor(num) {
        var a;
        var b2;
        if (this.length > num.length) {
          a = this;
          b2 = num;
        } else {
          a = num;
          b2 = this;
        }
        for (var i = 0; i < b2.length; i++) {
          this.words[i] = a.words[i] ^ b2.words[i];
        }
        if (this !== a) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = a.length;
        return this.strip();
      };
      BN.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN.prototype.xor = function xor(num) {
        if (this.length > num.length) return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length) return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i = 0; i < bytesNeeded; i++) {
          this.words[i] = ~this.words[i] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN.prototype.iadd = function iadd(num) {
        var r;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r = this.isub(num);
          num.negative = 1;
          return r._normSign();
        }
        var a, b2;
        if (this.length > num.length) {
          a = this;
          b2 = num;
        } else {
          a = num;
          b2 = this;
        }
        var carry = 0;
        for (var i = 0; i < b2.length; i++) {
          r = (a.words[i] | 0) + (b2.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        return this;
      };
      BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length) return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          num.negative = 1;
          return r._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a, b2;
        if (cmp > 0) {
          a = this;
          b2 = num;
        } else {
          a = num;
          b2 = this;
        }
        var carry = 0;
        for (var i = 0; i < b2.length; i++) {
          r = (a.words[i] | 0) - (b2.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        if (carry === 0 && i < a.length && a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = Math.max(this.length, i);
        if (a !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a = self2.words[0] | 0;
        var b2 = num.words[0] | 0;
        var r = a * b2;
        var lo = r & 67108863;
        var carry = r / 67108864 | 0;
        out.words[0] = lo;
        for (var k = 1; k < len; k++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j | 0;
            a = self2.words[i] | 0;
            b2 = num.words[j] | 0;
            r = a * b2 + rword;
            ncarry += r / 67108864 | 0;
            rword = r & 67108863;
          }
          out.words[k] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a = self2.words;
        var b2 = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 8191;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b2[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b2[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b22 = b2[2] | 0;
        var bl2 = b22 & 8191;
        var bh2 = b22 >>> 13;
        var b3 = b2[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b2[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b2[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b2[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b2[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b2[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b2[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
          o[19] = c;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k = 0; k < out.length - 1; k++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j;
            var a = self2.words[i] | 0;
            var b2 = num.words[j] | 0;
            var r = a * b2;
            var lo = r & 67108863;
            ncarry = ncarry + (r / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x, y) {
        this.x = x;
        this.y = y;
      }
      FFTM.prototype.makeRBT = function makeRBT(N) {
        var t = new Array(N);
        var l = BN.prototype._countBits(N) - 1;
        for (var i = 0; i < N; i++) {
          t[i] = this.revBin(i, l, N);
        }
        return t;
      };
      FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1) return x;
        var rb = 0;
        for (var i = 0; i < l; i++) {
          rb |= (x & 1) << l - i - 1;
          x >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for (var i = 0; i < N; i++) {
          rtws[i] = rws[rbt[i]];
          itws[i] = iws[rbt[i]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for (var s = 1; s < N; s <<= 1) {
          var l = s << 1;
          var rtwdf = Math.cos(2 * Math.PI / l);
          var itwdf = Math.sin(2 * Math.PI / l);
          for (var p = 0; p < N; p += l) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j = 0; j < s; j++) {
              var re = rtws[p + j];
              var ie = itws[p + j];
              var ro = rtws[p + j + s];
              var io = itws[p + j + s];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p + j] = re + ro;
              itws[p + j] = ie + io;
              rtws[p + j + s] = re - ro;
              itws[p + j + s] = ie - io;
              if (j !== l) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N = Math.max(m, n) | 1;
        var odd = N & 1;
        var i = 0;
        for (N = N / 2 | 0; N; N = N >>> 1) {
          i++;
        }
        return 1 << i + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1) return;
        for (var i = 0; i < N / 2; i++) {
          var t = rws[i];
          rws[i] = rws[N - i - 1];
          rws[N - i - 1] = t;
          t = iws[i];
          iws[i] = -iws[N - i - 1];
          iws[N - i - 1] = -t;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;
        for (var i = 0; i < N / 2; i++) {
          var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
          ws[i] = w & 67108863;
          if (w < 67108864) {
            carry = 0;
          } else {
            carry = w / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
        var carry = 0;
        for (var i = 0; i < len; i++) {
          carry = carry + (ws[i] | 0);
          rws[2 * i] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i = 2 * len; i < N; ++i) {
          rws[i] = 0;
        }
        assert(carry === 0);
        assert((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for (var i = 0; i < N; i++) {
          ph[i] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N);
        var _ = this.stub(N);
        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
        var rmws = out.words;
        rmws.length = N;
        this.convert13b(x.words, x.length, rws, N);
        this.convert13b(y.words, y.length, nrws, N);
        this.transform(rws, _, rwst, iwst, N, rbt);
        this.transform(nrws, _, nrwst, niwst, N, rbt);
        for (var i = 0; i < N; i++) {
          var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
          iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
          rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _, N, rbt);
        this.conjugate(rmws, _, N);
        this.normalize13b(rmws, N);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out.strip();
      };
      BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN.prototype.imuln = function imuln(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w = (this.words[i] | 0) * num;
          var lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        this.length = num === 0 ? 1 : this.length;
        return this;
      };
      BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0) return new BN(1);
        var res = this;
        for (var i = 0; i < w.length; i++, res = res.sqr()) {
          if (w[i] !== 0) break;
        }
        if (++i < w.length) {
          for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
            if (w[i] === 0) continue;
            res = res.mul(q);
          }
        }
        return res;
      };
      BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 67108863 >>> 26 - r << 26 - r;
        var i;
        if (r !== 0) {
          var carry = 0;
          for (i = 0; i < this.length; i++) {
            var newCarry = this.words[i] & carryMask;
            var c = (this.words[i] | 0) - newCarry << r;
            this.words[i] = c | carry;
            carry = newCarry >>> 26 - r;
          }
          if (carry) {
            this.words[i] = carry;
            this.length++;
          }
        }
        if (s !== 0) {
          for (i = this.length - 1; i >= 0; i--) {
            this.words[i + s] = this.words[i];
          }
          for (i = 0; i < s; i++) {
            this.words[i] = 0;
          }
          this.length += s;
        }
        return this.strip();
      };
      BN.prototype.ishln = function ishln(bits) {
        assert(this.negative === 0);
        return this.iushln(bits);
      };
      BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) {
          h = (hint - hint % 26) / 26;
        } else {
          h = 0;
        }
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r << r;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        if (maskedWords) {
          for (var i = 0; i < s; i++) {
            maskedWords.words[i] = this.words[i];
          }
          maskedWords.length = s;
        }
        if (s === 0) {
        } else if (this.length > s) {
          this.length -= s;
          for (i = 0; i < this.length; i++) {
            this.words[i] = this.words[i + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
          var word = this.words[i] | 0;
          this.words[i] = carry << 26 - r | word >>> r;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) return false;
        var w = this.words[s];
        return !!(w & q);
      };
      BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) {
          return this;
        }
        if (r !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
        if (r !== 0) {
          var mask = 67108863 ^ 67108863 >>> r << r;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0) return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
          this.words[i] -= 67108864;
          if (i === this.length - 1) {
            this.words[i + 1] = 1;
          } else {
            this.words[i + 1]++;
          }
        }
        this.length = Math.max(this.length, i + 1);
        return this;
      };
      BN.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0) return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i = 0; i < this.length && this.words[i] < 0; i++) {
            this.words[i] += 67108864;
            this.words[i + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i;
        this._expand(len);
        var w;
        var carry = 0;
        for (i = 0; i < num.length; i++) {
          w = (this.words[i + shift] | 0) + carry;
          var right = (num.words[i] | 0) * mul;
          w -= right & 67108863;
          carry = (w >> 26) - (right / 67108864 | 0);
          this.words[i + shift] = w & 67108863;
        }
        for (; i < this.length - shift; i++) {
          w = (this.words[i + shift] | 0) + carry;
          carry = w >> 26;
          this.words[i + shift] = w & 67108863;
        }
        if (carry === 0) return this.strip();
        assert(carry === -1);
        carry = 0;
        for (i = 0; i < this.length; i++) {
          w = -(this.words[i] | 0) + carry;
          carry = w >> 26;
          this.words[i] = w & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b2 = num;
        var bhi = b2.words[b2.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b2 = b2.ushln(shift);
          a.iushln(shift);
          bhi = b2.words[b2.length - 1] | 0;
        }
        var m = a.length - b2.length;
        var q;
        if (mode !== "mod") {
          q = new BN(null);
          q.length = m + 1;
          q.words = new Array(q.length);
          for (var i = 0; i < q.length; i++) {
            q.words[i] = 0;
          }
        }
        var diff = a.clone()._ishlnsubmul(b2, 1, m);
        if (diff.negative === 0) {
          a = diff;
          if (q) {
            q.words[m] = 1;
          }
        }
        for (var j = m - 1; j >= 0; j--) {
          var qj = (a.words[b2.length + j] | 0) * 67108864 + (a.words[b2.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a._ishlnsubmul(b2, qj, j);
          while (a.negative !== 0) {
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b2, 1, j);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q) {
            q.words[j] = qj;
          }
        }
        if (q) {
          q.strip();
        }
        a.strip();
        if (mode !== "div" && shift !== 0) {
          a.iushrn(shift);
        }
        return {
          div: q || null,
          mod: a
        };
      };
      BN.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN(0),
            mod: new BN(0)
          };
        }
        var div, mod3, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod3 = res.mod.neg();
            if (positive && mod3.negative !== 0) {
              mod3.iadd(num);
            }
          }
          return {
            div,
            mod: mod3
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod3 = res.mod.neg();
            if (positive && mod3.negative !== 0) {
              mod3.isub(num);
            }
          }
          return {
            div: res.div,
            mod: mod3
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN.prototype.mod = function mod3(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero()) return dm.div;
        var mod3 = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod3.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN.prototype.modn = function modn(num) {
        assert(num <= 67108863);
        var p = (1 << 26) % num;
        var acc = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          acc = (p * acc + (this.words[i] | 0)) % num;
        }
        return acc;
      };
      BN.prototype.idivn = function idivn(num) {
        assert(num <= 67108863);
        var carry = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var w = (this.words[i] | 0) + carry * 67108864;
          this.words[i] = w / num | 0;
          carry = w % num;
        }
        return this.strip();
      };
      BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN.prototype.egcd = function egcd(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) {
          x = x.umod(p);
        } else {
          x = x.clone();
        }
        var A = new BN(1);
        var B = new BN(0);
        var C = new BN(0);
        var D = new BN(1);
        var g = 0;
        while (x.isEven() && y.isEven()) {
          x.iushrn(1);
          y.iushrn(1);
          ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while (!x.isZero()) {
          for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1) ;
          if (i > 0) {
            x.iushrn(i);
            while (i-- > 0) {
              if (A.isOdd() || B.isOdd()) {
                A.iadd(yp);
                B.isub(xp);
              }
              A.iushrn(1);
              B.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) ;
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }
              C.iushrn(1);
              D.iushrn(1);
            }
          }
          if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
          } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
          }
        }
        return {
          a: C,
          b: D,
          gcd: y.iushln(g)
        };
      };
      BN.prototype._invmp = function _invmp(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var a = this;
        var b2 = p.clone();
        if (a.negative !== 0) {
          a = a.umod(p);
        } else {
          a = a.clone();
        }
        var x1 = new BN(1);
        var x2 = new BN(0);
        var delta = b2.clone();
        while (a.cmpn(1) > 0 && b2.cmpn(1) > 0) {
          for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1) ;
          if (i > 0) {
            a.iushrn(i);
            while (i-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (b2.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) ;
          if (j > 0) {
            b2.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a.cmp(b2) >= 0) {
            a.isub(b2);
            x1.isub(x2);
          } else {
            b2.isub(a);
            x2.isub(x1);
          }
        }
        var res;
        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }
        return res;
      };
      BN.prototype.gcd = function gcd(num) {
        if (this.isZero()) return num.abs();
        if (num.isZero()) return this.abs();
        var a = this.clone();
        var b2 = num.clone();
        a.negative = 0;
        b2.negative = 0;
        for (var shift = 0; a.isEven() && b2.isEven(); shift++) {
          a.iushrn(1);
          b2.iushrn(1);
        }
        do {
          while (a.isEven()) {
            a.iushrn(1);
          }
          while (b2.isEven()) {
            b2.iushrn(1);
          }
          var r = a.cmp(b2);
          if (r < 0) {
            var t = a;
            a = b2;
            b2 = t;
          } else if (r === 0 || b2.cmpn(1) === 0) {
            break;
          }
          a.isub(b2);
        } while (true);
        return b2.iushln(shift);
      };
      BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q;
          return this;
        }
        var carry = q;
        for (var i = s; carry !== 0 && i < this.length; i++) {
          var w = this.words[i] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 67108863;
          this.words[i] = w;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative) return -1;
        if (this.negative === 0 && negative) return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert(num <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0) return -1;
        if (this.negative === 0 && num.negative !== 0) return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length) return 1;
        if (this.length < num.length) return -1;
        var res = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var a = this.words[i] | 0;
          var b2 = num.words[i] | 0;
          if (a === b2) continue;
          if (a < b2) {
            res = -1;
          } else if (a > b2) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN.red = function red(num) {
        return new Red(num);
      };
      BN.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p) {
        this.name = name;
        this.p = new BN(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r = num;
        var rlen;
        do {
          this.split(r, this.tmp);
          r = this.imulK(r);
          r = r.iadd(this.tmp);
          rlen = r.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
          r.words[0] = 0;
          r.length = 1;
        } else if (cmp > 0) {
          r.isub(this.p);
        } else {
          if (r.strip !== void 0) {
            r.strip();
          } else {
            r._strip();
          }
        }
        return r;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i = 0; i < outLen; i++) {
          output.words[i] = input.words[i];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i = 10; i < input.length; i++) {
          var next = input.words[i] | 0;
          input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i = 0; i < num.length; i++) {
          var w = num.words[i] | 0;
          lo += w * 977;
          num.words[i] = lo & 67108863;
          lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i = 0; i < num.length; i++) {
          var hi = (num.words[i] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN._prime = function prime(name) {
        if (primes[name]) return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert(m.gtn(1), "modulus must be greater than 1");
          this.m = m;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, "red works only with positives");
        assert(a.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a, b2) {
        assert((a.negative | b2.negative) === 0, "red works only with positives");
        assert(
          a.red && a.red === b2.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a) {
        if (this.prime) return this.prime.ireduce(a)._forceRed(this);
        return a.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
          return a.clone();
        }
        return this.m.sub(a)._forceRed(this);
      };
      Red.prototype.add = function add(a, b2) {
        this._verify2(a, b2);
        var res = a.add(b2);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a, b2) {
        this._verify2(a, b2);
        var res = a.iadd(b2);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a, b2) {
        this._verify2(a, b2);
        var res = a.sub(b2);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a, b2) {
        this._verify2(a, b2);
        var res = a.isub(b2);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
      };
      Red.prototype.imul = function imul(a, b2) {
        this._verify2(a, b2);
        return this.imod(a.imul(b2));
      };
      Red.prototype.mul = function mul(a, b2) {
        this._verify2(a, b2);
        return this.imod(a.mul(b2));
      };
      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };
      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };
      Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero()) return a.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a, pow);
        }
        var q = this.m.subn(1);
        var s = 0;
        while (!q.isZero() && q.andln(1) === 0) {
          s++;
          q.iushrn(1);
        }
        assert(!q.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }
        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i = 0; tmp.cmp(one) !== 0; i++) {
            tmp = tmp.redSqr();
          }
          assert(i < m);
          var b2 = this.pow(c, new BN(1).iushln(m - i - 1));
          r = r.redMul(b2);
          c = b2.redSqr();
          t = t.redMul(c);
          m = i;
        }
        return r;
      };
      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a, num) {
        if (num.isZero()) return new BN(1).toRed(this);
        if (num.cmpn(1) === 0) return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a;
        for (var i = 2; i < wnd.length; i++) {
          wnd[i] = this.mul(wnd[i - 1], a);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i = num.length - 1; i >= 0; i--) {
          var word = num.words[i];
          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
      };
      Mont.prototype.imul = function imul(a, b2) {
        if (a.isZero() || b2.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }
        var t = a.imul(b2);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a, b2) {
        if (a.isZero() || b2.isZero()) return new BN(0)._forceRed(this);
        var t = a.mul(b2);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module2 === "undefined" || module2, exports2);
  }
});

// node_modules/minimalistic-assert/index.js
var require_minimalistic_assert = __commonJS({
  "node_modules/minimalistic-assert/index.js"(exports2, module2) {
    module2.exports = assert;
    function assert(val, msg) {
      if (!val)
        throw new Error(msg || "Assertion failed");
    }
    assert.equal = function assertEqual(l, r, msg) {
      if (l != r)
        throw new Error(msg || "Assertion failed: " + l + " != " + r);
    };
  }
});

// node_modules/minimalistic-crypto-utils/lib/utils.js
var require_utils = __commonJS({
  "node_modules/minimalistic-crypto-utils/lib/utils.js"(exports2) {
    "use strict";
    var utils = exports2;
    function toArray(msg, enc) {
      if (Array.isArray(msg))
        return msg.slice();
      if (!msg)
        return [];
      var res = [];
      if (typeof msg !== "string") {
        for (var i = 0; i < msg.length; i++)
          res[i] = msg[i] | 0;
        return res;
      }
      if (enc === "hex") {
        msg = msg.replace(/[^a-z0-9]+/ig, "");
        if (msg.length % 2 !== 0)
          msg = "0" + msg;
        for (var i = 0; i < msg.length; i += 2)
          res.push(parseInt(msg[i] + msg[i + 1], 16));
      } else {
        for (var i = 0; i < msg.length; i++) {
          var c = msg.charCodeAt(i);
          var hi = c >> 8;
          var lo = c & 255;
          if (hi)
            res.push(hi, lo);
          else
            res.push(lo);
        }
      }
      return res;
    }
    utils.toArray = toArray;
    function zero2(word) {
      if (word.length === 1)
        return "0" + word;
      else
        return word;
    }
    utils.zero2 = zero2;
    function toHex(msg) {
      var res = "";
      for (var i = 0; i < msg.length; i++)
        res += zero2(msg[i].toString(16));
      return res;
    }
    utils.toHex = toHex;
    utils.encode = function encode(arr, enc) {
      if (enc === "hex")
        return toHex(arr);
      else
        return arr;
    };
  }
});

// node_modules/elliptic/lib/elliptic/utils.js
var require_utils2 = __commonJS({
  "node_modules/elliptic/lib/elliptic/utils.js"(exports2) {
    "use strict";
    var utils = exports2;
    var BN = require_bn2();
    var minAssert = require_minimalistic_assert();
    var minUtils = require_utils();
    utils.assert = minAssert;
    utils.toArray = minUtils.toArray;
    utils.zero2 = minUtils.zero2;
    utils.toHex = minUtils.toHex;
    utils.encode = minUtils.encode;
    function getNAF(num, w, bits) {
      var naf = new Array(Math.max(num.bitLength(), bits) + 1);
      var i;
      for (i = 0; i < naf.length; i += 1) {
        naf[i] = 0;
      }
      var ws = 1 << w + 1;
      var k = num.clone();
      for (i = 0; i < naf.length; i++) {
        var z;
        var mod3 = k.andln(ws - 1);
        if (k.isOdd()) {
          if (mod3 > (ws >> 1) - 1)
            z = (ws >> 1) - mod3;
          else
            z = mod3;
          k.isubn(z);
        } else {
          z = 0;
        }
        naf[i] = z;
        k.iushrn(1);
      }
      return naf;
    }
    utils.getNAF = getNAF;
    function getJSF(k1, k2) {
      var jsf = [
        [],
        []
      ];
      k1 = k1.clone();
      k2 = k2.clone();
      var d1 = 0;
      var d2 = 0;
      var m8;
      while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
        var m14 = k1.andln(3) + d1 & 3;
        var m24 = k2.andln(3) + d2 & 3;
        if (m14 === 3)
          m14 = -1;
        if (m24 === 3)
          m24 = -1;
        var u1;
        if ((m14 & 1) === 0) {
          u1 = 0;
        } else {
          m8 = k1.andln(7) + d1 & 7;
          if ((m8 === 3 || m8 === 5) && m24 === 2)
            u1 = -m14;
          else
            u1 = m14;
        }
        jsf[0].push(u1);
        var u2;
        if ((m24 & 1) === 0) {
          u2 = 0;
        } else {
          m8 = k2.andln(7) + d2 & 7;
          if ((m8 === 3 || m8 === 5) && m14 === 2)
            u2 = -m24;
          else
            u2 = m24;
        }
        jsf[1].push(u2);
        if (2 * d1 === u1 + 1)
          d1 = 1 - d1;
        if (2 * d2 === u2 + 1)
          d2 = 1 - d2;
        k1.iushrn(1);
        k2.iushrn(1);
      }
      return jsf;
    }
    utils.getJSF = getJSF;
    function cachedProperty(obj, name, computer) {
      var key = "_" + name;
      obj.prototype[name] = function cachedProperty2() {
        return this[key] !== void 0 ? this[key] : this[key] = computer.call(this);
      };
    }
    utils.cachedProperty = cachedProperty;
    function parseBytes(bytes) {
      return typeof bytes === "string" ? utils.toArray(bytes, "hex") : bytes;
    }
    utils.parseBytes = parseBytes;
    function intFromLE(bytes) {
      return new BN(bytes, "hex", "le");
    }
    utils.intFromLE = intFromLE;
  }
});

// (disabled):crypto
var require_crypto2 = __commonJS({
  "(disabled):crypto"() {
  }
});

// node_modules/brorand/index.js
var require_brorand = __commonJS({
  "node_modules/brorand/index.js"(exports2, module2) {
    var r;
    module2.exports = function rand(len) {
      if (!r)
        r = new Rand(null);
      return r.generate(len);
    };
    function Rand(rand) {
      this.rand = rand;
    }
    module2.exports.Rand = Rand;
    Rand.prototype.generate = function generate(len) {
      return this._rand(len);
    };
    Rand.prototype._rand = function _rand(n) {
      if (this.rand.getBytes)
        return this.rand.getBytes(n);
      var res = new Uint8Array(n);
      for (var i = 0; i < res.length; i++)
        res[i] = this.rand.getByte();
      return res;
    };
    if (typeof self === "object") {
      if (self.crypto && self.crypto.getRandomValues) {
        Rand.prototype._rand = function _rand(n) {
          var arr = new Uint8Array(n);
          self.crypto.getRandomValues(arr);
          return arr;
        };
      } else if (self.msCrypto && self.msCrypto.getRandomValues) {
        Rand.prototype._rand = function _rand(n) {
          var arr = new Uint8Array(n);
          self.msCrypto.getRandomValues(arr);
          return arr;
        };
      } else if (typeof window === "object") {
        Rand.prototype._rand = function() {
          throw new Error("Not implemented yet");
        };
      }
    } else {
      try {
        crypto8 = require_crypto2();
        if (typeof crypto8.randomBytes !== "function")
          throw new Error("Not supported");
        Rand.prototype._rand = function _rand(n) {
          return crypto8.randomBytes(n);
        };
      } catch (e) {
      }
    }
    var crypto8;
  }
});

// node_modules/elliptic/lib/elliptic/curve/base.js
var require_base2 = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/base.js"(exports2, module2) {
    "use strict";
    var BN = require_bn2();
    var utils = require_utils2();
    var getNAF = utils.getNAF;
    var getJSF = utils.getJSF;
    var assert = utils.assert;
    function BaseCurve(type, conf) {
      this.type = type;
      this.p = new BN(conf.p, 16);
      this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);
      this.zero = new BN(0).toRed(this.red);
      this.one = new BN(1).toRed(this.red);
      this.two = new BN(2).toRed(this.red);
      this.n = conf.n && new BN(conf.n, 16);
      this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
      this._wnafT1 = new Array(4);
      this._wnafT2 = new Array(4);
      this._wnafT3 = new Array(4);
      this._wnafT4 = new Array(4);
      this._bitLength = this.n ? this.n.bitLength() : 0;
      var adjustCount = this.n && this.p.div(this.n);
      if (!adjustCount || adjustCount.cmpn(100) > 0) {
        this.redN = null;
      } else {
        this._maxwellTrick = true;
        this.redN = this.n.toRed(this.red);
      }
    }
    module2.exports = BaseCurve;
    BaseCurve.prototype.point = function point() {
      throw new Error("Not implemented");
    };
    BaseCurve.prototype.validate = function validate() {
      throw new Error("Not implemented");
    };
    BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
      assert(p.precomputed);
      var doubles = p._getDoubles();
      var naf = getNAF(k, 1, this._bitLength);
      var I = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
      I /= 3;
      var repr = [];
      var j;
      var nafW;
      for (j = 0; j < naf.length; j += doubles.step) {
        nafW = 0;
        for (var l = j + doubles.step - 1; l >= j; l--)
          nafW = (nafW << 1) + naf[l];
        repr.push(nafW);
      }
      var a = this.jpoint(null, null, null);
      var b2 = this.jpoint(null, null, null);
      for (var i = I; i > 0; i--) {
        for (j = 0; j < repr.length; j++) {
          nafW = repr[j];
          if (nafW === i)
            b2 = b2.mixedAdd(doubles.points[j]);
          else if (nafW === -i)
            b2 = b2.mixedAdd(doubles.points[j].neg());
        }
        a = a.add(b2);
      }
      return a.toP();
    };
    BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
      var w = 4;
      var nafPoints = p._getNAFPoints(w);
      w = nafPoints.wnd;
      var wnd = nafPoints.points;
      var naf = getNAF(k, w, this._bitLength);
      var acc = this.jpoint(null, null, null);
      for (var i = naf.length - 1; i >= 0; i--) {
        for (var l = 0; i >= 0 && naf[i] === 0; i--)
          l++;
        if (i >= 0)
          l++;
        acc = acc.dblp(l);
        if (i < 0)
          break;
        var z = naf[i];
        assert(z !== 0);
        if (p.type === "affine") {
          if (z > 0)
            acc = acc.mixedAdd(wnd[z - 1 >> 1]);
          else
            acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg());
        } else {
          if (z > 0)
            acc = acc.add(wnd[z - 1 >> 1]);
          else
            acc = acc.add(wnd[-z - 1 >> 1].neg());
        }
      }
      return p.type === "affine" ? acc.toP() : acc;
    };
    BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
      var wndWidth = this._wnafT1;
      var wnd = this._wnafT2;
      var naf = this._wnafT3;
      var max = 0;
      var i;
      var j;
      var p;
      for (i = 0; i < len; i++) {
        p = points[i];
        var nafPoints = p._getNAFPoints(defW);
        wndWidth[i] = nafPoints.wnd;
        wnd[i] = nafPoints.points;
      }
      for (i = len - 1; i >= 1; i -= 2) {
        var a = i - 1;
        var b2 = i;
        if (wndWidth[a] !== 1 || wndWidth[b2] !== 1) {
          naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
          naf[b2] = getNAF(coeffs[b2], wndWidth[b2], this._bitLength);
          max = Math.max(naf[a].length, max);
          max = Math.max(naf[b2].length, max);
          continue;
        }
        var comb = [
          points[a],
          /* 1 */
          null,
          /* 3 */
          null,
          /* 5 */
          points[b2]
          /* 7 */
        ];
        if (points[a].y.cmp(points[b2].y) === 0) {
          comb[1] = points[a].add(points[b2]);
          comb[2] = points[a].toJ().mixedAdd(points[b2].neg());
        } else if (points[a].y.cmp(points[b2].y.redNeg()) === 0) {
          comb[1] = points[a].toJ().mixedAdd(points[b2]);
          comb[2] = points[a].add(points[b2].neg());
        } else {
          comb[1] = points[a].toJ().mixedAdd(points[b2]);
          comb[2] = points[a].toJ().mixedAdd(points[b2].neg());
        }
        var index = [
          -3,
          /* -1 -1 */
          -1,
          /* -1 0 */
          -5,
          /* -1 1 */
          -7,
          /* 0 -1 */
          0,
          /* 0 0 */
          7,
          /* 0 1 */
          5,
          /* 1 -1 */
          1,
          /* 1 0 */
          3
          /* 1 1 */
        ];
        var jsf = getJSF(coeffs[a], coeffs[b2]);
        max = Math.max(jsf[0].length, max);
        naf[a] = new Array(max);
        naf[b2] = new Array(max);
        for (j = 0; j < max; j++) {
          var ja = jsf[0][j] | 0;
          var jb = jsf[1][j] | 0;
          naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
          naf[b2][j] = 0;
          wnd[a] = comb;
        }
      }
      var acc = this.jpoint(null, null, null);
      var tmp = this._wnafT4;
      for (i = max; i >= 0; i--) {
        var k = 0;
        while (i >= 0) {
          var zero = true;
          for (j = 0; j < len; j++) {
            tmp[j] = naf[j][i] | 0;
            if (tmp[j] !== 0)
              zero = false;
          }
          if (!zero)
            break;
          k++;
          i--;
        }
        if (i >= 0)
          k++;
        acc = acc.dblp(k);
        if (i < 0)
          break;
        for (j = 0; j < len; j++) {
          var z = tmp[j];
          p;
          if (z === 0)
            continue;
          else if (z > 0)
            p = wnd[j][z - 1 >> 1];
          else if (z < 0)
            p = wnd[j][-z - 1 >> 1].neg();
          if (p.type === "affine")
            acc = acc.mixedAdd(p);
          else
            acc = acc.add(p);
        }
      }
      for (i = 0; i < len; i++)
        wnd[i] = null;
      if (jacobianResult)
        return acc;
      else
        return acc.toP();
    };
    function BasePoint(curve, type) {
      this.curve = curve;
      this.type = type;
      this.precomputed = null;
    }
    BaseCurve.BasePoint = BasePoint;
    BasePoint.prototype.eq = function eq() {
      throw new Error("Not implemented");
    };
    BasePoint.prototype.validate = function validate() {
      return this.curve.validate(this);
    };
    BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
      bytes = utils.toArray(bytes, enc);
      var len = this.p.byteLength();
      if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len) {
        if (bytes[0] === 6)
          assert(bytes[bytes.length - 1] % 2 === 0);
        else if (bytes[0] === 7)
          assert(bytes[bytes.length - 1] % 2 === 1);
        var res = this.point(
          bytes.slice(1, 1 + len),
          bytes.slice(1 + len, 1 + 2 * len)
        );
        return res;
      } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len) {
        return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 3);
      }
      throw new Error("Unknown point format");
    };
    BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
      return this.encode(enc, true);
    };
    BasePoint.prototype._encode = function _encode(compact) {
      var len = this.curve.p.byteLength();
      var x = this.getX().toArray("be", len);
      if (compact)
        return [this.getY().isEven() ? 2 : 3].concat(x);
      return [4].concat(x, this.getY().toArray("be", len));
    };
    BasePoint.prototype.encode = function encode(enc, compact) {
      return utils.encode(this._encode(compact), enc);
    };
    BasePoint.prototype.precompute = function precompute(power) {
      if (this.precomputed)
        return this;
      var precomputed = {
        doubles: null,
        naf: null,
        beta: null
      };
      precomputed.naf = this._getNAFPoints(8);
      precomputed.doubles = this._getDoubles(4, power);
      precomputed.beta = this._getBeta();
      this.precomputed = precomputed;
      return this;
    };
    BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
      if (!this.precomputed)
        return false;
      var doubles = this.precomputed.doubles;
      if (!doubles)
        return false;
      return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
    };
    BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
      if (this.precomputed && this.precomputed.doubles)
        return this.precomputed.doubles;
      var doubles = [this];
      var acc = this;
      for (var i = 0; i < power; i += step) {
        for (var j = 0; j < step; j++)
          acc = acc.dbl();
        doubles.push(acc);
      }
      return {
        step,
        points: doubles
      };
    };
    BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
      if (this.precomputed && this.precomputed.naf)
        return this.precomputed.naf;
      var res = [this];
      var max = (1 << wnd) - 1;
      var dbl = max === 1 ? null : this.dbl();
      for (var i = 1; i < max; i++)
        res[i] = res[i - 1].add(dbl);
      return {
        wnd,
        points: res
      };
    };
    BasePoint.prototype._getBeta = function _getBeta() {
      return null;
    };
    BasePoint.prototype.dblp = function dblp(k) {
      var r = this;
      for (var i = 0; i < k; i++)
        r = r.dbl();
      return r;
    };
  }
});

// node_modules/elliptic/lib/elliptic/curve/short.js
var require_short = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/short.js"(exports2, module2) {
    "use strict";
    var utils = require_utils2();
    var BN = require_bn2();
    var inherits = require_inherits_browser();
    var Base = require_base2();
    var assert = utils.assert;
    function ShortCurve(conf) {
      Base.call(this, "short", conf);
      this.a = new BN(conf.a, 16).toRed(this.red);
      this.b = new BN(conf.b, 16).toRed(this.red);
      this.tinv = this.two.redInvm();
      this.zeroA = this.a.fromRed().cmpn(0) === 0;
      this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
      this.endo = this._getEndomorphism(conf);
      this._endoWnafT1 = new Array(4);
      this._endoWnafT2 = new Array(4);
    }
    inherits(ShortCurve, Base);
    module2.exports = ShortCurve;
    ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
      if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
        return;
      var beta;
      var lambda;
      if (conf.beta) {
        beta = new BN(conf.beta, 16).toRed(this.red);
      } else {
        var betas = this._getEndoRoots(this.p);
        beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
        beta = beta.toRed(this.red);
      }
      if (conf.lambda) {
        lambda = new BN(conf.lambda, 16);
      } else {
        var lambdas = this._getEndoRoots(this.n);
        if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
          lambda = lambdas[0];
        } else {
          lambda = lambdas[1];
          assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
        }
      }
      var basis;
      if (conf.basis) {
        basis = conf.basis.map(function(vec) {
          return {
            a: new BN(vec.a, 16),
            b: new BN(vec.b, 16)
          };
        });
      } else {
        basis = this._getEndoBasis(lambda);
      }
      return {
        beta,
        lambda,
        basis
      };
    };
    ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
      var red = num === this.p ? this.red : BN.mont(num);
      var tinv = new BN(2).toRed(red).redInvm();
      var ntinv = tinv.redNeg();
      var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);
      var l1 = ntinv.redAdd(s).fromRed();
      var l2 = ntinv.redSub(s).fromRed();
      return [l1, l2];
    };
    ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
      var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
      var u = lambda;
      var v = this.n.clone();
      var x1 = new BN(1);
      var y1 = new BN(0);
      var x2 = new BN(0);
      var y2 = new BN(1);
      var a0;
      var b0;
      var a1;
      var b1;
      var a2;
      var b2;
      var prevR;
      var i = 0;
      var r;
      var x;
      while (u.cmpn(0) !== 0) {
        var q = v.div(u);
        r = v.sub(q.mul(u));
        x = x2.sub(q.mul(x1));
        var y = y2.sub(q.mul(y1));
        if (!a1 && r.cmp(aprxSqrt) < 0) {
          a0 = prevR.neg();
          b0 = x1;
          a1 = r.neg();
          b1 = x;
        } else if (a1 && ++i === 2) {
          break;
        }
        prevR = r;
        v = u;
        u = r;
        x2 = x1;
        x1 = x;
        y2 = y1;
        y1 = y;
      }
      a2 = r.neg();
      b2 = x;
      var len1 = a1.sqr().add(b1.sqr());
      var len2 = a2.sqr().add(b2.sqr());
      if (len2.cmp(len1) >= 0) {
        a2 = a0;
        b2 = b0;
      }
      if (a1.negative) {
        a1 = a1.neg();
        b1 = b1.neg();
      }
      if (a2.negative) {
        a2 = a2.neg();
        b2 = b2.neg();
      }
      return [
        { a: a1, b: b1 },
        { a: a2, b: b2 }
      ];
    };
    ShortCurve.prototype._endoSplit = function _endoSplit(k) {
      var basis = this.endo.basis;
      var v1 = basis[0];
      var v2 = basis[1];
      var c1 = v2.b.mul(k).divRound(this.n);
      var c2 = v1.b.neg().mul(k).divRound(this.n);
      var p1 = c1.mul(v1.a);
      var p2 = c2.mul(v2.a);
      var q1 = c1.mul(v1.b);
      var q2 = c2.mul(v2.b);
      var k1 = k.sub(p1).sub(p2);
      var k2 = q1.add(q2).neg();
      return { k1, k2 };
    };
    ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
      x = new BN(x, 16);
      if (!x.red)
        x = x.toRed(this.red);
      var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
      var y = y2.redSqrt();
      if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var isOdd = y.fromRed().isOdd();
      if (odd && !isOdd || !odd && isOdd)
        y = y.redNeg();
      return this.point(x, y);
    };
    ShortCurve.prototype.validate = function validate(point) {
      if (point.inf)
        return true;
      var x = point.x;
      var y = point.y;
      var ax = this.a.redMul(x);
      var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
      return y.redSqr().redISub(rhs).cmpn(0) === 0;
    };
    ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
      var npoints = this._endoWnafT1;
      var ncoeffs = this._endoWnafT2;
      for (var i = 0; i < points.length; i++) {
        var split = this._endoSplit(coeffs[i]);
        var p = points[i];
        var beta = p._getBeta();
        if (split.k1.negative) {
          split.k1.ineg();
          p = p.neg(true);
        }
        if (split.k2.negative) {
          split.k2.ineg();
          beta = beta.neg(true);
        }
        npoints[i * 2] = p;
        npoints[i * 2 + 1] = beta;
        ncoeffs[i * 2] = split.k1;
        ncoeffs[i * 2 + 1] = split.k2;
      }
      var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);
      for (var j = 0; j < i * 2; j++) {
        npoints[j] = null;
        ncoeffs[j] = null;
      }
      return res;
    };
    function Point(curve, x, y, isRed) {
      Base.BasePoint.call(this, curve, "affine");
      if (x === null && y === null) {
        this.x = null;
        this.y = null;
        this.inf = true;
      } else {
        this.x = new BN(x, 16);
        this.y = new BN(y, 16);
        if (isRed) {
          this.x.forceRed(this.curve.red);
          this.y.forceRed(this.curve.red);
        }
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        this.inf = false;
      }
    }
    inherits(Point, Base.BasePoint);
    ShortCurve.prototype.point = function point(x, y, isRed) {
      return new Point(this, x, y, isRed);
    };
    ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
      return Point.fromJSON(this, obj, red);
    };
    Point.prototype._getBeta = function _getBeta() {
      if (!this.curve.endo)
        return;
      var pre = this.precomputed;
      if (pre && pre.beta)
        return pre.beta;
      var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (pre) {
        var curve = this.curve;
        var endoMul = function(p) {
          return curve.point(p.x.redMul(curve.endo.beta), p.y);
        };
        pre.beta = beta;
        beta.precomputed = {
          beta: null,
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: pre.naf.points.map(endoMul)
          },
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: pre.doubles.points.map(endoMul)
          }
        };
      }
      return beta;
    };
    Point.prototype.toJSON = function toJSON() {
      if (!this.precomputed)
        return [this.x, this.y];
      return [this.x, this.y, this.precomputed && {
        doubles: this.precomputed.doubles && {
          step: this.precomputed.doubles.step,
          points: this.precomputed.doubles.points.slice(1)
        },
        naf: this.precomputed.naf && {
          wnd: this.precomputed.naf.wnd,
          points: this.precomputed.naf.points.slice(1)
        }
      }];
    };
    Point.fromJSON = function fromJSON(curve, obj, red) {
      if (typeof obj === "string")
        obj = JSON.parse(obj);
      var res = curve.point(obj[0], obj[1], red);
      if (!obj[2])
        return res;
      function obj2point(obj2) {
        return curve.point(obj2[0], obj2[1], red);
      }
      var pre = obj[2];
      res.precomputed = {
        beta: null,
        doubles: pre.doubles && {
          step: pre.doubles.step,
          points: [res].concat(pre.doubles.points.map(obj2point))
        },
        naf: pre.naf && {
          wnd: pre.naf.wnd,
          points: [res].concat(pre.naf.points.map(obj2point))
        }
      };
      return res;
    };
    Point.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.inf;
    };
    Point.prototype.add = function add(p) {
      if (this.inf)
        return p;
      if (p.inf)
        return this;
      if (this.eq(p))
        return this.dbl();
      if (this.neg().eq(p))
        return this.curve.point(null, null);
      if (this.x.cmp(p.x) === 0)
        return this.curve.point(null, null);
      var c = this.y.redSub(p.y);
      if (c.cmpn(0) !== 0)
        c = c.redMul(this.x.redSub(p.x).redInvm());
      var nx = c.redSqr().redISub(this.x).redISub(p.x);
      var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    };
    Point.prototype.dbl = function dbl() {
      if (this.inf)
        return this;
      var ys1 = this.y.redAdd(this.y);
      if (ys1.cmpn(0) === 0)
        return this.curve.point(null, null);
      var a = this.curve.a;
      var x2 = this.x.redSqr();
      var dyinv = ys1.redInvm();
      var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);
      var nx = c.redSqr().redISub(this.x.redAdd(this.x));
      var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    };
    Point.prototype.getX = function getX() {
      return this.x.fromRed();
    };
    Point.prototype.getY = function getY() {
      return this.y.fromRed();
    };
    Point.prototype.mul = function mul(k) {
      k = new BN(k, 16);
      if (this.isInfinity())
        return this;
      else if (this._hasDoubles(k))
        return this.curve._fixedNafMul(this, k);
      else if (this.curve.endo)
        return this.curve._endoWnafMulAdd([this], [k]);
      else
        return this.curve._wnafMul(this, k);
    };
    Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
      var points = [this, p2];
      var coeffs = [k1, k2];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2);
    };
    Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
      var points = [this, p2];
      var coeffs = [k1, k2];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs, true);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
    };
    Point.prototype.eq = function eq(p) {
      return this === p || this.inf === p.inf && (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
    };
    Point.prototype.neg = function neg(_precompute) {
      if (this.inf)
        return this;
      var res = this.curve.point(this.x, this.y.redNeg());
      if (_precompute && this.precomputed) {
        var pre = this.precomputed;
        var negate = function(p) {
          return p.neg();
        };
        res.precomputed = {
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: pre.naf.points.map(negate)
          },
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: pre.doubles.points.map(negate)
          }
        };
      }
      return res;
    };
    Point.prototype.toJ = function toJ() {
      if (this.inf)
        return this.curve.jpoint(null, null, null);
      var res = this.curve.jpoint(this.x, this.y, this.curve.one);
      return res;
    };
    function JPoint(curve, x, y, z) {
      Base.BasePoint.call(this, curve, "jacobian");
      if (x === null && y === null && z === null) {
        this.x = this.curve.one;
        this.y = this.curve.one;
        this.z = new BN(0);
      } else {
        this.x = new BN(x, 16);
        this.y = new BN(y, 16);
        this.z = new BN(z, 16);
      }
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.y.red)
        this.y = this.y.toRed(this.curve.red);
      if (!this.z.red)
        this.z = this.z.toRed(this.curve.red);
      this.zOne = this.z === this.curve.one;
    }
    inherits(JPoint, Base.BasePoint);
    ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
      return new JPoint(this, x, y, z);
    };
    JPoint.prototype.toP = function toP() {
      if (this.isInfinity())
        return this.curve.point(null, null);
      var zinv = this.z.redInvm();
      var zinv2 = zinv.redSqr();
      var ax = this.x.redMul(zinv2);
      var ay = this.y.redMul(zinv2).redMul(zinv);
      return this.curve.point(ax, ay);
    };
    JPoint.prototype.neg = function neg() {
      return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
    };
    JPoint.prototype.add = function add(p) {
      if (this.isInfinity())
        return p;
      if (p.isInfinity())
        return this;
      var pz2 = p.z.redSqr();
      var z2 = this.z.redSqr();
      var u1 = this.x.redMul(pz2);
      var u2 = p.x.redMul(z2);
      var s1 = this.y.redMul(pz2.redMul(p.z));
      var s2 = p.y.redMul(z2.redMul(this.z));
      var h = u1.redSub(u2);
      var r = s1.redSub(s2);
      if (h.cmpn(0) === 0) {
        if (r.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      }
      var h2 = h.redSqr();
      var h3 = h2.redMul(h);
      var v = u1.redMul(h2);
      var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
      var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
      var nz = this.z.redMul(p.z).redMul(h);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.mixedAdd = function mixedAdd(p) {
      if (this.isInfinity())
        return p.toJ();
      if (p.isInfinity())
        return this;
      var z2 = this.z.redSqr();
      var u1 = this.x;
      var u2 = p.x.redMul(z2);
      var s1 = this.y;
      var s2 = p.y.redMul(z2).redMul(this.z);
      var h = u1.redSub(u2);
      var r = s1.redSub(s2);
      if (h.cmpn(0) === 0) {
        if (r.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      }
      var h2 = h.redSqr();
      var h3 = h2.redMul(h);
      var v = u1.redMul(h2);
      var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
      var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
      var nz = this.z.redMul(h);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.dblp = function dblp(pow) {
      if (pow === 0)
        return this;
      if (this.isInfinity())
        return this;
      if (!pow)
        return this.dbl();
      var i;
      if (this.curve.zeroA || this.curve.threeA) {
        var r = this;
        for (i = 0; i < pow; i++)
          r = r.dbl();
        return r;
      }
      var a = this.curve.a;
      var tinv = this.curve.tinv;
      var jx = this.x;
      var jy = this.y;
      var jz = this.z;
      var jz4 = jz.redSqr().redSqr();
      var jyd = jy.redAdd(jy);
      for (i = 0; i < pow; i++) {
        var jx2 = jx.redSqr();
        var jyd2 = jyd.redSqr();
        var jyd4 = jyd2.redSqr();
        var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
        var t1 = jx.redMul(jyd2);
        var nx = c.redSqr().redISub(t1.redAdd(t1));
        var t2 = t1.redISub(nx);
        var dny = c.redMul(t2);
        dny = dny.redIAdd(dny).redISub(jyd4);
        var nz = jyd.redMul(jz);
        if (i + 1 < pow)
          jz4 = jz4.redMul(jyd4);
        jx = nx;
        jz = nz;
        jyd = dny;
      }
      return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
    };
    JPoint.prototype.dbl = function dbl() {
      if (this.isInfinity())
        return this;
      if (this.curve.zeroA)
        return this._zeroDbl();
      else if (this.curve.threeA)
        return this._threeDbl();
      else
        return this._dbl();
    };
    JPoint.prototype._zeroDbl = function _zeroDbl() {
      var nx;
      var ny;
      var nz;
      if (this.zOne) {
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var yyyy = yy.redSqr();
        var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s = s.redIAdd(s);
        var m = xx.redAdd(xx).redIAdd(xx);
        var t = m.redSqr().redISub(s).redISub(s);
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        nx = t;
        ny = m.redMul(s.redISub(t)).redISub(yyyy8);
        nz = this.y.redAdd(this.y);
      } else {
        var a = this.x.redSqr();
        var b2 = this.y.redSqr();
        var c = b2.redSqr();
        var d = this.x.redAdd(b2).redSqr().redISub(a).redISub(c);
        d = d.redIAdd(d);
        var e = a.redAdd(a).redIAdd(a);
        var f = e.redSqr();
        var c8 = c.redIAdd(c);
        c8 = c8.redIAdd(c8);
        c8 = c8.redIAdd(c8);
        nx = f.redISub(d).redISub(d);
        ny = e.redMul(d.redISub(nx)).redISub(c8);
        nz = this.y.redMul(this.z);
        nz = nz.redIAdd(nz);
      }
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype._threeDbl = function _threeDbl() {
      var nx;
      var ny;
      var nz;
      if (this.zOne) {
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var yyyy = yy.redSqr();
        var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s = s.redIAdd(s);
        var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
        var t = m.redSqr().redISub(s).redISub(s);
        nx = t;
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        ny = m.redMul(s.redISub(t)).redISub(yyyy8);
        nz = this.y.redAdd(this.y);
      } else {
        var delta = this.z.redSqr();
        var gamma = this.y.redSqr();
        var beta = this.x.redMul(gamma);
        var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
        alpha = alpha.redAdd(alpha).redIAdd(alpha);
        var beta4 = beta.redIAdd(beta);
        beta4 = beta4.redIAdd(beta4);
        var beta8 = beta4.redAdd(beta4);
        nx = alpha.redSqr().redISub(beta8);
        nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
        var ggamma8 = gamma.redSqr();
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
      }
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype._dbl = function _dbl() {
      var a = this.curve.a;
      var jx = this.x;
      var jy = this.y;
      var jz = this.z;
      var jz4 = jz.redSqr().redSqr();
      var jx2 = jx.redSqr();
      var jy2 = jy.redSqr();
      var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
      var jxd4 = jx.redAdd(jx);
      jxd4 = jxd4.redIAdd(jxd4);
      var t1 = jxd4.redMul(jy2);
      var nx = c.redSqr().redISub(t1.redAdd(t1));
      var t2 = t1.redISub(nx);
      var jyd8 = jy2.redSqr();
      jyd8 = jyd8.redIAdd(jyd8);
      jyd8 = jyd8.redIAdd(jyd8);
      jyd8 = jyd8.redIAdd(jyd8);
      var ny = c.redMul(t2).redISub(jyd8);
      var nz = jy.redAdd(jy).redMul(jz);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.trpl = function trpl() {
      if (!this.curve.zeroA)
        return this.dbl().add(this);
      var xx = this.x.redSqr();
      var yy = this.y.redSqr();
      var zz = this.z.redSqr();
      var yyyy = yy.redSqr();
      var m = xx.redAdd(xx).redIAdd(xx);
      var mm = m.redSqr();
      var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
      e = e.redIAdd(e);
      e = e.redAdd(e).redIAdd(e);
      e = e.redISub(mm);
      var ee = e.redSqr();
      var t = yyyy.redIAdd(yyyy);
      t = t.redIAdd(t);
      t = t.redIAdd(t);
      t = t.redIAdd(t);
      var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
      var yyu4 = yy.redMul(u);
      yyu4 = yyu4.redIAdd(yyu4);
      yyu4 = yyu4.redIAdd(yyu4);
      var nx = this.x.redMul(ee).redISub(yyu4);
      nx = nx.redIAdd(nx);
      nx = nx.redIAdd(nx);
      var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
      ny = ny.redIAdd(ny);
      ny = ny.redIAdd(ny);
      ny = ny.redIAdd(ny);
      var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.mul = function mul(k, kbase) {
      k = new BN(k, kbase);
      return this.curve._wnafMul(this, k);
    };
    JPoint.prototype.eq = function eq(p) {
      if (p.type === "affine")
        return this.eq(p.toJ());
      if (this === p)
        return true;
      var z2 = this.z.redSqr();
      var pz2 = p.z.redSqr();
      if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
        return false;
      var z3 = z2.redMul(this.z);
      var pz3 = pz2.redMul(p.z);
      return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
    };
    JPoint.prototype.eqXToP = function eqXToP(x) {
      var zs = this.z.redSqr();
      var rx = x.toRed(this.curve.red).redMul(zs);
      if (this.x.cmp(rx) === 0)
        return true;
      var xc = x.clone();
      var t = this.curve.redN.redMul(zs);
      for (; ; ) {
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0)
          return false;
        rx.redIAdd(t);
        if (this.x.cmp(rx) === 0)
          return true;
      }
    };
    JPoint.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC JPoint Infinity>";
      return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
    };
    JPoint.prototype.isInfinity = function isInfinity() {
      return this.z.cmpn(0) === 0;
    };
  }
});

// node_modules/elliptic/lib/elliptic/curve/mont.js
var require_mont = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/mont.js"(exports2, module2) {
    "use strict";
    var BN = require_bn2();
    var inherits = require_inherits_browser();
    var Base = require_base2();
    var utils = require_utils2();
    function MontCurve(conf) {
      Base.call(this, "mont", conf);
      this.a = new BN(conf.a, 16).toRed(this.red);
      this.b = new BN(conf.b, 16).toRed(this.red);
      this.i4 = new BN(4).toRed(this.red).redInvm();
      this.two = new BN(2).toRed(this.red);
      this.a24 = this.i4.redMul(this.a.redAdd(this.two));
    }
    inherits(MontCurve, Base);
    module2.exports = MontCurve;
    MontCurve.prototype.validate = function validate(point) {
      var x = point.normalize().x;
      var x2 = x.redSqr();
      var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
      var y = rhs.redSqrt();
      return y.redSqr().cmp(rhs) === 0;
    };
    function Point(curve, x, z) {
      Base.BasePoint.call(this, curve, "projective");
      if (x === null && z === null) {
        this.x = this.curve.one;
        this.z = this.curve.zero;
      } else {
        this.x = new BN(x, 16);
        this.z = new BN(z, 16);
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
      }
    }
    inherits(Point, Base.BasePoint);
    MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
      return this.point(utils.toArray(bytes, enc), 1);
    };
    MontCurve.prototype.point = function point(x, z) {
      return new Point(this, x, z);
    };
    MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
      return Point.fromJSON(this, obj);
    };
    Point.prototype.precompute = function precompute() {
    };
    Point.prototype._encode = function _encode() {
      return this.getX().toArray("be", this.curve.p.byteLength());
    };
    Point.fromJSON = function fromJSON(curve, obj) {
      return new Point(curve, obj[0], obj[1] || curve.one);
    };
    Point.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.z.cmpn(0) === 0;
    };
    Point.prototype.dbl = function dbl() {
      var a = this.x.redAdd(this.z);
      var aa = a.redSqr();
      var b2 = this.x.redSub(this.z);
      var bb = b2.redSqr();
      var c = aa.redSub(bb);
      var nx = aa.redMul(bb);
      var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
      return this.curve.point(nx, nz);
    };
    Point.prototype.add = function add() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.diffAdd = function diffAdd(p, diff) {
      var a = this.x.redAdd(this.z);
      var b2 = this.x.redSub(this.z);
      var c = p.x.redAdd(p.z);
      var d = p.x.redSub(p.z);
      var da = d.redMul(a);
      var cb = c.redMul(b2);
      var nx = diff.z.redMul(da.redAdd(cb).redSqr());
      var nz = diff.x.redMul(da.redISub(cb).redSqr());
      return this.curve.point(nx, nz);
    };
    Point.prototype.mul = function mul(k) {
      var t = k.clone();
      var a = this;
      var b2 = this.curve.point(null, null);
      var c = this;
      for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
        bits.push(t.andln(1));
      for (var i = bits.length - 1; i >= 0; i--) {
        if (bits[i] === 0) {
          a = a.diffAdd(b2, c);
          b2 = b2.dbl();
        } else {
          b2 = a.diffAdd(b2, c);
          a = a.dbl();
        }
      }
      return b2;
    };
    Point.prototype.mulAdd = function mulAdd() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.jumlAdd = function jumlAdd() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.eq = function eq(other) {
      return this.getX().cmp(other.getX()) === 0;
    };
    Point.prototype.normalize = function normalize() {
      this.x = this.x.redMul(this.z.redInvm());
      this.z = this.curve.one;
      return this;
    };
    Point.prototype.getX = function getX() {
      this.normalize();
      return this.x.fromRed();
    };
  }
});

// node_modules/elliptic/lib/elliptic/curve/edwards.js
var require_edwards = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/edwards.js"(exports2, module2) {
    "use strict";
    var utils = require_utils2();
    var BN = require_bn2();
    var inherits = require_inherits_browser();
    var Base = require_base2();
    var assert = utils.assert;
    function EdwardsCurve(conf) {
      this.twisted = (conf.a | 0) !== 1;
      this.mOneA = this.twisted && (conf.a | 0) === -1;
      this.extended = this.mOneA;
      Base.call(this, "edwards", conf);
      this.a = new BN(conf.a, 16).umod(this.red.m);
      this.a = this.a.toRed(this.red);
      this.c = new BN(conf.c, 16).toRed(this.red);
      this.c2 = this.c.redSqr();
      this.d = new BN(conf.d, 16).toRed(this.red);
      this.dd = this.d.redAdd(this.d);
      assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
      this.oneC = (conf.c | 0) === 1;
    }
    inherits(EdwardsCurve, Base);
    module2.exports = EdwardsCurve;
    EdwardsCurve.prototype._mulA = function _mulA(num) {
      if (this.mOneA)
        return num.redNeg();
      else
        return this.a.redMul(num);
    };
    EdwardsCurve.prototype._mulC = function _mulC(num) {
      if (this.oneC)
        return num;
      else
        return this.c.redMul(num);
    };
    EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
      return this.point(x, y, z, t);
    };
    EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
      x = new BN(x, 16);
      if (!x.red)
        x = x.toRed(this.red);
      var x2 = x.redSqr();
      var rhs = this.c2.redSub(this.a.redMul(x2));
      var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));
      var y2 = rhs.redMul(lhs.redInvm());
      var y = y2.redSqrt();
      if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var isOdd = y.fromRed().isOdd();
      if (odd && !isOdd || !odd && isOdd)
        y = y.redNeg();
      return this.point(x, y);
    };
    EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
      y = new BN(y, 16);
      if (!y.red)
        y = y.toRed(this.red);
      var y2 = y.redSqr();
      var lhs = y2.redSub(this.c2);
      var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
      var x2 = lhs.redMul(rhs.redInvm());
      if (x2.cmp(this.zero) === 0) {
        if (odd)
          throw new Error("invalid point");
        else
          return this.point(this.zero, y);
      }
      var x = x2.redSqrt();
      if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      if (x.fromRed().isOdd() !== odd)
        x = x.redNeg();
      return this.point(x, y);
    };
    EdwardsCurve.prototype.validate = function validate(point) {
      if (point.isInfinity())
        return true;
      point.normalize();
      var x2 = point.x.redSqr();
      var y2 = point.y.redSqr();
      var lhs = x2.redMul(this.a).redAdd(y2);
      var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));
      return lhs.cmp(rhs) === 0;
    };
    function Point(curve, x, y, z, t) {
      Base.BasePoint.call(this, curve, "projective");
      if (x === null && y === null && z === null) {
        this.x = this.curve.zero;
        this.y = this.curve.one;
        this.z = this.curve.one;
        this.t = this.curve.zero;
        this.zOne = true;
      } else {
        this.x = new BN(x, 16);
        this.y = new BN(y, 16);
        this.z = z ? new BN(z, 16) : this.curve.one;
        this.t = t && new BN(t, 16);
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
        if (this.t && !this.t.red)
          this.t = this.t.toRed(this.curve.red);
        this.zOne = this.z === this.curve.one;
        if (this.curve.extended && !this.t) {
          this.t = this.x.redMul(this.y);
          if (!this.zOne)
            this.t = this.t.redMul(this.z.redInvm());
        }
      }
    }
    inherits(Point, Base.BasePoint);
    EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
      return Point.fromJSON(this, obj);
    };
    EdwardsCurve.prototype.point = function point(x, y, z, t) {
      return new Point(this, x, y, z, t);
    };
    Point.fromJSON = function fromJSON(curve, obj) {
      return new Point(curve, obj[0], obj[1], obj[2]);
    };
    Point.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
    };
    Point.prototype._extDbl = function _extDbl() {
      var a = this.x.redSqr();
      var b2 = this.y.redSqr();
      var c = this.z.redSqr();
      c = c.redIAdd(c);
      var d = this.curve._mulA(a);
      var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b2);
      var g = d.redAdd(b2);
      var f = g.redSub(c);
      var h = d.redSub(b2);
      var nx = e.redMul(f);
      var ny = g.redMul(h);
      var nt = e.redMul(h);
      var nz = f.redMul(g);
      return this.curve.point(nx, ny, nz, nt);
    };
    Point.prototype._projDbl = function _projDbl() {
      var b2 = this.x.redAdd(this.y).redSqr();
      var c = this.x.redSqr();
      var d = this.y.redSqr();
      var nx;
      var ny;
      var nz;
      var e;
      var h;
      var j;
      if (this.curve.twisted) {
        e = this.curve._mulA(c);
        var f = e.redAdd(d);
        if (this.zOne) {
          nx = b2.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
          ny = f.redMul(e.redSub(d));
          nz = f.redSqr().redSub(f).redSub(f);
        } else {
          h = this.z.redSqr();
          j = f.redSub(h).redISub(h);
          nx = b2.redSub(c).redISub(d).redMul(j);
          ny = f.redMul(e.redSub(d));
          nz = f.redMul(j);
        }
      } else {
        e = c.redAdd(d);
        h = this.curve._mulC(this.z).redSqr();
        j = e.redSub(h).redSub(h);
        nx = this.curve._mulC(b2.redISub(e)).redMul(j);
        ny = this.curve._mulC(e).redMul(c.redISub(d));
        nz = e.redMul(j);
      }
      return this.curve.point(nx, ny, nz);
    };
    Point.prototype.dbl = function dbl() {
      if (this.isInfinity())
        return this;
      if (this.curve.extended)
        return this._extDbl();
      else
        return this._projDbl();
    };
    Point.prototype._extAdd = function _extAdd(p) {
      var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
      var b2 = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
      var c = this.t.redMul(this.curve.dd).redMul(p.t);
      var d = this.z.redMul(p.z.redAdd(p.z));
      var e = b2.redSub(a);
      var f = d.redSub(c);
      var g = d.redAdd(c);
      var h = b2.redAdd(a);
      var nx = e.redMul(f);
      var ny = g.redMul(h);
      var nt = e.redMul(h);
      var nz = f.redMul(g);
      return this.curve.point(nx, ny, nz, nt);
    };
    Point.prototype._projAdd = function _projAdd(p) {
      var a = this.z.redMul(p.z);
      var b2 = a.redSqr();
      var c = this.x.redMul(p.x);
      var d = this.y.redMul(p.y);
      var e = this.curve.d.redMul(c).redMul(d);
      var f = b2.redSub(e);
      var g = b2.redAdd(e);
      var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
      var nx = a.redMul(f).redMul(tmp);
      var ny;
      var nz;
      if (this.curve.twisted) {
        ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
        nz = f.redMul(g);
      } else {
        ny = a.redMul(g).redMul(d.redSub(c));
        nz = this.curve._mulC(f).redMul(g);
      }
      return this.curve.point(nx, ny, nz);
    };
    Point.prototype.add = function add(p) {
      if (this.isInfinity())
        return p;
      if (p.isInfinity())
        return this;
      if (this.curve.extended)
        return this._extAdd(p);
      else
        return this._projAdd(p);
    };
    Point.prototype.mul = function mul(k) {
      if (this._hasDoubles(k))
        return this.curve._fixedNafMul(this, k);
      else
        return this.curve._wnafMul(this, k);
    };
    Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
      return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, false);
    };
    Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
      return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, true);
    };
    Point.prototype.normalize = function normalize() {
      if (this.zOne)
        return this;
      var zi = this.z.redInvm();
      this.x = this.x.redMul(zi);
      this.y = this.y.redMul(zi);
      if (this.t)
        this.t = this.t.redMul(zi);
      this.z = this.curve.one;
      this.zOne = true;
      return this;
    };
    Point.prototype.neg = function neg() {
      return this.curve.point(
        this.x.redNeg(),
        this.y,
        this.z,
        this.t && this.t.redNeg()
      );
    };
    Point.prototype.getX = function getX() {
      this.normalize();
      return this.x.fromRed();
    };
    Point.prototype.getY = function getY() {
      this.normalize();
      return this.y.fromRed();
    };
    Point.prototype.eq = function eq(other) {
      return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
    };
    Point.prototype.eqXToP = function eqXToP(x) {
      var rx = x.toRed(this.curve.red).redMul(this.z);
      if (this.x.cmp(rx) === 0)
        return true;
      var xc = x.clone();
      var t = this.curve.redN.redMul(this.z);
      for (; ; ) {
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0)
          return false;
        rx.redIAdd(t);
        if (this.x.cmp(rx) === 0)
          return true;
      }
    };
    Point.prototype.toP = Point.prototype.normalize;
    Point.prototype.mixedAdd = Point.prototype.add;
  }
});

// node_modules/elliptic/lib/elliptic/curve/index.js
var require_curve = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/index.js"(exports2) {
    "use strict";
    var curve = exports2;
    curve.base = require_base2();
    curve.short = require_short();
    curve.mont = require_mont();
    curve.edwards = require_edwards();
  }
});

// node_modules/hash.js/lib/hash/utils.js
var require_utils3 = __commonJS({
  "node_modules/hash.js/lib/hash/utils.js"(exports2) {
    "use strict";
    var assert = require_minimalistic_assert();
    var inherits = require_inherits_browser();
    exports2.inherits = inherits;
    function isSurrogatePair(msg, i) {
      if ((msg.charCodeAt(i) & 64512) !== 55296) {
        return false;
      }
      if (i < 0 || i + 1 >= msg.length) {
        return false;
      }
      return (msg.charCodeAt(i + 1) & 64512) === 56320;
    }
    function toArray(msg, enc) {
      if (Array.isArray(msg))
        return msg.slice();
      if (!msg)
        return [];
      var res = [];
      if (typeof msg === "string") {
        if (!enc) {
          var p = 0;
          for (var i = 0; i < msg.length; i++) {
            var c = msg.charCodeAt(i);
            if (c < 128) {
              res[p++] = c;
            } else if (c < 2048) {
              res[p++] = c >> 6 | 192;
              res[p++] = c & 63 | 128;
            } else if (isSurrogatePair(msg, i)) {
              c = 65536 + ((c & 1023) << 10) + (msg.charCodeAt(++i) & 1023);
              res[p++] = c >> 18 | 240;
              res[p++] = c >> 12 & 63 | 128;
              res[p++] = c >> 6 & 63 | 128;
              res[p++] = c & 63 | 128;
            } else {
              res[p++] = c >> 12 | 224;
              res[p++] = c >> 6 & 63 | 128;
              res[p++] = c & 63 | 128;
            }
          }
        } else if (enc === "hex") {
          msg = msg.replace(/[^a-z0-9]+/ig, "");
          if (msg.length % 2 !== 0)
            msg = "0" + msg;
          for (i = 0; i < msg.length; i += 2)
            res.push(parseInt(msg[i] + msg[i + 1], 16));
        }
      } else {
        for (i = 0; i < msg.length; i++)
          res[i] = msg[i] | 0;
      }
      return res;
    }
    exports2.toArray = toArray;
    function toHex(msg) {
      var res = "";
      for (var i = 0; i < msg.length; i++)
        res += zero2(msg[i].toString(16));
      return res;
    }
    exports2.toHex = toHex;
    function htonl(w) {
      var res = w >>> 24 | w >>> 8 & 65280 | w << 8 & 16711680 | (w & 255) << 24;
      return res >>> 0;
    }
    exports2.htonl = htonl;
    function toHex32(msg, endian) {
      var res = "";
      for (var i = 0; i < msg.length; i++) {
        var w = msg[i];
        if (endian === "little")
          w = htonl(w);
        res += zero8(w.toString(16));
      }
      return res;
    }
    exports2.toHex32 = toHex32;
    function zero2(word) {
      if (word.length === 1)
        return "0" + word;
      else
        return word;
    }
    exports2.zero2 = zero2;
    function zero8(word) {
      if (word.length === 7)
        return "0" + word;
      else if (word.length === 6)
        return "00" + word;
      else if (word.length === 5)
        return "000" + word;
      else if (word.length === 4)
        return "0000" + word;
      else if (word.length === 3)
        return "00000" + word;
      else if (word.length === 2)
        return "000000" + word;
      else if (word.length === 1)
        return "0000000" + word;
      else
        return word;
    }
    exports2.zero8 = zero8;
    function join32(msg, start, end, endian) {
      var len = end - start;
      assert(len % 4 === 0);
      var res = new Array(len / 4);
      for (var i = 0, k = start; i < res.length; i++, k += 4) {
        var w;
        if (endian === "big")
          w = msg[k] << 24 | msg[k + 1] << 16 | msg[k + 2] << 8 | msg[k + 3];
        else
          w = msg[k + 3] << 24 | msg[k + 2] << 16 | msg[k + 1] << 8 | msg[k];
        res[i] = w >>> 0;
      }
      return res;
    }
    exports2.join32 = join32;
    function split32(msg, endian) {
      var res = new Array(msg.length * 4);
      for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
        var m = msg[i];
        if (endian === "big") {
          res[k] = m >>> 24;
          res[k + 1] = m >>> 16 & 255;
          res[k + 2] = m >>> 8 & 255;
          res[k + 3] = m & 255;
        } else {
          res[k + 3] = m >>> 24;
          res[k + 2] = m >>> 16 & 255;
          res[k + 1] = m >>> 8 & 255;
          res[k] = m & 255;
        }
      }
      return res;
    }
    exports2.split32 = split32;
    function rotr32(w, b2) {
      return w >>> b2 | w << 32 - b2;
    }
    exports2.rotr32 = rotr32;
    function rotl32(w, b2) {
      return w << b2 | w >>> 32 - b2;
    }
    exports2.rotl32 = rotl32;
    function sum32(a, b2) {
      return a + b2 >>> 0;
    }
    exports2.sum32 = sum32;
    function sum32_3(a, b2, c) {
      return a + b2 + c >>> 0;
    }
    exports2.sum32_3 = sum32_3;
    function sum32_4(a, b2, c, d) {
      return a + b2 + c + d >>> 0;
    }
    exports2.sum32_4 = sum32_4;
    function sum32_5(a, b2, c, d, e) {
      return a + b2 + c + d + e >>> 0;
    }
    exports2.sum32_5 = sum32_5;
    function sum64(buf, pos, ah, al) {
      var bh = buf[pos];
      var bl = buf[pos + 1];
      var lo = al + bl >>> 0;
      var hi = (lo < al ? 1 : 0) + ah + bh;
      buf[pos] = hi >>> 0;
      buf[pos + 1] = lo;
    }
    exports2.sum64 = sum64;
    function sum64_hi(ah, al, bh, bl) {
      var lo = al + bl >>> 0;
      var hi = (lo < al ? 1 : 0) + ah + bh;
      return hi >>> 0;
    }
    exports2.sum64_hi = sum64_hi;
    function sum64_lo(ah, al, bh, bl) {
      var lo = al + bl;
      return lo >>> 0;
    }
    exports2.sum64_lo = sum64_lo;
    function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
      var carry = 0;
      var lo = al;
      lo = lo + bl >>> 0;
      carry += lo < al ? 1 : 0;
      lo = lo + cl >>> 0;
      carry += lo < cl ? 1 : 0;
      lo = lo + dl >>> 0;
      carry += lo < dl ? 1 : 0;
      var hi = ah + bh + ch + dh + carry;
      return hi >>> 0;
    }
    exports2.sum64_4_hi = sum64_4_hi;
    function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
      var lo = al + bl + cl + dl;
      return lo >>> 0;
    }
    exports2.sum64_4_lo = sum64_4_lo;
    function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
      var carry = 0;
      var lo = al;
      lo = lo + bl >>> 0;
      carry += lo < al ? 1 : 0;
      lo = lo + cl >>> 0;
      carry += lo < cl ? 1 : 0;
      lo = lo + dl >>> 0;
      carry += lo < dl ? 1 : 0;
      lo = lo + el >>> 0;
      carry += lo < el ? 1 : 0;
      var hi = ah + bh + ch + dh + eh + carry;
      return hi >>> 0;
    }
    exports2.sum64_5_hi = sum64_5_hi;
    function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
      var lo = al + bl + cl + dl + el;
      return lo >>> 0;
    }
    exports2.sum64_5_lo = sum64_5_lo;
    function rotr64_hi(ah, al, num) {
      var r = al << 32 - num | ah >>> num;
      return r >>> 0;
    }
    exports2.rotr64_hi = rotr64_hi;
    function rotr64_lo(ah, al, num) {
      var r = ah << 32 - num | al >>> num;
      return r >>> 0;
    }
    exports2.rotr64_lo = rotr64_lo;
    function shr64_hi(ah, al, num) {
      return ah >>> num;
    }
    exports2.shr64_hi = shr64_hi;
    function shr64_lo(ah, al, num) {
      var r = ah << 32 - num | al >>> num;
      return r >>> 0;
    }
    exports2.shr64_lo = shr64_lo;
  }
});

// node_modules/hash.js/lib/hash/common.js
var require_common = __commonJS({
  "node_modules/hash.js/lib/hash/common.js"(exports2) {
    "use strict";
    var utils = require_utils3();
    var assert = require_minimalistic_assert();
    function BlockHash() {
      this.pending = null;
      this.pendingTotal = 0;
      this.blockSize = this.constructor.blockSize;
      this.outSize = this.constructor.outSize;
      this.hmacStrength = this.constructor.hmacStrength;
      this.padLength = this.constructor.padLength / 8;
      this.endian = "big";
      this._delta8 = this.blockSize / 8;
      this._delta32 = this.blockSize / 32;
    }
    exports2.BlockHash = BlockHash;
    BlockHash.prototype.update = function update(msg, enc) {
      msg = utils.toArray(msg, enc);
      if (!this.pending)
        this.pending = msg;
      else
        this.pending = this.pending.concat(msg);
      this.pendingTotal += msg.length;
      if (this.pending.length >= this._delta8) {
        msg = this.pending;
        var r = msg.length % this._delta8;
        this.pending = msg.slice(msg.length - r, msg.length);
        if (this.pending.length === 0)
          this.pending = null;
        msg = utils.join32(msg, 0, msg.length - r, this.endian);
        for (var i = 0; i < msg.length; i += this._delta32)
          this._update(msg, i, i + this._delta32);
      }
      return this;
    };
    BlockHash.prototype.digest = function digest(enc) {
      this.update(this._pad());
      assert(this.pending === null);
      return this._digest(enc);
    };
    BlockHash.prototype._pad = function pad() {
      var len = this.pendingTotal;
      var bytes = this._delta8;
      var k = bytes - (len + this.padLength) % bytes;
      var res = new Array(k + this.padLength);
      res[0] = 128;
      for (var i = 1; i < k; i++)
        res[i] = 0;
      len <<= 3;
      if (this.endian === "big") {
        for (var t = 8; t < this.padLength; t++)
          res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = len >>> 24 & 255;
        res[i++] = len >>> 16 & 255;
        res[i++] = len >>> 8 & 255;
        res[i++] = len & 255;
      } else {
        res[i++] = len & 255;
        res[i++] = len >>> 8 & 255;
        res[i++] = len >>> 16 & 255;
        res[i++] = len >>> 24 & 255;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        for (t = 8; t < this.padLength; t++)
          res[i++] = 0;
      }
      return res;
    };
  }
});

// node_modules/hash.js/lib/hash/sha/common.js
var require_common2 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/common.js"(exports2) {
    "use strict";
    var utils = require_utils3();
    var rotr32 = utils.rotr32;
    function ft_1(s, x, y, z) {
      if (s === 0)
        return ch32(x, y, z);
      if (s === 1 || s === 3)
        return p32(x, y, z);
      if (s === 2)
        return maj32(x, y, z);
    }
    exports2.ft_1 = ft_1;
    function ch32(x, y, z) {
      return x & y ^ ~x & z;
    }
    exports2.ch32 = ch32;
    function maj32(x, y, z) {
      return x & y ^ x & z ^ y & z;
    }
    exports2.maj32 = maj32;
    function p32(x, y, z) {
      return x ^ y ^ z;
    }
    exports2.p32 = p32;
    function s0_256(x) {
      return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
    }
    exports2.s0_256 = s0_256;
    function s1_256(x) {
      return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
    }
    exports2.s1_256 = s1_256;
    function g0_256(x) {
      return rotr32(x, 7) ^ rotr32(x, 18) ^ x >>> 3;
    }
    exports2.g0_256 = g0_256;
    function g1_256(x) {
      return rotr32(x, 17) ^ rotr32(x, 19) ^ x >>> 10;
    }
    exports2.g1_256 = g1_256;
  }
});

// node_modules/hash.js/lib/hash/sha/1.js
var require__ = __commonJS({
  "node_modules/hash.js/lib/hash/sha/1.js"(exports2, module2) {
    "use strict";
    var utils = require_utils3();
    var common = require_common();
    var shaCommon = require_common2();
    var rotl32 = utils.rotl32;
    var sum32 = utils.sum32;
    var sum32_5 = utils.sum32_5;
    var ft_1 = shaCommon.ft_1;
    var BlockHash = common.BlockHash;
    var sha1_K = [
      1518500249,
      1859775393,
      2400959708,
      3395469782
    ];
    function SHA1() {
      if (!(this instanceof SHA1))
        return new SHA1();
      BlockHash.call(this);
      this.h = [
        1732584193,
        4023233417,
        2562383102,
        271733878,
        3285377520
      ];
      this.W = new Array(80);
    }
    utils.inherits(SHA1, BlockHash);
    module2.exports = SHA1;
    SHA1.blockSize = 512;
    SHA1.outSize = 160;
    SHA1.hmacStrength = 80;
    SHA1.padLength = 64;
    SHA1.prototype._update = function _update(msg, start) {
      var W = this.W;
      for (var i = 0; i < 16; i++)
        W[i] = msg[start + i];
      for (; i < W.length; i++)
        W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);
      var a = this.h[0];
      var b2 = this.h[1];
      var c = this.h[2];
      var d = this.h[3];
      var e = this.h[4];
      for (i = 0; i < W.length; i++) {
        var s = ~~(i / 20);
        var t = sum32_5(rotl32(a, 5), ft_1(s, b2, c, d), e, W[i], sha1_K[s]);
        e = d;
        d = c;
        c = rotl32(b2, 30);
        b2 = a;
        a = t;
      }
      this.h[0] = sum32(this.h[0], a);
      this.h[1] = sum32(this.h[1], b2);
      this.h[2] = sum32(this.h[2], c);
      this.h[3] = sum32(this.h[3], d);
      this.h[4] = sum32(this.h[4], e);
    };
    SHA1.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha/256.js
var require__2 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/256.js"(exports2, module2) {
    "use strict";
    var utils = require_utils3();
    var common = require_common();
    var shaCommon = require_common2();
    var assert = require_minimalistic_assert();
    var sum32 = utils.sum32;
    var sum32_4 = utils.sum32_4;
    var sum32_5 = utils.sum32_5;
    var ch32 = shaCommon.ch32;
    var maj32 = shaCommon.maj32;
    var s0_256 = shaCommon.s0_256;
    var s1_256 = shaCommon.s1_256;
    var g0_256 = shaCommon.g0_256;
    var g1_256 = shaCommon.g1_256;
    var BlockHash = common.BlockHash;
    var sha256_K = [
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ];
    function SHA2562() {
      if (!(this instanceof SHA2562))
        return new SHA2562();
      BlockHash.call(this);
      this.h = [
        1779033703,
        3144134277,
        1013904242,
        2773480762,
        1359893119,
        2600822924,
        528734635,
        1541459225
      ];
      this.k = sha256_K;
      this.W = new Array(64);
    }
    utils.inherits(SHA2562, BlockHash);
    module2.exports = SHA2562;
    SHA2562.blockSize = 512;
    SHA2562.outSize = 256;
    SHA2562.hmacStrength = 192;
    SHA2562.padLength = 64;
    SHA2562.prototype._update = function _update(msg, start) {
      var W = this.W;
      for (var i = 0; i < 16; i++)
        W[i] = msg[start + i];
      for (; i < W.length; i++)
        W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);
      var a = this.h[0];
      var b2 = this.h[1];
      var c = this.h[2];
      var d = this.h[3];
      var e = this.h[4];
      var f = this.h[5];
      var g = this.h[6];
      var h = this.h[7];
      assert(this.k.length === W.length);
      for (i = 0; i < W.length; i++) {
        var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
        var T2 = sum32(s0_256(a), maj32(a, b2, c));
        h = g;
        g = f;
        f = e;
        e = sum32(d, T1);
        d = c;
        c = b2;
        b2 = a;
        a = sum32(T1, T2);
      }
      this.h[0] = sum32(this.h[0], a);
      this.h[1] = sum32(this.h[1], b2);
      this.h[2] = sum32(this.h[2], c);
      this.h[3] = sum32(this.h[3], d);
      this.h[4] = sum32(this.h[4], e);
      this.h[5] = sum32(this.h[5], f);
      this.h[6] = sum32(this.h[6], g);
      this.h[7] = sum32(this.h[7], h);
    };
    SHA2562.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha/224.js
var require__3 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/224.js"(exports2, module2) {
    "use strict";
    var utils = require_utils3();
    var SHA2562 = require__2();
    function SHA2242() {
      if (!(this instanceof SHA2242))
        return new SHA2242();
      SHA2562.call(this);
      this.h = [
        3238371032,
        914150663,
        812702999,
        4144912697,
        4290775857,
        1750603025,
        1694076839,
        3204075428
      ];
    }
    utils.inherits(SHA2242, SHA2562);
    module2.exports = SHA2242;
    SHA2242.blockSize = 512;
    SHA2242.outSize = 224;
    SHA2242.hmacStrength = 192;
    SHA2242.padLength = 64;
    SHA2242.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h.slice(0, 7), "big");
      else
        return utils.split32(this.h.slice(0, 7), "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha/512.js
var require__4 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/512.js"(exports2, module2) {
    "use strict";
    var utils = require_utils3();
    var common = require_common();
    var assert = require_minimalistic_assert();
    var rotr64_hi = utils.rotr64_hi;
    var rotr64_lo = utils.rotr64_lo;
    var shr64_hi = utils.shr64_hi;
    var shr64_lo = utils.shr64_lo;
    var sum64 = utils.sum64;
    var sum64_hi = utils.sum64_hi;
    var sum64_lo = utils.sum64_lo;
    var sum64_4_hi = utils.sum64_4_hi;
    var sum64_4_lo = utils.sum64_4_lo;
    var sum64_5_hi = utils.sum64_5_hi;
    var sum64_5_lo = utils.sum64_5_lo;
    var BlockHash = common.BlockHash;
    var sha512_K = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    function SHA512() {
      if (!(this instanceof SHA512))
        return new SHA512();
      BlockHash.call(this);
      this.h = [
        1779033703,
        4089235720,
        3144134277,
        2227873595,
        1013904242,
        4271175723,
        2773480762,
        1595750129,
        1359893119,
        2917565137,
        2600822924,
        725511199,
        528734635,
        4215389547,
        1541459225,
        327033209
      ];
      this.k = sha512_K;
      this.W = new Array(160);
    }
    utils.inherits(SHA512, BlockHash);
    module2.exports = SHA512;
    SHA512.blockSize = 1024;
    SHA512.outSize = 512;
    SHA512.hmacStrength = 192;
    SHA512.padLength = 128;
    SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
      var W = this.W;
      for (var i = 0; i < 32; i++)
        W[i] = msg[start + i];
      for (; i < W.length; i += 2) {
        var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);
        var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
        var c1_hi = W[i - 14];
        var c1_lo = W[i - 13];
        var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);
        var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
        var c3_hi = W[i - 32];
        var c3_lo = W[i - 31];
        W[i] = sum64_4_hi(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo
        );
        W[i + 1] = sum64_4_lo(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo
        );
      }
    };
    SHA512.prototype._update = function _update(msg, start) {
      this._prepareBlock(msg, start);
      var W = this.W;
      var ah = this.h[0];
      var al = this.h[1];
      var bh = this.h[2];
      var bl = this.h[3];
      var ch = this.h[4];
      var cl = this.h[5];
      var dh = this.h[6];
      var dl = this.h[7];
      var eh = this.h[8];
      var el = this.h[9];
      var fh = this.h[10];
      var fl = this.h[11];
      var gh = this.h[12];
      var gl = this.h[13];
      var hh = this.h[14];
      var hl = this.h[15];
      assert(this.k.length === W.length);
      for (var i = 0; i < W.length; i += 2) {
        var c0_hi = hh;
        var c0_lo = hl;
        var c1_hi = s1_512_hi(eh, el);
        var c1_lo = s1_512_lo(eh, el);
        var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
        var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
        var c3_hi = this.k[i];
        var c3_lo = this.k[i + 1];
        var c4_hi = W[i];
        var c4_lo = W[i + 1];
        var T1_hi = sum64_5_hi(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo,
          c4_hi,
          c4_lo
        );
        var T1_lo = sum64_5_lo(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo,
          c4_hi,
          c4_lo
        );
        c0_hi = s0_512_hi(ah, al);
        c0_lo = s0_512_lo(ah, al);
        c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
        c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
        var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
        var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
        hh = gh;
        hl = gl;
        gh = fh;
        gl = fl;
        fh = eh;
        fl = el;
        eh = sum64_hi(dh, dl, T1_hi, T1_lo);
        el = sum64_lo(dl, dl, T1_hi, T1_lo);
        dh = ch;
        dl = cl;
        ch = bh;
        cl = bl;
        bh = ah;
        bl = al;
        ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
        al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
      }
      sum64(this.h, 0, ah, al);
      sum64(this.h, 2, bh, bl);
      sum64(this.h, 4, ch, cl);
      sum64(this.h, 6, dh, dl);
      sum64(this.h, 8, eh, el);
      sum64(this.h, 10, fh, fl);
      sum64(this.h, 12, gh, gl);
      sum64(this.h, 14, hh, hl);
    };
    SHA512.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
    function ch64_hi(xh, xl, yh, yl, zh) {
      var r = xh & yh ^ ~xh & zh;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function ch64_lo(xh, xl, yh, yl, zh, zl) {
      var r = xl & yl ^ ~xl & zl;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function maj64_hi(xh, xl, yh, yl, zh) {
      var r = xh & yh ^ xh & zh ^ yh & zh;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function maj64_lo(xh, xl, yh, yl, zh, zl) {
      var r = xl & yl ^ xl & zl ^ yl & zl;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function s0_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 28);
      var c1_hi = rotr64_hi(xl, xh, 2);
      var c2_hi = rotr64_hi(xl, xh, 7);
      var r = c0_hi ^ c1_hi ^ c2_hi;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function s0_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 28);
      var c1_lo = rotr64_lo(xl, xh, 2);
      var c2_lo = rotr64_lo(xl, xh, 7);
      var r = c0_lo ^ c1_lo ^ c2_lo;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function s1_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 14);
      var c1_hi = rotr64_hi(xh, xl, 18);
      var c2_hi = rotr64_hi(xl, xh, 9);
      var r = c0_hi ^ c1_hi ^ c2_hi;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function s1_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 14);
      var c1_lo = rotr64_lo(xh, xl, 18);
      var c2_lo = rotr64_lo(xl, xh, 9);
      var r = c0_lo ^ c1_lo ^ c2_lo;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function g0_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 1);
      var c1_hi = rotr64_hi(xh, xl, 8);
      var c2_hi = shr64_hi(xh, xl, 7);
      var r = c0_hi ^ c1_hi ^ c2_hi;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function g0_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 1);
      var c1_lo = rotr64_lo(xh, xl, 8);
      var c2_lo = shr64_lo(xh, xl, 7);
      var r = c0_lo ^ c1_lo ^ c2_lo;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function g1_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 19);
      var c1_hi = rotr64_hi(xl, xh, 29);
      var c2_hi = shr64_hi(xh, xl, 6);
      var r = c0_hi ^ c1_hi ^ c2_hi;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function g1_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 19);
      var c1_lo = rotr64_lo(xl, xh, 29);
      var c2_lo = shr64_lo(xh, xl, 6);
      var r = c0_lo ^ c1_lo ^ c2_lo;
      if (r < 0)
        r += 4294967296;
      return r;
    }
  }
});

// node_modules/hash.js/lib/hash/sha/384.js
var require__5 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/384.js"(exports2, module2) {
    "use strict";
    var utils = require_utils3();
    var SHA512 = require__4();
    function SHA384() {
      if (!(this instanceof SHA384))
        return new SHA384();
      SHA512.call(this);
      this.h = [
        3418070365,
        3238371032,
        1654270250,
        914150663,
        2438529370,
        812702999,
        355462360,
        4144912697,
        1731405415,
        4290775857,
        2394180231,
        1750603025,
        3675008525,
        1694076839,
        1203062813,
        3204075428
      ];
    }
    utils.inherits(SHA384, SHA512);
    module2.exports = SHA384;
    SHA384.blockSize = 1024;
    SHA384.outSize = 384;
    SHA384.hmacStrength = 192;
    SHA384.padLength = 128;
    SHA384.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h.slice(0, 12), "big");
      else
        return utils.split32(this.h.slice(0, 12), "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha.js
var require_sha3 = __commonJS({
  "node_modules/hash.js/lib/hash/sha.js"(exports2) {
    "use strict";
    exports2.sha1 = require__();
    exports2.sha224 = require__3();
    exports2.sha256 = require__2();
    exports2.sha384 = require__5();
    exports2.sha512 = require__4();
  }
});

// node_modules/hash.js/lib/hash/ripemd.js
var require_ripemd = __commonJS({
  "node_modules/hash.js/lib/hash/ripemd.js"(exports2) {
    "use strict";
    var utils = require_utils3();
    var common = require_common();
    var rotl32 = utils.rotl32;
    var sum32 = utils.sum32;
    var sum32_3 = utils.sum32_3;
    var sum32_4 = utils.sum32_4;
    var BlockHash = common.BlockHash;
    function RIPEMD1602() {
      if (!(this instanceof RIPEMD1602))
        return new RIPEMD1602();
      BlockHash.call(this);
      this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
      this.endian = "little";
    }
    utils.inherits(RIPEMD1602, BlockHash);
    exports2.ripemd160 = RIPEMD1602;
    RIPEMD1602.blockSize = 512;
    RIPEMD1602.outSize = 160;
    RIPEMD1602.hmacStrength = 192;
    RIPEMD1602.padLength = 64;
    RIPEMD1602.prototype._update = function update(msg, start) {
      var A = this.h[0];
      var B = this.h[1];
      var C = this.h[2];
      var D = this.h[3];
      var E = this.h[4];
      var Ah = A;
      var Bh = B;
      var Ch = C;
      var Dh = D;
      var Eh = E;
      for (var j = 0; j < 80; j++) {
        var T = sum32(
          rotl32(
            sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)),
            s[j]
          ),
          E
        );
        A = E;
        E = D;
        D = rotl32(C, 10);
        C = B;
        B = T;
        T = sum32(
          rotl32(
            sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
            sh[j]
          ),
          Eh
        );
        Ah = Eh;
        Eh = Dh;
        Dh = rotl32(Ch, 10);
        Ch = Bh;
        Bh = T;
      }
      T = sum32_3(this.h[1], C, Dh);
      this.h[1] = sum32_3(this.h[2], D, Eh);
      this.h[2] = sum32_3(this.h[3], E, Ah);
      this.h[3] = sum32_3(this.h[4], A, Bh);
      this.h[4] = sum32_3(this.h[0], B, Ch);
      this.h[0] = T;
    };
    RIPEMD1602.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "little");
      else
        return utils.split32(this.h, "little");
    };
    function f(j, x, y, z) {
      if (j <= 15)
        return x ^ y ^ z;
      else if (j <= 31)
        return x & y | ~x & z;
      else if (j <= 47)
        return (x | ~y) ^ z;
      else if (j <= 63)
        return x & z | y & ~z;
      else
        return x ^ (y | ~z);
    }
    function K(j) {
      if (j <= 15)
        return 0;
      else if (j <= 31)
        return 1518500249;
      else if (j <= 47)
        return 1859775393;
      else if (j <= 63)
        return 2400959708;
      else
        return 2840853838;
    }
    function Kh(j) {
      if (j <= 15)
        return 1352829926;
      else if (j <= 31)
        return 1548603684;
      else if (j <= 47)
        return 1836072691;
      else if (j <= 63)
        return 2053994217;
      else
        return 0;
    }
    var r = [
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      7,
      4,
      13,
      1,
      10,
      6,
      15,
      3,
      12,
      0,
      9,
      5,
      2,
      14,
      11,
      8,
      3,
      10,
      14,
      4,
      9,
      15,
      8,
      1,
      2,
      7,
      0,
      6,
      13,
      11,
      5,
      12,
      1,
      9,
      11,
      10,
      0,
      8,
      12,
      4,
      13,
      3,
      7,
      15,
      14,
      5,
      6,
      2,
      4,
      0,
      5,
      9,
      7,
      12,
      2,
      10,
      14,
      1,
      3,
      8,
      11,
      6,
      15,
      13
    ];
    var rh = [
      5,
      14,
      7,
      0,
      9,
      2,
      11,
      4,
      13,
      6,
      15,
      8,
      1,
      10,
      3,
      12,
      6,
      11,
      3,
      7,
      0,
      13,
      5,
      10,
      14,
      15,
      8,
      12,
      4,
      9,
      1,
      2,
      15,
      5,
      1,
      3,
      7,
      14,
      6,
      9,
      11,
      8,
      12,
      2,
      10,
      0,
      4,
      13,
      8,
      6,
      4,
      1,
      3,
      11,
      15,
      0,
      5,
      12,
      2,
      13,
      9,
      7,
      10,
      14,
      12,
      15,
      10,
      4,
      1,
      5,
      8,
      7,
      6,
      2,
      13,
      14,
      0,
      3,
      9,
      11
    ];
    var s = [
      11,
      14,
      15,
      12,
      5,
      8,
      7,
      9,
      11,
      13,
      14,
      15,
      6,
      7,
      9,
      8,
      7,
      6,
      8,
      13,
      11,
      9,
      7,
      15,
      7,
      12,
      15,
      9,
      11,
      7,
      13,
      12,
      11,
      13,
      6,
      7,
      14,
      9,
      13,
      15,
      14,
      8,
      13,
      6,
      5,
      12,
      7,
      5,
      11,
      12,
      14,
      15,
      14,
      15,
      9,
      8,
      9,
      14,
      5,
      6,
      8,
      6,
      5,
      12,
      9,
      15,
      5,
      11,
      6,
      8,
      13,
      12,
      5,
      12,
      13,
      14,
      11,
      8,
      5,
      6
    ];
    var sh = [
      8,
      9,
      9,
      11,
      13,
      15,
      15,
      5,
      7,
      7,
      8,
      11,
      14,
      14,
      12,
      6,
      9,
      13,
      15,
      7,
      12,
      8,
      9,
      11,
      7,
      7,
      12,
      7,
      6,
      15,
      13,
      11,
      9,
      7,
      15,
      11,
      8,
      6,
      6,
      14,
      12,
      13,
      5,
      14,
      13,
      13,
      7,
      5,
      15,
      5,
      8,
      11,
      14,
      14,
      6,
      14,
      6,
      9,
      12,
      9,
      12,
      5,
      15,
      8,
      8,
      5,
      12,
      9,
      12,
      5,
      14,
      6,
      8,
      13,
      6,
      5,
      15,
      13,
      11,
      11
    ];
  }
});

// node_modules/hash.js/lib/hash/hmac.js
var require_hmac = __commonJS({
  "node_modules/hash.js/lib/hash/hmac.js"(exports2, module2) {
    "use strict";
    var utils = require_utils3();
    var assert = require_minimalistic_assert();
    function Hmac(hash, key, enc) {
      if (!(this instanceof Hmac))
        return new Hmac(hash, key, enc);
      this.Hash = hash;
      this.blockSize = hash.blockSize / 8;
      this.outSize = hash.outSize / 8;
      this.inner = null;
      this.outer = null;
      this._init(utils.toArray(key, enc));
    }
    module2.exports = Hmac;
    Hmac.prototype._init = function init(key) {
      if (key.length > this.blockSize)
        key = new this.Hash().update(key).digest();
      assert(key.length <= this.blockSize);
      for (var i = key.length; i < this.blockSize; i++)
        key.push(0);
      for (i = 0; i < key.length; i++)
        key[i] ^= 54;
      this.inner = new this.Hash().update(key);
      for (i = 0; i < key.length; i++)
        key[i] ^= 106;
      this.outer = new this.Hash().update(key);
    };
    Hmac.prototype.update = function update(msg, enc) {
      this.inner.update(msg, enc);
      return this;
    };
    Hmac.prototype.digest = function digest(enc) {
      this.outer.update(this.inner.digest());
      return this.outer.digest(enc);
    };
  }
});

// node_modules/hash.js/lib/hash.js
var require_hash2 = __commonJS({
  "node_modules/hash.js/lib/hash.js"(exports2) {
    var hash = exports2;
    hash.utils = require_utils3();
    hash.common = require_common();
    hash.sha = require_sha3();
    hash.ripemd = require_ripemd();
    hash.hmac = require_hmac();
    hash.sha1 = hash.sha.sha1;
    hash.sha256 = hash.sha.sha256;
    hash.sha224 = hash.sha.sha224;
    hash.sha384 = hash.sha.sha384;
    hash.sha512 = hash.sha.sha512;
    hash.ripemd160 = hash.ripemd.ripemd160;
  }
});

// node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js
var require_secp256k1 = __commonJS({
  "node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js"(exports2, module2) {
    module2.exports = {
      doubles: {
        step: 4,
        points: [
          [
            "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
            "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
          ],
          [
            "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
            "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
          ],
          [
            "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
            "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
          ],
          [
            "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
            "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
          ],
          [
            "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
            "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
          ],
          [
            "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
            "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
          ],
          [
            "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
            "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
          ],
          [
            "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
            "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
          ],
          [
            "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
            "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
          ],
          [
            "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
            "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
          ],
          [
            "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
            "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
          ],
          [
            "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
            "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
          ],
          [
            "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
            "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
          ],
          [
            "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
            "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
          ],
          [
            "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
            "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
          ],
          [
            "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
            "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
          ],
          [
            "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
            "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
          ],
          [
            "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
            "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
          ],
          [
            "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
            "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
          ],
          [
            "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
            "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
          ],
          [
            "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
            "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
          ],
          [
            "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
            "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
          ],
          [
            "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
            "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
          ],
          [
            "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
            "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
          ],
          [
            "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
            "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
          ],
          [
            "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
            "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
          ],
          [
            "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
            "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
          ],
          [
            "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
            "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
          ],
          [
            "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
            "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
          ],
          [
            "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
            "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
          ],
          [
            "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
            "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
          ],
          [
            "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
            "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
          ],
          [
            "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
            "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
          ],
          [
            "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
            "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
          ],
          [
            "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
            "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
          ],
          [
            "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
            "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
          ],
          [
            "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
            "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
          ],
          [
            "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
            "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
          ],
          [
            "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
            "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
          ],
          [
            "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
            "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
          ],
          [
            "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
            "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
          ],
          [
            "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
            "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
          ],
          [
            "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
            "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
          ],
          [
            "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
            "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
          ],
          [
            "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
            "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
          ],
          [
            "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
            "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
          ],
          [
            "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
            "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
          ],
          [
            "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
            "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
          ],
          [
            "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
            "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
          ],
          [
            "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
            "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
          ],
          [
            "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
            "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
          ],
          [
            "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
            "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
          ],
          [
            "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
            "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
          ],
          [
            "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
            "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
          ],
          [
            "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
            "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
          ],
          [
            "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
            "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
          ],
          [
            "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
            "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
          ],
          [
            "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
            "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
          ],
          [
            "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
            "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
          ],
          [
            "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
            "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
          ],
          [
            "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
            "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
          ],
          [
            "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
            "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
          ],
          [
            "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
            "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
          ],
          [
            "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
            "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
          ],
          [
            "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
            "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
          ]
        ]
      },
      naf: {
        wnd: 7,
        points: [
          [
            "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
            "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
          ],
          [
            "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
            "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
          ],
          [
            "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
            "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
          ],
          [
            "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
            "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
          ],
          [
            "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
            "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
          ],
          [
            "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
            "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
          ],
          [
            "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
            "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
          ],
          [
            "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
            "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
          ],
          [
            "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
            "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
          ],
          [
            "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
            "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
          ],
          [
            "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
            "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
          ],
          [
            "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
            "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
          ],
          [
            "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
            "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
          ],
          [
            "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
            "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
          ],
          [
            "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
            "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
          ],
          [
            "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
            "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
          ],
          [
            "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
            "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
          ],
          [
            "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
            "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
          ],
          [
            "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
            "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
          ],
          [
            "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
            "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
          ],
          [
            "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
            "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
          ],
          [
            "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
            "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
          ],
          [
            "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
            "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
          ],
          [
            "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
            "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
          ],
          [
            "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
            "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
          ],
          [
            "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
            "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
          ],
          [
            "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
            "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
          ],
          [
            "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
            "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
          ],
          [
            "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
            "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
          ],
          [
            "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
            "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
          ],
          [
            "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
            "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
          ],
          [
            "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
            "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
          ],
          [
            "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
            "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
          ],
          [
            "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
            "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
          ],
          [
            "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
            "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
          ],
          [
            "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
            "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
          ],
          [
            "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
            "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
          ],
          [
            "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
            "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
          ],
          [
            "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
            "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
          ],
          [
            "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
            "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
          ],
          [
            "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
            "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
          ],
          [
            "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
            "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
          ],
          [
            "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
            "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
          ],
          [
            "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
            "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
          ],
          [
            "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
            "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
          ],
          [
            "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
            "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
          ],
          [
            "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
            "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
          ],
          [
            "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
            "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
          ],
          [
            "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
            "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
          ],
          [
            "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
            "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
          ],
          [
            "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
            "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
          ],
          [
            "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
            "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
          ],
          [
            "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
            "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
          ],
          [
            "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
            "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
          ],
          [
            "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
            "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
          ],
          [
            "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
            "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
          ],
          [
            "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
            "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
          ],
          [
            "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
            "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
          ],
          [
            "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
            "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
          ],
          [
            "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
            "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
          ],
          [
            "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
            "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
          ],
          [
            "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
            "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
          ],
          [
            "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
            "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
          ],
          [
            "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
            "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
          ],
          [
            "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
            "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
          ],
          [
            "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
            "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
          ],
          [
            "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
            "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
          ],
          [
            "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
            "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
          ],
          [
            "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
            "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
          ],
          [
            "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
            "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
          ],
          [
            "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
            "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
          ],
          [
            "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
            "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
          ],
          [
            "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
            "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
          ],
          [
            "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
            "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
          ],
          [
            "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
            "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
          ],
          [
            "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
            "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
          ],
          [
            "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
            "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
          ],
          [
            "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
            "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
          ],
          [
            "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
            "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
          ],
          [
            "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
            "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
          ],
          [
            "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
            "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
          ],
          [
            "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
            "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
          ],
          [
            "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
            "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
          ],
          [
            "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
            "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
          ],
          [
            "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
            "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
          ],
          [
            "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
            "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
          ],
          [
            "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
            "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
          ],
          [
            "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
            "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
          ],
          [
            "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
            "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
          ],
          [
            "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
            "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
          ],
          [
            "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
            "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
          ],
          [
            "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
            "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
          ],
          [
            "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
            "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
          ],
          [
            "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
            "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
          ],
          [
            "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
            "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
          ],
          [
            "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
            "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
          ],
          [
            "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
            "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
          ],
          [
            "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
            "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
          ],
          [
            "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
            "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
          ],
          [
            "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
            "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
          ],
          [
            "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
            "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
          ],
          [
            "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
            "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
          ],
          [
            "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
            "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
          ],
          [
            "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
            "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
          ],
          [
            "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
            "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
          ],
          [
            "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
            "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
          ],
          [
            "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
            "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
          ],
          [
            "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
            "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
          ],
          [
            "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
            "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
          ],
          [
            "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
            "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
          ],
          [
            "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
            "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
          ],
          [
            "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
            "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
          ],
          [
            "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
            "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
          ],
          [
            "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
            "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
          ],
          [
            "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
            "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
          ],
          [
            "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
            "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
          ],
          [
            "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
            "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
          ],
          [
            "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
            "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
          ],
          [
            "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
            "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
          ],
          [
            "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
            "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
          ],
          [
            "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
            "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
          ],
          [
            "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
            "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
          ],
          [
            "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
            "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
          ],
          [
            "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
            "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
          ],
          [
            "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
            "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
          ],
          [
            "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
            "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
          ],
          [
            "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
            "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
          ]
        ]
      }
    };
  }
});

// node_modules/elliptic/lib/elliptic/curves.js
var require_curves = __commonJS({
  "node_modules/elliptic/lib/elliptic/curves.js"(exports2) {
    "use strict";
    var curves = exports2;
    var hash = require_hash2();
    var curve = require_curve();
    var utils = require_utils2();
    var assert = utils.assert;
    function PresetCurve(options) {
      if (options.type === "short")
        this.curve = new curve.short(options);
      else if (options.type === "edwards")
        this.curve = new curve.edwards(options);
      else
        this.curve = new curve.mont(options);
      this.g = this.curve.g;
      this.n = this.curve.n;
      this.hash = options.hash;
      assert(this.g.validate(), "Invalid curve");
      assert(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    curves.PresetCurve = PresetCurve;
    function defineCurve(name, options) {
      Object.defineProperty(curves, name, {
        configurable: true,
        enumerable: true,
        get: function() {
          var curve2 = new PresetCurve(options);
          Object.defineProperty(curves, name, {
            configurable: true,
            enumerable: true,
            value: curve2
          });
          return curve2;
        }
      });
    }
    defineCurve("p192", {
      type: "short",
      prime: "p192",
      p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
      b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
      n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
      hash: hash.sha256,
      gRed: false,
      g: [
        "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
        "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
      ]
    });
    defineCurve("p224", {
      type: "short",
      prime: "p224",
      p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
      b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
      n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
      hash: hash.sha256,
      gRed: false,
      g: [
        "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
        "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
      ]
    });
    defineCurve("p256", {
      type: "short",
      prime: null,
      p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
      a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
      b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
      n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
      hash: hash.sha256,
      gRed: false,
      g: [
        "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
        "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
      ]
    });
    defineCurve("p384", {
      type: "short",
      prime: null,
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
      a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
      b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
      n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
      hash: hash.sha384,
      gRed: false,
      g: [
        "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
        "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
      ]
    });
    defineCurve("p521", {
      type: "short",
      prime: null,
      p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
      a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
      b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
      n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
      hash: hash.sha512,
      gRed: false,
      g: [
        "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
        "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
      ]
    });
    defineCurve("curve25519", {
      type: "mont",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "76d06",
      b: "1",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hash.sha256,
      gRed: false,
      g: [
        "9"
      ]
    });
    defineCurve("ed25519", {
      type: "edwards",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "-1",
      c: "1",
      // -121665 * (121666^(-1)) (mod P)
      d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hash.sha256,
      gRed: false,
      g: [
        "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
        // 4/5
        "6666666666666666666666666666666666666666666666666666666666666658"
      ]
    });
    var pre;
    try {
      pre = require_secp256k1();
    } catch (e) {
      pre = void 0;
    }
    defineCurve("secp256k1", {
      type: "short",
      prime: "k256",
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
      a: "0",
      b: "7",
      n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
      h: "1",
      hash: hash.sha256,
      // Precomputed endomorphism
      beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
      lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
      basis: [
        {
          a: "3086d221a7d46bcde86c90e49284eb15",
          b: "-e4437ed6010e88286f547fa90abfe4c3"
        },
        {
          a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
          b: "3086d221a7d46bcde86c90e49284eb15"
        }
      ],
      gRed: false,
      g: [
        "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
        pre
      ]
    });
  }
});

// node_modules/hmac-drbg/lib/hmac-drbg.js
var require_hmac_drbg = __commonJS({
  "node_modules/hmac-drbg/lib/hmac-drbg.js"(exports2, module2) {
    "use strict";
    var hash = require_hash2();
    var utils = require_utils();
    var assert = require_minimalistic_assert();
    function HmacDRBG(options) {
      if (!(this instanceof HmacDRBG))
        return new HmacDRBG(options);
      this.hash = options.hash;
      this.predResist = !!options.predResist;
      this.outLen = this.hash.outSize;
      this.minEntropy = options.minEntropy || this.hash.hmacStrength;
      this._reseed = null;
      this.reseedInterval = null;
      this.K = null;
      this.V = null;
      var entropy = utils.toArray(options.entropy, options.entropyEnc || "hex");
      var nonce = utils.toArray(options.nonce, options.nonceEnc || "hex");
      var pers = utils.toArray(options.pers, options.persEnc || "hex");
      assert(
        entropy.length >= this.minEntropy / 8,
        "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
      );
      this._init(entropy, nonce, pers);
    }
    module2.exports = HmacDRBG;
    HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
      var seed = entropy.concat(nonce).concat(pers);
      this.K = new Array(this.outLen / 8);
      this.V = new Array(this.outLen / 8);
      for (var i = 0; i < this.V.length; i++) {
        this.K[i] = 0;
        this.V[i] = 1;
      }
      this._update(seed);
      this._reseed = 1;
      this.reseedInterval = 281474976710656;
    };
    HmacDRBG.prototype._hmac = function hmac2() {
      return new hash.hmac(this.hash, this.K);
    };
    HmacDRBG.prototype._update = function update(seed) {
      var kmac = this._hmac().update(this.V).update([0]);
      if (seed)
        kmac = kmac.update(seed);
      this.K = kmac.digest();
      this.V = this._hmac().update(this.V).digest();
      if (!seed)
        return;
      this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
      this.V = this._hmac().update(this.V).digest();
    };
    HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
      if (typeof entropyEnc !== "string") {
        addEnc = add;
        add = entropyEnc;
        entropyEnc = null;
      }
      entropy = utils.toArray(entropy, entropyEnc);
      add = utils.toArray(add, addEnc);
      assert(
        entropy.length >= this.minEntropy / 8,
        "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
      );
      this._update(entropy.concat(add || []));
      this._reseed = 1;
    };
    HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
      if (this._reseed > this.reseedInterval)
        throw new Error("Reseed is required");
      if (typeof enc !== "string") {
        addEnc = add;
        add = enc;
        enc = null;
      }
      if (add) {
        add = utils.toArray(add, addEnc || "hex");
        this._update(add);
      }
      var temp = [];
      while (temp.length < len) {
        this.V = this._hmac().update(this.V).digest();
        temp = temp.concat(this.V);
      }
      var res = temp.slice(0, len);
      this._update(add);
      this._reseed++;
      return utils.encode(res, enc);
    };
  }
});

// node_modules/elliptic/lib/elliptic/ec/key.js
var require_key = __commonJS({
  "node_modules/elliptic/lib/elliptic/ec/key.js"(exports2, module2) {
    "use strict";
    var BN = require_bn2();
    var utils = require_utils2();
    var assert = utils.assert;
    function KeyPair2(ec, options) {
      this.ec = ec;
      this.priv = null;
      this.pub = null;
      if (options.priv)
        this._importPrivate(options.priv, options.privEnc);
      if (options.pub)
        this._importPublic(options.pub, options.pubEnc);
    }
    module2.exports = KeyPair2;
    KeyPair2.fromPublic = function fromPublic(ec, pub, enc) {
      if (pub instanceof KeyPair2)
        return pub;
      return new KeyPair2(ec, {
        pub,
        pubEnc: enc
      });
    };
    KeyPair2.fromPrivate = function fromPrivate(ec, priv, enc) {
      if (priv instanceof KeyPair2)
        return priv;
      return new KeyPair2(ec, {
        priv,
        privEnc: enc
      });
    };
    KeyPair2.prototype.validate = function validate() {
      var pub = this.getPublic();
      if (pub.isInfinity())
        return { result: false, reason: "Invalid public key" };
      if (!pub.validate())
        return { result: false, reason: "Public key is not a point" };
      if (!pub.mul(this.ec.curve.n).isInfinity())
        return { result: false, reason: "Public key * N != O" };
      return { result: true, reason: null };
    };
    KeyPair2.prototype.getPublic = function getPublic(compact, enc) {
      if (typeof compact === "string") {
        enc = compact;
        compact = null;
      }
      if (!this.pub)
        this.pub = this.ec.g.mul(this.priv);
      if (!enc)
        return this.pub;
      return this.pub.encode(enc, compact);
    };
    KeyPair2.prototype.getPrivate = function getPrivate(enc) {
      if (enc === "hex")
        return this.priv.toString(16, 2);
      else
        return this.priv;
    };
    KeyPair2.prototype._importPrivate = function _importPrivate(key, enc) {
      this.priv = new BN(key, enc || 16);
      this.priv = this.priv.umod(this.ec.curve.n);
    };
    KeyPair2.prototype._importPublic = function _importPublic(key, enc) {
      if (key.x || key.y) {
        if (this.ec.curve.type === "mont") {
          assert(key.x, "Need x coordinate");
        } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
          assert(key.x && key.y, "Need both x and y coordinate");
        }
        this.pub = this.ec.curve.point(key.x, key.y);
        return;
      }
      this.pub = this.ec.curve.decodePoint(key, enc);
    };
    KeyPair2.prototype.derive = function derive(pub) {
      if (!pub.validate()) {
        assert(pub.validate(), "public point not validated");
      }
      return pub.mul(this.priv).getX();
    };
    KeyPair2.prototype.sign = function sign(msg, enc, options) {
      return this.ec.sign(msg, this, enc, options);
    };
    KeyPair2.prototype.verify = function verify(msg, signature, options) {
      return this.ec.verify(msg, signature, this, void 0, options);
    };
    KeyPair2.prototype.inspect = function inspect() {
      return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
    };
  }
});

// node_modules/elliptic/lib/elliptic/ec/signature.js
var require_signature = __commonJS({
  "node_modules/elliptic/lib/elliptic/ec/signature.js"(exports2, module2) {
    "use strict";
    var BN = require_bn2();
    var utils = require_utils2();
    var assert = utils.assert;
    function Signature(options, enc) {
      if (options instanceof Signature)
        return options;
      if (this._importDER(options, enc))
        return;
      assert(options.r && options.s, "Signature without r or s");
      this.r = new BN(options.r, 16);
      this.s = new BN(options.s, 16);
      if (options.recoveryParam === void 0)
        this.recoveryParam = null;
      else
        this.recoveryParam = options.recoveryParam;
    }
    module2.exports = Signature;
    function Position() {
      this.place = 0;
    }
    function getLength(buf, p) {
      var initial = buf[p.place++];
      if (!(initial & 128)) {
        return initial;
      }
      var octetLen = initial & 15;
      if (octetLen === 0 || octetLen > 4) {
        return false;
      }
      if (buf[p.place] === 0) {
        return false;
      }
      var val = 0;
      for (var i = 0, off = p.place; i < octetLen; i++, off++) {
        val <<= 8;
        val |= buf[off];
        val >>>= 0;
      }
      if (val <= 127) {
        return false;
      }
      p.place = off;
      return val;
    }
    function rmPadding(buf) {
      var i = 0;
      var len = buf.length - 1;
      while (!buf[i] && !(buf[i + 1] & 128) && i < len) {
        i++;
      }
      if (i === 0) {
        return buf;
      }
      return buf.slice(i);
    }
    Signature.prototype._importDER = function _importDER(data, enc) {
      data = utils.toArray(data, enc);
      var p = new Position();
      if (data[p.place++] !== 48) {
        return false;
      }
      var len = getLength(data, p);
      if (len === false) {
        return false;
      }
      if (len + p.place !== data.length) {
        return false;
      }
      if (data[p.place++] !== 2) {
        return false;
      }
      var rlen = getLength(data, p);
      if (rlen === false) {
        return false;
      }
      if ((data[p.place] & 128) !== 0) {
        return false;
      }
      var r = data.slice(p.place, rlen + p.place);
      p.place += rlen;
      if (data[p.place++] !== 2) {
        return false;
      }
      var slen = getLength(data, p);
      if (slen === false) {
        return false;
      }
      if (data.length !== slen + p.place) {
        return false;
      }
      if ((data[p.place] & 128) !== 0) {
        return false;
      }
      var s = data.slice(p.place, slen + p.place);
      if (r[0] === 0) {
        if (r[1] & 128) {
          r = r.slice(1);
        } else {
          return false;
        }
      }
      if (s[0] === 0) {
        if (s[1] & 128) {
          s = s.slice(1);
        } else {
          return false;
        }
      }
      this.r = new BN(r);
      this.s = new BN(s);
      this.recoveryParam = null;
      return true;
    };
    function constructLength(arr, len) {
      if (len < 128) {
        arr.push(len);
        return;
      }
      var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
      arr.push(octets | 128);
      while (--octets) {
        arr.push(len >>> (octets << 3) & 255);
      }
      arr.push(len);
    }
    Signature.prototype.toDER = function toDER(enc) {
      var r = this.r.toArray();
      var s = this.s.toArray();
      if (r[0] & 128)
        r = [0].concat(r);
      if (s[0] & 128)
        s = [0].concat(s);
      r = rmPadding(r);
      s = rmPadding(s);
      while (!s[0] && !(s[1] & 128)) {
        s = s.slice(1);
      }
      var arr = [2];
      constructLength(arr, r.length);
      arr = arr.concat(r);
      arr.push(2);
      constructLength(arr, s.length);
      var backHalf = arr.concat(s);
      var res = [48];
      constructLength(res, backHalf.length);
      res = res.concat(backHalf);
      return utils.encode(res, enc);
    };
  }
});

// node_modules/elliptic/lib/elliptic/ec/index.js
var require_ec = __commonJS({
  "node_modules/elliptic/lib/elliptic/ec/index.js"(exports2, module2) {
    "use strict";
    var BN = require_bn2();
    var HmacDRBG = require_hmac_drbg();
    var utils = require_utils2();
    var curves = require_curves();
    var rand = require_brorand();
    var assert = utils.assert;
    var KeyPair2 = require_key();
    var Signature = require_signature();
    function EC(options) {
      if (!(this instanceof EC))
        return new EC(options);
      if (typeof options === "string") {
        assert(
          Object.prototype.hasOwnProperty.call(curves, options),
          "Unknown curve " + options
        );
        options = curves[options];
      }
      if (options instanceof curves.PresetCurve)
        options = { curve: options };
      this.curve = options.curve.curve;
      this.n = this.curve.n;
      this.nh = this.n.ushrn(1);
      this.g = this.curve.g;
      this.g = options.curve.g;
      this.g.precompute(options.curve.n.bitLength() + 1);
      this.hash = options.hash || options.curve.hash;
    }
    module2.exports = EC;
    EC.prototype.keyPair = function keyPair(options) {
      return new KeyPair2(this, options);
    };
    EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
      return KeyPair2.fromPrivate(this, priv, enc);
    };
    EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
      return KeyPair2.fromPublic(this, pub, enc);
    };
    EC.prototype.genKeyPair = function genKeyPair(options) {
      if (!options)
        options = {};
      var drbg = new HmacDRBG({
        hash: this.hash,
        pers: options.pers,
        persEnc: options.persEnc || "utf8",
        entropy: options.entropy || rand(this.hash.hmacStrength),
        entropyEnc: options.entropy && options.entropyEnc || "utf8",
        nonce: this.n.toArray()
      });
      var bytes = this.n.byteLength();
      var ns2 = this.n.sub(new BN(2));
      for (; ; ) {
        var priv = new BN(drbg.generate(bytes));
        if (priv.cmp(ns2) > 0)
          continue;
        priv.iaddn(1);
        return this.keyFromPrivate(priv);
      }
    };
    EC.prototype._truncateToN = function _truncateToN(msg, truncOnly, bitLength) {
      var byteLength;
      if (BN.isBN(msg) || typeof msg === "number") {
        msg = new BN(msg, 16);
        byteLength = msg.byteLength();
      } else if (typeof msg === "object") {
        byteLength = msg.length;
        msg = new BN(msg, 16);
      } else {
        var str = msg.toString();
        byteLength = str.length + 1 >>> 1;
        msg = new BN(str, 16);
      }
      if (typeof bitLength !== "number") {
        bitLength = byteLength * 8;
      }
      var delta = bitLength - this.n.bitLength();
      if (delta > 0)
        msg = msg.ushrn(delta);
      if (!truncOnly && msg.cmp(this.n) >= 0)
        return msg.sub(this.n);
      else
        return msg;
    };
    EC.prototype.sign = function sign(msg, key, enc, options) {
      if (typeof enc === "object") {
        options = enc;
        enc = null;
      }
      if (!options)
        options = {};
      if (typeof msg !== "string" && typeof msg !== "number" && !BN.isBN(msg)) {
        assert(
          typeof msg === "object" && msg && typeof msg.length === "number",
          "Expected message to be an array-like, a hex string, or a BN instance"
        );
        assert(msg.length >>> 0 === msg.length);
        for (var i = 0; i < msg.length; i++) assert((msg[i] & 255) === msg[i]);
      }
      key = this.keyFromPrivate(key, enc);
      msg = this._truncateToN(msg, false, options.msgBitLength);
      assert(!msg.isNeg(), "Can not sign a negative message");
      var bytes = this.n.byteLength();
      var bkey = key.getPrivate().toArray("be", bytes);
      var nonce = msg.toArray("be", bytes);
      assert(new BN(nonce).eq(msg), "Can not sign message");
      var drbg = new HmacDRBG({
        hash: this.hash,
        entropy: bkey,
        nonce,
        pers: options.pers,
        persEnc: options.persEnc || "utf8"
      });
      var ns1 = this.n.sub(new BN(1));
      for (var iter = 0; ; iter++) {
        var k = options.k ? options.k(iter) : new BN(drbg.generate(this.n.byteLength()));
        k = this._truncateToN(k, true);
        if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
          continue;
        var kp = this.g.mul(k);
        if (kp.isInfinity())
          continue;
        var kpX = kp.getX();
        var r = kpX.umod(this.n);
        if (r.cmpn(0) === 0)
          continue;
        var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
        s = s.umod(this.n);
        if (s.cmpn(0) === 0)
          continue;
        var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r) !== 0 ? 2 : 0);
        if (options.canonical && s.cmp(this.nh) > 0) {
          s = this.n.sub(s);
          recoveryParam ^= 1;
        }
        return new Signature({ r, s, recoveryParam });
      }
    };
    EC.prototype.verify = function verify(msg, signature, key, enc, options) {
      if (!options)
        options = {};
      msg = this._truncateToN(msg, false, options.msgBitLength);
      key = this.keyFromPublic(key, enc);
      signature = new Signature(signature, "hex");
      var r = signature.r;
      var s = signature.s;
      if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
        return false;
      if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
        return false;
      var sinv = s.invm(this.n);
      var u1 = sinv.mul(msg).umod(this.n);
      var u2 = sinv.mul(r).umod(this.n);
      var p;
      if (!this.curve._maxwellTrick) {
        p = this.g.mulAdd(u1, key.getPublic(), u2);
        if (p.isInfinity())
          return false;
        return p.getX().umod(this.n).cmp(r) === 0;
      }
      p = this.g.jmulAdd(u1, key.getPublic(), u2);
      if (p.isInfinity())
        return false;
      return p.eqXToP(r);
    };
    EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
      assert((3 & j) === j, "The recovery param is more than two bits");
      signature = new Signature(signature, enc);
      var n = this.n;
      var e = new BN(msg);
      var r = signature.r;
      var s = signature.s;
      var isYOdd = j & 1;
      var isSecondKey = j >> 1;
      if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
        throw new Error("Unable to find sencond key candinate");
      if (isSecondKey)
        r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
      else
        r = this.curve.pointFromX(r, isYOdd);
      var rInv = signature.r.invm(n);
      var s1 = n.sub(e).mul(rInv).umod(n);
      var s2 = s.mul(rInv).umod(n);
      return this.g.mulAdd(s1, r, s2);
    };
    EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
      signature = new Signature(signature, enc);
      if (signature.recoveryParam !== null)
        return signature.recoveryParam;
      for (var i = 0; i < 4; i++) {
        var Qprime;
        try {
          Qprime = this.recoverPubKey(e, signature, i);
        } catch (e2) {
          continue;
        }
        if (Qprime.eq(Q))
          return i;
      }
      throw new Error("Unable to find valid recovery factor");
    };
  }
});

// node_modules/elliptic/lib/elliptic/eddsa/key.js
var require_key2 = __commonJS({
  "node_modules/elliptic/lib/elliptic/eddsa/key.js"(exports2, module2) {
    "use strict";
    var utils = require_utils2();
    var assert = utils.assert;
    var parseBytes = utils.parseBytes;
    var cachedProperty = utils.cachedProperty;
    function KeyPair2(eddsa, params) {
      this.eddsa = eddsa;
      this._secret = parseBytes(params.secret);
      if (eddsa.isPoint(params.pub))
        this._pub = params.pub;
      else
        this._pubBytes = parseBytes(params.pub);
    }
    KeyPair2.fromPublic = function fromPublic(eddsa, pub) {
      if (pub instanceof KeyPair2)
        return pub;
      return new KeyPair2(eddsa, { pub });
    };
    KeyPair2.fromSecret = function fromSecret(eddsa, secret) {
      if (secret instanceof KeyPair2)
        return secret;
      return new KeyPair2(eddsa, { secret });
    };
    KeyPair2.prototype.secret = function secret() {
      return this._secret;
    };
    cachedProperty(KeyPair2, "pubBytes", function pubBytes() {
      return this.eddsa.encodePoint(this.pub());
    });
    cachedProperty(KeyPair2, "pub", function pub() {
      if (this._pubBytes)
        return this.eddsa.decodePoint(this._pubBytes);
      return this.eddsa.g.mul(this.priv());
    });
    cachedProperty(KeyPair2, "privBytes", function privBytes() {
      var eddsa = this.eddsa;
      var hash = this.hash();
      var lastIx = eddsa.encodingLength - 1;
      var a = hash.slice(0, eddsa.encodingLength);
      a[0] &= 248;
      a[lastIx] &= 127;
      a[lastIx] |= 64;
      return a;
    });
    cachedProperty(KeyPair2, "priv", function priv() {
      return this.eddsa.decodeInt(this.privBytes());
    });
    cachedProperty(KeyPair2, "hash", function hash() {
      return this.eddsa.hash().update(this.secret()).digest();
    });
    cachedProperty(KeyPair2, "messagePrefix", function messagePrefix() {
      return this.hash().slice(this.eddsa.encodingLength);
    });
    KeyPair2.prototype.sign = function sign(message) {
      assert(this._secret, "KeyPair can only verify");
      return this.eddsa.sign(message, this);
    };
    KeyPair2.prototype.verify = function verify(message, sig) {
      return this.eddsa.verify(message, sig, this);
    };
    KeyPair2.prototype.getSecret = function getSecret(enc) {
      assert(this._secret, "KeyPair is public only");
      return utils.encode(this.secret(), enc);
    };
    KeyPair2.prototype.getPublic = function getPublic(enc) {
      return utils.encode(this.pubBytes(), enc);
    };
    module2.exports = KeyPair2;
  }
});

// node_modules/elliptic/lib/elliptic/eddsa/signature.js
var require_signature2 = __commonJS({
  "node_modules/elliptic/lib/elliptic/eddsa/signature.js"(exports2, module2) {
    "use strict";
    var BN = require_bn2();
    var utils = require_utils2();
    var assert = utils.assert;
    var cachedProperty = utils.cachedProperty;
    var parseBytes = utils.parseBytes;
    function Signature(eddsa, sig) {
      this.eddsa = eddsa;
      if (typeof sig !== "object")
        sig = parseBytes(sig);
      if (Array.isArray(sig)) {
        assert(sig.length === eddsa.encodingLength * 2, "Signature has invalid size");
        sig = {
          R: sig.slice(0, eddsa.encodingLength),
          S: sig.slice(eddsa.encodingLength)
        };
      }
      assert(sig.R && sig.S, "Signature without R or S");
      if (eddsa.isPoint(sig.R))
        this._R = sig.R;
      if (sig.S instanceof BN)
        this._S = sig.S;
      this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
      this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
    }
    cachedProperty(Signature, "S", function S() {
      return this.eddsa.decodeInt(this.Sencoded());
    });
    cachedProperty(Signature, "R", function R() {
      return this.eddsa.decodePoint(this.Rencoded());
    });
    cachedProperty(Signature, "Rencoded", function Rencoded() {
      return this.eddsa.encodePoint(this.R());
    });
    cachedProperty(Signature, "Sencoded", function Sencoded() {
      return this.eddsa.encodeInt(this.S());
    });
    Signature.prototype.toBytes = function toBytes2() {
      return this.Rencoded().concat(this.Sencoded());
    };
    Signature.prototype.toHex = function toHex() {
      return utils.encode(this.toBytes(), "hex").toUpperCase();
    };
    module2.exports = Signature;
  }
});

// node_modules/elliptic/lib/elliptic/eddsa/index.js
var require_eddsa = __commonJS({
  "node_modules/elliptic/lib/elliptic/eddsa/index.js"(exports2, module2) {
    "use strict";
    var hash = require_hash2();
    var curves = require_curves();
    var utils = require_utils2();
    var assert = utils.assert;
    var parseBytes = utils.parseBytes;
    var KeyPair2 = require_key2();
    var Signature = require_signature2();
    function EDDSA(curve) {
      assert(curve === "ed25519", "only tested with ed25519 so far");
      if (!(this instanceof EDDSA))
        return new EDDSA(curve);
      curve = curves[curve].curve;
      this.curve = curve;
      this.g = curve.g;
      this.g.precompute(curve.n.bitLength() + 1);
      this.pointClass = curve.point().constructor;
      this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
      this.hash = hash.sha512;
    }
    module2.exports = EDDSA;
    EDDSA.prototype.sign = function sign(message, secret) {
      message = parseBytes(message);
      var key = this.keyFromSecret(secret);
      var r = this.hashInt(key.messagePrefix(), message);
      var R = this.g.mul(r);
      var Rencoded = this.encodePoint(R);
      var s_ = this.hashInt(Rencoded, key.pubBytes(), message).mul(key.priv());
      var S = r.add(s_).umod(this.curve.n);
      return this.makeSignature({ R, S, Rencoded });
    };
    EDDSA.prototype.verify = function verify(message, sig, pub) {
      message = parseBytes(message);
      sig = this.makeSignature(sig);
      if (sig.S().gte(sig.eddsa.curve.n) || sig.S().isNeg()) {
        return false;
      }
      var key = this.keyFromPublic(pub);
      var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
      var SG = this.g.mul(sig.S());
      var RplusAh = sig.R().add(key.pub().mul(h));
      return RplusAh.eq(SG);
    };
    EDDSA.prototype.hashInt = function hashInt() {
      var hash2 = this.hash();
      for (var i = 0; i < arguments.length; i++)
        hash2.update(arguments[i]);
      return utils.intFromLE(hash2.digest()).umod(this.curve.n);
    };
    EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
      return KeyPair2.fromPublic(this, pub);
    };
    EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
      return KeyPair2.fromSecret(this, secret);
    };
    EDDSA.prototype.makeSignature = function makeSignature(sig) {
      if (sig instanceof Signature)
        return sig;
      return new Signature(this, sig);
    };
    EDDSA.prototype.encodePoint = function encodePoint(point) {
      var enc = point.getY().toArray("le", this.encodingLength);
      enc[this.encodingLength - 1] |= point.getX().isOdd() ? 128 : 0;
      return enc;
    };
    EDDSA.prototype.decodePoint = function decodePoint(bytes) {
      bytes = utils.parseBytes(bytes);
      var lastIx = bytes.length - 1;
      var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~128);
      var xIsOdd = (bytes[lastIx] & 128) !== 0;
      var y = utils.intFromLE(normed);
      return this.curve.pointFromY(y, xIsOdd);
    };
    EDDSA.prototype.encodeInt = function encodeInt(num) {
      return num.toArray("le", this.encodingLength);
    };
    EDDSA.prototype.decodeInt = function decodeInt(bytes) {
      return utils.intFromLE(bytes);
    };
    EDDSA.prototype.isPoint = function isPoint(val) {
      return val instanceof this.pointClass;
    };
  }
});

// node_modules/elliptic/lib/elliptic.js
var require_elliptic = __commonJS({
  "node_modules/elliptic/lib/elliptic.js"(exports2) {
    "use strict";
    var elliptic = exports2;
    elliptic.version = require_package().version;
    elliptic.utils = require_utils2();
    elliptic.rand = require_brorand();
    elliptic.curve = require_curve();
    elliptic.curves = require_curves();
    elliptic.ec = require_ec();
    elliptic.eddsa = require_eddsa();
  }
});

// node_modules/tiny-secp256k1/rfc6979.js
var require_rfc6979 = __commonJS({
  "node_modules/tiny-secp256k1/rfc6979.js"(exports2, module2) {
    var createHmac = require_browser3();
    var ONE1 = Buffer.alloc(1, 1);
    var ZERO1 = Buffer.alloc(1, 0);
    function deterministicGenerateK(hash, x, checkSig, isPrivate, extraEntropy) {
      let k = Buffer.alloc(32, 0);
      let v = Buffer.alloc(32, 1);
      k = createHmac("sha256", k).update(v).update(ZERO1).update(x).update(hash).update(extraEntropy || "").digest();
      v = createHmac("sha256", k).update(v).digest();
      k = createHmac("sha256", k).update(v).update(ONE1).update(x).update(hash).update(extraEntropy || "").digest();
      v = createHmac("sha256", k).update(v).digest();
      v = createHmac("sha256", k).update(v).digest();
      let T = v;
      while (!isPrivate(T) || !checkSig(T)) {
        k = createHmac("sha256", k).update(v).update(ZERO1).digest();
        v = createHmac("sha256", k).update(v).digest();
        v = createHmac("sha256", k).update(v).digest();
        T = v;
      }
      return T;
    }
    module2.exports = deterministicGenerateK;
  }
});

// node_modules/tiny-secp256k1/js.js
var require_js = __commonJS({
  "node_modules/tiny-secp256k1/js.js"(exports2, module2) {
    var BN = require_bn();
    var EC = require_elliptic().ec;
    var secp256k12 = new EC("secp256k1");
    var deterministicGenerateK = require_rfc6979();
    var ZERO32 = Buffer.alloc(32, 0);
    var EC_GROUP_ORDER = Buffer.from("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141", "hex");
    var EC_P = Buffer.from("fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f", "hex");
    var n = secp256k12.curve.n;
    var nDiv2 = n.shrn(1);
    var G = secp256k12.curve.g;
    var THROW_BAD_PRIVATE = "Expected Private";
    var THROW_BAD_POINT = "Expected Point";
    var THROW_BAD_TWEAK = "Expected Tweak";
    var THROW_BAD_HASH = "Expected Hash";
    var THROW_BAD_SIGNATURE = "Expected Signature";
    var THROW_BAD_EXTRA_DATA = "Expected Extra Data (32 bytes)";
    function isScalar(x) {
      return x instanceof Uint8Array && x.length === 32;
    }
    function isOrderScalar(x) {
      if (!isScalar(x)) return false;
      return EC_GROUP_ORDER.compare(x) > 0;
    }
    function isPoint(p) {
      if (!(p instanceof Uint8Array)) return false;
      if (p.length < 33) return false;
      const t = p[0];
      const x = p.subarray(1, 33);
      if (ZERO32.compare(x) === 0) return false;
      if (EC_P.compare(x) <= 0) return false;
      if ((t === 2 || t === 3) && p.length === 33) {
        try {
          decodeFrom(p);
        } catch (e) {
          return false;
        }
        return true;
      }
      const y = p.subarray(33);
      if (ZERO32.compare(y) === 0) return false;
      if (EC_P.compare(y) <= 0) return false;
      if (t === 4 && p.length === 65) return true;
      return false;
    }
    function __isPointCompressed(p) {
      return p[0] !== 4;
    }
    function isPointCompressed(p) {
      if (!isPoint(p)) return false;
      return __isPointCompressed(p);
    }
    function isPrivate(x) {
      if (!isScalar(x)) return false;
      return ZERO32.compare(x) < 0 && // > 0
      EC_GROUP_ORDER.compare(x) > 0;
    }
    function isSignature(value) {
      const r = value.subarray(0, 32);
      const s = value.subarray(32, 64);
      return value instanceof Uint8Array && value.length === 64 && EC_GROUP_ORDER.compare(r) > 0 && EC_GROUP_ORDER.compare(s) > 0;
    }
    function assumeCompression(value, pubkey) {
      if (value === void 0 && pubkey !== void 0) return __isPointCompressed(pubkey);
      if (value === void 0) return true;
      return value;
    }
    function fromBuffer(d) {
      return new BN(d);
    }
    function toBuffer(d) {
      return d.toArrayLike(Buffer, "be", 32);
    }
    function decodeFrom(P) {
      return secp256k12.curve.decodePoint(P);
    }
    function getEncoded(P, compressed) {
      return Buffer.from(P._encode(compressed));
    }
    function pointAdd(pA, pB, __compressed) {
      if (!isPoint(pA)) throw new TypeError(THROW_BAD_POINT);
      if (!isPoint(pB)) throw new TypeError(THROW_BAD_POINT);
      const a = decodeFrom(pA);
      const b2 = decodeFrom(pB);
      const pp = a.add(b2);
      if (pp.isInfinity()) return null;
      const compressed = assumeCompression(__compressed, pA);
      return getEncoded(pp, compressed);
    }
    function pointAddScalar2(p, tweak, __compressed) {
      if (!isPoint(p)) throw new TypeError(THROW_BAD_POINT);
      if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK);
      const compressed = assumeCompression(__compressed, p);
      const pp = decodeFrom(p);
      if (ZERO32.compare(tweak) === 0) return getEncoded(pp, compressed);
      const tt = fromBuffer(tweak);
      const qq = G.mul(tt);
      const uu = pp.add(qq);
      if (uu.isInfinity()) return null;
      return getEncoded(uu, compressed);
    }
    function pointCompress2(p, __compressed) {
      if (!isPoint(p)) throw new TypeError(THROW_BAD_POINT);
      const pp = decodeFrom(p);
      if (pp.isInfinity()) throw new TypeError(THROW_BAD_POINT);
      const compressed = assumeCompression(__compressed, p);
      return getEncoded(pp, compressed);
    }
    function pointFromScalar(d, __compressed) {
      if (!isPrivate(d)) throw new TypeError(THROW_BAD_PRIVATE);
      const dd = fromBuffer(d);
      const pp = G.mul(dd);
      if (pp.isInfinity()) return null;
      const compressed = assumeCompression(__compressed);
      return getEncoded(pp, compressed);
    }
    function pointMultiply(p, tweak, __compressed) {
      if (!isPoint(p)) throw new TypeError(THROW_BAD_POINT);
      if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK);
      const compressed = assumeCompression(__compressed, p);
      const pp = decodeFrom(p);
      const tt = fromBuffer(tweak);
      const qq = pp.mul(tt);
      if (qq.isInfinity()) return null;
      return getEncoded(qq, compressed);
    }
    function privateAdd(d, tweak) {
      if (!isPrivate(d)) throw new TypeError(THROW_BAD_PRIVATE);
      if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK);
      const dd = fromBuffer(d);
      const tt = fromBuffer(tweak);
      const dt = toBuffer(dd.add(tt).umod(n));
      if (!isPrivate(dt)) return null;
      return dt;
    }
    function privateSub(d, tweak) {
      if (!isPrivate(d)) throw new TypeError(THROW_BAD_PRIVATE);
      if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK);
      const dd = fromBuffer(d);
      const tt = fromBuffer(tweak);
      const dt = toBuffer(dd.sub(tt).umod(n));
      if (!isPrivate(dt)) return null;
      return dt;
    }
    function sign(hash, x) {
      return __sign(hash, x);
    }
    function signWithEntropy(hash, x, addData) {
      return __sign(hash, x, addData);
    }
    function __sign(hash, x, addData) {
      if (!isScalar(hash)) throw new TypeError(THROW_BAD_HASH);
      if (!isPrivate(x)) throw new TypeError(THROW_BAD_PRIVATE);
      if (addData !== void 0 && !isScalar(addData)) throw new TypeError(THROW_BAD_EXTRA_DATA);
      const d = fromBuffer(x);
      const e = fromBuffer(hash);
      let r, s;
      const checkSig = function(k) {
        const kI = fromBuffer(k);
        const Q = G.mul(kI);
        if (Q.isInfinity()) return false;
        r = Q.x.umod(n);
        if (r.isZero() === 0) return false;
        s = kI.invm(n).mul(e.add(d.mul(r))).umod(n);
        if (s.isZero() === 0) return false;
        return true;
      };
      deterministicGenerateK(hash, x, checkSig, isPrivate, addData);
      if (s.cmp(nDiv2) > 0) {
        s = n.sub(s);
      }
      const buffer = Buffer.allocUnsafe(64);
      toBuffer(r).copy(buffer, 0);
      toBuffer(s).copy(buffer, 32);
      return buffer;
    }
    function verify(hash, q, signature, strict) {
      if (!isScalar(hash)) throw new TypeError(THROW_BAD_HASH);
      if (!isPoint(q)) throw new TypeError(THROW_BAD_POINT);
      if (!isSignature(signature)) throw new TypeError(THROW_BAD_SIGNATURE);
      const Q = decodeFrom(q);
      const r = fromBuffer(signature.subarray(0, 32));
      const s = fromBuffer(signature.subarray(32, 64));
      if (strict && s.cmp(nDiv2) > 0) {
        return false;
      }
      if (r.gtn(0) <= 0) return false;
      if (s.gtn(0) <= 0) return false;
      const e = fromBuffer(hash);
      const sInv = s.invm(n);
      const u1 = e.mul(sInv).umod(n);
      const u2 = r.mul(sInv).umod(n);
      const R = G.mulAdd(u1, Q, u2);
      if (R.isInfinity()) return false;
      const xR = R.x;
      const v = xR.umod(n);
      return v.eq(r);
    }
    module2.exports = {
      isPoint,
      isPointCompressed,
      isPrivate,
      pointAdd,
      pointAddScalar: pointAddScalar2,
      pointCompress: pointCompress2,
      pointFromScalar,
      pointMultiply,
      privateAdd,
      privateSub,
      sign,
      signWithEntropy,
      verify
    };
  }
});

// node_modules/typeforce/native.js
var require_native = __commonJS({
  "node_modules/typeforce/native.js"(exports2, module2) {
    var types = {
      Array: function(value) {
        return value !== null && value !== void 0 && value.constructor === Array;
      },
      Boolean: function(value) {
        return typeof value === "boolean";
      },
      Function: function(value) {
        return typeof value === "function";
      },
      Nil: function(value) {
        return value === void 0 || value === null;
      },
      Number: function(value) {
        return typeof value === "number";
      },
      Object: function(value) {
        return typeof value === "object";
      },
      String: function(value) {
        return typeof value === "string";
      },
      "": function() {
        return true;
      }
    };
    types.Null = types.Nil;
    for (typeName in types) {
      types[typeName].toJSON = function(t) {
        return t;
      }.bind(null, typeName);
    }
    var typeName;
    module2.exports = types;
  }
});

// node_modules/typeforce/errors.js
var require_errors = __commonJS({
  "node_modules/typeforce/errors.js"(exports2, module2) {
    var native = require_native();
    function getTypeName(fn) {
      return fn.name || fn.toString().match(/function (.*?)\s*\(/)[1];
    }
    function getValueTypeName(value) {
      return native.Nil(value) ? "" : getTypeName(value.constructor);
    }
    function getValue(value) {
      if (native.Function(value)) return "";
      if (native.String(value)) return JSON.stringify(value);
      if (value && native.Object(value)) return "";
      return value;
    }
    function captureStackTrace(e, t) {
      if (Error.captureStackTrace) {
        Error.captureStackTrace(e, t);
      }
    }
    function tfJSON(type) {
      if (native.Function(type)) return type.toJSON ? type.toJSON() : getTypeName(type);
      if (native.Array(type)) return "Array";
      if (type && native.Object(type)) return "Object";
      return type !== void 0 ? type : "";
    }
    function tfErrorString(type, value, valueTypeName) {
      var valueJson = getValue(value);
      return "Expected " + tfJSON(type) + ", got" + (valueTypeName !== "" ? " " + valueTypeName : "") + (valueJson !== "" ? " " + valueJson : "");
    }
    function TfTypeError(type, value, valueTypeName) {
      valueTypeName = valueTypeName || getValueTypeName(value);
      this.message = tfErrorString(type, value, valueTypeName);
      captureStackTrace(this, TfTypeError);
      this.__type = type;
      this.__value = value;
      this.__valueTypeName = valueTypeName;
    }
    TfTypeError.prototype = Object.create(Error.prototype);
    TfTypeError.prototype.constructor = TfTypeError;
    function tfPropertyErrorString(type, label, name, value, valueTypeName) {
      var description = '" of type ';
      if (label === "key") description = '" with key type ';
      return tfErrorString('property "' + tfJSON(name) + description + tfJSON(type), value, valueTypeName);
    }
    function TfPropertyTypeError(type, property, label, value, valueTypeName) {
      if (type) {
        valueTypeName = valueTypeName || getValueTypeName(value);
        this.message = tfPropertyErrorString(type, label, property, value, valueTypeName);
      } else {
        this.message = 'Unexpected property "' + property + '"';
      }
      captureStackTrace(this, TfTypeError);
      this.__label = label;
      this.__property = property;
      this.__type = type;
      this.__value = value;
      this.__valueTypeName = valueTypeName;
    }
    TfPropertyTypeError.prototype = Object.create(Error.prototype);
    TfPropertyTypeError.prototype.constructor = TfTypeError;
    function tfCustomError(expected, actual) {
      return new TfTypeError(expected, {}, actual);
    }
    function tfSubError(e, property, label) {
      if (e instanceof TfPropertyTypeError) {
        property = property + "." + e.__property;
        e = new TfPropertyTypeError(
          e.__type,
          property,
          e.__label,
          e.__value,
          e.__valueTypeName
        );
      } else if (e instanceof TfTypeError) {
        e = new TfPropertyTypeError(
          e.__type,
          property,
          label,
          e.__value,
          e.__valueTypeName
        );
      }
      captureStackTrace(e);
      return e;
    }
    module2.exports = {
      TfTypeError,
      TfPropertyTypeError,
      tfCustomError,
      tfSubError,
      tfJSON,
      getValueTypeName
    };
  }
});

// node_modules/typeforce/extra.js
var require_extra = __commonJS({
  "node_modules/typeforce/extra.js"(exports2, module2) {
    var NATIVE = require_native();
    var ERRORS = require_errors();
    function _Buffer(value) {
      return Buffer.isBuffer(value);
    }
    function Hex(value) {
      return typeof value === "string" && /^([0-9a-f]{2})+$/i.test(value);
    }
    function _LengthN(type, length) {
      var name = type.toJSON();
      function Length(value) {
        if (!type(value)) return false;
        if (value.length === length) return true;
        throw ERRORS.tfCustomError(name + "(Length: " + length + ")", name + "(Length: " + value.length + ")");
      }
      Length.toJSON = function() {
        return name;
      };
      return Length;
    }
    var _ArrayN = _LengthN.bind(null, NATIVE.Array);
    var _BufferN = _LengthN.bind(null, _Buffer);
    var _HexN = _LengthN.bind(null, Hex);
    var _StringN = _LengthN.bind(null, NATIVE.String);
    function Range(a, b2, f) {
      f = f || NATIVE.Number;
      function _range(value, strict) {
        return f(value, strict) && value > a && value < b2;
      }
      _range.toJSON = function() {
        return `${f.toJSON()} between [${a}, ${b2}]`;
      };
      return _range;
    }
    var INT53_MAX = Math.pow(2, 53) - 1;
    function Finite(value) {
      return typeof value === "number" && isFinite(value);
    }
    function Int8(value) {
      return value << 24 >> 24 === value;
    }
    function Int16(value) {
      return value << 16 >> 16 === value;
    }
    function Int32(value) {
      return (value | 0) === value;
    }
    function Int53(value) {
      return typeof value === "number" && value >= -INT53_MAX && value <= INT53_MAX && Math.floor(value) === value;
    }
    function UInt8(value) {
      return (value & 255) === value;
    }
    function UInt16(value) {
      return (value & 65535) === value;
    }
    function UInt32(value) {
      return value >>> 0 === value;
    }
    function UInt53(value) {
      return typeof value === "number" && value >= 0 && value <= INT53_MAX && Math.floor(value) === value;
    }
    var types = {
      ArrayN: _ArrayN,
      Buffer: _Buffer,
      BufferN: _BufferN,
      Finite,
      Hex,
      HexN: _HexN,
      Int8,
      Int16,
      Int32,
      Int53,
      Range,
      StringN: _StringN,
      UInt8,
      UInt16,
      UInt32,
      UInt53
    };
    for (typeName in types) {
      types[typeName].toJSON = function(t) {
        return t;
      }.bind(null, typeName);
    }
    var typeName;
    module2.exports = types;
  }
});

// node_modules/typeforce/index.js
var require_typeforce = __commonJS({
  "node_modules/typeforce/index.js"(exports2, module2) {
    var ERRORS = require_errors();
    var NATIVE = require_native();
    var tfJSON = ERRORS.tfJSON;
    var TfTypeError = ERRORS.TfTypeError;
    var TfPropertyTypeError = ERRORS.TfPropertyTypeError;
    var tfSubError = ERRORS.tfSubError;
    var getValueTypeName = ERRORS.getValueTypeName;
    var TYPES = {
      arrayOf: function arrayOf(type, options) {
        type = compile(type);
        options = options || {};
        function _arrayOf(array, strict) {
          if (!NATIVE.Array(array)) return false;
          if (NATIVE.Nil(array)) return false;
          if (options.minLength !== void 0 && array.length < options.minLength) return false;
          if (options.maxLength !== void 0 && array.length > options.maxLength) return false;
          if (options.length !== void 0 && array.length !== options.length) return false;
          return array.every(function(value, i) {
            try {
              return typeforce(type, value, strict);
            } catch (e) {
              throw tfSubError(e, i);
            }
          });
        }
        _arrayOf.toJSON = function() {
          var str = "[" + tfJSON(type) + "]";
          if (options.length !== void 0) {
            str += "{" + options.length + "}";
          } else if (options.minLength !== void 0 || options.maxLength !== void 0) {
            str += "{" + (options.minLength === void 0 ? 0 : options.minLength) + "," + (options.maxLength === void 0 ? Infinity : options.maxLength) + "}";
          }
          return str;
        };
        return _arrayOf;
      },
      maybe: function maybe(type) {
        type = compile(type);
        function _maybe(value, strict) {
          return NATIVE.Nil(value) || type(value, strict, maybe);
        }
        _maybe.toJSON = function() {
          return "?" + tfJSON(type);
        };
        return _maybe;
      },
      map: function map(propertyType, propertyKeyType) {
        propertyType = compile(propertyType);
        if (propertyKeyType) propertyKeyType = compile(propertyKeyType);
        function _map(value, strict) {
          if (!NATIVE.Object(value)) return false;
          if (NATIVE.Nil(value)) return false;
          for (var propertyName in value) {
            try {
              if (propertyKeyType) {
                typeforce(propertyKeyType, propertyName, strict);
              }
            } catch (e) {
              throw tfSubError(e, propertyName, "key");
            }
            try {
              var propertyValue = value[propertyName];
              typeforce(propertyType, propertyValue, strict);
            } catch (e) {
              throw tfSubError(e, propertyName);
            }
          }
          return true;
        }
        if (propertyKeyType) {
          _map.toJSON = function() {
            return "{" + tfJSON(propertyKeyType) + ": " + tfJSON(propertyType) + "}";
          };
        } else {
          _map.toJSON = function() {
            return "{" + tfJSON(propertyType) + "}";
          };
        }
        return _map;
      },
      object: function object(uncompiled) {
        var type = {};
        for (var typePropertyName in uncompiled) {
          type[typePropertyName] = compile(uncompiled[typePropertyName]);
        }
        function _object(value, strict) {
          if (!NATIVE.Object(value)) return false;
          if (NATIVE.Nil(value)) return false;
          var propertyName;
          try {
            for (propertyName in type) {
              var propertyType = type[propertyName];
              var propertyValue = value[propertyName];
              typeforce(propertyType, propertyValue, strict);
            }
          } catch (e) {
            throw tfSubError(e, propertyName);
          }
          if (strict) {
            for (propertyName in value) {
              if (type[propertyName]) continue;
              throw new TfPropertyTypeError(void 0, propertyName);
            }
          }
          return true;
        }
        _object.toJSON = function() {
          return tfJSON(type);
        };
        return _object;
      },
      anyOf: function anyOf() {
        var types = [].slice.call(arguments).map(compile);
        function _anyOf(value, strict) {
          return types.some(function(type) {
            try {
              return typeforce(type, value, strict);
            } catch (e) {
              return false;
            }
          });
        }
        _anyOf.toJSON = function() {
          return types.map(tfJSON).join("|");
        };
        return _anyOf;
      },
      allOf: function allOf() {
        var types = [].slice.call(arguments).map(compile);
        function _allOf(value, strict) {
          return types.every(function(type) {
            try {
              return typeforce(type, value, strict);
            } catch (e) {
              return false;
            }
          });
        }
        _allOf.toJSON = function() {
          return types.map(tfJSON).join(" & ");
        };
        return _allOf;
      },
      quacksLike: function quacksLike(type) {
        function _quacksLike(value) {
          return type === getValueTypeName(value);
        }
        _quacksLike.toJSON = function() {
          return type;
        };
        return _quacksLike;
      },
      tuple: function tuple() {
        var types = [].slice.call(arguments).map(compile);
        function _tuple(values, strict) {
          if (NATIVE.Nil(values)) return false;
          if (NATIVE.Nil(values.length)) return false;
          if (strict && values.length !== types.length) return false;
          return types.every(function(type, i) {
            try {
              return typeforce(type, values[i], strict);
            } catch (e) {
              throw tfSubError(e, i);
            }
          });
        }
        _tuple.toJSON = function() {
          return "(" + types.map(tfJSON).join(", ") + ")";
        };
        return _tuple;
      },
      value: function value(expected) {
        function _value(actual) {
          return actual === expected;
        }
        _value.toJSON = function() {
          return expected;
        };
        return _value;
      }
    };
    TYPES.oneOf = TYPES.anyOf;
    function compile(type) {
      if (NATIVE.String(type)) {
        if (type[0] === "?") return TYPES.maybe(type.slice(1));
        return NATIVE[type] || TYPES.quacksLike(type);
      } else if (type && NATIVE.Object(type)) {
        if (NATIVE.Array(type)) {
          if (type.length !== 1) throw new TypeError("Expected compile() parameter of type Array of length 1");
          return TYPES.arrayOf(type[0]);
        }
        return TYPES.object(type);
      } else if (NATIVE.Function(type)) {
        return type;
      }
      return TYPES.value(type);
    }
    function typeforce(type, value, strict, surrogate) {
      if (NATIVE.Function(type)) {
        if (type(value, strict)) return true;
        throw new TfTypeError(surrogate || type, value);
      }
      return typeforce(compile(type), value, strict);
    }
    for (typeName in NATIVE) {
      typeforce[typeName] = NATIVE[typeName];
    }
    var typeName;
    for (typeName in TYPES) {
      typeforce[typeName] = TYPES[typeName];
    }
    var EXTRA = require_extra();
    for (typeName in EXTRA) {
      typeforce[typeName] = EXTRA[typeName];
    }
    typeforce.compile = compile;
    typeforce.TfTypeError = TfTypeError;
    typeforce.TfPropertyTypeError = TfPropertyTypeError;
    module2.exports = typeforce;
  }
});

// node_modules/bip32/node_modules/wif/index.js
var require_wif = __commonJS({
  "node_modules/bip32/node_modules/wif/index.js"(exports2, module2) {
    var bs58check2 = require_bs58check();
    function decodeRaw(buffer, version) {
      if (version !== void 0 && buffer[0] !== version) throw new Error("Invalid network version");
      if (buffer.length === 33) {
        return {
          version: buffer[0],
          privateKey: buffer.slice(1, 33),
          compressed: false
        };
      }
      if (buffer.length !== 34) throw new Error("Invalid WIF length");
      if (buffer[33] !== 1) throw new Error("Invalid compression flag");
      return {
        version: buffer[0],
        privateKey: buffer.slice(1, 33),
        compressed: true
      };
    }
    function encodeRaw(version, privateKey, compressed) {
      var result = new Buffer(compressed ? 34 : 33);
      result.writeUInt8(version, 0);
      privateKey.copy(result, 1);
      if (compressed) {
        result[33] = 1;
      }
      return result;
    }
    function decode(string, version) {
      return decodeRaw(bs58check2.decode(string), version);
    }
    function encode(version, privateKey, compressed) {
      if (typeof version === "number") return bs58check2.encode(encodeRaw(version, privateKey, compressed));
      return bs58check2.encode(
        encodeRaw(
          version.version,
          version.privateKey,
          version.compressed
        )
      );
    }
    module2.exports = {
      decode,
      decodeRaw,
      encode,
      encodeRaw
    };
  }
});

// node_modules/bip32/src/bip32.js
var require_bip32 = __commonJS({
  "node_modules/bip32/src/bip32.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var crypto8 = require_crypto();
    var bs58check2 = require_bs58check();
    var ecc = require_js();
    var typeforce = require_typeforce();
    var wif = require_wif();
    var UINT256_TYPE = typeforce.BufferN(32);
    var NETWORK_TYPE = typeforce.compile({
      wif: typeforce.UInt8,
      bip32: {
        public: typeforce.UInt32,
        private: typeforce.UInt32
      }
    });
    var BITCOIN = {
      messagePrefix: "Bitcoin Signed Message:\n",
      bech32: "bc",
      bip32: {
        public: 76067358,
        private: 76066276
      },
      pubKeyHash: 0,
      scriptHash: 5,
      wif: 128
    };
    var HIGHEST_BIT = 2147483648;
    var UINT31_MAX = Math.pow(2, 31) - 1;
    function BIP32Path(value) {
      return typeforce.String(value) && value.match(/^(m\/)?(\d+'?\/)*\d+'?$/) !== null;
    }
    function UInt31(value) {
      return typeforce.UInt32(value) && value <= UINT31_MAX;
    }
    var BIP32 = class {
      constructor(__D, __Q, chainCode, network, __DEPTH = 0, __INDEX = 0, __PARENT_FINGERPRINT = 0) {
        this.__D = __D;
        this.__Q = __Q;
        this.chainCode = chainCode;
        this.network = network;
        this.__DEPTH = __DEPTH;
        this.__INDEX = __INDEX;
        this.__PARENT_FINGERPRINT = __PARENT_FINGERPRINT;
        typeforce(NETWORK_TYPE, network);
        this.lowR = false;
      }
      get depth() {
        return this.__DEPTH;
      }
      get index() {
        return this.__INDEX;
      }
      get parentFingerprint() {
        return this.__PARENT_FINGERPRINT;
      }
      get publicKey() {
        if (this.__Q === void 0)
          this.__Q = ecc.pointFromScalar(this.__D, true);
        return this.__Q;
      }
      get privateKey() {
        return this.__D;
      }
      get identifier() {
        return crypto8.hash160(this.publicKey);
      }
      get fingerprint() {
        return this.identifier.slice(0, 4);
      }
      get compressed() {
        return true;
      }
      // Private === not neutered
      // Public === neutered
      isNeutered() {
        return this.__D === void 0;
      }
      neutered() {
        return fromPublicKeyLocal(this.publicKey, this.chainCode, this.network, this.depth, this.index, this.parentFingerprint);
      }
      toBase58() {
        const network = this.network;
        const version = !this.isNeutered() ? network.bip32.private : network.bip32.public;
        const buffer = Buffer.allocUnsafe(78);
        buffer.writeUInt32BE(version, 0);
        buffer.writeUInt8(this.depth, 4);
        buffer.writeUInt32BE(this.parentFingerprint, 5);
        buffer.writeUInt32BE(this.index, 9);
        this.chainCode.copy(buffer, 13);
        if (!this.isNeutered()) {
          buffer.writeUInt8(0, 45);
          this.privateKey.copy(buffer, 46);
        } else {
          this.publicKey.copy(buffer, 45);
        }
        return bs58check2.encode(buffer);
      }
      toWIF() {
        if (!this.privateKey)
          throw new TypeError("Missing private key");
        return wif.encode(this.network.wif, this.privateKey, true);
      }
      // https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#child-key-derivation-ckd-functions
      derive(index) {
        typeforce(typeforce.UInt32, index);
        const isHardened = index >= HIGHEST_BIT;
        const data = Buffer.allocUnsafe(37);
        if (isHardened) {
          if (this.isNeutered())
            throw new TypeError("Missing private key for hardened child key");
          data[0] = 0;
          this.privateKey.copy(data, 1);
          data.writeUInt32BE(index, 33);
        } else {
          this.publicKey.copy(data, 0);
          data.writeUInt32BE(index, 33);
        }
        const I = crypto8.hmacSHA512(this.chainCode, data);
        const IL = I.slice(0, 32);
        const IR = I.slice(32);
        if (!ecc.isPrivate(IL))
          return this.derive(index + 1);
        let hd;
        if (!this.isNeutered()) {
          const ki = ecc.privateAdd(this.privateKey, IL);
          if (ki == null)
            return this.derive(index + 1);
          hd = fromPrivateKeyLocal(ki, IR, this.network, this.depth + 1, index, this.fingerprint.readUInt32BE(0));
        } else {
          const Ki = ecc.pointAddScalar(this.publicKey, IL, true);
          if (Ki === null)
            return this.derive(index + 1);
          hd = fromPublicKeyLocal(Ki, IR, this.network, this.depth + 1, index, this.fingerprint.readUInt32BE(0));
        }
        return hd;
      }
      deriveHardened(index) {
        typeforce(UInt31, index);
        return this.derive(index + HIGHEST_BIT);
      }
      derivePath(path) {
        typeforce(BIP32Path, path);
        let splitPath = path.split("/");
        if (splitPath[0] === "m") {
          if (this.parentFingerprint)
            throw new TypeError("Expected master, got child");
          splitPath = splitPath.slice(1);
        }
        return splitPath.reduce((prevHd, indexStr) => {
          let index;
          if (indexStr.slice(-1) === `'`) {
            index = parseInt(indexStr.slice(0, -1), 10);
            return prevHd.deriveHardened(index);
          } else {
            index = parseInt(indexStr, 10);
            return prevHd.derive(index);
          }
        }, this);
      }
      sign(hash, lowR) {
        if (!this.privateKey)
          throw new Error("Missing private key");
        if (lowR === void 0)
          lowR = this.lowR;
        if (lowR === false) {
          return ecc.sign(hash, this.privateKey);
        } else {
          let sig = ecc.sign(hash, this.privateKey);
          const extraData = Buffer.alloc(32, 0);
          let counter = 0;
          while (sig[0] > 127) {
            counter++;
            extraData.writeUIntLE(counter, 0, 6);
            sig = ecc.signWithEntropy(hash, this.privateKey, extraData);
          }
          return sig;
        }
      }
      verify(hash, signature) {
        return ecc.verify(hash, this.publicKey, signature);
      }
    };
    function fromBase58(inString, network) {
      const buffer = bs58check2.decode(inString);
      if (buffer.length !== 78)
        throw new TypeError("Invalid buffer length");
      network = network || BITCOIN;
      const version = buffer.readUInt32BE(0);
      if (version !== network.bip32.private && version !== network.bip32.public)
        throw new TypeError("Invalid network version");
      const depth = buffer[4];
      const parentFingerprint = buffer.readUInt32BE(5);
      if (depth === 0) {
        if (parentFingerprint !== 0)
          throw new TypeError("Invalid parent fingerprint");
      }
      const index = buffer.readUInt32BE(9);
      if (depth === 0 && index !== 0)
        throw new TypeError("Invalid index");
      const chainCode = buffer.slice(13, 45);
      let hd;
      if (version === network.bip32.private) {
        if (buffer.readUInt8(45) !== 0)
          throw new TypeError("Invalid private key");
        const k = buffer.slice(46, 78);
        hd = fromPrivateKeyLocal(k, chainCode, network, depth, index, parentFingerprint);
      } else {
        const X = buffer.slice(45, 78);
        hd = fromPublicKeyLocal(X, chainCode, network, depth, index, parentFingerprint);
      }
      return hd;
    }
    exports2.fromBase58 = fromBase58;
    function fromPrivateKey(privateKey, chainCode, network) {
      return fromPrivateKeyLocal(privateKey, chainCode, network);
    }
    exports2.fromPrivateKey = fromPrivateKey;
    function fromPrivateKeyLocal(privateKey, chainCode, network, depth, index, parentFingerprint) {
      typeforce({
        privateKey: UINT256_TYPE,
        chainCode: UINT256_TYPE
      }, { privateKey, chainCode });
      network = network || BITCOIN;
      if (!ecc.isPrivate(privateKey))
        throw new TypeError("Private key not in range [1, n)");
      return new BIP32(privateKey, void 0, chainCode, network, depth, index, parentFingerprint);
    }
    function fromPublicKey(publicKey, chainCode, network) {
      return fromPublicKeyLocal(publicKey, chainCode, network);
    }
    exports2.fromPublicKey = fromPublicKey;
    function fromPublicKeyLocal(publicKey, chainCode, network, depth, index, parentFingerprint) {
      typeforce({
        publicKey: typeforce.BufferN(33),
        chainCode: UINT256_TYPE
      }, { publicKey, chainCode });
      network = network || BITCOIN;
      if (!ecc.isPoint(publicKey))
        throw new TypeError("Point is not on the curve");
      return new BIP32(void 0, publicKey, chainCode, network, depth, index, parentFingerprint);
    }
    function fromSeed(seed, network) {
      typeforce(typeforce.Buffer, seed);
      if (seed.length < 16)
        throw new TypeError("Seed should be at least 128 bits");
      if (seed.length > 64)
        throw new TypeError("Seed should be at most 512 bits");
      network = network || BITCOIN;
      const I = crypto8.hmacSHA512(Buffer.from("Bitcoin seed", "utf8"), seed);
      const IL = I.slice(0, 32);
      const IR = I.slice(32);
      return fromPrivateKey(IL, IR, network);
    }
    exports2.fromSeed = fromSeed;
  }
});

// node_modules/bip32/src/index.js
var require_src2 = __commonJS({
  "node_modules/bip32/src/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var bip32_1 = require_bip32();
    exports2.fromSeed = bip32_1.fromSeed;
    exports2.fromBase58 = bip32_1.fromBase58;
    exports2.fromPublicKey = bip32_1.fromPublicKey;
    exports2.fromPrivateKey = bip32_1.fromPrivateKey;
  }
});

// node_modules/bitcoinjs-lib/src/networks.js
var require_networks = __commonJS({
  "node_modules/bitcoinjs-lib/src/networks.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.bitcoin = {
      messagePrefix: "Bitcoin Signed Message:\n",
      bech32: "bc",
      bip32: {
        public: 76067358,
        private: 76066276
      },
      pubKeyHash: 0,
      scriptHash: 5,
      wif: 128
    };
    exports2.regtest = {
      messagePrefix: "Bitcoin Signed Message:\n",
      bech32: "bcrt",
      bip32: {
        public: 70617039,
        private: 70615956
      },
      pubKeyHash: 111,
      scriptHash: 196,
      wif: 239
    };
    exports2.testnet = {
      messagePrefix: "Bitcoin Signed Message:\n",
      bech32: "tb",
      bip32: {
        public: 70617039,
        private: 70615956
      },
      pubKeyHash: 111,
      scriptHash: 196,
      wif: 239
    };
  }
});

// node_modules/bitcoinjs-lib/src/script_number.js
var require_script_number = __commonJS({
  "node_modules/bitcoinjs-lib/src/script_number.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function decode(buffer, maxLength, minimal) {
      maxLength = maxLength || 4;
      minimal = minimal === void 0 ? true : minimal;
      const length = buffer.length;
      if (length === 0) return 0;
      if (length > maxLength) throw new TypeError("Script number overflow");
      if (minimal) {
        if ((buffer[length - 1] & 127) === 0) {
          if (length <= 1 || (buffer[length - 2] & 128) === 0)
            throw new Error("Non-minimally encoded script number");
        }
      }
      if (length === 5) {
        const a = buffer.readUInt32LE(0);
        const b2 = buffer.readUInt8(4);
        if (b2 & 128) return -((b2 & ~128) * 4294967296 + a);
        return b2 * 4294967296 + a;
      }
      let result = 0;
      for (let i = 0; i < length; ++i) {
        result |= buffer[i] << 8 * i;
      }
      if (buffer[length - 1] & 128)
        return -(result & ~(128 << 8 * (length - 1)));
      return result;
    }
    exports2.decode = decode;
    function scriptNumSize(i) {
      return i > 2147483647 ? 5 : i > 8388607 ? 4 : i > 32767 ? 3 : i > 127 ? 2 : i > 0 ? 1 : 0;
    }
    function encode(_number) {
      let value = Math.abs(_number);
      const size = scriptNumSize(value);
      const buffer = Buffer.allocUnsafe(size);
      const negative = _number < 0;
      for (let i = 0; i < size; ++i) {
        buffer.writeUInt8(value & 255, i);
        value >>= 8;
      }
      if (buffer[size - 1] & 128) {
        buffer.writeUInt8(negative ? 128 : 0, size - 1);
      } else if (negative) {
        buffer[size - 1] |= 128;
      }
      return buffer;
    }
    exports2.encode = encode;
  }
});

// node_modules/bitcoinjs-lib/src/types.js
var require_types = __commonJS({
  "node_modules/bitcoinjs-lib/src/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var typeforce = require_typeforce();
    var UINT31_MAX = Math.pow(2, 31) - 1;
    function UInt31(value) {
      return typeforce.UInt32(value) && value <= UINT31_MAX;
    }
    exports2.UInt31 = UInt31;
    function BIP32Path(value) {
      return typeforce.String(value) && !!value.match(/^(m\/)?(\d+'?\/)*\d+'?$/);
    }
    exports2.BIP32Path = BIP32Path;
    BIP32Path.toJSON = () => {
      return "BIP32 derivation path";
    };
    function Signer(obj) {
      return (typeforce.Buffer(obj.publicKey) || typeof obj.getPublicKey === "function") && typeof obj.sign === "function";
    }
    exports2.Signer = Signer;
    var SATOSHI_MAX = 21 * 1e14;
    function Satoshi(value) {
      return typeforce.UInt53(value) && value <= SATOSHI_MAX;
    }
    exports2.Satoshi = Satoshi;
    exports2.ECPoint = typeforce.quacksLike("Point");
    exports2.Network = typeforce.compile({
      messagePrefix: typeforce.oneOf(typeforce.Buffer, typeforce.String),
      bip32: {
        public: typeforce.UInt32,
        private: typeforce.UInt32
      },
      pubKeyHash: typeforce.UInt8,
      scriptHash: typeforce.UInt8,
      wif: typeforce.UInt8
    });
    exports2.Buffer256bit = typeforce.BufferN(32);
    exports2.Hash160bit = typeforce.BufferN(20);
    exports2.Hash256bit = typeforce.BufferN(32);
    exports2.Number = typeforce.Number;
    exports2.Array = typeforce.Array;
    exports2.Boolean = typeforce.Boolean;
    exports2.String = typeforce.String;
    exports2.Buffer = typeforce.Buffer;
    exports2.Hex = typeforce.Hex;
    exports2.maybe = typeforce.maybe;
    exports2.tuple = typeforce.tuple;
    exports2.UInt8 = typeforce.UInt8;
    exports2.UInt32 = typeforce.UInt32;
    exports2.Function = typeforce.Function;
    exports2.BufferN = typeforce.BufferN;
    exports2.Null = typeforce.Null;
    exports2.oneOf = typeforce.oneOf;
  }
});

// node_modules/bitcoinjs-lib/node_modules/bip66/index.js
var require_bip66 = __commonJS({
  "node_modules/bitcoinjs-lib/node_modules/bip66/index.js"(exports2, module2) {
    var Buffer2 = require_safe_buffer().Buffer;
    function check(buffer) {
      if (buffer.length < 8) return false;
      if (buffer.length > 72) return false;
      if (buffer[0] !== 48) return false;
      if (buffer[1] !== buffer.length - 2) return false;
      if (buffer[2] !== 2) return false;
      var lenR = buffer[3];
      if (lenR === 0) return false;
      if (5 + lenR >= buffer.length) return false;
      if (buffer[4 + lenR] !== 2) return false;
      var lenS = buffer[5 + lenR];
      if (lenS === 0) return false;
      if (6 + lenR + lenS !== buffer.length) return false;
      if (buffer[4] & 128) return false;
      if (lenR > 1 && buffer[4] === 0 && !(buffer[5] & 128)) return false;
      if (buffer[lenR + 6] & 128) return false;
      if (lenS > 1 && buffer[lenR + 6] === 0 && !(buffer[lenR + 7] & 128)) return false;
      return true;
    }
    function decode(buffer) {
      if (buffer.length < 8) throw new Error("DER sequence length is too short");
      if (buffer.length > 72) throw new Error("DER sequence length is too long");
      if (buffer[0] !== 48) throw new Error("Expected DER sequence");
      if (buffer[1] !== buffer.length - 2) throw new Error("DER sequence length is invalid");
      if (buffer[2] !== 2) throw new Error("Expected DER integer");
      var lenR = buffer[3];
      if (lenR === 0) throw new Error("R length is zero");
      if (5 + lenR >= buffer.length) throw new Error("R length is too long");
      if (buffer[4 + lenR] !== 2) throw new Error("Expected DER integer (2)");
      var lenS = buffer[5 + lenR];
      if (lenS === 0) throw new Error("S length is zero");
      if (6 + lenR + lenS !== buffer.length) throw new Error("S length is invalid");
      if (buffer[4] & 128) throw new Error("R value is negative");
      if (lenR > 1 && buffer[4] === 0 && !(buffer[5] & 128)) throw new Error("R value excessively padded");
      if (buffer[lenR + 6] & 128) throw new Error("S value is negative");
      if (lenS > 1 && buffer[lenR + 6] === 0 && !(buffer[lenR + 7] & 128)) throw new Error("S value excessively padded");
      return {
        r: buffer.slice(4, 4 + lenR),
        s: buffer.slice(6 + lenR)
      };
    }
    function encode(r, s) {
      var lenR = r.length;
      var lenS = s.length;
      if (lenR === 0) throw new Error("R length is zero");
      if (lenS === 0) throw new Error("S length is zero");
      if (lenR > 33) throw new Error("R length is too long");
      if (lenS > 33) throw new Error("S length is too long");
      if (r[0] & 128) throw new Error("R value is negative");
      if (s[0] & 128) throw new Error("S value is negative");
      if (lenR > 1 && r[0] === 0 && !(r[1] & 128)) throw new Error("R value excessively padded");
      if (lenS > 1 && s[0] === 0 && !(s[1] & 128)) throw new Error("S value excessively padded");
      var signature = Buffer2.allocUnsafe(6 + lenR + lenS);
      signature[0] = 48;
      signature[1] = signature.length - 2;
      signature[2] = 2;
      signature[3] = r.length;
      r.copy(signature, 4);
      signature[4 + lenR] = 2;
      signature[5 + lenR] = s.length;
      s.copy(signature, 6 + lenR);
      return signature;
    }
    module2.exports = {
      check,
      decode,
      encode
    };
  }
});

// node_modules/bitcoinjs-lib/src/script_signature.js
var require_script_signature = __commonJS({
  "node_modules/bitcoinjs-lib/src/script_signature.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var types = require_types();
    var bip66 = require_bip66();
    var typeforce = require_typeforce();
    var ZERO = Buffer.alloc(1, 0);
    function toDER(x) {
      let i = 0;
      while (x[i] === 0) ++i;
      if (i === x.length) return ZERO;
      x = x.slice(i);
      if (x[0] & 128) return Buffer.concat([ZERO, x], 1 + x.length);
      return x;
    }
    function fromDER(x) {
      if (x[0] === 0) x = x.slice(1);
      const buffer = Buffer.alloc(32, 0);
      const bstart = Math.max(0, 32 - x.length);
      x.copy(buffer, bstart);
      return buffer;
    }
    function decode(buffer) {
      const hashType = buffer.readUInt8(buffer.length - 1);
      const hashTypeMod = hashType & ~128;
      if (hashTypeMod <= 0 || hashTypeMod >= 4)
        throw new Error("Invalid hashType " + hashType);
      const decoded = bip66.decode(buffer.slice(0, -1));
      const r = fromDER(decoded.r);
      const s = fromDER(decoded.s);
      const signature = Buffer.concat([r, s], 64);
      return { signature, hashType };
    }
    exports2.decode = decode;
    function encode(signature, hashType) {
      typeforce(
        {
          signature: types.BufferN(64),
          hashType: types.UInt8
        },
        { signature, hashType }
      );
      const hashTypeMod = hashType & ~128;
      if (hashTypeMod <= 0 || hashTypeMod >= 4)
        throw new Error("Invalid hashType " + hashType);
      const hashTypeBuffer = Buffer.allocUnsafe(1);
      hashTypeBuffer.writeUInt8(hashType, 0);
      const r = toDER(signature.slice(0, 32));
      const s = toDER(signature.slice(32, 64));
      return Buffer.concat([bip66.encode(r, s), hashTypeBuffer]);
    }
    exports2.encode = encode;
  }
});

// node_modules/bitcoin-ops/index.json
var require_bitcoin_ops = __commonJS({
  "node_modules/bitcoin-ops/index.json"(exports2, module2) {
    module2.exports = {
      OP_FALSE: 0,
      OP_0: 0,
      OP_PUSHDATA1: 76,
      OP_PUSHDATA2: 77,
      OP_PUSHDATA4: 78,
      OP_1NEGATE: 79,
      OP_RESERVED: 80,
      OP_TRUE: 81,
      OP_1: 81,
      OP_2: 82,
      OP_3: 83,
      OP_4: 84,
      OP_5: 85,
      OP_6: 86,
      OP_7: 87,
      OP_8: 88,
      OP_9: 89,
      OP_10: 90,
      OP_11: 91,
      OP_12: 92,
      OP_13: 93,
      OP_14: 94,
      OP_15: 95,
      OP_16: 96,
      OP_NOP: 97,
      OP_VER: 98,
      OP_IF: 99,
      OP_NOTIF: 100,
      OP_VERIF: 101,
      OP_VERNOTIF: 102,
      OP_ELSE: 103,
      OP_ENDIF: 104,
      OP_VERIFY: 105,
      OP_RETURN: 106,
      OP_TOALTSTACK: 107,
      OP_FROMALTSTACK: 108,
      OP_2DROP: 109,
      OP_2DUP: 110,
      OP_3DUP: 111,
      OP_2OVER: 112,
      OP_2ROT: 113,
      OP_2SWAP: 114,
      OP_IFDUP: 115,
      OP_DEPTH: 116,
      OP_DROP: 117,
      OP_DUP: 118,
      OP_NIP: 119,
      OP_OVER: 120,
      OP_PICK: 121,
      OP_ROLL: 122,
      OP_ROT: 123,
      OP_SWAP: 124,
      OP_TUCK: 125,
      OP_CAT: 126,
      OP_SUBSTR: 127,
      OP_LEFT: 128,
      OP_RIGHT: 129,
      OP_SIZE: 130,
      OP_INVERT: 131,
      OP_AND: 132,
      OP_OR: 133,
      OP_XOR: 134,
      OP_EQUAL: 135,
      OP_EQUALVERIFY: 136,
      OP_RESERVED1: 137,
      OP_RESERVED2: 138,
      OP_1ADD: 139,
      OP_1SUB: 140,
      OP_2MUL: 141,
      OP_2DIV: 142,
      OP_NEGATE: 143,
      OP_ABS: 144,
      OP_NOT: 145,
      OP_0NOTEQUAL: 146,
      OP_ADD: 147,
      OP_SUB: 148,
      OP_MUL: 149,
      OP_DIV: 150,
      OP_MOD: 151,
      OP_LSHIFT: 152,
      OP_RSHIFT: 153,
      OP_BOOLAND: 154,
      OP_BOOLOR: 155,
      OP_NUMEQUAL: 156,
      OP_NUMEQUALVERIFY: 157,
      OP_NUMNOTEQUAL: 158,
      OP_LESSTHAN: 159,
      OP_GREATERTHAN: 160,
      OP_LESSTHANOREQUAL: 161,
      OP_GREATERTHANOREQUAL: 162,
      OP_MIN: 163,
      OP_MAX: 164,
      OP_WITHIN: 165,
      OP_RIPEMD160: 166,
      OP_SHA1: 167,
      OP_SHA256: 168,
      OP_HASH160: 169,
      OP_HASH256: 170,
      OP_CODESEPARATOR: 171,
      OP_CHECKSIG: 172,
      OP_CHECKSIGVERIFY: 173,
      OP_CHECKMULTISIG: 174,
      OP_CHECKMULTISIGVERIFY: 175,
      OP_NOP1: 176,
      OP_NOP2: 177,
      OP_CHECKLOCKTIMEVERIFY: 177,
      OP_NOP3: 178,
      OP_CHECKSEQUENCEVERIFY: 178,
      OP_NOP4: 179,
      OP_NOP5: 180,
      OP_NOP6: 181,
      OP_NOP7: 182,
      OP_NOP8: 183,
      OP_NOP9: 184,
      OP_NOP10: 185,
      OP_PUBKEYHASH: 253,
      OP_PUBKEY: 254,
      OP_INVALIDOPCODE: 255
    };
  }
});

// node_modules/pushdata-bitcoin/index.js
var require_pushdata_bitcoin = __commonJS({
  "node_modules/pushdata-bitcoin/index.js"(exports2, module2) {
    var OPS = require_bitcoin_ops();
    function encodingLength(i) {
      return i < OPS.OP_PUSHDATA1 ? 1 : i <= 255 ? 2 : i <= 65535 ? 3 : 5;
    }
    function encode(buffer, number, offset) {
      var size = encodingLength(number);
      if (size === 1) {
        buffer.writeUInt8(number, offset);
      } else if (size === 2) {
        buffer.writeUInt8(OPS.OP_PUSHDATA1, offset);
        buffer.writeUInt8(number, offset + 1);
      } else if (size === 3) {
        buffer.writeUInt8(OPS.OP_PUSHDATA2, offset);
        buffer.writeUInt16LE(number, offset + 1);
      } else {
        buffer.writeUInt8(OPS.OP_PUSHDATA4, offset);
        buffer.writeUInt32LE(number, offset + 1);
      }
      return size;
    }
    function decode(buffer, offset) {
      var opcode = buffer.readUInt8(offset);
      var number, size;
      if (opcode < OPS.OP_PUSHDATA1) {
        number = opcode;
        size = 1;
      } else if (opcode === OPS.OP_PUSHDATA1) {
        if (offset + 2 > buffer.length) return null;
        number = buffer.readUInt8(offset + 1);
        size = 2;
      } else if (opcode === OPS.OP_PUSHDATA2) {
        if (offset + 3 > buffer.length) return null;
        number = buffer.readUInt16LE(offset + 1);
        size = 3;
      } else {
        if (offset + 5 > buffer.length) return null;
        if (opcode !== OPS.OP_PUSHDATA4) throw new Error("Unexpected opcode");
        number = buffer.readUInt32LE(offset + 1);
        size = 5;
      }
      return {
        opcode,
        number,
        size
      };
    }
    module2.exports = {
      encodingLength,
      encode,
      decode
    };
  }
});

// node_modules/bitcoin-ops/map.js
var require_map = __commonJS({
  "node_modules/bitcoin-ops/map.js"(exports2, module2) {
    var OPS = require_bitcoin_ops();
    var map = {};
    for (op in OPS) {
      code = OPS[op];
      map[code] = op;
    }
    var code;
    var op;
    module2.exports = map;
  }
});

// node_modules/bitcoinjs-lib/src/script.js
var require_script = __commonJS({
  "node_modules/bitcoinjs-lib/src/script.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var scriptNumber = require_script_number();
    var scriptSignature = require_script_signature();
    var types = require_types();
    var bip66 = require_bip66();
    var ecc = require_js();
    var pushdata = require_pushdata_bitcoin();
    var typeforce = require_typeforce();
    exports2.OPS = require_bitcoin_ops();
    var REVERSE_OPS = require_map();
    var OP_INT_BASE = exports2.OPS.OP_RESERVED;
    function isOPInt(value) {
      return types.Number(value) && (value === exports2.OPS.OP_0 || value >= exports2.OPS.OP_1 && value <= exports2.OPS.OP_16 || value === exports2.OPS.OP_1NEGATE);
    }
    function isPushOnlyChunk(value) {
      return types.Buffer(value) || isOPInt(value);
    }
    function isPushOnly(value) {
      return types.Array(value) && value.every(isPushOnlyChunk);
    }
    exports2.isPushOnly = isPushOnly;
    function asMinimalOP(buffer) {
      if (buffer.length === 0) return exports2.OPS.OP_0;
      if (buffer.length !== 1) return;
      if (buffer[0] >= 1 && buffer[0] <= 16) return OP_INT_BASE + buffer[0];
      if (buffer[0] === 129) return exports2.OPS.OP_1NEGATE;
    }
    function chunksIsBuffer(buf) {
      return Buffer.isBuffer(buf);
    }
    function chunksIsArray(buf) {
      return types.Array(buf);
    }
    function singleChunkIsBuffer(buf) {
      return Buffer.isBuffer(buf);
    }
    function compile(chunks) {
      if (chunksIsBuffer(chunks)) return chunks;
      typeforce(types.Array, chunks);
      const bufferSize = chunks.reduce((accum, chunk) => {
        if (singleChunkIsBuffer(chunk)) {
          if (chunk.length === 1 && asMinimalOP(chunk) !== void 0) {
            return accum + 1;
          }
          return accum + pushdata.encodingLength(chunk.length) + chunk.length;
        }
        return accum + 1;
      }, 0);
      const buffer = Buffer.allocUnsafe(bufferSize);
      let offset = 0;
      chunks.forEach((chunk) => {
        if (singleChunkIsBuffer(chunk)) {
          const opcode = asMinimalOP(chunk);
          if (opcode !== void 0) {
            buffer.writeUInt8(opcode, offset);
            offset += 1;
            return;
          }
          offset += pushdata.encode(buffer, chunk.length, offset);
          chunk.copy(buffer, offset);
          offset += chunk.length;
        } else {
          buffer.writeUInt8(chunk, offset);
          offset += 1;
        }
      });
      if (offset !== buffer.length) throw new Error("Could not decode chunks");
      return buffer;
    }
    exports2.compile = compile;
    function decompile(buffer) {
      if (chunksIsArray(buffer)) return buffer;
      typeforce(types.Buffer, buffer);
      const chunks = [];
      let i = 0;
      while (i < buffer.length) {
        const opcode = buffer[i];
        if (opcode > exports2.OPS.OP_0 && opcode <= exports2.OPS.OP_PUSHDATA4) {
          const d = pushdata.decode(buffer, i);
          if (d === null) return null;
          i += d.size;
          if (i + d.number > buffer.length) return null;
          const data = buffer.slice(i, i + d.number);
          i += d.number;
          const op = asMinimalOP(data);
          if (op !== void 0) {
            chunks.push(op);
          } else {
            chunks.push(data);
          }
        } else {
          chunks.push(opcode);
          i += 1;
        }
      }
      return chunks;
    }
    exports2.decompile = decompile;
    function toASM(chunks) {
      if (chunksIsBuffer(chunks)) {
        chunks = decompile(chunks);
      }
      return chunks.map((chunk) => {
        if (singleChunkIsBuffer(chunk)) {
          const op = asMinimalOP(chunk);
          if (op === void 0) return chunk.toString("hex");
          chunk = op;
        }
        return REVERSE_OPS[chunk];
      }).join(" ");
    }
    exports2.toASM = toASM;
    function fromASM(asm) {
      typeforce(types.String, asm);
      return compile(
        asm.split(" ").map((chunkStr) => {
          if (exports2.OPS[chunkStr] !== void 0) return exports2.OPS[chunkStr];
          typeforce(types.Hex, chunkStr);
          return Buffer.from(chunkStr, "hex");
        })
      );
    }
    exports2.fromASM = fromASM;
    function toStack(chunks) {
      chunks = decompile(chunks);
      typeforce(isPushOnly, chunks);
      return chunks.map((op) => {
        if (singleChunkIsBuffer(op)) return op;
        if (op === exports2.OPS.OP_0) return Buffer.allocUnsafe(0);
        return scriptNumber.encode(op - OP_INT_BASE);
      });
    }
    exports2.toStack = toStack;
    function isCanonicalPubKey(buffer) {
      return ecc.isPoint(buffer);
    }
    exports2.isCanonicalPubKey = isCanonicalPubKey;
    function isDefinedHashType(hashType) {
      const hashTypeMod = hashType & ~128;
      return hashTypeMod > 0 && hashTypeMod < 4;
    }
    exports2.isDefinedHashType = isDefinedHashType;
    function isCanonicalScriptSignature(buffer) {
      if (!Buffer.isBuffer(buffer)) return false;
      if (!isDefinedHashType(buffer[buffer.length - 1])) return false;
      return bip66.check(buffer.slice(0, -1));
    }
    exports2.isCanonicalScriptSignature = isCanonicalScriptSignature;
    exports2.number = scriptNumber;
    exports2.signature = scriptSignature;
  }
});

// node_modules/bitcoinjs-lib/src/payments/lazy.js
var require_lazy = __commonJS({
  "node_modules/bitcoinjs-lib/src/payments/lazy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function prop(object, name, f) {
      Object.defineProperty(object, name, {
        configurable: true,
        enumerable: true,
        get() {
          const _value = f.call(this);
          this[name] = _value;
          return _value;
        },
        set(_value) {
          Object.defineProperty(this, name, {
            configurable: true,
            enumerable: true,
            value: _value,
            writable: true
          });
        }
      });
    }
    exports2.prop = prop;
    function value(f) {
      let _value;
      return () => {
        if (_value !== void 0) return _value;
        _value = f();
        return _value;
      };
    }
    exports2.value = value;
  }
});

// node_modules/bitcoinjs-lib/src/payments/embed.js
var require_embed = __commonJS({
  "node_modules/bitcoinjs-lib/src/payments/embed.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var networks_1 = require_networks();
    var bscript = require_script();
    var lazy = require_lazy();
    var typef = require_typeforce();
    var OPS = bscript.OPS;
    function stacksEqual(a, b2) {
      if (a.length !== b2.length) return false;
      return a.every((x, i) => {
        return x.equals(b2[i]);
      });
    }
    function p2data(a, opts) {
      if (!a.data && !a.output) throw new TypeError("Not enough data");
      opts = Object.assign({ validate: true }, opts || {});
      typef(
        {
          network: typef.maybe(typef.Object),
          output: typef.maybe(typef.Buffer),
          data: typef.maybe(typef.arrayOf(typef.Buffer))
        },
        a
      );
      const network = a.network || networks_1.bitcoin;
      const o = { name: "embed", network };
      lazy.prop(o, "output", () => {
        if (!a.data) return;
        return bscript.compile([OPS.OP_RETURN].concat(a.data));
      });
      lazy.prop(o, "data", () => {
        if (!a.output) return;
        return bscript.decompile(a.output).slice(1);
      });
      if (opts.validate) {
        if (a.output) {
          const chunks = bscript.decompile(a.output);
          if (chunks[0] !== OPS.OP_RETURN) throw new TypeError("Output is invalid");
          if (!chunks.slice(1).every(typef.Buffer))
            throw new TypeError("Output is invalid");
          if (a.data && !stacksEqual(a.data, o.data))
            throw new TypeError("Data mismatch");
        }
      }
      return Object.assign(o, a);
    }
    exports2.p2data = p2data;
  }
});

// node_modules/bitcoinjs-lib/src/payments/p2ms.js
var require_p2ms = __commonJS({
  "node_modules/bitcoinjs-lib/src/payments/p2ms.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var networks_1 = require_networks();
    var bscript = require_script();
    var lazy = require_lazy();
    var OPS = bscript.OPS;
    var typef = require_typeforce();
    var ecc = require_js();
    var OP_INT_BASE = OPS.OP_RESERVED;
    function stacksEqual(a, b2) {
      if (a.length !== b2.length) return false;
      return a.every((x, i) => {
        return x.equals(b2[i]);
      });
    }
    function p2ms(a, opts) {
      if (!a.input && !a.output && !(a.pubkeys && a.m !== void 0) && !a.signatures)
        throw new TypeError("Not enough data");
      opts = Object.assign({ validate: true }, opts || {});
      function isAcceptableSignature(x) {
        return bscript.isCanonicalScriptSignature(x) || (opts.allowIncomplete && x === OPS.OP_0) !== void 0;
      }
      typef(
        {
          network: typef.maybe(typef.Object),
          m: typef.maybe(typef.Number),
          n: typef.maybe(typef.Number),
          output: typef.maybe(typef.Buffer),
          pubkeys: typef.maybe(typef.arrayOf(ecc.isPoint)),
          signatures: typef.maybe(typef.arrayOf(isAcceptableSignature)),
          input: typef.maybe(typef.Buffer)
        },
        a
      );
      const network = a.network || networks_1.bitcoin;
      const o = { network };
      let chunks = [];
      let decoded = false;
      function decode(output) {
        if (decoded) return;
        decoded = true;
        chunks = bscript.decompile(output);
        o.m = chunks[0] - OP_INT_BASE;
        o.n = chunks[chunks.length - 2] - OP_INT_BASE;
        o.pubkeys = chunks.slice(1, -2);
      }
      lazy.prop(o, "output", () => {
        if (!a.m) return;
        if (!o.n) return;
        if (!a.pubkeys) return;
        return bscript.compile(
          [].concat(
            OP_INT_BASE + a.m,
            a.pubkeys,
            OP_INT_BASE + o.n,
            OPS.OP_CHECKMULTISIG
          )
        );
      });
      lazy.prop(o, "m", () => {
        if (!o.output) return;
        decode(o.output);
        return o.m;
      });
      lazy.prop(o, "n", () => {
        if (!o.pubkeys) return;
        return o.pubkeys.length;
      });
      lazy.prop(o, "pubkeys", () => {
        if (!a.output) return;
        decode(a.output);
        return o.pubkeys;
      });
      lazy.prop(o, "signatures", () => {
        if (!a.input) return;
        return bscript.decompile(a.input).slice(1);
      });
      lazy.prop(o, "input", () => {
        if (!a.signatures) return;
        return bscript.compile([OPS.OP_0].concat(a.signatures));
      });
      lazy.prop(o, "witness", () => {
        if (!o.input) return;
        return [];
      });
      lazy.prop(o, "name", () => {
        if (!o.m || !o.n) return;
        return `p2ms(${o.m} of ${o.n})`;
      });
      if (opts.validate) {
        if (a.output) {
          decode(a.output);
          if (!typef.Number(chunks[0])) throw new TypeError("Output is invalid");
          if (!typef.Number(chunks[chunks.length - 2]))
            throw new TypeError("Output is invalid");
          if (chunks[chunks.length - 1] !== OPS.OP_CHECKMULTISIG)
            throw new TypeError("Output is invalid");
          if (o.m <= 0 || o.n > 16 || o.m > o.n || o.n !== chunks.length - 3)
            throw new TypeError("Output is invalid");
          if (!o.pubkeys.every((x) => ecc.isPoint(x)))
            throw new TypeError("Output is invalid");
          if (a.m !== void 0 && a.m !== o.m) throw new TypeError("m mismatch");
          if (a.n !== void 0 && a.n !== o.n) throw new TypeError("n mismatch");
          if (a.pubkeys && !stacksEqual(a.pubkeys, o.pubkeys))
            throw new TypeError("Pubkeys mismatch");
        }
        if (a.pubkeys) {
          if (a.n !== void 0 && a.n !== a.pubkeys.length)
            throw new TypeError("Pubkey count mismatch");
          o.n = a.pubkeys.length;
          if (o.n < o.m) throw new TypeError("Pubkey count cannot be less than m");
        }
        if (a.signatures) {
          if (a.signatures.length < o.m)
            throw new TypeError("Not enough signatures provided");
          if (a.signatures.length > o.m)
            throw new TypeError("Too many signatures provided");
        }
        if (a.input) {
          if (a.input[0] !== OPS.OP_0) throw new TypeError("Input is invalid");
          if (o.signatures.length === 0 || !o.signatures.every(isAcceptableSignature))
            throw new TypeError("Input has invalid signature(s)");
          if (a.signatures && !stacksEqual(a.signatures, o.signatures))
            throw new TypeError("Signature mismatch");
          if (a.m !== void 0 && a.m !== a.signatures.length)
            throw new TypeError("Signature count mismatch");
        }
      }
      return Object.assign(o, a);
    }
    exports2.p2ms = p2ms;
  }
});

// node_modules/bitcoinjs-lib/src/payments/p2pk.js
var require_p2pk = __commonJS({
  "node_modules/bitcoinjs-lib/src/payments/p2pk.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var networks_1 = require_networks();
    var bscript = require_script();
    var lazy = require_lazy();
    var typef = require_typeforce();
    var OPS = bscript.OPS;
    var ecc = require_js();
    function p2pk(a, opts) {
      if (!a.input && !a.output && !a.pubkey && !a.input && !a.signature)
        throw new TypeError("Not enough data");
      opts = Object.assign({ validate: true }, opts || {});
      typef(
        {
          network: typef.maybe(typef.Object),
          output: typef.maybe(typef.Buffer),
          pubkey: typef.maybe(ecc.isPoint),
          signature: typef.maybe(bscript.isCanonicalScriptSignature),
          input: typef.maybe(typef.Buffer)
        },
        a
      );
      const _chunks = lazy.value(() => {
        return bscript.decompile(a.input);
      });
      const network = a.network || networks_1.bitcoin;
      const o = { name: "p2pk", network };
      lazy.prop(o, "output", () => {
        if (!a.pubkey) return;
        return bscript.compile([a.pubkey, OPS.OP_CHECKSIG]);
      });
      lazy.prop(o, "pubkey", () => {
        if (!a.output) return;
        return a.output.slice(1, -1);
      });
      lazy.prop(o, "signature", () => {
        if (!a.input) return;
        return _chunks()[0];
      });
      lazy.prop(o, "input", () => {
        if (!a.signature) return;
        return bscript.compile([a.signature]);
      });
      lazy.prop(o, "witness", () => {
        if (!o.input) return;
        return [];
      });
      if (opts.validate) {
        if (a.output) {
          if (a.output[a.output.length - 1] !== OPS.OP_CHECKSIG)
            throw new TypeError("Output is invalid");
          if (!ecc.isPoint(o.pubkey))
            throw new TypeError("Output pubkey is invalid");
          if (a.pubkey && !a.pubkey.equals(o.pubkey))
            throw new TypeError("Pubkey mismatch");
        }
        if (a.signature) {
          if (a.input && !a.input.equals(o.input))
            throw new TypeError("Signature mismatch");
        }
        if (a.input) {
          if (_chunks().length !== 1) throw new TypeError("Input is invalid");
          if (!bscript.isCanonicalScriptSignature(o.signature))
            throw new TypeError("Input has invalid signature");
        }
      }
      return Object.assign(o, a);
    }
    exports2.p2pk = p2pk;
  }
});

// node_modules/bitcoinjs-lib/src/crypto.js
var require_crypto3 = __commonJS({
  "node_modules/bitcoinjs-lib/src/crypto.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var createHash = require_browser2();
    function ripemd1604(buffer) {
      try {
        return createHash("rmd160").update(buffer).digest();
      } catch (err) {
        return createHash("ripemd160").update(buffer).digest();
      }
    }
    exports2.ripemd160 = ripemd1604;
    function sha1(buffer) {
      return createHash("sha1").update(buffer).digest();
    }
    exports2.sha1 = sha1;
    function sha2564(buffer) {
      return createHash("sha256").update(buffer).digest();
    }
    exports2.sha256 = sha2564;
    function hash1602(buffer) {
      return ripemd1604(sha2564(buffer));
    }
    exports2.hash160 = hash1602;
    function hash2562(buffer) {
      return sha2564(sha2564(buffer));
    }
    exports2.hash256 = hash2562;
  }
});

// node_modules/bitcoinjs-lib/src/payments/p2pkh.js
var require_p2pkh = __commonJS({
  "node_modules/bitcoinjs-lib/src/payments/p2pkh.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var bcrypto = require_crypto3();
    var networks_1 = require_networks();
    var bscript = require_script();
    var lazy = require_lazy();
    var typef = require_typeforce();
    var OPS = bscript.OPS;
    var ecc = require_js();
    var bs58check2 = require_bs58check();
    function p2pkh2(a, opts) {
      if (!a.address && !a.hash && !a.output && !a.pubkey && !a.input)
        throw new TypeError("Not enough data");
      opts = Object.assign({ validate: true }, opts || {});
      typef(
        {
          network: typef.maybe(typef.Object),
          address: typef.maybe(typef.String),
          hash: typef.maybe(typef.BufferN(20)),
          output: typef.maybe(typef.BufferN(25)),
          pubkey: typef.maybe(ecc.isPoint),
          signature: typef.maybe(bscript.isCanonicalScriptSignature),
          input: typef.maybe(typef.Buffer)
        },
        a
      );
      const _address = lazy.value(() => {
        const payload = bs58check2.decode(a.address);
        const version = payload.readUInt8(0);
        const hash = payload.slice(1);
        return { version, hash };
      });
      const _chunks = lazy.value(() => {
        return bscript.decompile(a.input);
      });
      const network = a.network || networks_1.bitcoin;
      const o = { name: "p2pkh", network };
      lazy.prop(o, "address", () => {
        if (!o.hash) return;
        const payload = Buffer.allocUnsafe(21);
        payload.writeUInt8(network.pubKeyHash, 0);
        o.hash.copy(payload, 1);
        return bs58check2.encode(payload);
      });
      lazy.prop(o, "hash", () => {
        if (a.output) return a.output.slice(3, 23);
        if (a.address) return _address().hash;
        if (a.pubkey || o.pubkey) return bcrypto.hash160(a.pubkey || o.pubkey);
      });
      lazy.prop(o, "output", () => {
        if (!o.hash) return;
        return bscript.compile([
          OPS.OP_DUP,
          OPS.OP_HASH160,
          o.hash,
          OPS.OP_EQUALVERIFY,
          OPS.OP_CHECKSIG
        ]);
      });
      lazy.prop(o, "pubkey", () => {
        if (!a.input) return;
        return _chunks()[1];
      });
      lazy.prop(o, "signature", () => {
        if (!a.input) return;
        return _chunks()[0];
      });
      lazy.prop(o, "input", () => {
        if (!a.pubkey) return;
        if (!a.signature) return;
        return bscript.compile([a.signature, a.pubkey]);
      });
      lazy.prop(o, "witness", () => {
        if (!o.input) return;
        return [];
      });
      if (opts.validate) {
        let hash = Buffer.from([]);
        if (a.address) {
          if (_address().version !== network.pubKeyHash)
            throw new TypeError("Invalid version or Network mismatch");
          if (_address().hash.length !== 20) throw new TypeError("Invalid address");
          hash = _address().hash;
        }
        if (a.hash) {
          if (hash.length > 0 && !hash.equals(a.hash))
            throw new TypeError("Hash mismatch");
          else hash = a.hash;
        }
        if (a.output) {
          if (a.output.length !== 25 || a.output[0] !== OPS.OP_DUP || a.output[1] !== OPS.OP_HASH160 || a.output[2] !== 20 || a.output[23] !== OPS.OP_EQUALVERIFY || a.output[24] !== OPS.OP_CHECKSIG)
            throw new TypeError("Output is invalid");
          const hash2 = a.output.slice(3, 23);
          if (hash.length > 0 && !hash.equals(hash2))
            throw new TypeError("Hash mismatch");
          else hash = hash2;
        }
        if (a.pubkey) {
          const pkh = bcrypto.hash160(a.pubkey);
          if (hash.length > 0 && !hash.equals(pkh))
            throw new TypeError("Hash mismatch");
          else hash = pkh;
        }
        if (a.input) {
          const chunks = _chunks();
          if (chunks.length !== 2) throw new TypeError("Input is invalid");
          if (!bscript.isCanonicalScriptSignature(chunks[0]))
            throw new TypeError("Input has invalid signature");
          if (!ecc.isPoint(chunks[1]))
            throw new TypeError("Input has invalid pubkey");
          if (a.signature && !a.signature.equals(chunks[0]))
            throw new TypeError("Signature mismatch");
          if (a.pubkey && !a.pubkey.equals(chunks[1]))
            throw new TypeError("Pubkey mismatch");
          const pkh = bcrypto.hash160(chunks[1]);
          if (hash.length > 0 && !hash.equals(pkh))
            throw new TypeError("Hash mismatch");
        }
      }
      return Object.assign(o, a);
    }
    exports2.p2pkh = p2pkh2;
  }
});

// node_modules/bitcoinjs-lib/src/payments/p2sh.js
var require_p2sh = __commonJS({
  "node_modules/bitcoinjs-lib/src/payments/p2sh.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var bcrypto = require_crypto3();
    var networks_1 = require_networks();
    var bscript = require_script();
    var lazy = require_lazy();
    var typef = require_typeforce();
    var OPS = bscript.OPS;
    var bs58check2 = require_bs58check();
    function stacksEqual(a, b2) {
      if (a.length !== b2.length) return false;
      return a.every((x, i) => {
        return x.equals(b2[i]);
      });
    }
    function p2sh(a, opts) {
      if (!a.address && !a.hash && !a.output && !a.redeem && !a.input)
        throw new TypeError("Not enough data");
      opts = Object.assign({ validate: true }, opts || {});
      typef(
        {
          network: typef.maybe(typef.Object),
          address: typef.maybe(typef.String),
          hash: typef.maybe(typef.BufferN(20)),
          output: typef.maybe(typef.BufferN(23)),
          redeem: typef.maybe({
            network: typef.maybe(typef.Object),
            output: typef.maybe(typef.Buffer),
            input: typef.maybe(typef.Buffer),
            witness: typef.maybe(typef.arrayOf(typef.Buffer))
          }),
          input: typef.maybe(typef.Buffer),
          witness: typef.maybe(typef.arrayOf(typef.Buffer))
        },
        a
      );
      let network = a.network;
      if (!network) {
        network = a.redeem && a.redeem.network || networks_1.bitcoin;
      }
      const o = { network };
      const _address = lazy.value(() => {
        const payload = bs58check2.decode(a.address);
        const version = payload.readUInt8(0);
        const hash = payload.slice(1);
        return { version, hash };
      });
      const _chunks = lazy.value(() => {
        return bscript.decompile(a.input);
      });
      const _redeem = lazy.value(() => {
        const chunks = _chunks();
        return {
          network,
          output: chunks[chunks.length - 1],
          input: bscript.compile(chunks.slice(0, -1)),
          witness: a.witness || []
        };
      });
      lazy.prop(o, "address", () => {
        if (!o.hash) return;
        const payload = Buffer.allocUnsafe(21);
        payload.writeUInt8(o.network.scriptHash, 0);
        o.hash.copy(payload, 1);
        return bs58check2.encode(payload);
      });
      lazy.prop(o, "hash", () => {
        if (a.output) return a.output.slice(2, 22);
        if (a.address) return _address().hash;
        if (o.redeem && o.redeem.output) return bcrypto.hash160(o.redeem.output);
      });
      lazy.prop(o, "output", () => {
        if (!o.hash) return;
        return bscript.compile([OPS.OP_HASH160, o.hash, OPS.OP_EQUAL]);
      });
      lazy.prop(o, "redeem", () => {
        if (!a.input) return;
        return _redeem();
      });
      lazy.prop(o, "input", () => {
        if (!a.redeem || !a.redeem.input || !a.redeem.output) return;
        return bscript.compile(
          [].concat(bscript.decompile(a.redeem.input), a.redeem.output)
        );
      });
      lazy.prop(o, "witness", () => {
        if (o.redeem && o.redeem.witness) return o.redeem.witness;
        if (o.input) return [];
      });
      lazy.prop(o, "name", () => {
        const nameParts = ["p2sh"];
        if (o.redeem !== void 0) nameParts.push(o.redeem.name);
        return nameParts.join("-");
      });
      if (opts.validate) {
        let hash = Buffer.from([]);
        if (a.address) {
          if (_address().version !== network.scriptHash)
            throw new TypeError("Invalid version or Network mismatch");
          if (_address().hash.length !== 20) throw new TypeError("Invalid address");
          hash = _address().hash;
        }
        if (a.hash) {
          if (hash.length > 0 && !hash.equals(a.hash))
            throw new TypeError("Hash mismatch");
          else hash = a.hash;
        }
        if (a.output) {
          if (a.output.length !== 23 || a.output[0] !== OPS.OP_HASH160 || a.output[1] !== 20 || a.output[22] !== OPS.OP_EQUAL)
            throw new TypeError("Output is invalid");
          const hash2 = a.output.slice(2, 22);
          if (hash.length > 0 && !hash.equals(hash2))
            throw new TypeError("Hash mismatch");
          else hash = hash2;
        }
        const checkRedeem = (redeem) => {
          if (redeem.output) {
            const decompile = bscript.decompile(redeem.output);
            if (!decompile || decompile.length < 1)
              throw new TypeError("Redeem.output too short");
            const hash2 = bcrypto.hash160(redeem.output);
            if (hash.length > 0 && !hash.equals(hash2))
              throw new TypeError("Hash mismatch");
            else hash = hash2;
          }
          if (redeem.input) {
            const hasInput = redeem.input.length > 0;
            const hasWitness = redeem.witness && redeem.witness.length > 0;
            if (!hasInput && !hasWitness) throw new TypeError("Empty input");
            if (hasInput && hasWitness)
              throw new TypeError("Input and witness provided");
            if (hasInput) {
              const richunks = bscript.decompile(redeem.input);
              if (!bscript.isPushOnly(richunks))
                throw new TypeError("Non push-only scriptSig");
            }
          }
        };
        if (a.input) {
          const chunks = _chunks();
          if (!chunks || chunks.length < 1) throw new TypeError("Input too short");
          if (!Buffer.isBuffer(_redeem().output))
            throw new TypeError("Input is invalid");
          checkRedeem(_redeem());
        }
        if (a.redeem) {
          if (a.redeem.network && a.redeem.network !== network)
            throw new TypeError("Network mismatch");
          if (a.input) {
            const redeem = _redeem();
            if (a.redeem.output && !a.redeem.output.equals(redeem.output))
              throw new TypeError("Redeem.output mismatch");
            if (a.redeem.input && !a.redeem.input.equals(redeem.input))
              throw new TypeError("Redeem.input mismatch");
          }
          checkRedeem(a.redeem);
        }
        if (a.witness) {
          if (a.redeem && a.redeem.witness && !stacksEqual(a.redeem.witness, a.witness))
            throw new TypeError("Witness and redeem.witness mismatch");
        }
      }
      return Object.assign(o, a);
    }
    exports2.p2sh = p2sh;
  }
});

// node_modules/bitcoinjs-lib/node_modules/bech32/index.js
var require_bech32 = __commonJS({
  "node_modules/bitcoinjs-lib/node_modules/bech32/index.js"(exports2, module2) {
    "use strict";
    var ALPHABET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
    var ALPHABET_MAP = {};
    for (z = 0; z < ALPHABET.length; z++) {
      x = ALPHABET.charAt(z);
      if (ALPHABET_MAP[x] !== void 0) throw new TypeError(x + " is ambiguous");
      ALPHABET_MAP[x] = z;
    }
    var x;
    var z;
    function polymodStep(pre) {
      var b2 = pre >> 25;
      return (pre & 33554431) << 5 ^ -(b2 >> 0 & 1) & 996825010 ^ -(b2 >> 1 & 1) & 642813549 ^ -(b2 >> 2 & 1) & 513874426 ^ -(b2 >> 3 & 1) & 1027748829 ^ -(b2 >> 4 & 1) & 705979059;
    }
    function prefixChk(prefix) {
      var chk = 1;
      for (var i = 0; i < prefix.length; ++i) {
        var c = prefix.charCodeAt(i);
        if (c < 33 || c > 126) return "Invalid prefix (" + prefix + ")";
        chk = polymodStep(chk) ^ c >> 5;
      }
      chk = polymodStep(chk);
      for (i = 0; i < prefix.length; ++i) {
        var v = prefix.charCodeAt(i);
        chk = polymodStep(chk) ^ v & 31;
      }
      return chk;
    }
    function encode(prefix, words, LIMIT) {
      LIMIT = LIMIT || 90;
      if (prefix.length + 7 + words.length > LIMIT) throw new TypeError("Exceeds length limit");
      prefix = prefix.toLowerCase();
      var chk = prefixChk(prefix);
      if (typeof chk === "string") throw new Error(chk);
      var result = prefix + "1";
      for (var i = 0; i < words.length; ++i) {
        var x2 = words[i];
        if (x2 >> 5 !== 0) throw new Error("Non 5-bit word");
        chk = polymodStep(chk) ^ x2;
        result += ALPHABET.charAt(x2);
      }
      for (i = 0; i < 6; ++i) {
        chk = polymodStep(chk);
      }
      chk ^= 1;
      for (i = 0; i < 6; ++i) {
        var v = chk >> (5 - i) * 5 & 31;
        result += ALPHABET.charAt(v);
      }
      return result;
    }
    function __decode(str, LIMIT) {
      LIMIT = LIMIT || 90;
      if (str.length < 8) return str + " too short";
      if (str.length > LIMIT) return "Exceeds length limit";
      var lowered = str.toLowerCase();
      var uppered = str.toUpperCase();
      if (str !== lowered && str !== uppered) return "Mixed-case string " + str;
      str = lowered;
      var split = str.lastIndexOf("1");
      if (split === -1) return "No separator character for " + str;
      if (split === 0) return "Missing prefix for " + str;
      var prefix = str.slice(0, split);
      var wordChars = str.slice(split + 1);
      if (wordChars.length < 6) return "Data too short";
      var chk = prefixChk(prefix);
      if (typeof chk === "string") return chk;
      var words = [];
      for (var i = 0; i < wordChars.length; ++i) {
        var c = wordChars.charAt(i);
        var v = ALPHABET_MAP[c];
        if (v === void 0) return "Unknown character " + c;
        chk = polymodStep(chk) ^ v;
        if (i + 6 >= wordChars.length) continue;
        words.push(v);
      }
      if (chk !== 1) return "Invalid checksum for " + str;
      return { prefix, words };
    }
    function decodeUnsafe() {
      var res = __decode.apply(null, arguments);
      if (typeof res === "object") return res;
    }
    function decode(str) {
      var res = __decode.apply(null, arguments);
      if (typeof res === "object") return res;
      throw new Error(res);
    }
    function convert(data, inBits, outBits, pad) {
      var value = 0;
      var bits = 0;
      var maxV = (1 << outBits) - 1;
      var result = [];
      for (var i = 0; i < data.length; ++i) {
        value = value << inBits | data[i];
        bits += inBits;
        while (bits >= outBits) {
          bits -= outBits;
          result.push(value >> bits & maxV);
        }
      }
      if (pad) {
        if (bits > 0) {
          result.push(value << outBits - bits & maxV);
        }
      } else {
        if (bits >= inBits) return "Excess padding";
        if (value << outBits - bits & maxV) return "Non-zero padding";
      }
      return result;
    }
    function toWordsUnsafe(bytes) {
      var res = convert(bytes, 8, 5, true);
      if (Array.isArray(res)) return res;
    }
    function toWords(bytes) {
      var res = convert(bytes, 8, 5, true);
      if (Array.isArray(res)) return res;
      throw new Error(res);
    }
    function fromWordsUnsafe(words) {
      var res = convert(words, 5, 8, false);
      if (Array.isArray(res)) return res;
    }
    function fromWords(words) {
      var res = convert(words, 5, 8, false);
      if (Array.isArray(res)) return res;
      throw new Error(res);
    }
    module2.exports = {
      decodeUnsafe,
      decode,
      encode,
      toWordsUnsafe,
      toWords,
      fromWordsUnsafe,
      fromWords
    };
  }
});

// node_modules/bitcoinjs-lib/src/payments/p2wpkh.js
var require_p2wpkh = __commonJS({
  "node_modules/bitcoinjs-lib/src/payments/p2wpkh.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var bcrypto = require_crypto3();
    var networks_1 = require_networks();
    var bscript = require_script();
    var lazy = require_lazy();
    var typef = require_typeforce();
    var OPS = bscript.OPS;
    var ecc = require_js();
    var bech32 = require_bech32();
    var EMPTY_BUFFER = Buffer.alloc(0);
    function p2wpkh2(a, opts) {
      if (!a.address && !a.hash && !a.output && !a.pubkey && !a.witness)
        throw new TypeError("Not enough data");
      opts = Object.assign({ validate: true }, opts || {});
      typef(
        {
          address: typef.maybe(typef.String),
          hash: typef.maybe(typef.BufferN(20)),
          input: typef.maybe(typef.BufferN(0)),
          network: typef.maybe(typef.Object),
          output: typef.maybe(typef.BufferN(22)),
          pubkey: typef.maybe(ecc.isPoint),
          signature: typef.maybe(bscript.isCanonicalScriptSignature),
          witness: typef.maybe(typef.arrayOf(typef.Buffer))
        },
        a
      );
      const _address = lazy.value(() => {
        const result = bech32.decode(a.address);
        const version = result.words.shift();
        const data = bech32.fromWords(result.words);
        return {
          version,
          prefix: result.prefix,
          data: Buffer.from(data)
        };
      });
      const network = a.network || networks_1.bitcoin;
      const o = { name: "p2wpkh", network };
      lazy.prop(o, "address", () => {
        if (!o.hash) return;
        const words = bech32.toWords(o.hash);
        words.unshift(0);
        return bech32.encode(network.bech32, words);
      });
      lazy.prop(o, "hash", () => {
        if (a.output) return a.output.slice(2, 22);
        if (a.address) return _address().data;
        if (a.pubkey || o.pubkey) return bcrypto.hash160(a.pubkey || o.pubkey);
      });
      lazy.prop(o, "output", () => {
        if (!o.hash) return;
        return bscript.compile([OPS.OP_0, o.hash]);
      });
      lazy.prop(o, "pubkey", () => {
        if (a.pubkey) return a.pubkey;
        if (!a.witness) return;
        return a.witness[1];
      });
      lazy.prop(o, "signature", () => {
        if (!a.witness) return;
        return a.witness[0];
      });
      lazy.prop(o, "input", () => {
        if (!o.witness) return;
        return EMPTY_BUFFER;
      });
      lazy.prop(o, "witness", () => {
        if (!a.pubkey) return;
        if (!a.signature) return;
        return [a.signature, a.pubkey];
      });
      if (opts.validate) {
        let hash = Buffer.from([]);
        if (a.address) {
          if (network && network.bech32 !== _address().prefix)
            throw new TypeError("Invalid prefix or Network mismatch");
          if (_address().version !== 0)
            throw new TypeError("Invalid address version");
          if (_address().data.length !== 20)
            throw new TypeError("Invalid address data");
          hash = _address().data;
        }
        if (a.hash) {
          if (hash.length > 0 && !hash.equals(a.hash))
            throw new TypeError("Hash mismatch");
          else hash = a.hash;
        }
        if (a.output) {
          if (a.output.length !== 22 || a.output[0] !== OPS.OP_0 || a.output[1] !== 20)
            throw new TypeError("Output is invalid");
          if (hash.length > 0 && !hash.equals(a.output.slice(2)))
            throw new TypeError("Hash mismatch");
          else hash = a.output.slice(2);
        }
        if (a.pubkey) {
          const pkh = bcrypto.hash160(a.pubkey);
          if (hash.length > 0 && !hash.equals(pkh))
            throw new TypeError("Hash mismatch");
          else hash = pkh;
          if (!ecc.isPoint(a.pubkey) || a.pubkey.length !== 33)
            throw new TypeError("Invalid pubkey for p2wpkh");
        }
        if (a.witness) {
          if (a.witness.length !== 2) throw new TypeError("Witness is invalid");
          if (!bscript.isCanonicalScriptSignature(a.witness[0]))
            throw new TypeError("Witness has invalid signature");
          if (!ecc.isPoint(a.witness[1]) || a.witness[1].length !== 33)
            throw new TypeError("Witness has invalid pubkey");
          if (a.signature && !a.signature.equals(a.witness[0]))
            throw new TypeError("Signature mismatch");
          if (a.pubkey && !a.pubkey.equals(a.witness[1]))
            throw new TypeError("Pubkey mismatch");
          const pkh = bcrypto.hash160(a.witness[1]);
          if (hash.length > 0 && !hash.equals(pkh))
            throw new TypeError("Hash mismatch");
        }
      }
      return Object.assign(o, a);
    }
    exports2.p2wpkh = p2wpkh2;
  }
});

// node_modules/bitcoinjs-lib/src/payments/p2wsh.js
var require_p2wsh = __commonJS({
  "node_modules/bitcoinjs-lib/src/payments/p2wsh.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var bcrypto = require_crypto3();
    var networks_1 = require_networks();
    var bscript = require_script();
    var lazy = require_lazy();
    var typef = require_typeforce();
    var OPS = bscript.OPS;
    var ecc = require_js();
    var bech32 = require_bech32();
    var EMPTY_BUFFER = Buffer.alloc(0);
    function stacksEqual(a, b2) {
      if (a.length !== b2.length) return false;
      return a.every((x, i) => {
        return x.equals(b2[i]);
      });
    }
    function chunkHasUncompressedPubkey(chunk) {
      if (Buffer.isBuffer(chunk) && chunk.length === 65 && chunk[0] === 4 && ecc.isPoint(chunk)) {
        return true;
      } else {
        return false;
      }
    }
    function p2wsh(a, opts) {
      if (!a.address && !a.hash && !a.output && !a.redeem && !a.witness)
        throw new TypeError("Not enough data");
      opts = Object.assign({ validate: true }, opts || {});
      typef(
        {
          network: typef.maybe(typef.Object),
          address: typef.maybe(typef.String),
          hash: typef.maybe(typef.BufferN(32)),
          output: typef.maybe(typef.BufferN(34)),
          redeem: typef.maybe({
            input: typef.maybe(typef.Buffer),
            network: typef.maybe(typef.Object),
            output: typef.maybe(typef.Buffer),
            witness: typef.maybe(typef.arrayOf(typef.Buffer))
          }),
          input: typef.maybe(typef.BufferN(0)),
          witness: typef.maybe(typef.arrayOf(typef.Buffer))
        },
        a
      );
      const _address = lazy.value(() => {
        const result = bech32.decode(a.address);
        const version = result.words.shift();
        const data = bech32.fromWords(result.words);
        return {
          version,
          prefix: result.prefix,
          data: Buffer.from(data)
        };
      });
      const _rchunks = lazy.value(() => {
        return bscript.decompile(a.redeem.input);
      });
      let network = a.network;
      if (!network) {
        network = a.redeem && a.redeem.network || networks_1.bitcoin;
      }
      const o = { network };
      lazy.prop(o, "address", () => {
        if (!o.hash) return;
        const words = bech32.toWords(o.hash);
        words.unshift(0);
        return bech32.encode(network.bech32, words);
      });
      lazy.prop(o, "hash", () => {
        if (a.output) return a.output.slice(2);
        if (a.address) return _address().data;
        if (o.redeem && o.redeem.output) return bcrypto.sha256(o.redeem.output);
      });
      lazy.prop(o, "output", () => {
        if (!o.hash) return;
        return bscript.compile([OPS.OP_0, o.hash]);
      });
      lazy.prop(o, "redeem", () => {
        if (!a.witness) return;
        return {
          output: a.witness[a.witness.length - 1],
          input: EMPTY_BUFFER,
          witness: a.witness.slice(0, -1)
        };
      });
      lazy.prop(o, "input", () => {
        if (!o.witness) return;
        return EMPTY_BUFFER;
      });
      lazy.prop(o, "witness", () => {
        if (a.redeem && a.redeem.input && a.redeem.input.length > 0 && a.redeem.output && a.redeem.output.length > 0) {
          const stack = bscript.toStack(_rchunks());
          o.redeem = Object.assign({ witness: stack }, a.redeem);
          o.redeem.input = EMPTY_BUFFER;
          return [].concat(stack, a.redeem.output);
        }
        if (!a.redeem) return;
        if (!a.redeem.output) return;
        if (!a.redeem.witness) return;
        return [].concat(a.redeem.witness, a.redeem.output);
      });
      lazy.prop(o, "name", () => {
        const nameParts = ["p2wsh"];
        if (o.redeem !== void 0) nameParts.push(o.redeem.name);
        return nameParts.join("-");
      });
      if (opts.validate) {
        let hash = Buffer.from([]);
        if (a.address) {
          if (_address().prefix !== network.bech32)
            throw new TypeError("Invalid prefix or Network mismatch");
          if (_address().version !== 0)
            throw new TypeError("Invalid address version");
          if (_address().data.length !== 32)
            throw new TypeError("Invalid address data");
          hash = _address().data;
        }
        if (a.hash) {
          if (hash.length > 0 && !hash.equals(a.hash))
            throw new TypeError("Hash mismatch");
          else hash = a.hash;
        }
        if (a.output) {
          if (a.output.length !== 34 || a.output[0] !== OPS.OP_0 || a.output[1] !== 32)
            throw new TypeError("Output is invalid");
          const hash2 = a.output.slice(2);
          if (hash.length > 0 && !hash.equals(hash2))
            throw new TypeError("Hash mismatch");
          else hash = hash2;
        }
        if (a.redeem) {
          if (a.redeem.network && a.redeem.network !== network)
            throw new TypeError("Network mismatch");
          if (a.redeem.input && a.redeem.input.length > 0 && a.redeem.witness && a.redeem.witness.length > 0)
            throw new TypeError("Ambiguous witness source");
          if (a.redeem.output) {
            if (bscript.decompile(a.redeem.output).length === 0)
              throw new TypeError("Redeem.output is invalid");
            const hash2 = bcrypto.sha256(a.redeem.output);
            if (hash.length > 0 && !hash.equals(hash2))
              throw new TypeError("Hash mismatch");
            else hash = hash2;
          }
          if (a.redeem.input && !bscript.isPushOnly(_rchunks()))
            throw new TypeError("Non push-only scriptSig");
          if (a.witness && a.redeem.witness && !stacksEqual(a.witness, a.redeem.witness))
            throw new TypeError("Witness and redeem.witness mismatch");
          if (a.redeem.input && _rchunks().some(chunkHasUncompressedPubkey) || a.redeem.output && (bscript.decompile(a.redeem.output) || []).some(
            chunkHasUncompressedPubkey
          )) {
            throw new TypeError(
              "redeem.input or redeem.output contains uncompressed pubkey"
            );
          }
        }
        if (a.witness && a.witness.length > 0) {
          const wScript = a.witness[a.witness.length - 1];
          if (a.redeem && a.redeem.output && !a.redeem.output.equals(wScript))
            throw new TypeError("Witness and redeem.output mismatch");
          if (a.witness.some(chunkHasUncompressedPubkey) || (bscript.decompile(wScript) || []).some(chunkHasUncompressedPubkey))
            throw new TypeError("Witness contains uncompressed pubkey");
        }
      }
      return Object.assign(o, a);
    }
    exports2.p2wsh = p2wsh;
  }
});

// node_modules/bitcoinjs-lib/src/payments/index.js
var require_payments = __commonJS({
  "node_modules/bitcoinjs-lib/src/payments/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var embed_1 = require_embed();
    exports2.embed = embed_1.p2data;
    var p2ms_1 = require_p2ms();
    exports2.p2ms = p2ms_1.p2ms;
    var p2pk_1 = require_p2pk();
    exports2.p2pk = p2pk_1.p2pk;
    var p2pkh_1 = require_p2pkh();
    exports2.p2pkh = p2pkh_1.p2pkh;
    var p2sh_1 = require_p2sh();
    exports2.p2sh = p2sh_1.p2sh;
    var p2wpkh_1 = require_p2wpkh();
    exports2.p2wpkh = p2wpkh_1.p2wpkh;
    var p2wsh_1 = require_p2wsh();
    exports2.p2wsh = p2wsh_1.p2wsh;
  }
});

// node_modules/bitcoinjs-lib/src/address.js
var require_address = __commonJS({
  "node_modules/bitcoinjs-lib/src/address.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var networks = require_networks();
    var payments = require_payments();
    var bscript = require_script();
    var types = require_types();
    var bech32 = require_bech32();
    var bs58check2 = require_bs58check();
    var typeforce = require_typeforce();
    function fromBase58Check(address) {
      const payload = bs58check2.decode(address);
      if (payload.length < 21) throw new TypeError(address + " is too short");
      if (payload.length > 21) throw new TypeError(address + " is too long");
      const version = payload.readUInt8(0);
      const hash = payload.slice(1);
      return { version, hash };
    }
    exports2.fromBase58Check = fromBase58Check;
    function fromBech32(address) {
      const result = bech32.decode(address);
      const data = bech32.fromWords(result.words.slice(1));
      return {
        version: result.words[0],
        prefix: result.prefix,
        data: Buffer.from(data)
      };
    }
    exports2.fromBech32 = fromBech32;
    function toBase58Check(hash, version) {
      typeforce(types.tuple(types.Hash160bit, types.UInt8), arguments);
      const payload = Buffer.allocUnsafe(21);
      payload.writeUInt8(version, 0);
      hash.copy(payload, 1);
      return bs58check2.encode(payload);
    }
    exports2.toBase58Check = toBase58Check;
    function toBech32(data, version, prefix) {
      const words = bech32.toWords(data);
      words.unshift(version);
      return bech32.encode(prefix, words);
    }
    exports2.toBech32 = toBech32;
    function fromOutputScript(output, network) {
      network = network || networks.bitcoin;
      try {
        return payments.p2pkh({ output, network }).address;
      } catch (e) {
      }
      try {
        return payments.p2sh({ output, network }).address;
      } catch (e) {
      }
      try {
        return payments.p2wpkh({ output, network }).address;
      } catch (e) {
      }
      try {
        return payments.p2wsh({ output, network }).address;
      } catch (e) {
      }
      throw new Error(bscript.toASM(output) + " has no matching Address");
    }
    exports2.fromOutputScript = fromOutputScript;
    function toOutputScript(address, network) {
      network = network || networks.bitcoin;
      let decodeBase58;
      let decodeBech32;
      try {
        decodeBase58 = fromBase58Check(address);
      } catch (e) {
      }
      if (decodeBase58) {
        if (decodeBase58.version === network.pubKeyHash)
          return payments.p2pkh({ hash: decodeBase58.hash }).output;
        if (decodeBase58.version === network.scriptHash)
          return payments.p2sh({ hash: decodeBase58.hash }).output;
      } else {
        try {
          decodeBech32 = fromBech32(address);
        } catch (e) {
        }
        if (decodeBech32) {
          if (decodeBech32.prefix !== network.bech32)
            throw new Error(address + " has an invalid prefix");
          if (decodeBech32.version === 0) {
            if (decodeBech32.data.length === 20)
              return payments.p2wpkh({ hash: decodeBech32.data }).output;
            if (decodeBech32.data.length === 32)
              return payments.p2wsh({ hash: decodeBech32.data }).output;
          }
        }
      }
      throw new Error(address + " has no matching Script");
    }
    exports2.toOutputScript = toOutputScript;
  }
});

// node_modules/randombytes/browser.js
var require_browser4 = __commonJS({
  "node_modules/randombytes/browser.js"(exports2, module2) {
    "use strict";
    var MAX_BYTES = 65536;
    var MAX_UINT32 = 4294967295;
    function oldBrowser() {
      throw new Error("Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11");
    }
    var Buffer2 = require_safe_buffer().Buffer;
    var crypto8 = globalThis.crypto || globalThis.msCrypto;
    if (crypto8 && crypto8.getRandomValues) {
      module2.exports = randomBytes2;
    } else {
      module2.exports = oldBrowser;
    }
    function randomBytes2(size, cb) {
      if (size > MAX_UINT32) throw new RangeError("requested too many random bytes");
      var bytes = Buffer2.allocUnsafe(size);
      if (size > 0) {
        if (size > MAX_BYTES) {
          for (var generated = 0; generated < size; generated += MAX_BYTES) {
            crypto8.getRandomValues(bytes.slice(generated, generated + MAX_BYTES));
          }
        } else {
          crypto8.getRandomValues(bytes);
        }
      }
      if (typeof cb === "function") {
        return process.nextTick(function() {
          cb(null, bytes);
        });
      }
      return bytes;
    }
  }
});

// node_modules/bitcoinjs-lib/node_modules/wif/index.js
var require_wif2 = __commonJS({
  "node_modules/bitcoinjs-lib/node_modules/wif/index.js"(exports2, module2) {
    var bs58check2 = require_bs58check();
    function decodeRaw(buffer, version) {
      if (version !== void 0 && buffer[0] !== version) throw new Error("Invalid network version");
      if (buffer.length === 33) {
        return {
          version: buffer[0],
          privateKey: buffer.slice(1, 33),
          compressed: false
        };
      }
      if (buffer.length !== 34) throw new Error("Invalid WIF length");
      if (buffer[33] !== 1) throw new Error("Invalid compression flag");
      return {
        version: buffer[0],
        privateKey: buffer.slice(1, 33),
        compressed: true
      };
    }
    function encodeRaw(version, privateKey, compressed) {
      var result = new Buffer(compressed ? 34 : 33);
      result.writeUInt8(version, 0);
      privateKey.copy(result, 1);
      if (compressed) {
        result[33] = 1;
      }
      return result;
    }
    function decode(string, version) {
      return decodeRaw(bs58check2.decode(string), version);
    }
    function encode(version, privateKey, compressed) {
      if (typeof version === "number") return bs58check2.encode(encodeRaw(version, privateKey, compressed));
      return bs58check2.encode(
        encodeRaw(
          version.version,
          version.privateKey,
          version.compressed
        )
      );
    }
    module2.exports = {
      decode,
      decodeRaw,
      encode,
      encodeRaw
    };
  }
});

// node_modules/bitcoinjs-lib/src/ecpair.js
var require_ecpair = __commonJS({
  "node_modules/bitcoinjs-lib/src/ecpair.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var NETWORKS = require_networks();
    var types = require_types();
    var ecc = require_js();
    var randomBytes2 = require_browser4();
    var typeforce = require_typeforce();
    var wif = require_wif2();
    var isOptions = typeforce.maybe(
      typeforce.compile({
        compressed: types.maybe(types.Boolean),
        network: types.maybe(types.Network)
      })
    );
    var ECPair = class {
      constructor(__D, __Q, options) {
        this.__D = __D;
        this.__Q = __Q;
        this.lowR = false;
        if (options === void 0) options = {};
        this.compressed = options.compressed === void 0 ? true : options.compressed;
        this.network = options.network || NETWORKS.bitcoin;
        if (__Q !== void 0) this.__Q = ecc.pointCompress(__Q, this.compressed);
      }
      get privateKey() {
        return this.__D;
      }
      get publicKey() {
        if (!this.__Q) this.__Q = ecc.pointFromScalar(this.__D, this.compressed);
        return this.__Q;
      }
      toWIF() {
        if (!this.__D) throw new Error("Missing private key");
        return wif.encode(this.network.wif, this.__D, this.compressed);
      }
      sign(hash, lowR) {
        if (!this.__D) throw new Error("Missing private key");
        if (lowR === void 0) lowR = this.lowR;
        if (lowR === false) {
          return ecc.sign(hash, this.__D);
        } else {
          let sig = ecc.sign(hash, this.__D);
          const extraData = Buffer.alloc(32, 0);
          let counter = 0;
          while (sig[0] > 127) {
            counter++;
            extraData.writeUIntLE(counter, 0, 6);
            sig = ecc.signWithEntropy(hash, this.__D, extraData);
          }
          return sig;
        }
      }
      verify(hash, signature) {
        return ecc.verify(hash, this.publicKey, signature);
      }
    };
    function fromPrivateKey(buffer, options) {
      typeforce(types.Buffer256bit, buffer);
      if (!ecc.isPrivate(buffer))
        throw new TypeError("Private key not in range [1, n)");
      typeforce(isOptions, options);
      return new ECPair(buffer, void 0, options);
    }
    exports2.fromPrivateKey = fromPrivateKey;
    function fromPublicKey(buffer, options) {
      typeforce(ecc.isPoint, buffer);
      typeforce(isOptions, options);
      return new ECPair(void 0, buffer, options);
    }
    exports2.fromPublicKey = fromPublicKey;
    function fromWIF(wifString, network) {
      const decoded = wif.decode(wifString);
      const version = decoded.version;
      if (types.Array(network)) {
        network = network.filter((x) => {
          return version === x.wif;
        }).pop();
        if (!network) throw new Error("Unknown network version");
      } else {
        network = network || NETWORKS.bitcoin;
        if (version !== network.wif) throw new Error("Invalid network version");
      }
      return fromPrivateKey(decoded.privateKey, {
        compressed: decoded.compressed,
        network
      });
    }
    exports2.fromWIF = fromWIF;
    function makeRandom(options) {
      typeforce(isOptions, options);
      if (options === void 0) options = {};
      const rng = options.rng || randomBytes2;
      let d;
      do {
        d = rng(32);
        typeforce(types.Buffer256bit, d);
      } while (!ecc.isPrivate(d));
      return fromPrivateKey(d, options);
    }
    exports2.makeRandom = makeRandom;
  }
});

// node_modules/varuint-bitcoin/index.js
var require_varuint_bitcoin = __commonJS({
  "node_modules/varuint-bitcoin/index.js"(exports2, module2) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var MAX_SAFE_INTEGER = 9007199254740991;
    function checkUInt53(n) {
      if (n < 0 || n > MAX_SAFE_INTEGER || n % 1 !== 0) throw new RangeError("value out of range");
    }
    function encode(number, buffer, offset) {
      checkUInt53(number);
      if (!buffer) buffer = Buffer2.allocUnsafe(encodingLength(number));
      if (!Buffer2.isBuffer(buffer)) throw new TypeError("buffer must be a Buffer instance");
      if (!offset) offset = 0;
      if (number < 253) {
        buffer.writeUInt8(number, offset);
        encode.bytes = 1;
      } else if (number <= 65535) {
        buffer.writeUInt8(253, offset);
        buffer.writeUInt16LE(number, offset + 1);
        encode.bytes = 3;
      } else if (number <= 4294967295) {
        buffer.writeUInt8(254, offset);
        buffer.writeUInt32LE(number, offset + 1);
        encode.bytes = 5;
      } else {
        buffer.writeUInt8(255, offset);
        buffer.writeUInt32LE(number >>> 0, offset + 1);
        buffer.writeUInt32LE(number / 4294967296 | 0, offset + 5);
        encode.bytes = 9;
      }
      return buffer;
    }
    function decode(buffer, offset) {
      if (!Buffer2.isBuffer(buffer)) throw new TypeError("buffer must be a Buffer instance");
      if (!offset) offset = 0;
      var first = buffer.readUInt8(offset);
      if (first < 253) {
        decode.bytes = 1;
        return first;
      } else if (first === 253) {
        decode.bytes = 3;
        return buffer.readUInt16LE(offset + 1);
      } else if (first === 254) {
        decode.bytes = 5;
        return buffer.readUInt32LE(offset + 1);
      } else {
        decode.bytes = 9;
        var lo = buffer.readUInt32LE(offset + 1);
        var hi = buffer.readUInt32LE(offset + 5);
        var number = hi * 4294967296 + lo;
        checkUInt53(number);
        return number;
      }
    }
    function encodingLength(number) {
      checkUInt53(number);
      return number < 253 ? 1 : number <= 65535 ? 3 : number <= 4294967295 ? 5 : 9;
    }
    module2.exports = { encode, decode, encodingLength };
  }
});

// node_modules/bitcoinjs-lib/src/bufferutils.js
var require_bufferutils = __commonJS({
  "node_modules/bitcoinjs-lib/src/bufferutils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var types = require_types();
    var typeforce = require_typeforce();
    var varuint2 = require_varuint_bitcoin();
    function verifuint(value, max) {
      if (typeof value !== "number")
        throw new Error("cannot write a non-number as a number");
      if (value < 0)
        throw new Error("specified a negative value for writing an unsigned value");
      if (value > max) throw new Error("RangeError: value out of range");
      if (Math.floor(value) !== value)
        throw new Error("value has a fractional component");
    }
    function readUInt64LE(buffer, offset) {
      const a = buffer.readUInt32LE(offset);
      let b2 = buffer.readUInt32LE(offset + 4);
      b2 *= 4294967296;
      verifuint(b2 + a, 9007199254740991);
      return b2 + a;
    }
    exports2.readUInt64LE = readUInt64LE;
    function writeUInt64LE(buffer, value, offset) {
      verifuint(value, 9007199254740991);
      buffer.writeInt32LE(value & -1, offset);
      buffer.writeUInt32LE(Math.floor(value / 4294967296), offset + 4);
      return offset + 8;
    }
    exports2.writeUInt64LE = writeUInt64LE;
    function reverseBuffer(buffer) {
      if (buffer.length < 1) return buffer;
      let j = buffer.length - 1;
      let tmp = 0;
      for (let i = 0; i < buffer.length / 2; i++) {
        tmp = buffer[i];
        buffer[i] = buffer[j];
        buffer[j] = tmp;
        j--;
      }
      return buffer;
    }
    exports2.reverseBuffer = reverseBuffer;
    function cloneBuffer(buffer) {
      const clone = Buffer.allocUnsafe(buffer.length);
      buffer.copy(clone);
      return clone;
    }
    exports2.cloneBuffer = cloneBuffer;
    var BufferWriter2 = class {
      constructor(buffer, offset = 0) {
        this.buffer = buffer;
        this.offset = offset;
        typeforce(types.tuple(types.Buffer, types.UInt32), [buffer, offset]);
      }
      writeUInt8(i) {
        this.offset = this.buffer.writeUInt8(i, this.offset);
      }
      writeInt32(i) {
        this.offset = this.buffer.writeInt32LE(i, this.offset);
      }
      writeUInt32(i) {
        this.offset = this.buffer.writeUInt32LE(i, this.offset);
      }
      writeUInt64(i) {
        this.offset = writeUInt64LE(this.buffer, i, this.offset);
      }
      writeVarInt(i) {
        varuint2.encode(i, this.buffer, this.offset);
        this.offset += varuint2.encode.bytes;
      }
      writeSlice(slice) {
        if (this.buffer.length < this.offset + slice.length) {
          throw new Error("Cannot write slice out of bounds");
        }
        this.offset += slice.copy(this.buffer, this.offset);
      }
      writeVarSlice(slice) {
        this.writeVarInt(slice.length);
        this.writeSlice(slice);
      }
      writeVector(vector) {
        this.writeVarInt(vector.length);
        vector.forEach((buf) => this.writeVarSlice(buf));
      }
    };
    exports2.BufferWriter = BufferWriter2;
    var BufferReader2 = class {
      constructor(buffer, offset = 0) {
        this.buffer = buffer;
        this.offset = offset;
        typeforce(types.tuple(types.Buffer, types.UInt32), [buffer, offset]);
      }
      readUInt8() {
        const result = this.buffer.readUInt8(this.offset);
        this.offset++;
        return result;
      }
      readInt32() {
        const result = this.buffer.readInt32LE(this.offset);
        this.offset += 4;
        return result;
      }
      readUInt32() {
        const result = this.buffer.readUInt32LE(this.offset);
        this.offset += 4;
        return result;
      }
      readUInt64() {
        const result = readUInt64LE(this.buffer, this.offset);
        this.offset += 8;
        return result;
      }
      readVarInt() {
        const vi = varuint2.decode(this.buffer, this.offset);
        this.offset += varuint2.decode.bytes;
        return vi;
      }
      readSlice(n) {
        if (this.buffer.length < this.offset + n) {
          throw new Error("Cannot read slice out of bounds");
        }
        const result = this.buffer.slice(this.offset, this.offset + n);
        this.offset += n;
        return result;
      }
      readVarSlice() {
        return this.readSlice(this.readVarInt());
      }
      readVector() {
        const count = this.readVarInt();
        const vector = [];
        for (let i = 0; i < count; i++) vector.push(this.readVarSlice());
        return vector;
      }
    };
    exports2.BufferReader = BufferReader2;
  }
});

// node_modules/bitcoinjs-lib/src/transaction.js
var require_transaction = __commonJS({
  "node_modules/bitcoinjs-lib/src/transaction.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var bufferutils_1 = require_bufferutils();
    var bcrypto = require_crypto3();
    var bscript = require_script();
    var script_1 = require_script();
    var types = require_types();
    var typeforce = require_typeforce();
    var varuint2 = require_varuint_bitcoin();
    function varSliceSize(someScript) {
      const length = someScript.length;
      return varuint2.encodingLength(length) + length;
    }
    function vectorSize(someVector) {
      const length = someVector.length;
      return varuint2.encodingLength(length) + someVector.reduce((sum, witness) => {
        return sum + varSliceSize(witness);
      }, 0);
    }
    var EMPTY_SCRIPT = Buffer.allocUnsafe(0);
    var EMPTY_WITNESS = [];
    var ZERO = Buffer.from(
      "0000000000000000000000000000000000000000000000000000000000000000",
      "hex"
    );
    var ONE = Buffer.from(
      "0000000000000000000000000000000000000000000000000000000000000001",
      "hex"
    );
    var VALUE_UINT64_MAX = Buffer.from("ffffffffffffffff", "hex");
    var BLANK_OUTPUT = {
      script: EMPTY_SCRIPT,
      valueBuffer: VALUE_UINT64_MAX
    };
    function isOutput(out) {
      return out.value !== void 0;
    }
    var Transaction = class _Transaction {
      constructor() {
        this.version = 1;
        this.locktime = 0;
        this.ins = [];
        this.outs = [];
      }
      static fromBuffer(buffer, _NO_STRICT) {
        const bufferReader = new bufferutils_1.BufferReader(buffer);
        const tx = new _Transaction();
        tx.version = bufferReader.readInt32();
        const marker = bufferReader.readUInt8();
        const flag = bufferReader.readUInt8();
        let hasWitnesses = false;
        if (marker === _Transaction.ADVANCED_TRANSACTION_MARKER && flag === _Transaction.ADVANCED_TRANSACTION_FLAG) {
          hasWitnesses = true;
        } else {
          bufferReader.offset -= 2;
        }
        const vinLen = bufferReader.readVarInt();
        for (let i = 0; i < vinLen; ++i) {
          tx.ins.push({
            hash: bufferReader.readSlice(32),
            index: bufferReader.readUInt32(),
            script: bufferReader.readVarSlice(),
            sequence: bufferReader.readUInt32(),
            witness: EMPTY_WITNESS
          });
        }
        const voutLen = bufferReader.readVarInt();
        for (let i = 0; i < voutLen; ++i) {
          tx.outs.push({
            value: bufferReader.readUInt64(),
            script: bufferReader.readVarSlice()
          });
        }
        if (hasWitnesses) {
          for (let i = 0; i < vinLen; ++i) {
            tx.ins[i].witness = bufferReader.readVector();
          }
          if (!tx.hasWitnesses())
            throw new Error("Transaction has superfluous witness data");
        }
        tx.locktime = bufferReader.readUInt32();
        if (_NO_STRICT) return tx;
        if (bufferReader.offset !== buffer.length)
          throw new Error("Transaction has unexpected data");
        return tx;
      }
      static fromHex(hex) {
        return _Transaction.fromBuffer(Buffer.from(hex, "hex"), false);
      }
      static isCoinbaseHash(buffer) {
        typeforce(types.Hash256bit, buffer);
        for (let i = 0; i < 32; ++i) {
          if (buffer[i] !== 0) return false;
        }
        return true;
      }
      isCoinbase() {
        return this.ins.length === 1 && _Transaction.isCoinbaseHash(this.ins[0].hash);
      }
      addInput(hash, index, sequence, scriptSig) {
        typeforce(
          types.tuple(
            types.Hash256bit,
            types.UInt32,
            types.maybe(types.UInt32),
            types.maybe(types.Buffer)
          ),
          arguments
        );
        if (types.Null(sequence)) {
          sequence = _Transaction.DEFAULT_SEQUENCE;
        }
        return this.ins.push({
          hash,
          index,
          script: scriptSig || EMPTY_SCRIPT,
          sequence,
          witness: EMPTY_WITNESS
        }) - 1;
      }
      addOutput(scriptPubKey, value) {
        typeforce(types.tuple(types.Buffer, types.Satoshi), arguments);
        return this.outs.push({
          script: scriptPubKey,
          value
        }) - 1;
      }
      hasWitnesses() {
        return this.ins.some((x) => {
          return x.witness.length !== 0;
        });
      }
      weight() {
        const base = this.byteLength(false);
        const total = this.byteLength(true);
        return base * 3 + total;
      }
      virtualSize() {
        return Math.ceil(this.weight() / 4);
      }
      byteLength(_ALLOW_WITNESS = true) {
        const hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();
        return (hasWitnesses ? 10 : 8) + varuint2.encodingLength(this.ins.length) + varuint2.encodingLength(this.outs.length) + this.ins.reduce((sum, input) => {
          return sum + 40 + varSliceSize(input.script);
        }, 0) + this.outs.reduce((sum, output) => {
          return sum + 8 + varSliceSize(output.script);
        }, 0) + (hasWitnesses ? this.ins.reduce((sum, input) => {
          return sum + vectorSize(input.witness);
        }, 0) : 0);
      }
      clone() {
        const newTx = new _Transaction();
        newTx.version = this.version;
        newTx.locktime = this.locktime;
        newTx.ins = this.ins.map((txIn) => {
          return {
            hash: txIn.hash,
            index: txIn.index,
            script: txIn.script,
            sequence: txIn.sequence,
            witness: txIn.witness
          };
        });
        newTx.outs = this.outs.map((txOut) => {
          return {
            script: txOut.script,
            value: txOut.value
          };
        });
        return newTx;
      }
      /**
       * Hash transaction for signing a specific input.
       *
       * Bitcoin uses a different hash for each signed transaction input.
       * This method copies the transaction, makes the necessary changes based on the
       * hashType, and then hashes the result.
       * This hash can then be used to sign the provided transaction input.
       */
      hashForSignature(inIndex, prevOutScript, hashType) {
        typeforce(
          types.tuple(
            types.UInt32,
            types.Buffer,
            /* types.UInt8 */
            types.Number
          ),
          arguments
        );
        if (inIndex >= this.ins.length) return ONE;
        const ourScript = bscript.compile(
          bscript.decompile(prevOutScript).filter((x) => {
            return x !== script_1.OPS.OP_CODESEPARATOR;
          })
        );
        const txTmp = this.clone();
        if ((hashType & 31) === _Transaction.SIGHASH_NONE) {
          txTmp.outs = [];
          txTmp.ins.forEach((input, i) => {
            if (i === inIndex) return;
            input.sequence = 0;
          });
        } else if ((hashType & 31) === _Transaction.SIGHASH_SINGLE) {
          if (inIndex >= this.outs.length) return ONE;
          txTmp.outs.length = inIndex + 1;
          for (let i = 0; i < inIndex; i++) {
            txTmp.outs[i] = BLANK_OUTPUT;
          }
          txTmp.ins.forEach((input, y) => {
            if (y === inIndex) return;
            input.sequence = 0;
          });
        }
        if (hashType & _Transaction.SIGHASH_ANYONECANPAY) {
          txTmp.ins = [txTmp.ins[inIndex]];
          txTmp.ins[0].script = ourScript;
        } else {
          txTmp.ins.forEach((input) => {
            input.script = EMPTY_SCRIPT;
          });
          txTmp.ins[inIndex].script = ourScript;
        }
        const buffer = Buffer.allocUnsafe(txTmp.byteLength(false) + 4);
        buffer.writeInt32LE(hashType, buffer.length - 4);
        txTmp.__toBuffer(buffer, 0, false);
        return bcrypto.hash256(buffer);
      }
      hashForWitnessV0(inIndex, prevOutScript, value, hashType) {
        typeforce(
          types.tuple(types.UInt32, types.Buffer, types.Satoshi, types.UInt32),
          arguments
        );
        let tbuffer = Buffer.from([]);
        let bufferWriter;
        let hashOutputs = ZERO;
        let hashPrevouts = ZERO;
        let hashSequence = ZERO;
        if (!(hashType & _Transaction.SIGHASH_ANYONECANPAY)) {
          tbuffer = Buffer.allocUnsafe(36 * this.ins.length);
          bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);
          this.ins.forEach((txIn) => {
            bufferWriter.writeSlice(txIn.hash);
            bufferWriter.writeUInt32(txIn.index);
          });
          hashPrevouts = bcrypto.hash256(tbuffer);
        }
        if (!(hashType & _Transaction.SIGHASH_ANYONECANPAY) && (hashType & 31) !== _Transaction.SIGHASH_SINGLE && (hashType & 31) !== _Transaction.SIGHASH_NONE) {
          tbuffer = Buffer.allocUnsafe(4 * this.ins.length);
          bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);
          this.ins.forEach((txIn) => {
            bufferWriter.writeUInt32(txIn.sequence);
          });
          hashSequence = bcrypto.hash256(tbuffer);
        }
        if ((hashType & 31) !== _Transaction.SIGHASH_SINGLE && (hashType & 31) !== _Transaction.SIGHASH_NONE) {
          const txOutsSize = this.outs.reduce((sum, output) => {
            return sum + 8 + varSliceSize(output.script);
          }, 0);
          tbuffer = Buffer.allocUnsafe(txOutsSize);
          bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);
          this.outs.forEach((out) => {
            bufferWriter.writeUInt64(out.value);
            bufferWriter.writeVarSlice(out.script);
          });
          hashOutputs = bcrypto.hash256(tbuffer);
        } else if ((hashType & 31) === _Transaction.SIGHASH_SINGLE && inIndex < this.outs.length) {
          const output = this.outs[inIndex];
          tbuffer = Buffer.allocUnsafe(8 + varSliceSize(output.script));
          bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);
          bufferWriter.writeUInt64(output.value);
          bufferWriter.writeVarSlice(output.script);
          hashOutputs = bcrypto.hash256(tbuffer);
        }
        tbuffer = Buffer.allocUnsafe(156 + varSliceSize(prevOutScript));
        bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);
        const input = this.ins[inIndex];
        bufferWriter.writeUInt32(this.version);
        bufferWriter.writeSlice(hashPrevouts);
        bufferWriter.writeSlice(hashSequence);
        bufferWriter.writeSlice(input.hash);
        bufferWriter.writeUInt32(input.index);
        bufferWriter.writeVarSlice(prevOutScript);
        bufferWriter.writeUInt64(value);
        bufferWriter.writeUInt32(input.sequence);
        bufferWriter.writeSlice(hashOutputs);
        bufferWriter.writeUInt32(this.locktime);
        bufferWriter.writeUInt32(hashType);
        return bcrypto.hash256(tbuffer);
      }
      getHash(forWitness) {
        if (forWitness && this.isCoinbase()) return Buffer.alloc(32, 0);
        return bcrypto.hash256(this.__toBuffer(void 0, void 0, forWitness));
      }
      getId() {
        return bufferutils_1.reverseBuffer(this.getHash(false)).toString("hex");
      }
      toBuffer(buffer, initialOffset) {
        return this.__toBuffer(buffer, initialOffset, true);
      }
      toHex() {
        return this.toBuffer(void 0, void 0).toString("hex");
      }
      setInputScript(index, scriptSig) {
        typeforce(types.tuple(types.Number, types.Buffer), arguments);
        this.ins[index].script = scriptSig;
      }
      setWitness(index, witness) {
        typeforce(types.tuple(types.Number, [types.Buffer]), arguments);
        this.ins[index].witness = witness;
      }
      __toBuffer(buffer, initialOffset, _ALLOW_WITNESS = false) {
        if (!buffer) buffer = Buffer.allocUnsafe(this.byteLength(_ALLOW_WITNESS));
        const bufferWriter = new bufferutils_1.BufferWriter(
          buffer,
          initialOffset || 0
        );
        bufferWriter.writeInt32(this.version);
        const hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();
        if (hasWitnesses) {
          bufferWriter.writeUInt8(_Transaction.ADVANCED_TRANSACTION_MARKER);
          bufferWriter.writeUInt8(_Transaction.ADVANCED_TRANSACTION_FLAG);
        }
        bufferWriter.writeVarInt(this.ins.length);
        this.ins.forEach((txIn) => {
          bufferWriter.writeSlice(txIn.hash);
          bufferWriter.writeUInt32(txIn.index);
          bufferWriter.writeVarSlice(txIn.script);
          bufferWriter.writeUInt32(txIn.sequence);
        });
        bufferWriter.writeVarInt(this.outs.length);
        this.outs.forEach((txOut) => {
          if (isOutput(txOut)) {
            bufferWriter.writeUInt64(txOut.value);
          } else {
            bufferWriter.writeSlice(txOut.valueBuffer);
          }
          bufferWriter.writeVarSlice(txOut.script);
        });
        if (hasWitnesses) {
          this.ins.forEach((input) => {
            bufferWriter.writeVector(input.witness);
          });
        }
        bufferWriter.writeUInt32(this.locktime);
        if (initialOffset !== void 0)
          return buffer.slice(initialOffset, bufferWriter.offset);
        return buffer;
      }
    };
    Transaction.DEFAULT_SEQUENCE = 4294967295;
    Transaction.SIGHASH_ALL = 1;
    Transaction.SIGHASH_NONE = 2;
    Transaction.SIGHASH_SINGLE = 3;
    Transaction.SIGHASH_ANYONECANPAY = 128;
    Transaction.ADVANCED_TRANSACTION_MARKER = 0;
    Transaction.ADVANCED_TRANSACTION_FLAG = 1;
    exports2.Transaction = Transaction;
  }
});

// node_modules/merkle-lib/fastRoot.js
var require_fastRoot = __commonJS({
  "node_modules/merkle-lib/fastRoot.js"(exports2, module2) {
    module2.exports = function fastRoot(values, digestFn) {
      if (!Array.isArray(values)) throw TypeError("Expected values Array");
      if (typeof digestFn !== "function") throw TypeError("Expected digest Function");
      var length = values.length;
      var results = values.concat();
      while (length > 1) {
        var j = 0;
        for (var i = 0; i < length; i += 2, ++j) {
          var left = results[i];
          var right = i + 1 === length ? left : results[i + 1];
          var data = Buffer.concat([left, right]);
          results[j] = digestFn(data);
        }
        length = j;
      }
      return results[0];
    };
  }
});

// node_modules/bitcoinjs-lib/src/block.js
var require_block = __commonJS({
  "node_modules/bitcoinjs-lib/src/block.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var bufferutils_1 = require_bufferutils();
    var bcrypto = require_crypto3();
    var transaction_1 = require_transaction();
    var types = require_types();
    var fastMerkleRoot = require_fastRoot();
    var typeforce = require_typeforce();
    var varuint2 = require_varuint_bitcoin();
    var errorMerkleNoTxes = new TypeError(
      "Cannot compute merkle root for zero transactions"
    );
    var errorWitnessNotSegwit = new TypeError(
      "Cannot compute witness commit for non-segwit block"
    );
    var Block = class _Block {
      constructor() {
        this.version = 1;
        this.prevHash = void 0;
        this.merkleRoot = void 0;
        this.timestamp = 0;
        this.witnessCommit = void 0;
        this.bits = 0;
        this.nonce = 0;
        this.transactions = void 0;
      }
      static fromBuffer(buffer) {
        if (buffer.length < 80) throw new Error("Buffer too small (< 80 bytes)");
        const bufferReader = new bufferutils_1.BufferReader(buffer);
        const block = new _Block();
        block.version = bufferReader.readInt32();
        block.prevHash = bufferReader.readSlice(32);
        block.merkleRoot = bufferReader.readSlice(32);
        block.timestamp = bufferReader.readUInt32();
        block.bits = bufferReader.readUInt32();
        block.nonce = bufferReader.readUInt32();
        if (buffer.length === 80) return block;
        const readTransaction = () => {
          const tx = transaction_1.Transaction.fromBuffer(
            bufferReader.buffer.slice(bufferReader.offset),
            true
          );
          bufferReader.offset += tx.byteLength();
          return tx;
        };
        const nTransactions = bufferReader.readVarInt();
        block.transactions = [];
        for (let i = 0; i < nTransactions; ++i) {
          const tx = readTransaction();
          block.transactions.push(tx);
        }
        const witnessCommit = block.getWitnessCommit();
        if (witnessCommit) block.witnessCommit = witnessCommit;
        return block;
      }
      static fromHex(hex) {
        return _Block.fromBuffer(Buffer.from(hex, "hex"));
      }
      static calculateTarget(bits) {
        const exponent = ((bits & 4278190080) >> 24) - 3;
        const mantissa = bits & 8388607;
        const target = Buffer.alloc(32, 0);
        target.writeUIntBE(mantissa, 29 - exponent, 3);
        return target;
      }
      static calculateMerkleRoot(transactions, forWitness) {
        typeforce([{ getHash: types.Function }], transactions);
        if (transactions.length === 0) throw errorMerkleNoTxes;
        if (forWitness && !txesHaveWitnessCommit(transactions))
          throw errorWitnessNotSegwit;
        const hashes = transactions.map(
          (transaction) => transaction.getHash(forWitness)
        );
        const rootHash = fastMerkleRoot(hashes, bcrypto.hash256);
        return forWitness ? bcrypto.hash256(
          Buffer.concat([rootHash, transactions[0].ins[0].witness[0]])
        ) : rootHash;
      }
      getWitnessCommit() {
        if (!txesHaveWitnessCommit(this.transactions)) return null;
        const witnessCommits = this.transactions[0].outs.filter(
          (out) => out.script.slice(0, 6).equals(Buffer.from("6a24aa21a9ed", "hex"))
        ).map((out) => out.script.slice(6, 38));
        if (witnessCommits.length === 0) return null;
        const result = witnessCommits[witnessCommits.length - 1];
        if (!(result instanceof Buffer && result.length === 32)) return null;
        return result;
      }
      hasWitnessCommit() {
        if (this.witnessCommit instanceof Buffer && this.witnessCommit.length === 32)
          return true;
        if (this.getWitnessCommit() !== null) return true;
        return false;
      }
      hasWitness() {
        return anyTxHasWitness(this.transactions);
      }
      weight() {
        const base = this.byteLength(false, false);
        const total = this.byteLength(false, true);
        return base * 3 + total;
      }
      byteLength(headersOnly, allowWitness = true) {
        if (headersOnly || !this.transactions) return 80;
        return 80 + varuint2.encodingLength(this.transactions.length) + this.transactions.reduce((a, x) => a + x.byteLength(allowWitness), 0);
      }
      getHash() {
        return bcrypto.hash256(this.toBuffer(true));
      }
      getId() {
        return bufferutils_1.reverseBuffer(this.getHash()).toString("hex");
      }
      getUTCDate() {
        const date = /* @__PURE__ */ new Date(0);
        date.setUTCSeconds(this.timestamp);
        return date;
      }
      // TODO: buffer, offset compatibility
      toBuffer(headersOnly) {
        const buffer = Buffer.allocUnsafe(this.byteLength(headersOnly));
        const bufferWriter = new bufferutils_1.BufferWriter(buffer);
        bufferWriter.writeInt32(this.version);
        bufferWriter.writeSlice(this.prevHash);
        bufferWriter.writeSlice(this.merkleRoot);
        bufferWriter.writeUInt32(this.timestamp);
        bufferWriter.writeUInt32(this.bits);
        bufferWriter.writeUInt32(this.nonce);
        if (headersOnly || !this.transactions) return buffer;
        varuint2.encode(this.transactions.length, buffer, bufferWriter.offset);
        bufferWriter.offset += varuint2.encode.bytes;
        this.transactions.forEach((tx) => {
          const txSize = tx.byteLength();
          tx.toBuffer(buffer, bufferWriter.offset);
          bufferWriter.offset += txSize;
        });
        return buffer;
      }
      toHex(headersOnly) {
        return this.toBuffer(headersOnly).toString("hex");
      }
      checkTxRoots() {
        const hasWitnessCommit = this.hasWitnessCommit();
        if (!hasWitnessCommit && this.hasWitness()) return false;
        return this.__checkMerkleRoot() && (hasWitnessCommit ? this.__checkWitnessCommit() : true);
      }
      checkProofOfWork() {
        const hash = bufferutils_1.reverseBuffer(this.getHash());
        const target = _Block.calculateTarget(this.bits);
        return hash.compare(target) <= 0;
      }
      __checkMerkleRoot() {
        if (!this.transactions) throw errorMerkleNoTxes;
        const actualMerkleRoot = _Block.calculateMerkleRoot(this.transactions);
        return this.merkleRoot.compare(actualMerkleRoot) === 0;
      }
      __checkWitnessCommit() {
        if (!this.transactions) throw errorMerkleNoTxes;
        if (!this.hasWitnessCommit()) throw errorWitnessNotSegwit;
        const actualWitnessCommit = _Block.calculateMerkleRoot(
          this.transactions,
          true
        );
        return this.witnessCommit.compare(actualWitnessCommit) === 0;
      }
    };
    exports2.Block = Block;
    function txesHaveWitnessCommit(transactions) {
      return transactions instanceof Array && transactions[0] && transactions[0].ins && transactions[0].ins instanceof Array && transactions[0].ins[0] && transactions[0].ins[0].witness && transactions[0].ins[0].witness instanceof Array && transactions[0].ins[0].witness.length > 0;
    }
    function anyTxHasWitness(transactions) {
      return transactions instanceof Array && transactions.some(
        (tx) => typeof tx === "object" && tx.ins instanceof Array && tx.ins.some(
          (input) => typeof input === "object" && input.witness instanceof Array && input.witness.length > 0
        )
      );
    }
  }
});

// node_modules/bip174/src/lib/typeFields.js
var require_typeFields = __commonJS({
  "node_modules/bip174/src/lib/typeFields.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var GlobalTypes;
    (function(GlobalTypes2) {
      GlobalTypes2[GlobalTypes2["UNSIGNED_TX"] = 0] = "UNSIGNED_TX";
      GlobalTypes2[GlobalTypes2["GLOBAL_XPUB"] = 1] = "GLOBAL_XPUB";
    })(GlobalTypes = exports2.GlobalTypes || (exports2.GlobalTypes = {}));
    exports2.GLOBAL_TYPE_NAMES = ["unsignedTx", "globalXpub"];
    var InputTypes;
    (function(InputTypes2) {
      InputTypes2[InputTypes2["NON_WITNESS_UTXO"] = 0] = "NON_WITNESS_UTXO";
      InputTypes2[InputTypes2["WITNESS_UTXO"] = 1] = "WITNESS_UTXO";
      InputTypes2[InputTypes2["PARTIAL_SIG"] = 2] = "PARTIAL_SIG";
      InputTypes2[InputTypes2["SIGHASH_TYPE"] = 3] = "SIGHASH_TYPE";
      InputTypes2[InputTypes2["REDEEM_SCRIPT"] = 4] = "REDEEM_SCRIPT";
      InputTypes2[InputTypes2["WITNESS_SCRIPT"] = 5] = "WITNESS_SCRIPT";
      InputTypes2[InputTypes2["BIP32_DERIVATION"] = 6] = "BIP32_DERIVATION";
      InputTypes2[InputTypes2["FINAL_SCRIPTSIG"] = 7] = "FINAL_SCRIPTSIG";
      InputTypes2[InputTypes2["FINAL_SCRIPTWITNESS"] = 8] = "FINAL_SCRIPTWITNESS";
      InputTypes2[InputTypes2["POR_COMMITMENT"] = 9] = "POR_COMMITMENT";
      InputTypes2[InputTypes2["TAP_KEY_SIG"] = 19] = "TAP_KEY_SIG";
      InputTypes2[InputTypes2["TAP_SCRIPT_SIG"] = 20] = "TAP_SCRIPT_SIG";
      InputTypes2[InputTypes2["TAP_LEAF_SCRIPT"] = 21] = "TAP_LEAF_SCRIPT";
      InputTypes2[InputTypes2["TAP_BIP32_DERIVATION"] = 22] = "TAP_BIP32_DERIVATION";
      InputTypes2[InputTypes2["TAP_INTERNAL_KEY"] = 23] = "TAP_INTERNAL_KEY";
      InputTypes2[InputTypes2["TAP_MERKLE_ROOT"] = 24] = "TAP_MERKLE_ROOT";
    })(InputTypes = exports2.InputTypes || (exports2.InputTypes = {}));
    exports2.INPUT_TYPE_NAMES = [
      "nonWitnessUtxo",
      "witnessUtxo",
      "partialSig",
      "sighashType",
      "redeemScript",
      "witnessScript",
      "bip32Derivation",
      "finalScriptSig",
      "finalScriptWitness",
      "porCommitment",
      "tapKeySig",
      "tapScriptSig",
      "tapLeafScript",
      "tapBip32Derivation",
      "tapInternalKey",
      "tapMerkleRoot"
    ];
    var OutputTypes;
    (function(OutputTypes2) {
      OutputTypes2[OutputTypes2["REDEEM_SCRIPT"] = 0] = "REDEEM_SCRIPT";
      OutputTypes2[OutputTypes2["WITNESS_SCRIPT"] = 1] = "WITNESS_SCRIPT";
      OutputTypes2[OutputTypes2["BIP32_DERIVATION"] = 2] = "BIP32_DERIVATION";
      OutputTypes2[OutputTypes2["TAP_INTERNAL_KEY"] = 5] = "TAP_INTERNAL_KEY";
      OutputTypes2[OutputTypes2["TAP_TREE"] = 6] = "TAP_TREE";
      OutputTypes2[OutputTypes2["TAP_BIP32_DERIVATION"] = 7] = "TAP_BIP32_DERIVATION";
    })(OutputTypes = exports2.OutputTypes || (exports2.OutputTypes = {}));
    exports2.OUTPUT_TYPE_NAMES = [
      "redeemScript",
      "witnessScript",
      "bip32Derivation",
      "tapInternalKey",
      "tapTree",
      "tapBip32Derivation"
    ];
  }
});

// node_modules/bip174/src/lib/converter/global/globalXpub.js
var require_globalXpub = __commonJS({
  "node_modules/bip174/src/lib/converter/global/globalXpub.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    var range = (n) => [...Array(n).keys()];
    function decode(keyVal) {
      if (keyVal.key[0] !== typeFields_1.GlobalTypes.GLOBAL_XPUB) {
        throw new Error(
          "Decode Error: could not decode globalXpub with key 0x" + keyVal.key.toString("hex")
        );
      }
      if (keyVal.key.length !== 79 || ![2, 3].includes(keyVal.key[46])) {
        throw new Error(
          "Decode Error: globalXpub has invalid extended pubkey in key 0x" + keyVal.key.toString("hex")
        );
      }
      if (keyVal.value.length / 4 % 1 !== 0) {
        throw new Error(
          "Decode Error: Global GLOBAL_XPUB value length should be multiple of 4"
        );
      }
      const extendedPubkey = keyVal.key.slice(1);
      const data = {
        masterFingerprint: keyVal.value.slice(0, 4),
        extendedPubkey,
        path: "m"
      };
      for (const i of range(keyVal.value.length / 4 - 1)) {
        const val = keyVal.value.readUInt32LE(i * 4 + 4);
        const isHard = !!(val & 2147483648);
        const idx = val & 2147483647;
        data.path += "/" + idx.toString(10) + (isHard ? "'" : "");
      }
      return data;
    }
    exports2.decode = decode;
    function encode(data) {
      const head = Buffer.from([typeFields_1.GlobalTypes.GLOBAL_XPUB]);
      const key = Buffer.concat([head, data.extendedPubkey]);
      const splitPath = data.path.split("/");
      const value = Buffer.allocUnsafe(splitPath.length * 4);
      data.masterFingerprint.copy(value, 0);
      let offset = 4;
      splitPath.slice(1).forEach((level) => {
        const isHard = level.slice(-1) === "'";
        let num = 2147483647 & parseInt(isHard ? level.slice(0, -1) : level, 10);
        if (isHard) num += 2147483648;
        value.writeUInt32LE(num, offset);
        offset += 4;
      });
      return {
        key,
        value
      };
    }
    exports2.encode = encode;
    exports2.expected = "{ masterFingerprint: Buffer; extendedPubkey: Buffer; path: string; }";
    function check(data) {
      const epk = data.extendedPubkey;
      const mfp = data.masterFingerprint;
      const p = data.path;
      return Buffer.isBuffer(epk) && epk.length === 78 && [2, 3].indexOf(epk[45]) > -1 && Buffer.isBuffer(mfp) && mfp.length === 4 && typeof p === "string" && !!p.match(/^m(\/\d+'?)*$/);
    }
    exports2.check = check;
    function canAddToArray(array, item, dupeSet) {
      const dupeString = item.extendedPubkey.toString("hex");
      if (dupeSet.has(dupeString)) return false;
      dupeSet.add(dupeString);
      return array.filter((v) => v.extendedPubkey.equals(item.extendedPubkey)).length === 0;
    }
    exports2.canAddToArray = canAddToArray;
  }
});

// node_modules/bip174/src/lib/converter/global/unsignedTx.js
var require_unsignedTx = __commonJS({
  "node_modules/bip174/src/lib/converter/global/unsignedTx.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    function encode(data) {
      return {
        key: Buffer.from([typeFields_1.GlobalTypes.UNSIGNED_TX]),
        value: data.toBuffer()
      };
    }
    exports2.encode = encode;
  }
});

// node_modules/bip174/src/lib/converter/input/finalScriptSig.js
var require_finalScriptSig = __commonJS({
  "node_modules/bip174/src/lib/converter/input/finalScriptSig.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    function decode(keyVal) {
      if (keyVal.key[0] !== typeFields_1.InputTypes.FINAL_SCRIPTSIG) {
        throw new Error(
          "Decode Error: could not decode finalScriptSig with key 0x" + keyVal.key.toString("hex")
        );
      }
      return keyVal.value;
    }
    exports2.decode = decode;
    function encode(data) {
      const key = Buffer.from([typeFields_1.InputTypes.FINAL_SCRIPTSIG]);
      return {
        key,
        value: data
      };
    }
    exports2.encode = encode;
    exports2.expected = "Buffer";
    function check(data) {
      return Buffer.isBuffer(data);
    }
    exports2.check = check;
    function canAdd(currentData, newData) {
      return !!currentData && !!newData && currentData.finalScriptSig === void 0;
    }
    exports2.canAdd = canAdd;
  }
});

// node_modules/bip174/src/lib/converter/input/finalScriptWitness.js
var require_finalScriptWitness = __commonJS({
  "node_modules/bip174/src/lib/converter/input/finalScriptWitness.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    function decode(keyVal) {
      if (keyVal.key[0] !== typeFields_1.InputTypes.FINAL_SCRIPTWITNESS) {
        throw new Error(
          "Decode Error: could not decode finalScriptWitness with key 0x" + keyVal.key.toString("hex")
        );
      }
      return keyVal.value;
    }
    exports2.decode = decode;
    function encode(data) {
      const key = Buffer.from([typeFields_1.InputTypes.FINAL_SCRIPTWITNESS]);
      return {
        key,
        value: data
      };
    }
    exports2.encode = encode;
    exports2.expected = "Buffer";
    function check(data) {
      return Buffer.isBuffer(data);
    }
    exports2.check = check;
    function canAdd(currentData, newData) {
      return !!currentData && !!newData && currentData.finalScriptWitness === void 0;
    }
    exports2.canAdd = canAdd;
  }
});

// node_modules/bip174/src/lib/converter/input/nonWitnessUtxo.js
var require_nonWitnessUtxo = __commonJS({
  "node_modules/bip174/src/lib/converter/input/nonWitnessUtxo.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    function decode(keyVal) {
      if (keyVal.key[0] !== typeFields_1.InputTypes.NON_WITNESS_UTXO) {
        throw new Error(
          "Decode Error: could not decode nonWitnessUtxo with key 0x" + keyVal.key.toString("hex")
        );
      }
      return keyVal.value;
    }
    exports2.decode = decode;
    function encode(data) {
      return {
        key: Buffer.from([typeFields_1.InputTypes.NON_WITNESS_UTXO]),
        value: data
      };
    }
    exports2.encode = encode;
    exports2.expected = "Buffer";
    function check(data) {
      return Buffer.isBuffer(data);
    }
    exports2.check = check;
    function canAdd(currentData, newData) {
      return !!currentData && !!newData && currentData.nonWitnessUtxo === void 0;
    }
    exports2.canAdd = canAdd;
  }
});

// node_modules/bip174/src/lib/converter/input/partialSig.js
var require_partialSig = __commonJS({
  "node_modules/bip174/src/lib/converter/input/partialSig.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    function decode(keyVal) {
      if (keyVal.key[0] !== typeFields_1.InputTypes.PARTIAL_SIG) {
        throw new Error(
          "Decode Error: could not decode partialSig with key 0x" + keyVal.key.toString("hex")
        );
      }
      if (!(keyVal.key.length === 34 || keyVal.key.length === 66) || ![2, 3, 4].includes(keyVal.key[1])) {
        throw new Error(
          "Decode Error: partialSig has invalid pubkey in key 0x" + keyVal.key.toString("hex")
        );
      }
      const pubkey = keyVal.key.slice(1);
      return {
        pubkey,
        signature: keyVal.value
      };
    }
    exports2.decode = decode;
    function encode(pSig) {
      const head = Buffer.from([typeFields_1.InputTypes.PARTIAL_SIG]);
      return {
        key: Buffer.concat([head, pSig.pubkey]),
        value: pSig.signature
      };
    }
    exports2.encode = encode;
    exports2.expected = "{ pubkey: Buffer; signature: Buffer; }";
    function check(data) {
      return Buffer.isBuffer(data.pubkey) && Buffer.isBuffer(data.signature) && [33, 65].includes(data.pubkey.length) && [2, 3, 4].includes(data.pubkey[0]) && isDerSigWithSighash(data.signature);
    }
    exports2.check = check;
    function isDerSigWithSighash(buf) {
      if (!Buffer.isBuffer(buf) || buf.length < 9) return false;
      if (buf[0] !== 48) return false;
      if (buf.length !== buf[1] + 3) return false;
      if (buf[2] !== 2) return false;
      const rLen = buf[3];
      if (rLen > 33 || rLen < 1) return false;
      if (buf[3 + rLen + 1] !== 2) return false;
      const sLen = buf[3 + rLen + 2];
      if (sLen > 33 || sLen < 1) return false;
      if (buf.length !== 3 + rLen + 2 + sLen + 2) return false;
      return true;
    }
    function canAddToArray(array, item, dupeSet) {
      const dupeString = item.pubkey.toString("hex");
      if (dupeSet.has(dupeString)) return false;
      dupeSet.add(dupeString);
      return array.filter((v) => v.pubkey.equals(item.pubkey)).length === 0;
    }
    exports2.canAddToArray = canAddToArray;
  }
});

// node_modules/bip174/src/lib/converter/input/porCommitment.js
var require_porCommitment = __commonJS({
  "node_modules/bip174/src/lib/converter/input/porCommitment.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    function decode(keyVal) {
      if (keyVal.key[0] !== typeFields_1.InputTypes.POR_COMMITMENT) {
        throw new Error(
          "Decode Error: could not decode porCommitment with key 0x" + keyVal.key.toString("hex")
        );
      }
      return keyVal.value.toString("utf8");
    }
    exports2.decode = decode;
    function encode(data) {
      const key = Buffer.from([typeFields_1.InputTypes.POR_COMMITMENT]);
      return {
        key,
        value: Buffer.from(data, "utf8")
      };
    }
    exports2.encode = encode;
    exports2.expected = "string";
    function check(data) {
      return typeof data === "string";
    }
    exports2.check = check;
    function canAdd(currentData, newData) {
      return !!currentData && !!newData && currentData.porCommitment === void 0;
    }
    exports2.canAdd = canAdd;
  }
});

// node_modules/bip174/src/lib/converter/input/sighashType.js
var require_sighashType = __commonJS({
  "node_modules/bip174/src/lib/converter/input/sighashType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    function decode(keyVal) {
      if (keyVal.key[0] !== typeFields_1.InputTypes.SIGHASH_TYPE) {
        throw new Error(
          "Decode Error: could not decode sighashType with key 0x" + keyVal.key.toString("hex")
        );
      }
      return keyVal.value.readUInt32LE(0);
    }
    exports2.decode = decode;
    function encode(data) {
      const key = Buffer.from([typeFields_1.InputTypes.SIGHASH_TYPE]);
      const value = Buffer.allocUnsafe(4);
      value.writeUInt32LE(data, 0);
      return {
        key,
        value
      };
    }
    exports2.encode = encode;
    exports2.expected = "number";
    function check(data) {
      return typeof data === "number";
    }
    exports2.check = check;
    function canAdd(currentData, newData) {
      return !!currentData && !!newData && currentData.sighashType === void 0;
    }
    exports2.canAdd = canAdd;
  }
});

// node_modules/bip174/src/lib/converter/input/tapKeySig.js
var require_tapKeySig = __commonJS({
  "node_modules/bip174/src/lib/converter/input/tapKeySig.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    function decode(keyVal) {
      if (keyVal.key[0] !== typeFields_1.InputTypes.TAP_KEY_SIG || keyVal.key.length !== 1) {
        throw new Error(
          "Decode Error: could not decode tapKeySig with key 0x" + keyVal.key.toString("hex")
        );
      }
      if (!check(keyVal.value)) {
        throw new Error(
          "Decode Error: tapKeySig not a valid 64-65-byte BIP340 signature"
        );
      }
      return keyVal.value;
    }
    exports2.decode = decode;
    function encode(value) {
      const key = Buffer.from([typeFields_1.InputTypes.TAP_KEY_SIG]);
      return { key, value };
    }
    exports2.encode = encode;
    exports2.expected = "Buffer";
    function check(data) {
      return Buffer.isBuffer(data) && (data.length === 64 || data.length === 65);
    }
    exports2.check = check;
    function canAdd(currentData, newData) {
      return !!currentData && !!newData && currentData.tapKeySig === void 0;
    }
    exports2.canAdd = canAdd;
  }
});

// node_modules/bip174/src/lib/converter/input/tapLeafScript.js
var require_tapLeafScript = __commonJS({
  "node_modules/bip174/src/lib/converter/input/tapLeafScript.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    function decode(keyVal) {
      if (keyVal.key[0] !== typeFields_1.InputTypes.TAP_LEAF_SCRIPT) {
        throw new Error(
          "Decode Error: could not decode tapLeafScript with key 0x" + keyVal.key.toString("hex")
        );
      }
      if ((keyVal.key.length - 2) % 32 !== 0) {
        throw new Error(
          "Decode Error: tapLeafScript has invalid control block in key 0x" + keyVal.key.toString("hex")
        );
      }
      const leafVersion = keyVal.value[keyVal.value.length - 1];
      if ((keyVal.key[1] & 254) !== leafVersion) {
        throw new Error(
          "Decode Error: tapLeafScript bad leaf version in key 0x" + keyVal.key.toString("hex")
        );
      }
      const script = keyVal.value.slice(0, -1);
      const controlBlock = keyVal.key.slice(1);
      return { controlBlock, script, leafVersion };
    }
    exports2.decode = decode;
    function encode(tScript) {
      const head = Buffer.from([typeFields_1.InputTypes.TAP_LEAF_SCRIPT]);
      const verBuf = Buffer.from([tScript.leafVersion]);
      return {
        key: Buffer.concat([head, tScript.controlBlock]),
        value: Buffer.concat([tScript.script, verBuf])
      };
    }
    exports2.encode = encode;
    exports2.expected = "{ controlBlock: Buffer; leafVersion: number, script: Buffer; }";
    function check(data) {
      return Buffer.isBuffer(data.controlBlock) && (data.controlBlock.length - 1) % 32 === 0 && (data.controlBlock[0] & 254) === data.leafVersion && Buffer.isBuffer(data.script);
    }
    exports2.check = check;
    function canAddToArray(array, item, dupeSet) {
      const dupeString = item.controlBlock.toString("hex");
      if (dupeSet.has(dupeString)) return false;
      dupeSet.add(dupeString);
      return array.filter((v) => v.controlBlock.equals(item.controlBlock)).length === 0;
    }
    exports2.canAddToArray = canAddToArray;
  }
});

// node_modules/bip174/src/lib/converter/input/tapMerkleRoot.js
var require_tapMerkleRoot = __commonJS({
  "node_modules/bip174/src/lib/converter/input/tapMerkleRoot.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    function decode(keyVal) {
      if (keyVal.key[0] !== typeFields_1.InputTypes.TAP_MERKLE_ROOT || keyVal.key.length !== 1) {
        throw new Error(
          "Decode Error: could not decode tapMerkleRoot with key 0x" + keyVal.key.toString("hex")
        );
      }
      if (!check(keyVal.value)) {
        throw new Error("Decode Error: tapMerkleRoot not a 32-byte hash");
      }
      return keyVal.value;
    }
    exports2.decode = decode;
    function encode(value) {
      const key = Buffer.from([typeFields_1.InputTypes.TAP_MERKLE_ROOT]);
      return { key, value };
    }
    exports2.encode = encode;
    exports2.expected = "Buffer";
    function check(data) {
      return Buffer.isBuffer(data) && data.length === 32;
    }
    exports2.check = check;
    function canAdd(currentData, newData) {
      return !!currentData && !!newData && currentData.tapMerkleRoot === void 0;
    }
    exports2.canAdd = canAdd;
  }
});

// node_modules/bip174/src/lib/converter/input/tapScriptSig.js
var require_tapScriptSig = __commonJS({
  "node_modules/bip174/src/lib/converter/input/tapScriptSig.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    function decode(keyVal) {
      if (keyVal.key[0] !== typeFields_1.InputTypes.TAP_SCRIPT_SIG) {
        throw new Error(
          "Decode Error: could not decode tapScriptSig with key 0x" + keyVal.key.toString("hex")
        );
      }
      if (keyVal.key.length !== 65) {
        throw new Error(
          "Decode Error: tapScriptSig has invalid key 0x" + keyVal.key.toString("hex")
        );
      }
      if (keyVal.value.length !== 64 && keyVal.value.length !== 65) {
        throw new Error(
          "Decode Error: tapScriptSig has invalid signature in key 0x" + keyVal.key.toString("hex")
        );
      }
      const pubkey = keyVal.key.slice(1, 33);
      const leafHash = keyVal.key.slice(33);
      return {
        pubkey,
        leafHash,
        signature: keyVal.value
      };
    }
    exports2.decode = decode;
    function encode(tSig) {
      const head = Buffer.from([typeFields_1.InputTypes.TAP_SCRIPT_SIG]);
      return {
        key: Buffer.concat([head, tSig.pubkey, tSig.leafHash]),
        value: tSig.signature
      };
    }
    exports2.encode = encode;
    exports2.expected = "{ pubkey: Buffer; leafHash: Buffer; signature: Buffer; }";
    function check(data) {
      return Buffer.isBuffer(data.pubkey) && Buffer.isBuffer(data.leafHash) && Buffer.isBuffer(data.signature) && data.pubkey.length === 32 && data.leafHash.length === 32 && (data.signature.length === 64 || data.signature.length === 65);
    }
    exports2.check = check;
    function canAddToArray(array, item, dupeSet) {
      const dupeString = item.pubkey.toString("hex") + item.leafHash.toString("hex");
      if (dupeSet.has(dupeString)) return false;
      dupeSet.add(dupeString);
      return array.filter(
        (v) => v.pubkey.equals(item.pubkey) && v.leafHash.equals(item.leafHash)
      ).length === 0;
    }
    exports2.canAddToArray = canAddToArray;
  }
});

// node_modules/bip174/src/lib/converter/varint.js
var require_varint = __commonJS({
  "node_modules/bip174/src/lib/converter/varint.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var MAX_SAFE_INTEGER = 9007199254740991;
    function checkUInt53(n) {
      if (n < 0 || n > MAX_SAFE_INTEGER || n % 1 !== 0)
        throw new RangeError("value out of range");
    }
    function encode(_number, buffer, offset) {
      checkUInt53(_number);
      if (!buffer) buffer = Buffer.allocUnsafe(encodingLength(_number));
      if (!Buffer.isBuffer(buffer))
        throw new TypeError("buffer must be a Buffer instance");
      if (!offset) offset = 0;
      if (_number < 253) {
        buffer.writeUInt8(_number, offset);
        Object.assign(encode, { bytes: 1 });
      } else if (_number <= 65535) {
        buffer.writeUInt8(253, offset);
        buffer.writeUInt16LE(_number, offset + 1);
        Object.assign(encode, { bytes: 3 });
      } else if (_number <= 4294967295) {
        buffer.writeUInt8(254, offset);
        buffer.writeUInt32LE(_number, offset + 1);
        Object.assign(encode, { bytes: 5 });
      } else {
        buffer.writeUInt8(255, offset);
        buffer.writeUInt32LE(_number >>> 0, offset + 1);
        buffer.writeUInt32LE(_number / 4294967296 | 0, offset + 5);
        Object.assign(encode, { bytes: 9 });
      }
      return buffer;
    }
    exports2.encode = encode;
    function decode(buffer, offset) {
      if (!Buffer.isBuffer(buffer))
        throw new TypeError("buffer must be a Buffer instance");
      if (!offset) offset = 0;
      const first = buffer.readUInt8(offset);
      if (first < 253) {
        Object.assign(decode, { bytes: 1 });
        return first;
      } else if (first === 253) {
        Object.assign(decode, { bytes: 3 });
        return buffer.readUInt16LE(offset + 1);
      } else if (first === 254) {
        Object.assign(decode, { bytes: 5 });
        return buffer.readUInt32LE(offset + 1);
      } else {
        Object.assign(decode, { bytes: 9 });
        const lo = buffer.readUInt32LE(offset + 1);
        const hi = buffer.readUInt32LE(offset + 5);
        const _number = hi * 4294967296 + lo;
        checkUInt53(_number);
        return _number;
      }
    }
    exports2.decode = decode;
    function encodingLength(_number) {
      checkUInt53(_number);
      return _number < 253 ? 1 : _number <= 65535 ? 3 : _number <= 4294967295 ? 5 : 9;
    }
    exports2.encodingLength = encodingLength;
  }
});

// node_modules/bip174/src/lib/converter/tools.js
var require_tools = __commonJS({
  "node_modules/bip174/src/lib/converter/tools.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var varuint2 = require_varint();
    exports2.range = (n) => [...Array(n).keys()];
    function reverseBuffer(buffer) {
      if (buffer.length < 1) return buffer;
      let j = buffer.length - 1;
      let tmp = 0;
      for (let i = 0; i < buffer.length / 2; i++) {
        tmp = buffer[i];
        buffer[i] = buffer[j];
        buffer[j] = tmp;
        j--;
      }
      return buffer;
    }
    exports2.reverseBuffer = reverseBuffer;
    function keyValsToBuffer(keyVals) {
      const buffers = keyVals.map(keyValToBuffer);
      buffers.push(Buffer.from([0]));
      return Buffer.concat(buffers);
    }
    exports2.keyValsToBuffer = keyValsToBuffer;
    function keyValToBuffer(keyVal) {
      const keyLen = keyVal.key.length;
      const valLen = keyVal.value.length;
      const keyVarIntLen = varuint2.encodingLength(keyLen);
      const valVarIntLen = varuint2.encodingLength(valLen);
      const buffer = Buffer.allocUnsafe(
        keyVarIntLen + keyLen + valVarIntLen + valLen
      );
      varuint2.encode(keyLen, buffer, 0);
      keyVal.key.copy(buffer, keyVarIntLen);
      varuint2.encode(valLen, buffer, keyVarIntLen + keyLen);
      keyVal.value.copy(buffer, keyVarIntLen + keyLen + valVarIntLen);
      return buffer;
    }
    exports2.keyValToBuffer = keyValToBuffer;
    function verifuint(value, max) {
      if (typeof value !== "number")
        throw new Error("cannot write a non-number as a number");
      if (value < 0)
        throw new Error("specified a negative value for writing an unsigned value");
      if (value > max) throw new Error("RangeError: value out of range");
      if (Math.floor(value) !== value)
        throw new Error("value has a fractional component");
    }
    function readUInt64LE(buffer, offset) {
      const a = buffer.readUInt32LE(offset);
      let b2 = buffer.readUInt32LE(offset + 4);
      b2 *= 4294967296;
      verifuint(b2 + a, 9007199254740991);
      return b2 + a;
    }
    exports2.readUInt64LE = readUInt64LE;
    function writeUInt64LE(buffer, value, offset) {
      verifuint(value, 9007199254740991);
      buffer.writeInt32LE(value & -1, offset);
      buffer.writeUInt32LE(Math.floor(value / 4294967296), offset + 4);
      return offset + 8;
    }
    exports2.writeUInt64LE = writeUInt64LE;
  }
});

// node_modules/bip174/src/lib/converter/input/witnessUtxo.js
var require_witnessUtxo = __commonJS({
  "node_modules/bip174/src/lib/converter/input/witnessUtxo.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    var tools_1 = require_tools();
    var varuint2 = require_varint();
    function decode(keyVal) {
      if (keyVal.key[0] !== typeFields_1.InputTypes.WITNESS_UTXO) {
        throw new Error(
          "Decode Error: could not decode witnessUtxo with key 0x" + keyVal.key.toString("hex")
        );
      }
      const value = tools_1.readUInt64LE(keyVal.value, 0);
      let _offset = 8;
      const scriptLen = varuint2.decode(keyVal.value, _offset);
      _offset += varuint2.encodingLength(scriptLen);
      const script = keyVal.value.slice(_offset);
      if (script.length !== scriptLen) {
        throw new Error("Decode Error: WITNESS_UTXO script is not proper length");
      }
      return {
        script,
        value
      };
    }
    exports2.decode = decode;
    function encode(data) {
      const { script, value } = data;
      const varintLen = varuint2.encodingLength(script.length);
      const result = Buffer.allocUnsafe(8 + varintLen + script.length);
      tools_1.writeUInt64LE(result, value, 0);
      varuint2.encode(script.length, result, 8);
      script.copy(result, 8 + varintLen);
      return {
        key: Buffer.from([typeFields_1.InputTypes.WITNESS_UTXO]),
        value: result
      };
    }
    exports2.encode = encode;
    exports2.expected = "{ script: Buffer; value: number; }";
    function check(data) {
      return Buffer.isBuffer(data.script) && typeof data.value === "number";
    }
    exports2.check = check;
    function canAdd(currentData, newData) {
      return !!currentData && !!newData && currentData.witnessUtxo === void 0;
    }
    exports2.canAdd = canAdd;
  }
});

// node_modules/bip174/src/lib/converter/output/tapTree.js
var require_tapTree = __commonJS({
  "node_modules/bip174/src/lib/converter/output/tapTree.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    var varuint2 = require_varint();
    function decode(keyVal) {
      if (keyVal.key[0] !== typeFields_1.OutputTypes.TAP_TREE || keyVal.key.length !== 1) {
        throw new Error(
          "Decode Error: could not decode tapTree with key 0x" + keyVal.key.toString("hex")
        );
      }
      let _offset = 0;
      const data = [];
      while (_offset < keyVal.value.length) {
        const depth = keyVal.value[_offset++];
        const leafVersion = keyVal.value[_offset++];
        const scriptLen = varuint2.decode(keyVal.value, _offset);
        _offset += varuint2.encodingLength(scriptLen);
        data.push({
          depth,
          leafVersion,
          script: keyVal.value.slice(_offset, _offset + scriptLen)
        });
        _offset += scriptLen;
      }
      return { leaves: data };
    }
    exports2.decode = decode;
    function encode(tree) {
      const key = Buffer.from([typeFields_1.OutputTypes.TAP_TREE]);
      const bufs = [].concat(
        ...tree.leaves.map((tapLeaf) => [
          Buffer.of(tapLeaf.depth, tapLeaf.leafVersion),
          varuint2.encode(tapLeaf.script.length),
          tapLeaf.script
        ])
      );
      return {
        key,
        value: Buffer.concat(bufs)
      };
    }
    exports2.encode = encode;
    exports2.expected = "{ leaves: [{ depth: number; leafVersion: number, script: Buffer; }] }";
    function check(data) {
      return Array.isArray(data.leaves) && data.leaves.every(
        (tapLeaf) => tapLeaf.depth >= 0 && tapLeaf.depth <= 128 && (tapLeaf.leafVersion & 254) === tapLeaf.leafVersion && Buffer.isBuffer(tapLeaf.script)
      );
    }
    exports2.check = check;
    function canAdd(currentData, newData) {
      return !!currentData && !!newData && currentData.tapTree === void 0;
    }
    exports2.canAdd = canAdd;
  }
});

// node_modules/bip174/src/lib/converter/shared/bip32Derivation.js
var require_bip32Derivation = __commonJS({
  "node_modules/bip174/src/lib/converter/shared/bip32Derivation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var range = (n) => [...Array(n).keys()];
    var isValidDERKey = (pubkey) => pubkey.length === 33 && [2, 3].includes(pubkey[0]) || pubkey.length === 65 && 4 === pubkey[0];
    function makeConverter(TYPE_BYTE, isValidPubkey = isValidDERKey) {
      function decode(keyVal) {
        if (keyVal.key[0] !== TYPE_BYTE) {
          throw new Error(
            "Decode Error: could not decode bip32Derivation with key 0x" + keyVal.key.toString("hex")
          );
        }
        const pubkey = keyVal.key.slice(1);
        if (!isValidPubkey(pubkey)) {
          throw new Error(
            "Decode Error: bip32Derivation has invalid pubkey in key 0x" + keyVal.key.toString("hex")
          );
        }
        if (keyVal.value.length / 4 % 1 !== 0) {
          throw new Error(
            "Decode Error: Input BIP32_DERIVATION value length should be multiple of 4"
          );
        }
        const data = {
          masterFingerprint: keyVal.value.slice(0, 4),
          pubkey,
          path: "m"
        };
        for (const i of range(keyVal.value.length / 4 - 1)) {
          const val = keyVal.value.readUInt32LE(i * 4 + 4);
          const isHard = !!(val & 2147483648);
          const idx = val & 2147483647;
          data.path += "/" + idx.toString(10) + (isHard ? "'" : "");
        }
        return data;
      }
      function encode(data) {
        const head = Buffer.from([TYPE_BYTE]);
        const key = Buffer.concat([head, data.pubkey]);
        const splitPath = data.path.split("/");
        const value = Buffer.allocUnsafe(splitPath.length * 4);
        data.masterFingerprint.copy(value, 0);
        let offset = 4;
        splitPath.slice(1).forEach((level) => {
          const isHard = level.slice(-1) === "'";
          let num = 2147483647 & parseInt(isHard ? level.slice(0, -1) : level, 10);
          if (isHard) num += 2147483648;
          value.writeUInt32LE(num, offset);
          offset += 4;
        });
        return {
          key,
          value
        };
      }
      const expected = "{ masterFingerprint: Buffer; pubkey: Buffer; path: string; }";
      function check(data) {
        return Buffer.isBuffer(data.pubkey) && Buffer.isBuffer(data.masterFingerprint) && typeof data.path === "string" && isValidPubkey(data.pubkey) && data.masterFingerprint.length === 4;
      }
      function canAddToArray(array, item, dupeSet) {
        const dupeString = item.pubkey.toString("hex");
        if (dupeSet.has(dupeString)) return false;
        dupeSet.add(dupeString);
        return array.filter((v) => v.pubkey.equals(item.pubkey)).length === 0;
      }
      return {
        decode,
        encode,
        check,
        expected,
        canAddToArray
      };
    }
    exports2.makeConverter = makeConverter;
  }
});

// node_modules/bip174/src/lib/converter/shared/checkPubkey.js
var require_checkPubkey = __commonJS({
  "node_modules/bip174/src/lib/converter/shared/checkPubkey.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function makeChecker(pubkeyTypes) {
      return checkPubkey;
      function checkPubkey(keyVal) {
        let pubkey;
        if (pubkeyTypes.includes(keyVal.key[0])) {
          pubkey = keyVal.key.slice(1);
          if (!(pubkey.length === 33 || pubkey.length === 65) || ![2, 3, 4].includes(pubkey[0])) {
            throw new Error(
              "Format Error: invalid pubkey in key 0x" + keyVal.key.toString("hex")
            );
          }
        }
        return pubkey;
      }
    }
    exports2.makeChecker = makeChecker;
  }
});

// node_modules/bip174/src/lib/converter/shared/redeemScript.js
var require_redeemScript = __commonJS({
  "node_modules/bip174/src/lib/converter/shared/redeemScript.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function makeConverter(TYPE_BYTE) {
      function decode(keyVal) {
        if (keyVal.key[0] !== TYPE_BYTE) {
          throw new Error(
            "Decode Error: could not decode redeemScript with key 0x" + keyVal.key.toString("hex")
          );
        }
        return keyVal.value;
      }
      function encode(data) {
        const key = Buffer.from([TYPE_BYTE]);
        return {
          key,
          value: data
        };
      }
      const expected = "Buffer";
      function check(data) {
        return Buffer.isBuffer(data);
      }
      function canAdd(currentData, newData) {
        return !!currentData && !!newData && currentData.redeemScript === void 0;
      }
      return {
        decode,
        encode,
        check,
        expected,
        canAdd
      };
    }
    exports2.makeConverter = makeConverter;
  }
});

// node_modules/bip174/src/lib/converter/shared/tapBip32Derivation.js
var require_tapBip32Derivation = __commonJS({
  "node_modules/bip174/src/lib/converter/shared/tapBip32Derivation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var varuint2 = require_varint();
    var bip32Derivation = require_bip32Derivation();
    var isValidBIP340Key = (pubkey) => pubkey.length === 32;
    function makeConverter(TYPE_BYTE) {
      const parent = bip32Derivation.makeConverter(TYPE_BYTE, isValidBIP340Key);
      function decode(keyVal) {
        const nHashes = varuint2.decode(keyVal.value);
        const nHashesLen = varuint2.encodingLength(nHashes);
        const base = parent.decode({
          key: keyVal.key,
          value: keyVal.value.slice(nHashesLen + nHashes * 32)
        });
        const leafHashes = new Array(nHashes);
        for (let i = 0, _offset = nHashesLen; i < nHashes; i++, _offset += 32) {
          leafHashes[i] = keyVal.value.slice(_offset, _offset + 32);
        }
        return Object.assign({}, base, { leafHashes });
      }
      function encode(data) {
        const base = parent.encode(data);
        const nHashesLen = varuint2.encodingLength(data.leafHashes.length);
        const nHashesBuf = Buffer.allocUnsafe(nHashesLen);
        varuint2.encode(data.leafHashes.length, nHashesBuf);
        const value = Buffer.concat([nHashesBuf, ...data.leafHashes, base.value]);
        return Object.assign({}, base, { value });
      }
      const expected = "{ masterFingerprint: Buffer; pubkey: Buffer; path: string; leafHashes: Buffer[]; }";
      function check(data) {
        return Array.isArray(data.leafHashes) && data.leafHashes.every(
          (leafHash) => Buffer.isBuffer(leafHash) && leafHash.length === 32
        ) && parent.check(data);
      }
      return {
        decode,
        encode,
        check,
        expected,
        canAddToArray: parent.canAddToArray
      };
    }
    exports2.makeConverter = makeConverter;
  }
});

// node_modules/bip174/src/lib/converter/shared/tapInternalKey.js
var require_tapInternalKey = __commonJS({
  "node_modules/bip174/src/lib/converter/shared/tapInternalKey.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function makeConverter(TYPE_BYTE) {
      function decode(keyVal) {
        if (keyVal.key[0] !== TYPE_BYTE || keyVal.key.length !== 1) {
          throw new Error(
            "Decode Error: could not decode tapInternalKey with key 0x" + keyVal.key.toString("hex")
          );
        }
        if (keyVal.value.length !== 32) {
          throw new Error(
            "Decode Error: tapInternalKey not a 32-byte x-only pubkey"
          );
        }
        return keyVal.value;
      }
      function encode(value) {
        const key = Buffer.from([TYPE_BYTE]);
        return { key, value };
      }
      const expected = "Buffer";
      function check(data) {
        return Buffer.isBuffer(data) && data.length === 32;
      }
      function canAdd(currentData, newData) {
        return !!currentData && !!newData && currentData.tapInternalKey === void 0;
      }
      return {
        decode,
        encode,
        check,
        expected,
        canAdd
      };
    }
    exports2.makeConverter = makeConverter;
  }
});

// node_modules/bip174/src/lib/converter/shared/witnessScript.js
var require_witnessScript = __commonJS({
  "node_modules/bip174/src/lib/converter/shared/witnessScript.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function makeConverter(TYPE_BYTE) {
      function decode(keyVal) {
        if (keyVal.key[0] !== TYPE_BYTE) {
          throw new Error(
            "Decode Error: could not decode witnessScript with key 0x" + keyVal.key.toString("hex")
          );
        }
        return keyVal.value;
      }
      function encode(data) {
        const key = Buffer.from([TYPE_BYTE]);
        return {
          key,
          value: data
        };
      }
      const expected = "Buffer";
      function check(data) {
        return Buffer.isBuffer(data);
      }
      function canAdd(currentData, newData) {
        return !!currentData && !!newData && currentData.witnessScript === void 0;
      }
      return {
        decode,
        encode,
        check,
        expected,
        canAdd
      };
    }
    exports2.makeConverter = makeConverter;
  }
});

// node_modules/bip174/src/lib/converter/index.js
var require_converter = __commonJS({
  "node_modules/bip174/src/lib/converter/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    var globalXpub = require_globalXpub();
    var unsignedTx = require_unsignedTx();
    var finalScriptSig = require_finalScriptSig();
    var finalScriptWitness = require_finalScriptWitness();
    var nonWitnessUtxo = require_nonWitnessUtxo();
    var partialSig = require_partialSig();
    var porCommitment = require_porCommitment();
    var sighashType = require_sighashType();
    var tapKeySig = require_tapKeySig();
    var tapLeafScript = require_tapLeafScript();
    var tapMerkleRoot = require_tapMerkleRoot();
    var tapScriptSig = require_tapScriptSig();
    var witnessUtxo = require_witnessUtxo();
    var tapTree = require_tapTree();
    var bip32Derivation = require_bip32Derivation();
    var checkPubkey = require_checkPubkey();
    var redeemScript = require_redeemScript();
    var tapBip32Derivation = require_tapBip32Derivation();
    var tapInternalKey = require_tapInternalKey();
    var witnessScript = require_witnessScript();
    var globals = {
      unsignedTx,
      globalXpub,
      // pass an Array of key bytes that require pubkey beside the key
      checkPubkey: checkPubkey.makeChecker([])
    };
    exports2.globals = globals;
    var inputs = {
      nonWitnessUtxo,
      partialSig,
      sighashType,
      finalScriptSig,
      finalScriptWitness,
      porCommitment,
      witnessUtxo,
      bip32Derivation: bip32Derivation.makeConverter(
        typeFields_1.InputTypes.BIP32_DERIVATION
      ),
      redeemScript: redeemScript.makeConverter(
        typeFields_1.InputTypes.REDEEM_SCRIPT
      ),
      witnessScript: witnessScript.makeConverter(
        typeFields_1.InputTypes.WITNESS_SCRIPT
      ),
      checkPubkey: checkPubkey.makeChecker([
        typeFields_1.InputTypes.PARTIAL_SIG,
        typeFields_1.InputTypes.BIP32_DERIVATION
      ]),
      tapKeySig,
      tapScriptSig,
      tapLeafScript,
      tapBip32Derivation: tapBip32Derivation.makeConverter(
        typeFields_1.InputTypes.TAP_BIP32_DERIVATION
      ),
      tapInternalKey: tapInternalKey.makeConverter(
        typeFields_1.InputTypes.TAP_INTERNAL_KEY
      ),
      tapMerkleRoot
    };
    exports2.inputs = inputs;
    var outputs = {
      bip32Derivation: bip32Derivation.makeConverter(
        typeFields_1.OutputTypes.BIP32_DERIVATION
      ),
      redeemScript: redeemScript.makeConverter(
        typeFields_1.OutputTypes.REDEEM_SCRIPT
      ),
      witnessScript: witnessScript.makeConverter(
        typeFields_1.OutputTypes.WITNESS_SCRIPT
      ),
      checkPubkey: checkPubkey.makeChecker([
        typeFields_1.OutputTypes.BIP32_DERIVATION
      ]),
      tapBip32Derivation: tapBip32Derivation.makeConverter(
        typeFields_1.OutputTypes.TAP_BIP32_DERIVATION
      ),
      tapTree,
      tapInternalKey: tapInternalKey.makeConverter(
        typeFields_1.OutputTypes.TAP_INTERNAL_KEY
      )
    };
    exports2.outputs = outputs;
  }
});

// node_modules/bip174/src/lib/parser/fromBuffer.js
var require_fromBuffer = __commonJS({
  "node_modules/bip174/src/lib/parser/fromBuffer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var convert = require_converter();
    var tools_1 = require_tools();
    var varuint2 = require_varint();
    var typeFields_1 = require_typeFields();
    function psbtFromBuffer(buffer, txGetter) {
      let offset = 0;
      function varSlice() {
        const keyLen = varuint2.decode(buffer, offset);
        offset += varuint2.encodingLength(keyLen);
        const key = buffer.slice(offset, offset + keyLen);
        offset += keyLen;
        return key;
      }
      function readUInt32BE() {
        const num = buffer.readUInt32BE(offset);
        offset += 4;
        return num;
      }
      function readUInt8() {
        const num = buffer.readUInt8(offset);
        offset += 1;
        return num;
      }
      function getKeyValue() {
        const key = varSlice();
        const value = varSlice();
        return {
          key,
          value
        };
      }
      function checkEndOfKeyValPairs() {
        if (offset >= buffer.length) {
          throw new Error("Format Error: Unexpected End of PSBT");
        }
        const isEnd = buffer.readUInt8(offset) === 0;
        if (isEnd) {
          offset++;
        }
        return isEnd;
      }
      if (readUInt32BE() !== 1886610036) {
        throw new Error("Format Error: Invalid Magic Number");
      }
      if (readUInt8() !== 255) {
        throw new Error(
          "Format Error: Magic Number must be followed by 0xff separator"
        );
      }
      const globalMapKeyVals = [];
      const globalKeyIndex = {};
      while (!checkEndOfKeyValPairs()) {
        const keyVal = getKeyValue();
        const hexKey = keyVal.key.toString("hex");
        if (globalKeyIndex[hexKey]) {
          throw new Error(
            "Format Error: Keys must be unique for global keymap: key " + hexKey
          );
        }
        globalKeyIndex[hexKey] = 1;
        globalMapKeyVals.push(keyVal);
      }
      const unsignedTxMaps = globalMapKeyVals.filter(
        (keyVal) => keyVal.key[0] === typeFields_1.GlobalTypes.UNSIGNED_TX
      );
      if (unsignedTxMaps.length !== 1) {
        throw new Error("Format Error: Only one UNSIGNED_TX allowed");
      }
      const unsignedTx = txGetter(unsignedTxMaps[0].value);
      const { inputCount, outputCount } = unsignedTx.getInputOutputCounts();
      const inputKeyVals = [];
      const outputKeyVals = [];
      for (const index of tools_1.range(inputCount)) {
        const inputKeyIndex = {};
        const input = [];
        while (!checkEndOfKeyValPairs()) {
          const keyVal = getKeyValue();
          const hexKey = keyVal.key.toString("hex");
          if (inputKeyIndex[hexKey]) {
            throw new Error(
              "Format Error: Keys must be unique for each input: input index " + index + " key " + hexKey
            );
          }
          inputKeyIndex[hexKey] = 1;
          input.push(keyVal);
        }
        inputKeyVals.push(input);
      }
      for (const index of tools_1.range(outputCount)) {
        const outputKeyIndex = {};
        const output = [];
        while (!checkEndOfKeyValPairs()) {
          const keyVal = getKeyValue();
          const hexKey = keyVal.key.toString("hex");
          if (outputKeyIndex[hexKey]) {
            throw new Error(
              "Format Error: Keys must be unique for each output: output index " + index + " key " + hexKey
            );
          }
          outputKeyIndex[hexKey] = 1;
          output.push(keyVal);
        }
        outputKeyVals.push(output);
      }
      return psbtFromKeyVals(unsignedTx, {
        globalMapKeyVals,
        inputKeyVals,
        outputKeyVals
      });
    }
    exports2.psbtFromBuffer = psbtFromBuffer;
    function checkKeyBuffer(type, keyBuf, keyNum) {
      if (!keyBuf.equals(Buffer.from([keyNum]))) {
        throw new Error(
          `Format Error: Invalid ${type} key: ${keyBuf.toString("hex")}`
        );
      }
    }
    exports2.checkKeyBuffer = checkKeyBuffer;
    function psbtFromKeyVals(unsignedTx, { globalMapKeyVals, inputKeyVals, outputKeyVals }) {
      const globalMap = {
        unsignedTx
      };
      let txCount = 0;
      for (const keyVal of globalMapKeyVals) {
        switch (keyVal.key[0]) {
          case typeFields_1.GlobalTypes.UNSIGNED_TX:
            checkKeyBuffer(
              "global",
              keyVal.key,
              typeFields_1.GlobalTypes.UNSIGNED_TX
            );
            if (txCount > 0) {
              throw new Error("Format Error: GlobalMap has multiple UNSIGNED_TX");
            }
            txCount++;
            break;
          case typeFields_1.GlobalTypes.GLOBAL_XPUB:
            if (globalMap.globalXpub === void 0) {
              globalMap.globalXpub = [];
            }
            globalMap.globalXpub.push(convert.globals.globalXpub.decode(keyVal));
            break;
          default:
            if (!globalMap.unknownKeyVals) globalMap.unknownKeyVals = [];
            globalMap.unknownKeyVals.push(keyVal);
        }
      }
      const inputCount = inputKeyVals.length;
      const outputCount = outputKeyVals.length;
      const inputs = [];
      const outputs = [];
      for (const index of tools_1.range(inputCount)) {
        const input = {};
        for (const keyVal of inputKeyVals[index]) {
          convert.inputs.checkPubkey(keyVal);
          switch (keyVal.key[0]) {
            case typeFields_1.InputTypes.NON_WITNESS_UTXO:
              checkKeyBuffer(
                "input",
                keyVal.key,
                typeFields_1.InputTypes.NON_WITNESS_UTXO
              );
              if (input.nonWitnessUtxo !== void 0) {
                throw new Error(
                  "Format Error: Input has multiple NON_WITNESS_UTXO"
                );
              }
              input.nonWitnessUtxo = convert.inputs.nonWitnessUtxo.decode(keyVal);
              break;
            case typeFields_1.InputTypes.WITNESS_UTXO:
              checkKeyBuffer(
                "input",
                keyVal.key,
                typeFields_1.InputTypes.WITNESS_UTXO
              );
              if (input.witnessUtxo !== void 0) {
                throw new Error("Format Error: Input has multiple WITNESS_UTXO");
              }
              input.witnessUtxo = convert.inputs.witnessUtxo.decode(keyVal);
              break;
            case typeFields_1.InputTypes.PARTIAL_SIG:
              if (input.partialSig === void 0) {
                input.partialSig = [];
              }
              input.partialSig.push(convert.inputs.partialSig.decode(keyVal));
              break;
            case typeFields_1.InputTypes.SIGHASH_TYPE:
              checkKeyBuffer(
                "input",
                keyVal.key,
                typeFields_1.InputTypes.SIGHASH_TYPE
              );
              if (input.sighashType !== void 0) {
                throw new Error("Format Error: Input has multiple SIGHASH_TYPE");
              }
              input.sighashType = convert.inputs.sighashType.decode(keyVal);
              break;
            case typeFields_1.InputTypes.REDEEM_SCRIPT:
              checkKeyBuffer(
                "input",
                keyVal.key,
                typeFields_1.InputTypes.REDEEM_SCRIPT
              );
              if (input.redeemScript !== void 0) {
                throw new Error("Format Error: Input has multiple REDEEM_SCRIPT");
              }
              input.redeemScript = convert.inputs.redeemScript.decode(keyVal);
              break;
            case typeFields_1.InputTypes.WITNESS_SCRIPT:
              checkKeyBuffer(
                "input",
                keyVal.key,
                typeFields_1.InputTypes.WITNESS_SCRIPT
              );
              if (input.witnessScript !== void 0) {
                throw new Error("Format Error: Input has multiple WITNESS_SCRIPT");
              }
              input.witnessScript = convert.inputs.witnessScript.decode(keyVal);
              break;
            case typeFields_1.InputTypes.BIP32_DERIVATION:
              if (input.bip32Derivation === void 0) {
                input.bip32Derivation = [];
              }
              input.bip32Derivation.push(
                convert.inputs.bip32Derivation.decode(keyVal)
              );
              break;
            case typeFields_1.InputTypes.FINAL_SCRIPTSIG:
              checkKeyBuffer(
                "input",
                keyVal.key,
                typeFields_1.InputTypes.FINAL_SCRIPTSIG
              );
              input.finalScriptSig = convert.inputs.finalScriptSig.decode(keyVal);
              break;
            case typeFields_1.InputTypes.FINAL_SCRIPTWITNESS:
              checkKeyBuffer(
                "input",
                keyVal.key,
                typeFields_1.InputTypes.FINAL_SCRIPTWITNESS
              );
              input.finalScriptWitness = convert.inputs.finalScriptWitness.decode(
                keyVal
              );
              break;
            case typeFields_1.InputTypes.POR_COMMITMENT:
              checkKeyBuffer(
                "input",
                keyVal.key,
                typeFields_1.InputTypes.POR_COMMITMENT
              );
              input.porCommitment = convert.inputs.porCommitment.decode(keyVal);
              break;
            case typeFields_1.InputTypes.TAP_KEY_SIG:
              checkKeyBuffer(
                "input",
                keyVal.key,
                typeFields_1.InputTypes.TAP_KEY_SIG
              );
              input.tapKeySig = convert.inputs.tapKeySig.decode(keyVal);
              break;
            case typeFields_1.InputTypes.TAP_SCRIPT_SIG:
              if (input.tapScriptSig === void 0) {
                input.tapScriptSig = [];
              }
              input.tapScriptSig.push(convert.inputs.tapScriptSig.decode(keyVal));
              break;
            case typeFields_1.InputTypes.TAP_LEAF_SCRIPT:
              if (input.tapLeafScript === void 0) {
                input.tapLeafScript = [];
              }
              input.tapLeafScript.push(convert.inputs.tapLeafScript.decode(keyVal));
              break;
            case typeFields_1.InputTypes.TAP_BIP32_DERIVATION:
              if (input.tapBip32Derivation === void 0) {
                input.tapBip32Derivation = [];
              }
              input.tapBip32Derivation.push(
                convert.inputs.tapBip32Derivation.decode(keyVal)
              );
              break;
            case typeFields_1.InputTypes.TAP_INTERNAL_KEY:
              checkKeyBuffer(
                "input",
                keyVal.key,
                typeFields_1.InputTypes.TAP_INTERNAL_KEY
              );
              input.tapInternalKey = convert.inputs.tapInternalKey.decode(keyVal);
              break;
            case typeFields_1.InputTypes.TAP_MERKLE_ROOT:
              checkKeyBuffer(
                "input",
                keyVal.key,
                typeFields_1.InputTypes.TAP_MERKLE_ROOT
              );
              input.tapMerkleRoot = convert.inputs.tapMerkleRoot.decode(keyVal);
              break;
            default:
              if (!input.unknownKeyVals) input.unknownKeyVals = [];
              input.unknownKeyVals.push(keyVal);
          }
        }
        inputs.push(input);
      }
      for (const index of tools_1.range(outputCount)) {
        const output = {};
        for (const keyVal of outputKeyVals[index]) {
          convert.outputs.checkPubkey(keyVal);
          switch (keyVal.key[0]) {
            case typeFields_1.OutputTypes.REDEEM_SCRIPT:
              checkKeyBuffer(
                "output",
                keyVal.key,
                typeFields_1.OutputTypes.REDEEM_SCRIPT
              );
              if (output.redeemScript !== void 0) {
                throw new Error("Format Error: Output has multiple REDEEM_SCRIPT");
              }
              output.redeemScript = convert.outputs.redeemScript.decode(keyVal);
              break;
            case typeFields_1.OutputTypes.WITNESS_SCRIPT:
              checkKeyBuffer(
                "output",
                keyVal.key,
                typeFields_1.OutputTypes.WITNESS_SCRIPT
              );
              if (output.witnessScript !== void 0) {
                throw new Error("Format Error: Output has multiple WITNESS_SCRIPT");
              }
              output.witnessScript = convert.outputs.witnessScript.decode(keyVal);
              break;
            case typeFields_1.OutputTypes.BIP32_DERIVATION:
              if (output.bip32Derivation === void 0) {
                output.bip32Derivation = [];
              }
              output.bip32Derivation.push(
                convert.outputs.bip32Derivation.decode(keyVal)
              );
              break;
            case typeFields_1.OutputTypes.TAP_INTERNAL_KEY:
              checkKeyBuffer(
                "output",
                keyVal.key,
                typeFields_1.OutputTypes.TAP_INTERNAL_KEY
              );
              output.tapInternalKey = convert.outputs.tapInternalKey.decode(keyVal);
              break;
            case typeFields_1.OutputTypes.TAP_TREE:
              checkKeyBuffer(
                "output",
                keyVal.key,
                typeFields_1.OutputTypes.TAP_TREE
              );
              output.tapTree = convert.outputs.tapTree.decode(keyVal);
              break;
            case typeFields_1.OutputTypes.TAP_BIP32_DERIVATION:
              if (output.tapBip32Derivation === void 0) {
                output.tapBip32Derivation = [];
              }
              output.tapBip32Derivation.push(
                convert.outputs.tapBip32Derivation.decode(keyVal)
              );
              break;
            default:
              if (!output.unknownKeyVals) output.unknownKeyVals = [];
              output.unknownKeyVals.push(keyVal);
          }
        }
        outputs.push(output);
      }
      return { globalMap, inputs, outputs };
    }
    exports2.psbtFromKeyVals = psbtFromKeyVals;
  }
});

// node_modules/bip174/src/lib/parser/toBuffer.js
var require_toBuffer = __commonJS({
  "node_modules/bip174/src/lib/parser/toBuffer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var convert = require_converter();
    var tools_1 = require_tools();
    function psbtToBuffer({ globalMap, inputs, outputs }) {
      const { globalKeyVals, inputKeyVals, outputKeyVals } = psbtToKeyVals({
        globalMap,
        inputs,
        outputs
      });
      const globalBuffer = tools_1.keyValsToBuffer(globalKeyVals);
      const keyValsOrEmptyToBuffer = (keyVals) => keyVals.length === 0 ? [Buffer.from([0])] : keyVals.map(tools_1.keyValsToBuffer);
      const inputBuffers = keyValsOrEmptyToBuffer(inputKeyVals);
      const outputBuffers = keyValsOrEmptyToBuffer(outputKeyVals);
      const header = Buffer.allocUnsafe(5);
      header.writeUIntBE(482972169471, 0, 5);
      return Buffer.concat(
        [header, globalBuffer].concat(inputBuffers, outputBuffers)
      );
    }
    exports2.psbtToBuffer = psbtToBuffer;
    var sortKeyVals = (a, b2) => {
      return a.key.compare(b2.key);
    };
    function keyValsFromMap(keyValMap, converterFactory) {
      const keyHexSet = /* @__PURE__ */ new Set();
      const keyVals = Object.entries(keyValMap).reduce((result, [key, value]) => {
        if (key === "unknownKeyVals") return result;
        const converter = converterFactory[key];
        if (converter === void 0) return result;
        const encodedKeyVals = (Array.isArray(value) ? value : [value]).map(
          converter.encode
        );
        const keyHexes = encodedKeyVals.map((kv) => kv.key.toString("hex"));
        keyHexes.forEach((hex) => {
          if (keyHexSet.has(hex))
            throw new Error("Serialize Error: Duplicate key: " + hex);
          keyHexSet.add(hex);
        });
        return result.concat(encodedKeyVals);
      }, []);
      const otherKeyVals = keyValMap.unknownKeyVals ? keyValMap.unknownKeyVals.filter((keyVal) => {
        return !keyHexSet.has(keyVal.key.toString("hex"));
      }) : [];
      return keyVals.concat(otherKeyVals).sort(sortKeyVals);
    }
    function psbtToKeyVals({ globalMap, inputs, outputs }) {
      return {
        globalKeyVals: keyValsFromMap(globalMap, convert.globals),
        inputKeyVals: inputs.map((i) => keyValsFromMap(i, convert.inputs)),
        outputKeyVals: outputs.map((o) => keyValsFromMap(o, convert.outputs))
      };
    }
    exports2.psbtToKeyVals = psbtToKeyVals;
  }
});

// node_modules/bip174/src/lib/parser/index.js
var require_parser = __commonJS({
  "node_modules/bip174/src/lib/parser/index.js"(exports2) {
    "use strict";
    function __export2(m) {
      for (var p in m) if (!exports2.hasOwnProperty(p)) exports2[p] = m[p];
    }
    Object.defineProperty(exports2, "__esModule", { value: true });
    __export2(require_fromBuffer());
    __export2(require_toBuffer());
  }
});

// node_modules/bip174/src/lib/combiner/index.js
var require_combiner = __commonJS({
  "node_modules/bip174/src/lib/combiner/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var parser_1 = require_parser();
    function combine(psbts) {
      const self2 = psbts[0];
      const selfKeyVals = parser_1.psbtToKeyVals(self2);
      const others = psbts.slice(1);
      if (others.length === 0) throw new Error("Combine: Nothing to combine");
      const selfTx = getTx(self2);
      if (selfTx === void 0) {
        throw new Error("Combine: Self missing transaction");
      }
      const selfGlobalSet = getKeySet(selfKeyVals.globalKeyVals);
      const selfInputSets = selfKeyVals.inputKeyVals.map(getKeySet);
      const selfOutputSets = selfKeyVals.outputKeyVals.map(getKeySet);
      for (const other of others) {
        const otherTx = getTx(other);
        if (otherTx === void 0 || !otherTx.toBuffer().equals(selfTx.toBuffer())) {
          throw new Error(
            "Combine: One of the Psbts does not have the same transaction."
          );
        }
        const otherKeyVals = parser_1.psbtToKeyVals(other);
        const otherGlobalSet = getKeySet(otherKeyVals.globalKeyVals);
        otherGlobalSet.forEach(
          keyPusher(
            selfGlobalSet,
            selfKeyVals.globalKeyVals,
            otherKeyVals.globalKeyVals
          )
        );
        const otherInputSets = otherKeyVals.inputKeyVals.map(getKeySet);
        otherInputSets.forEach(
          (inputSet, idx) => inputSet.forEach(
            keyPusher(
              selfInputSets[idx],
              selfKeyVals.inputKeyVals[idx],
              otherKeyVals.inputKeyVals[idx]
            )
          )
        );
        const otherOutputSets = otherKeyVals.outputKeyVals.map(getKeySet);
        otherOutputSets.forEach(
          (outputSet, idx) => outputSet.forEach(
            keyPusher(
              selfOutputSets[idx],
              selfKeyVals.outputKeyVals[idx],
              otherKeyVals.outputKeyVals[idx]
            )
          )
        );
      }
      return parser_1.psbtFromKeyVals(selfTx, {
        globalMapKeyVals: selfKeyVals.globalKeyVals,
        inputKeyVals: selfKeyVals.inputKeyVals,
        outputKeyVals: selfKeyVals.outputKeyVals
      });
    }
    exports2.combine = combine;
    function keyPusher(selfSet, selfKeyVals, otherKeyVals) {
      return (key) => {
        if (selfSet.has(key)) return;
        const newKv = otherKeyVals.filter((kv) => kv.key.toString("hex") === key)[0];
        selfKeyVals.push(newKv);
        selfSet.add(key);
      };
    }
    function getTx(psbt) {
      return psbt.globalMap.unsignedTx;
    }
    function getKeySet(keyVals) {
      const set2 = /* @__PURE__ */ new Set();
      keyVals.forEach((keyVal) => {
        const hex = keyVal.key.toString("hex");
        if (set2.has(hex))
          throw new Error("Combine: KeyValue Map keys should be unique");
        set2.add(hex);
      });
      return set2;
    }
  }
});

// node_modules/bip174/src/lib/utils.js
var require_utils4 = __commonJS({
  "node_modules/bip174/src/lib/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var converter = require_converter();
    function checkForInput(inputs, inputIndex) {
      const input = inputs[inputIndex];
      if (input === void 0) throw new Error(`No input #${inputIndex}`);
      return input;
    }
    exports2.checkForInput = checkForInput;
    function checkForOutput(outputs, outputIndex) {
      const output = outputs[outputIndex];
      if (output === void 0) throw new Error(`No output #${outputIndex}`);
      return output;
    }
    exports2.checkForOutput = checkForOutput;
    function checkHasKey(checkKeyVal, keyVals, enumLength) {
      if (checkKeyVal.key[0] < enumLength) {
        throw new Error(
          `Use the method for your specific key instead of addUnknownKeyVal*`
        );
      }
      if (keyVals && keyVals.filter((kv) => kv.key.equals(checkKeyVal.key)).length !== 0) {
        throw new Error(`Duplicate Key: ${checkKeyVal.key.toString("hex")}`);
      }
    }
    exports2.checkHasKey = checkHasKey;
    function getEnumLength(myenum) {
      let count = 0;
      Object.keys(myenum).forEach((val) => {
        if (Number(isNaN(Number(val)))) {
          count++;
        }
      });
      return count;
    }
    exports2.getEnumLength = getEnumLength;
    function inputCheckUncleanFinalized(inputIndex, input) {
      let result = false;
      if (input.nonWitnessUtxo || input.witnessUtxo) {
        const needScriptSig = !!input.redeemScript;
        const needWitnessScript = !!input.witnessScript;
        const scriptSigOK = !needScriptSig || !!input.finalScriptSig;
        const witnessScriptOK = !needWitnessScript || !!input.finalScriptWitness;
        const hasOneFinal = !!input.finalScriptSig || !!input.finalScriptWitness;
        result = scriptSigOK && witnessScriptOK && hasOneFinal;
      }
      if (result === false) {
        throw new Error(
          `Input #${inputIndex} has too much or too little data to clean`
        );
      }
    }
    exports2.inputCheckUncleanFinalized = inputCheckUncleanFinalized;
    function throwForUpdateMaker(typeName, name, expected, data) {
      throw new Error(
        `Data for ${typeName} key ${name} is incorrect: Expected ${expected} and got ${JSON.stringify(data)}`
      );
    }
    function updateMaker(typeName) {
      return (updateData, mainData) => {
        for (const name of Object.keys(updateData)) {
          const data = updateData[name];
          const { canAdd, canAddToArray, check, expected } = (
            // @ts-ignore
            converter[typeName + "s"][name] || {}
          );
          const isArray = !!canAddToArray;
          if (check) {
            if (isArray) {
              if (!Array.isArray(data) || // @ts-ignore
              mainData[name] && !Array.isArray(mainData[name])) {
                throw new Error(`Key type ${name} must be an array`);
              }
              if (!data.every(check)) {
                throwForUpdateMaker(typeName, name, expected, data);
              }
              const arr = mainData[name] || [];
              const dupeCheckSet = /* @__PURE__ */ new Set();
              if (!data.every((v) => canAddToArray(arr, v, dupeCheckSet))) {
                throw new Error("Can not add duplicate data to array");
              }
              mainData[name] = arr.concat(data);
            } else {
              if (!check(data)) {
                throwForUpdateMaker(typeName, name, expected, data);
              }
              if (!canAdd(mainData, data)) {
                throw new Error(`Can not add duplicate data to ${typeName}`);
              }
              mainData[name] = data;
            }
          }
        }
      };
    }
    exports2.updateGlobal = updateMaker("global");
    exports2.updateInput = updateMaker("input");
    exports2.updateOutput = updateMaker("output");
    function addInputAttributes(inputs, data) {
      const index = inputs.length - 1;
      const input = checkForInput(inputs, index);
      exports2.updateInput(data, input);
    }
    exports2.addInputAttributes = addInputAttributes;
    function addOutputAttributes(outputs, data) {
      const index = outputs.length - 1;
      const output = checkForOutput(outputs, index);
      exports2.updateOutput(data, output);
    }
    exports2.addOutputAttributes = addOutputAttributes;
    function defaultVersionSetter(version, txBuf) {
      if (!Buffer.isBuffer(txBuf) || txBuf.length < 4) {
        throw new Error("Set Version: Invalid Transaction");
      }
      txBuf.writeUInt32LE(version, 0);
      return txBuf;
    }
    exports2.defaultVersionSetter = defaultVersionSetter;
    function defaultLocktimeSetter(locktime, txBuf) {
      if (!Buffer.isBuffer(txBuf) || txBuf.length < 4) {
        throw new Error("Set Locktime: Invalid Transaction");
      }
      txBuf.writeUInt32LE(locktime, txBuf.length - 4);
      return txBuf;
    }
    exports2.defaultLocktimeSetter = defaultLocktimeSetter;
  }
});

// node_modules/bip174/src/lib/psbt.js
var require_psbt = __commonJS({
  "node_modules/bip174/src/lib/psbt.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var combiner_1 = require_combiner();
    var parser_1 = require_parser();
    var typeFields_1 = require_typeFields();
    var utils_1 = require_utils4();
    var Psbt = class {
      constructor(tx) {
        this.inputs = [];
        this.outputs = [];
        this.globalMap = {
          unsignedTx: tx
        };
      }
      static fromBase64(data, txFromBuffer) {
        const buffer = Buffer.from(data, "base64");
        return this.fromBuffer(buffer, txFromBuffer);
      }
      static fromHex(data, txFromBuffer) {
        const buffer = Buffer.from(data, "hex");
        return this.fromBuffer(buffer, txFromBuffer);
      }
      static fromBuffer(buffer, txFromBuffer) {
        const results = parser_1.psbtFromBuffer(buffer, txFromBuffer);
        const psbt = new this(results.globalMap.unsignedTx);
        Object.assign(psbt, results);
        return psbt;
      }
      toBase64() {
        const buffer = this.toBuffer();
        return buffer.toString("base64");
      }
      toHex() {
        const buffer = this.toBuffer();
        return buffer.toString("hex");
      }
      toBuffer() {
        return parser_1.psbtToBuffer(this);
      }
      updateGlobal(updateData) {
        utils_1.updateGlobal(updateData, this.globalMap);
        return this;
      }
      updateInput(inputIndex, updateData) {
        const input = utils_1.checkForInput(this.inputs, inputIndex);
        utils_1.updateInput(updateData, input);
        return this;
      }
      updateOutput(outputIndex, updateData) {
        const output = utils_1.checkForOutput(this.outputs, outputIndex);
        utils_1.updateOutput(updateData, output);
        return this;
      }
      addUnknownKeyValToGlobal(keyVal) {
        utils_1.checkHasKey(
          keyVal,
          this.globalMap.unknownKeyVals,
          utils_1.getEnumLength(typeFields_1.GlobalTypes)
        );
        if (!this.globalMap.unknownKeyVals) this.globalMap.unknownKeyVals = [];
        this.globalMap.unknownKeyVals.push(keyVal);
        return this;
      }
      addUnknownKeyValToInput(inputIndex, keyVal) {
        const input = utils_1.checkForInput(this.inputs, inputIndex);
        utils_1.checkHasKey(
          keyVal,
          input.unknownKeyVals,
          utils_1.getEnumLength(typeFields_1.InputTypes)
        );
        if (!input.unknownKeyVals) input.unknownKeyVals = [];
        input.unknownKeyVals.push(keyVal);
        return this;
      }
      addUnknownKeyValToOutput(outputIndex, keyVal) {
        const output = utils_1.checkForOutput(this.outputs, outputIndex);
        utils_1.checkHasKey(
          keyVal,
          output.unknownKeyVals,
          utils_1.getEnumLength(typeFields_1.OutputTypes)
        );
        if (!output.unknownKeyVals) output.unknownKeyVals = [];
        output.unknownKeyVals.push(keyVal);
        return this;
      }
      addInput(inputData) {
        this.globalMap.unsignedTx.addInput(inputData);
        this.inputs.push({
          unknownKeyVals: []
        });
        const addKeyVals = inputData.unknownKeyVals || [];
        const inputIndex = this.inputs.length - 1;
        if (!Array.isArray(addKeyVals)) {
          throw new Error("unknownKeyVals must be an Array");
        }
        addKeyVals.forEach(
          (keyVal) => this.addUnknownKeyValToInput(inputIndex, keyVal)
        );
        utils_1.addInputAttributes(this.inputs, inputData);
        return this;
      }
      addOutput(outputData) {
        this.globalMap.unsignedTx.addOutput(outputData);
        this.outputs.push({
          unknownKeyVals: []
        });
        const addKeyVals = outputData.unknownKeyVals || [];
        const outputIndex = this.outputs.length - 1;
        if (!Array.isArray(addKeyVals)) {
          throw new Error("unknownKeyVals must be an Array");
        }
        addKeyVals.forEach(
          (keyVal) => this.addUnknownKeyValToOutput(outputIndex, keyVal)
        );
        utils_1.addOutputAttributes(this.outputs, outputData);
        return this;
      }
      clearFinalizedInput(inputIndex) {
        const input = utils_1.checkForInput(this.inputs, inputIndex);
        utils_1.inputCheckUncleanFinalized(inputIndex, input);
        for (const key of Object.keys(input)) {
          if (![
            "witnessUtxo",
            "nonWitnessUtxo",
            "finalScriptSig",
            "finalScriptWitness",
            "unknownKeyVals"
          ].includes(key)) {
            delete input[key];
          }
        }
        return this;
      }
      combine(...those) {
        const result = combiner_1.combine([this].concat(those));
        Object.assign(this, result);
        return this;
      }
      getTransaction() {
        return this.globalMap.unsignedTx.toBuffer();
      }
    };
    exports2.Psbt = Psbt;
  }
});

// node_modules/bitcoinjs-lib/src/psbt.js
var require_psbt2 = __commonJS({
  "node_modules/bitcoinjs-lib/src/psbt.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var bip174_1 = require_psbt();
    var varuint2 = require_varint();
    var utils_1 = require_utils4();
    var address_1 = require_address();
    var bufferutils_1 = require_bufferutils();
    var crypto_1 = require_crypto3();
    var ecpair_1 = require_ecpair();
    var networks_1 = require_networks();
    var payments = require_payments();
    var bscript = require_script();
    var transaction_1 = require_transaction();
    var DEFAULT_OPTS = {
      /**
       * A bitcoinjs Network object. This is only used if you pass an `address`
       * parameter to addOutput. Otherwise it is not needed and can be left default.
       */
      network: networks_1.bitcoin,
      /**
       * When extractTransaction is called, the fee rate is checked.
       * THIS IS NOT TO BE RELIED ON.
       * It is only here as a last ditch effort to prevent sending a 500 BTC fee etc.
       */
      maximumFeeRate: 5e3
    };
    var Psbt = class _Psbt {
      constructor(opts = {}, data = new bip174_1.Psbt(new PsbtTransaction())) {
        this.data = data;
        this.opts = Object.assign({}, DEFAULT_OPTS, opts);
        this.__CACHE = {
          __NON_WITNESS_UTXO_TX_CACHE: [],
          __NON_WITNESS_UTXO_BUF_CACHE: [],
          __TX_IN_CACHE: {},
          __TX: this.data.globalMap.unsignedTx.tx,
          // Old TransactionBuilder behavior was to not confirm input values
          // before signing. Even though we highly encourage people to get
          // the full parent transaction to verify values, the ability to
          // sign non-segwit inputs without the full transaction was often
          // requested. So the only way to activate is to use @ts-ignore.
          // We will disable exporting the Psbt when unsafe sign is active.
          // because it is not BIP174 compliant.
          __UNSAFE_SIGN_NONSEGWIT: false
        };
        if (this.data.inputs.length === 0) this.setVersion(2);
        const dpew = (obj, attr, enumerable, writable) => Object.defineProperty(obj, attr, {
          enumerable,
          writable
        });
        dpew(this, "__CACHE", false, true);
        dpew(this, "opts", false, true);
      }
      static fromBase64(data, opts = {}) {
        const buffer = Buffer.from(data, "base64");
        return this.fromBuffer(buffer, opts);
      }
      static fromHex(data, opts = {}) {
        const buffer = Buffer.from(data, "hex");
        return this.fromBuffer(buffer, opts);
      }
      static fromBuffer(buffer, opts = {}) {
        const psbtBase = bip174_1.Psbt.fromBuffer(buffer, transactionFromBuffer);
        const psbt = new _Psbt(opts, psbtBase);
        checkTxForDupeIns(psbt.__CACHE.__TX, psbt.__CACHE);
        return psbt;
      }
      get inputCount() {
        return this.data.inputs.length;
      }
      get version() {
        return this.__CACHE.__TX.version;
      }
      set version(version) {
        this.setVersion(version);
      }
      get locktime() {
        return this.__CACHE.__TX.locktime;
      }
      set locktime(locktime) {
        this.setLocktime(locktime);
      }
      get txInputs() {
        return this.__CACHE.__TX.ins.map((input) => ({
          hash: bufferutils_1.cloneBuffer(input.hash),
          index: input.index,
          sequence: input.sequence
        }));
      }
      get txOutputs() {
        return this.__CACHE.__TX.outs.map((output) => {
          let address;
          try {
            address = address_1.fromOutputScript(output.script, this.opts.network);
          } catch (_) {
          }
          return {
            script: bufferutils_1.cloneBuffer(output.script),
            value: output.value,
            address
          };
        });
      }
      combine(...those) {
        this.data.combine(...those.map((o) => o.data));
        return this;
      }
      clone() {
        const res = _Psbt.fromBuffer(this.data.toBuffer());
        res.opts = JSON.parse(JSON.stringify(this.opts));
        return res;
      }
      setMaximumFeeRate(satoshiPerByte) {
        check32Bit(satoshiPerByte);
        this.opts.maximumFeeRate = satoshiPerByte;
      }
      setVersion(version) {
        check32Bit(version);
        checkInputsForPartialSig(this.data.inputs, "setVersion");
        const c = this.__CACHE;
        c.__TX.version = version;
        c.__EXTRACTED_TX = void 0;
        return this;
      }
      setLocktime(locktime) {
        check32Bit(locktime);
        checkInputsForPartialSig(this.data.inputs, "setLocktime");
        const c = this.__CACHE;
        c.__TX.locktime = locktime;
        c.__EXTRACTED_TX = void 0;
        return this;
      }
      setInputSequence(inputIndex, sequence) {
        check32Bit(sequence);
        checkInputsForPartialSig(this.data.inputs, "setInputSequence");
        const c = this.__CACHE;
        if (c.__TX.ins.length <= inputIndex) {
          throw new Error("Input index too high");
        }
        c.__TX.ins[inputIndex].sequence = sequence;
        c.__EXTRACTED_TX = void 0;
        return this;
      }
      addInputs(inputDatas) {
        inputDatas.forEach((inputData) => this.addInput(inputData));
        return this;
      }
      addInput(inputData) {
        if (arguments.length > 1 || !inputData || inputData.hash === void 0 || inputData.index === void 0) {
          throw new Error(
            `Invalid arguments for Psbt.addInput. Requires single object with at least [hash] and [index]`
          );
        }
        checkInputsForPartialSig(this.data.inputs, "addInput");
        if (inputData.witnessScript) checkInvalidP2WSH(inputData.witnessScript);
        const c = this.__CACHE;
        this.data.addInput(inputData);
        const txIn = c.__TX.ins[c.__TX.ins.length - 1];
        checkTxInputCache(c, txIn);
        const inputIndex = this.data.inputs.length - 1;
        const input = this.data.inputs[inputIndex];
        if (input.nonWitnessUtxo) {
          addNonWitnessTxCache(this.__CACHE, input, inputIndex);
        }
        c.__FEE = void 0;
        c.__FEE_RATE = void 0;
        c.__EXTRACTED_TX = void 0;
        return this;
      }
      addOutputs(outputDatas) {
        outputDatas.forEach((outputData) => this.addOutput(outputData));
        return this;
      }
      addOutput(outputData) {
        if (arguments.length > 1 || !outputData || outputData.value === void 0 || outputData.address === void 0 && outputData.script === void 0) {
          throw new Error(
            `Invalid arguments for Psbt.addOutput. Requires single object with at least [script or address] and [value]`
          );
        }
        checkInputsForPartialSig(this.data.inputs, "addOutput");
        const { address } = outputData;
        if (typeof address === "string") {
          const { network } = this.opts;
          const script = address_1.toOutputScript(address, network);
          outputData = Object.assign(outputData, { script });
        }
        const c = this.__CACHE;
        this.data.addOutput(outputData);
        c.__FEE = void 0;
        c.__FEE_RATE = void 0;
        c.__EXTRACTED_TX = void 0;
        return this;
      }
      extractTransaction(disableFeeCheck) {
        if (!this.data.inputs.every(isFinalized)) throw new Error("Not finalized");
        const c = this.__CACHE;
        if (!disableFeeCheck) {
          checkFees(this, c, this.opts);
        }
        if (c.__EXTRACTED_TX) return c.__EXTRACTED_TX;
        const tx = c.__TX.clone();
        inputFinalizeGetAmts(this.data.inputs, tx, c, true);
        return tx;
      }
      getFeeRate() {
        return getTxCacheValue(
          "__FEE_RATE",
          "fee rate",
          this.data.inputs,
          this.__CACHE
        );
      }
      getFee() {
        return getTxCacheValue("__FEE", "fee", this.data.inputs, this.__CACHE);
      }
      finalizeAllInputs() {
        utils_1.checkForInput(this.data.inputs, 0);
        range(this.data.inputs.length).forEach((idx) => this.finalizeInput(idx));
        return this;
      }
      finalizeInput(inputIndex, finalScriptsFunc = getFinalScripts) {
        const input = utils_1.checkForInput(this.data.inputs, inputIndex);
        const { script, isP2SH, isP2WSH, isSegwit } = getScriptFromInput(
          inputIndex,
          input,
          this.__CACHE
        );
        if (!script) throw new Error(`No script found for input #${inputIndex}`);
        checkPartialSigSighashes(input);
        const { finalScriptSig, finalScriptWitness } = finalScriptsFunc(
          inputIndex,
          input,
          script,
          isSegwit,
          isP2SH,
          isP2WSH
        );
        if (finalScriptSig) this.data.updateInput(inputIndex, { finalScriptSig });
        if (finalScriptWitness)
          this.data.updateInput(inputIndex, { finalScriptWitness });
        if (!finalScriptSig && !finalScriptWitness)
          throw new Error(`Unknown error finalizing input #${inputIndex}`);
        this.data.clearFinalizedInput(inputIndex);
        return this;
      }
      getInputType(inputIndex) {
        const input = utils_1.checkForInput(this.data.inputs, inputIndex);
        const script = getScriptFromUtxo(inputIndex, input, this.__CACHE);
        const result = getMeaningfulScript(
          script,
          inputIndex,
          "input",
          input.redeemScript || redeemFromFinalScriptSig(input.finalScriptSig),
          input.witnessScript || redeemFromFinalWitnessScript(input.finalScriptWitness)
        );
        const type = result.type === "raw" ? "" : result.type + "-";
        const mainType = classifyScript(result.meaningfulScript);
        return type + mainType;
      }
      inputHasPubkey(inputIndex, pubkey) {
        const input = utils_1.checkForInput(this.data.inputs, inputIndex);
        return pubkeyInInput(pubkey, input, inputIndex, this.__CACHE);
      }
      inputHasHDKey(inputIndex, root) {
        const input = utils_1.checkForInput(this.data.inputs, inputIndex);
        const derivationIsMine = bip32DerivationIsMine(root);
        return !!input.bip32Derivation && input.bip32Derivation.some(derivationIsMine);
      }
      outputHasPubkey(outputIndex, pubkey) {
        const output = utils_1.checkForOutput(this.data.outputs, outputIndex);
        return pubkeyInOutput(pubkey, output, outputIndex, this.__CACHE);
      }
      outputHasHDKey(outputIndex, root) {
        const output = utils_1.checkForOutput(this.data.outputs, outputIndex);
        const derivationIsMine = bip32DerivationIsMine(root);
        return !!output.bip32Derivation && output.bip32Derivation.some(derivationIsMine);
      }
      validateSignaturesOfAllInputs() {
        utils_1.checkForInput(this.data.inputs, 0);
        const results = range(this.data.inputs.length).map(
          (idx) => this.validateSignaturesOfInput(idx)
        );
        return results.reduce((final, res) => res === true && final, true);
      }
      validateSignaturesOfInput(inputIndex, pubkey) {
        const input = this.data.inputs[inputIndex];
        const partialSig = (input || {}).partialSig;
        if (!input || !partialSig || partialSig.length < 1)
          throw new Error("No signatures to validate");
        const mySigs = pubkey ? partialSig.filter((sig) => sig.pubkey.equals(pubkey)) : partialSig;
        if (mySigs.length < 1) throw new Error("No signatures for this pubkey");
        const results = [];
        let hashCache;
        let scriptCache;
        let sighashCache;
        for (const pSig of mySigs) {
          const sig = bscript.signature.decode(pSig.signature);
          const { hash, script } = sighashCache !== sig.hashType ? getHashForSig(
            inputIndex,
            Object.assign({}, input, { sighashType: sig.hashType }),
            this.__CACHE,
            true
          ) : { hash: hashCache, script: scriptCache };
          sighashCache = sig.hashType;
          hashCache = hash;
          scriptCache = script;
          checkScriptForPubkey(pSig.pubkey, script, "verify");
          const keypair = ecpair_1.fromPublicKey(pSig.pubkey);
          results.push(keypair.verify(hash, sig.signature));
        }
        return results.every((res) => res === true);
      }
      signAllInputsHD(hdKeyPair, sighashTypes = [transaction_1.Transaction.SIGHASH_ALL]) {
        if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
          throw new Error("Need HDSigner to sign input");
        }
        const results = [];
        for (const i of range(this.data.inputs.length)) {
          try {
            this.signInputHD(i, hdKeyPair, sighashTypes);
            results.push(true);
          } catch (err) {
            results.push(false);
          }
        }
        if (results.every((v) => v === false)) {
          throw new Error("No inputs were signed");
        }
        return this;
      }
      signAllInputsHDAsync(hdKeyPair, sighashTypes = [transaction_1.Transaction.SIGHASH_ALL]) {
        return new Promise((resolve, reject) => {
          if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
            return reject(new Error("Need HDSigner to sign input"));
          }
          const results = [];
          const promises = [];
          for (const i of range(this.data.inputs.length)) {
            promises.push(
              this.signInputHDAsync(i, hdKeyPair, sighashTypes).then(
                () => {
                  results.push(true);
                },
                () => {
                  results.push(false);
                }
              )
            );
          }
          return Promise.all(promises).then(() => {
            if (results.every((v) => v === false)) {
              return reject(new Error("No inputs were signed"));
            }
            resolve();
          });
        });
      }
      signInputHD(inputIndex, hdKeyPair, sighashTypes = [transaction_1.Transaction.SIGHASH_ALL]) {
        if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
          throw new Error("Need HDSigner to sign input");
        }
        const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);
        signers.forEach((signer) => this.signInput(inputIndex, signer, sighashTypes));
        return this;
      }
      signInputHDAsync(inputIndex, hdKeyPair, sighashTypes = [transaction_1.Transaction.SIGHASH_ALL]) {
        return new Promise((resolve, reject) => {
          if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
            return reject(new Error("Need HDSigner to sign input"));
          }
          const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);
          const promises = signers.map(
            (signer) => this.signInputAsync(inputIndex, signer, sighashTypes)
          );
          return Promise.all(promises).then(() => {
            resolve();
          }).catch(reject);
        });
      }
      signAllInputs(keyPair, sighashTypes = [transaction_1.Transaction.SIGHASH_ALL]) {
        if (!keyPair || !keyPair.publicKey)
          throw new Error("Need Signer to sign input");
        const results = [];
        for (const i of range(this.data.inputs.length)) {
          try {
            this.signInput(i, keyPair, sighashTypes);
            results.push(true);
          } catch (err) {
            results.push(false);
          }
        }
        if (results.every((v) => v === false)) {
          throw new Error("No inputs were signed");
        }
        return this;
      }
      signAllInputsAsync(keyPair, sighashTypes = [transaction_1.Transaction.SIGHASH_ALL]) {
        return new Promise((resolve, reject) => {
          if (!keyPair || !keyPair.publicKey)
            return reject(new Error("Need Signer to sign input"));
          const results = [];
          const promises = [];
          for (const [i] of this.data.inputs.entries()) {
            promises.push(
              this.signInputAsync(i, keyPair, sighashTypes).then(
                () => {
                  results.push(true);
                },
                () => {
                  results.push(false);
                }
              )
            );
          }
          return Promise.all(promises).then(() => {
            if (results.every((v) => v === false)) {
              return reject(new Error("No inputs were signed"));
            }
            resolve();
          });
        });
      }
      signInput(inputIndex, keyPair, sighashTypes = [transaction_1.Transaction.SIGHASH_ALL]) {
        if (!keyPair || !keyPair.publicKey)
          throw new Error("Need Signer to sign input");
        const { hash, sighashType } = getHashAndSighashType(
          this.data.inputs,
          inputIndex,
          keyPair.publicKey,
          this.__CACHE,
          sighashTypes
        );
        const partialSig = [
          {
            pubkey: keyPair.publicKey,
            signature: bscript.signature.encode(keyPair.sign(hash), sighashType)
          }
        ];
        this.data.updateInput(inputIndex, { partialSig });
        return this;
      }
      signInputAsync(inputIndex, keyPair, sighashTypes = [transaction_1.Transaction.SIGHASH_ALL]) {
        return Promise.resolve().then(() => {
          if (!keyPair || !keyPair.publicKey)
            throw new Error("Need Signer to sign input");
          const { hash, sighashType } = getHashAndSighashType(
            this.data.inputs,
            inputIndex,
            keyPair.publicKey,
            this.__CACHE,
            sighashTypes
          );
          return Promise.resolve(keyPair.sign(hash)).then((signature) => {
            const partialSig = [
              {
                pubkey: keyPair.publicKey,
                signature: bscript.signature.encode(signature, sighashType)
              }
            ];
            this.data.updateInput(inputIndex, { partialSig });
          });
        });
      }
      toBuffer() {
        checkCache(this.__CACHE);
        return this.data.toBuffer();
      }
      toHex() {
        checkCache(this.__CACHE);
        return this.data.toHex();
      }
      toBase64() {
        checkCache(this.__CACHE);
        return this.data.toBase64();
      }
      updateGlobal(updateData) {
        this.data.updateGlobal(updateData);
        return this;
      }
      updateInput(inputIndex, updateData) {
        if (updateData.witnessScript) checkInvalidP2WSH(updateData.witnessScript);
        this.data.updateInput(inputIndex, updateData);
        if (updateData.nonWitnessUtxo) {
          addNonWitnessTxCache(
            this.__CACHE,
            this.data.inputs[inputIndex],
            inputIndex
          );
        }
        return this;
      }
      updateOutput(outputIndex, updateData) {
        this.data.updateOutput(outputIndex, updateData);
        return this;
      }
      addUnknownKeyValToGlobal(keyVal) {
        this.data.addUnknownKeyValToGlobal(keyVal);
        return this;
      }
      addUnknownKeyValToInput(inputIndex, keyVal) {
        this.data.addUnknownKeyValToInput(inputIndex, keyVal);
        return this;
      }
      addUnknownKeyValToOutput(outputIndex, keyVal) {
        this.data.addUnknownKeyValToOutput(outputIndex, keyVal);
        return this;
      }
      clearFinalizedInput(inputIndex) {
        this.data.clearFinalizedInput(inputIndex);
        return this;
      }
    };
    exports2.Psbt = Psbt;
    var transactionFromBuffer = (buffer) => new PsbtTransaction(buffer);
    var PsbtTransaction = class {
      constructor(buffer = Buffer.from([2, 0, 0, 0, 0, 0, 0, 0, 0, 0])) {
        this.tx = transaction_1.Transaction.fromBuffer(buffer);
        checkTxEmpty(this.tx);
        Object.defineProperty(this, "tx", {
          enumerable: false,
          writable: true
        });
      }
      getInputOutputCounts() {
        return {
          inputCount: this.tx.ins.length,
          outputCount: this.tx.outs.length
        };
      }
      addInput(input) {
        if (input.hash === void 0 || input.index === void 0 || !Buffer.isBuffer(input.hash) && typeof input.hash !== "string" || typeof input.index !== "number") {
          throw new Error("Error adding input.");
        }
        const hash = typeof input.hash === "string" ? bufferutils_1.reverseBuffer(Buffer.from(input.hash, "hex")) : input.hash;
        this.tx.addInput(hash, input.index, input.sequence);
      }
      addOutput(output) {
        if (output.script === void 0 || output.value === void 0 || !Buffer.isBuffer(output.script) || typeof output.value !== "number") {
          throw new Error("Error adding output.");
        }
        this.tx.addOutput(output.script, output.value);
      }
      toBuffer() {
        return this.tx.toBuffer();
      }
    };
    function canFinalize(input, script, scriptType) {
      switch (scriptType) {
        case "pubkey":
        case "pubkeyhash":
        case "witnesspubkeyhash":
          return hasSigs(1, input.partialSig);
        case "multisig":
          const p2ms = payments.p2ms({ output: script });
          return hasSigs(p2ms.m, input.partialSig, p2ms.pubkeys);
        default:
          return false;
      }
    }
    function checkCache(cache) {
      if (cache.__UNSAFE_SIGN_NONSEGWIT !== false) {
        throw new Error("Not BIP174 compliant, can not export");
      }
    }
    function hasSigs(neededSigs, partialSig, pubkeys) {
      if (!partialSig) return false;
      let sigs;
      if (pubkeys) {
        sigs = pubkeys.map((pkey) => {
          const pubkey = ecpair_1.fromPublicKey(pkey, { compressed: true }).publicKey;
          return partialSig.find((pSig) => pSig.pubkey.equals(pubkey));
        }).filter((v) => !!v);
      } else {
        sigs = partialSig;
      }
      if (sigs.length > neededSigs) throw new Error("Too many signatures");
      return sigs.length === neededSigs;
    }
    function isFinalized(input) {
      return !!input.finalScriptSig || !!input.finalScriptWitness;
    }
    function isPaymentFactory(payment) {
      return (script) => {
        try {
          payment({ output: script });
          return true;
        } catch (err) {
          return false;
        }
      };
    }
    var isP2MS = isPaymentFactory(payments.p2ms);
    var isP2PK = isPaymentFactory(payments.p2pk);
    var isP2PKH = isPaymentFactory(payments.p2pkh);
    var isP2WPKH = isPaymentFactory(payments.p2wpkh);
    var isP2WSHScript = isPaymentFactory(payments.p2wsh);
    var isP2SHScript = isPaymentFactory(payments.p2sh);
    function bip32DerivationIsMine(root) {
      return (d) => {
        if (!d.masterFingerprint.equals(root.fingerprint)) return false;
        if (!root.derivePath(d.path).publicKey.equals(d.pubkey)) return false;
        return true;
      };
    }
    function check32Bit(num) {
      if (typeof num !== "number" || num !== Math.floor(num) || num > 4294967295 || num < 0) {
        throw new Error("Invalid 32 bit integer");
      }
    }
    function checkFees(psbt, cache, opts) {
      const feeRate = cache.__FEE_RATE || psbt.getFeeRate();
      const vsize = cache.__EXTRACTED_TX.virtualSize();
      const satoshis = feeRate * vsize;
      if (feeRate >= opts.maximumFeeRate) {
        throw new Error(
          `Warning: You are paying around ${(satoshis / 1e8).toFixed(8)} in fees, which is ${feeRate} satoshi per byte for a transaction with a VSize of ${vsize} bytes (segwit counted as 0.25 byte per byte). Use setMaximumFeeRate method to raise your threshold, or pass true to the first arg of extractTransaction.`
        );
      }
    }
    function checkInputsForPartialSig(inputs, action) {
      inputs.forEach((input) => {
        let throws = false;
        let pSigs = [];
        if ((input.partialSig || []).length === 0) {
          if (!input.finalScriptSig && !input.finalScriptWitness) return;
          pSigs = getPsigsFromInputFinalScripts(input);
        } else {
          pSigs = input.partialSig;
        }
        pSigs.forEach((pSig) => {
          const { hashType } = bscript.signature.decode(pSig.signature);
          const whitelist = [];
          const isAnyoneCanPay = hashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY;
          if (isAnyoneCanPay) whitelist.push("addInput");
          const hashMod = hashType & 31;
          switch (hashMod) {
            case transaction_1.Transaction.SIGHASH_ALL:
              break;
            case transaction_1.Transaction.SIGHASH_SINGLE:
            case transaction_1.Transaction.SIGHASH_NONE:
              whitelist.push("addOutput");
              whitelist.push("setInputSequence");
              break;
          }
          if (whitelist.indexOf(action) === -1) {
            throws = true;
          }
        });
        if (throws) {
          throw new Error("Can not modify transaction, signatures exist.");
        }
      });
    }
    function checkPartialSigSighashes(input) {
      if (!input.sighashType || !input.partialSig) return;
      const { partialSig, sighashType } = input;
      partialSig.forEach((pSig) => {
        const { hashType } = bscript.signature.decode(pSig.signature);
        if (sighashType !== hashType) {
          throw new Error("Signature sighash does not match input sighash type");
        }
      });
    }
    function checkScriptForPubkey(pubkey, script, action) {
      if (!pubkeyInScript(pubkey, script)) {
        throw new Error(
          `Can not ${action} for this input with the key ${pubkey.toString("hex")}`
        );
      }
    }
    function checkTxEmpty(tx) {
      const isEmpty = tx.ins.every(
        (input) => input.script && input.script.length === 0 && input.witness && input.witness.length === 0
      );
      if (!isEmpty) {
        throw new Error("Format Error: Transaction ScriptSigs are not empty");
      }
    }
    function checkTxForDupeIns(tx, cache) {
      tx.ins.forEach((input) => {
        checkTxInputCache(cache, input);
      });
    }
    function checkTxInputCache(cache, input) {
      const key = bufferutils_1.reverseBuffer(Buffer.from(input.hash)).toString("hex") + ":" + input.index;
      if (cache.__TX_IN_CACHE[key]) throw new Error("Duplicate input detected.");
      cache.__TX_IN_CACHE[key] = 1;
    }
    function scriptCheckerFactory(payment, paymentScriptName) {
      return (inputIndex, scriptPubKey, redeemScript, ioType) => {
        const redeemScriptOutput = payment({
          redeem: { output: redeemScript }
        }).output;
        if (!scriptPubKey.equals(redeemScriptOutput)) {
          throw new Error(
            `${paymentScriptName} for ${ioType} #${inputIndex} doesn't match the scriptPubKey in the prevout`
          );
        }
      };
    }
    var checkRedeemScript = scriptCheckerFactory(payments.p2sh, "Redeem script");
    var checkWitnessScript = scriptCheckerFactory(
      payments.p2wsh,
      "Witness script"
    );
    function getTxCacheValue(key, name, inputs, c) {
      if (!inputs.every(isFinalized))
        throw new Error(`PSBT must be finalized to calculate ${name}`);
      if (key === "__FEE_RATE" && c.__FEE_RATE) return c.__FEE_RATE;
      if (key === "__FEE" && c.__FEE) return c.__FEE;
      let tx;
      let mustFinalize = true;
      if (c.__EXTRACTED_TX) {
        tx = c.__EXTRACTED_TX;
        mustFinalize = false;
      } else {
        tx = c.__TX.clone();
      }
      inputFinalizeGetAmts(inputs, tx, c, mustFinalize);
      if (key === "__FEE_RATE") return c.__FEE_RATE;
      else if (key === "__FEE") return c.__FEE;
    }
    function getFinalScripts(inputIndex, input, script, isSegwit, isP2SH, isP2WSH) {
      const scriptType = classifyScript(script);
      if (!canFinalize(input, script, scriptType))
        throw new Error(`Can not finalize input #${inputIndex}`);
      return prepareFinalScripts(
        script,
        scriptType,
        input.partialSig,
        isSegwit,
        isP2SH,
        isP2WSH
      );
    }
    function prepareFinalScripts(script, scriptType, partialSig, isSegwit, isP2SH, isP2WSH) {
      let finalScriptSig;
      let finalScriptWitness;
      const payment = getPayment(script, scriptType, partialSig);
      const p2wsh = !isP2WSH ? null : payments.p2wsh({ redeem: payment });
      const p2sh = !isP2SH ? null : payments.p2sh({ redeem: p2wsh || payment });
      if (isSegwit) {
        if (p2wsh) {
          finalScriptWitness = witnessStackToScriptWitness(p2wsh.witness);
        } else {
          finalScriptWitness = witnessStackToScriptWitness(payment.witness);
        }
        if (p2sh) {
          finalScriptSig = p2sh.input;
        }
      } else {
        if (p2sh) {
          finalScriptSig = p2sh.input;
        } else {
          finalScriptSig = payment.input;
        }
      }
      return {
        finalScriptSig,
        finalScriptWitness
      };
    }
    function getHashAndSighashType(inputs, inputIndex, pubkey, cache, sighashTypes) {
      const input = utils_1.checkForInput(inputs, inputIndex);
      const { hash, sighashType, script } = getHashForSig(
        inputIndex,
        input,
        cache,
        false,
        sighashTypes
      );
      checkScriptForPubkey(pubkey, script, "sign");
      return {
        hash,
        sighashType
      };
    }
    function getHashForSig(inputIndex, input, cache, forValidate, sighashTypes) {
      const unsignedTx = cache.__TX;
      const sighashType = input.sighashType || transaction_1.Transaction.SIGHASH_ALL;
      if (sighashTypes && sighashTypes.indexOf(sighashType) < 0) {
        const str = sighashTypeToString(sighashType);
        throw new Error(
          `Sighash type is not allowed. Retry the sign method passing the sighashTypes array of whitelisted types. Sighash type: ${str}`
        );
      }
      let hash;
      let prevout;
      if (input.nonWitnessUtxo) {
        const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(
          cache,
          input,
          inputIndex
        );
        const prevoutHash = unsignedTx.ins[inputIndex].hash;
        const utxoHash = nonWitnessUtxoTx.getHash();
        if (!prevoutHash.equals(utxoHash)) {
          throw new Error(
            `Non-witness UTXO hash for input #${inputIndex} doesn't match the hash specified in the prevout`
          );
        }
        const prevoutIndex = unsignedTx.ins[inputIndex].index;
        prevout = nonWitnessUtxoTx.outs[prevoutIndex];
      } else if (input.witnessUtxo) {
        prevout = input.witnessUtxo;
      } else {
        throw new Error("Need a Utxo input item for signing");
      }
      const { meaningfulScript, type } = getMeaningfulScript(
        prevout.script,
        inputIndex,
        "input",
        input.redeemScript,
        input.witnessScript
      );
      if (["p2sh-p2wsh", "p2wsh"].indexOf(type) >= 0) {
        hash = unsignedTx.hashForWitnessV0(
          inputIndex,
          meaningfulScript,
          prevout.value,
          sighashType
        );
      } else if (isP2WPKH(meaningfulScript)) {
        const signingScript = payments.p2pkh({ hash: meaningfulScript.slice(2) }).output;
        hash = unsignedTx.hashForWitnessV0(
          inputIndex,
          signingScript,
          prevout.value,
          sighashType
        );
      } else {
        if (input.nonWitnessUtxo === void 0 && cache.__UNSAFE_SIGN_NONSEGWIT === false)
          throw new Error(
            `Input #${inputIndex} has witnessUtxo but non-segwit script: ${meaningfulScript.toString("hex")}`
          );
        if (!forValidate && cache.__UNSAFE_SIGN_NONSEGWIT !== false)
          console.warn(
            "Warning: Signing non-segwit inputs without the full parent transaction means there is a chance that a miner could feed you incorrect information to trick you into paying large fees. This behavior is the same as the old TransactionBuilder class when signing non-segwit scripts. You are not able to export this Psbt with toBuffer|toBase64|toHex since it is not BIP174 compliant.\n*********************\nPROCEED WITH CAUTION!\n*********************"
          );
        hash = unsignedTx.hashForSignature(
          inputIndex,
          meaningfulScript,
          sighashType
        );
      }
      return {
        script: meaningfulScript,
        sighashType,
        hash
      };
    }
    function getPayment(script, scriptType, partialSig) {
      let payment;
      switch (scriptType) {
        case "multisig":
          const sigs = getSortedSigs(script, partialSig);
          payment = payments.p2ms({
            output: script,
            signatures: sigs
          });
          break;
        case "pubkey":
          payment = payments.p2pk({
            output: script,
            signature: partialSig[0].signature
          });
          break;
        case "pubkeyhash":
          payment = payments.p2pkh({
            output: script,
            pubkey: partialSig[0].pubkey,
            signature: partialSig[0].signature
          });
          break;
        case "witnesspubkeyhash":
          payment = payments.p2wpkh({
            output: script,
            pubkey: partialSig[0].pubkey,
            signature: partialSig[0].signature
          });
          break;
      }
      return payment;
    }
    function getPsigsFromInputFinalScripts(input) {
      const scriptItems = !input.finalScriptSig ? [] : bscript.decompile(input.finalScriptSig) || [];
      const witnessItems = !input.finalScriptWitness ? [] : bscript.decompile(input.finalScriptWitness) || [];
      return scriptItems.concat(witnessItems).filter((item) => {
        return Buffer.isBuffer(item) && bscript.isCanonicalScriptSignature(item);
      }).map((sig) => ({ signature: sig }));
    }
    function getScriptFromInput(inputIndex, input, cache) {
      const unsignedTx = cache.__TX;
      const res = {
        script: null,
        isSegwit: false,
        isP2SH: false,
        isP2WSH: false
      };
      res.isP2SH = !!input.redeemScript;
      res.isP2WSH = !!input.witnessScript;
      if (input.witnessScript) {
        res.script = input.witnessScript;
      } else if (input.redeemScript) {
        res.script = input.redeemScript;
      } else {
        if (input.nonWitnessUtxo) {
          const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(
            cache,
            input,
            inputIndex
          );
          const prevoutIndex = unsignedTx.ins[inputIndex].index;
          res.script = nonWitnessUtxoTx.outs[prevoutIndex].script;
        } else if (input.witnessUtxo) {
          res.script = input.witnessUtxo.script;
        }
      }
      if (input.witnessScript || isP2WPKH(res.script)) {
        res.isSegwit = true;
      }
      return res;
    }
    function getSignersFromHD(inputIndex, inputs, hdKeyPair) {
      const input = utils_1.checkForInput(inputs, inputIndex);
      if (!input.bip32Derivation || input.bip32Derivation.length === 0) {
        throw new Error("Need bip32Derivation to sign with HD");
      }
      const myDerivations = input.bip32Derivation.map((bipDv) => {
        if (bipDv.masterFingerprint.equals(hdKeyPair.fingerprint)) {
          return bipDv;
        } else {
          return;
        }
      }).filter((v) => !!v);
      if (myDerivations.length === 0) {
        throw new Error(
          "Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint"
        );
      }
      const signers = myDerivations.map((bipDv) => {
        const node = hdKeyPair.derivePath(bipDv.path);
        if (!bipDv.pubkey.equals(node.publicKey)) {
          throw new Error("pubkey did not match bip32Derivation");
        }
        return node;
      });
      return signers;
    }
    function getSortedSigs(script, partialSig) {
      const p2ms = payments.p2ms({ output: script });
      return p2ms.pubkeys.map((pk) => {
        return (partialSig.filter((ps) => {
          return ps.pubkey.equals(pk);
        })[0] || {}).signature;
      }).filter((v) => !!v);
    }
    function scriptWitnessToWitnessStack(buffer) {
      let offset = 0;
      function readSlice(n) {
        offset += n;
        return buffer.slice(offset - n, offset);
      }
      function readVarInt() {
        const vi = varuint2.decode(buffer, offset);
        offset += varuint2.decode.bytes;
        return vi;
      }
      function readVarSlice() {
        return readSlice(readVarInt());
      }
      function readVector() {
        const count = readVarInt();
        const vector = [];
        for (let i = 0; i < count; i++) vector.push(readVarSlice());
        return vector;
      }
      return readVector();
    }
    function sighashTypeToString(sighashType) {
      let text = sighashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY ? "SIGHASH_ANYONECANPAY | " : "";
      const sigMod = sighashType & 31;
      switch (sigMod) {
        case transaction_1.Transaction.SIGHASH_ALL:
          text += "SIGHASH_ALL";
          break;
        case transaction_1.Transaction.SIGHASH_SINGLE:
          text += "SIGHASH_SINGLE";
          break;
        case transaction_1.Transaction.SIGHASH_NONE:
          text += "SIGHASH_NONE";
          break;
      }
      return text;
    }
    function witnessStackToScriptWitness(witness) {
      let buffer = Buffer.allocUnsafe(0);
      function writeSlice(slice) {
        buffer = Buffer.concat([buffer, Buffer.from(slice)]);
      }
      function writeVarInt(i) {
        const currentLen = buffer.length;
        const varintLen = varuint2.encodingLength(i);
        buffer = Buffer.concat([buffer, Buffer.allocUnsafe(varintLen)]);
        varuint2.encode(i, buffer, currentLen);
      }
      function writeVarSlice(slice) {
        writeVarInt(slice.length);
        writeSlice(slice);
      }
      function writeVector(vector) {
        writeVarInt(vector.length);
        vector.forEach(writeVarSlice);
      }
      writeVector(witness);
      return buffer;
    }
    function addNonWitnessTxCache(cache, input, inputIndex) {
      cache.__NON_WITNESS_UTXO_BUF_CACHE[inputIndex] = input.nonWitnessUtxo;
      const tx = transaction_1.Transaction.fromBuffer(input.nonWitnessUtxo);
      cache.__NON_WITNESS_UTXO_TX_CACHE[inputIndex] = tx;
      const self2 = cache;
      const selfIndex = inputIndex;
      delete input.nonWitnessUtxo;
      Object.defineProperty(input, "nonWitnessUtxo", {
        enumerable: true,
        get() {
          const buf = self2.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex];
          const txCache = self2.__NON_WITNESS_UTXO_TX_CACHE[selfIndex];
          if (buf !== void 0) {
            return buf;
          } else {
            const newBuf = txCache.toBuffer();
            self2.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = newBuf;
            return newBuf;
          }
        },
        set(data) {
          self2.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = data;
        }
      });
    }
    function inputFinalizeGetAmts(inputs, tx, cache, mustFinalize) {
      let inputAmount = 0;
      inputs.forEach((input, idx) => {
        if (mustFinalize && input.finalScriptSig)
          tx.ins[idx].script = input.finalScriptSig;
        if (mustFinalize && input.finalScriptWitness) {
          tx.ins[idx].witness = scriptWitnessToWitnessStack(
            input.finalScriptWitness
          );
        }
        if (input.witnessUtxo) {
          inputAmount += input.witnessUtxo.value;
        } else if (input.nonWitnessUtxo) {
          const nwTx = nonWitnessUtxoTxFromCache(cache, input, idx);
          const vout = tx.ins[idx].index;
          const out = nwTx.outs[vout];
          inputAmount += out.value;
        }
      });
      const outputAmount = tx.outs.reduce((total, o) => total + o.value, 0);
      const fee = inputAmount - outputAmount;
      if (fee < 0) {
        throw new Error("Outputs are spending more than Inputs");
      }
      const bytes = tx.virtualSize();
      cache.__FEE = fee;
      cache.__EXTRACTED_TX = tx;
      cache.__FEE_RATE = Math.floor(fee / bytes);
    }
    function nonWitnessUtxoTxFromCache(cache, input, inputIndex) {
      const c = cache.__NON_WITNESS_UTXO_TX_CACHE;
      if (!c[inputIndex]) {
        addNonWitnessTxCache(cache, input, inputIndex);
      }
      return c[inputIndex];
    }
    function getScriptFromUtxo(inputIndex, input, cache) {
      if (input.witnessUtxo !== void 0) {
        return input.witnessUtxo.script;
      } else if (input.nonWitnessUtxo !== void 0) {
        const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(
          cache,
          input,
          inputIndex
        );
        return nonWitnessUtxoTx.outs[cache.__TX.ins[inputIndex].index].script;
      } else {
        throw new Error("Can't find pubkey in input without Utxo data");
      }
    }
    function pubkeyInInput(pubkey, input, inputIndex, cache) {
      const script = getScriptFromUtxo(inputIndex, input, cache);
      const { meaningfulScript } = getMeaningfulScript(
        script,
        inputIndex,
        "input",
        input.redeemScript,
        input.witnessScript
      );
      return pubkeyInScript(pubkey, meaningfulScript);
    }
    function pubkeyInOutput(pubkey, output, outputIndex, cache) {
      const script = cache.__TX.outs[outputIndex].script;
      const { meaningfulScript } = getMeaningfulScript(
        script,
        outputIndex,
        "output",
        output.redeemScript,
        output.witnessScript
      );
      return pubkeyInScript(pubkey, meaningfulScript);
    }
    function redeemFromFinalScriptSig(finalScript) {
      if (!finalScript) return;
      const decomp = bscript.decompile(finalScript);
      if (!decomp) return;
      const lastItem = decomp[decomp.length - 1];
      if (!Buffer.isBuffer(lastItem) || isPubkeyLike(lastItem) || isSigLike(lastItem))
        return;
      const sDecomp = bscript.decompile(lastItem);
      if (!sDecomp) return;
      return lastItem;
    }
    function redeemFromFinalWitnessScript(finalScript) {
      if (!finalScript) return;
      const decomp = scriptWitnessToWitnessStack(finalScript);
      const lastItem = decomp[decomp.length - 1];
      if (isPubkeyLike(lastItem)) return;
      const sDecomp = bscript.decompile(lastItem);
      if (!sDecomp) return;
      return lastItem;
    }
    function isPubkeyLike(buf) {
      return buf.length === 33 && bscript.isCanonicalPubKey(buf);
    }
    function isSigLike(buf) {
      return bscript.isCanonicalScriptSignature(buf);
    }
    function getMeaningfulScript(script, index, ioType, redeemScript, witnessScript) {
      const isP2SH = isP2SHScript(script);
      const isP2SHP2WSH = isP2SH && redeemScript && isP2WSHScript(redeemScript);
      const isP2WSH = isP2WSHScript(script);
      if (isP2SH && redeemScript === void 0)
        throw new Error("scriptPubkey is P2SH but redeemScript missing");
      if ((isP2WSH || isP2SHP2WSH) && witnessScript === void 0)
        throw new Error(
          "scriptPubkey or redeemScript is P2WSH but witnessScript missing"
        );
      let meaningfulScript;
      if (isP2SHP2WSH) {
        meaningfulScript = witnessScript;
        checkRedeemScript(index, script, redeemScript, ioType);
        checkWitnessScript(index, redeemScript, witnessScript, ioType);
        checkInvalidP2WSH(meaningfulScript);
      } else if (isP2WSH) {
        meaningfulScript = witnessScript;
        checkWitnessScript(index, script, witnessScript, ioType);
        checkInvalidP2WSH(meaningfulScript);
      } else if (isP2SH) {
        meaningfulScript = redeemScript;
        checkRedeemScript(index, script, redeemScript, ioType);
      } else {
        meaningfulScript = script;
      }
      return {
        meaningfulScript,
        type: isP2SHP2WSH ? "p2sh-p2wsh" : isP2SH ? "p2sh" : isP2WSH ? "p2wsh" : "raw"
      };
    }
    function checkInvalidP2WSH(script) {
      if (isP2WPKH(script) || isP2SHScript(script)) {
        throw new Error("P2WPKH or P2SH can not be contained within P2WSH");
      }
    }
    function pubkeyInScript(pubkey, script) {
      const pubkeyHash = crypto_1.hash160(pubkey);
      const decompiled = bscript.decompile(script);
      if (decompiled === null) throw new Error("Unknown script error");
      return decompiled.some((element) => {
        if (typeof element === "number") return false;
        return element.equals(pubkey) || element.equals(pubkeyHash);
      });
    }
    function classifyScript(script) {
      if (isP2WPKH(script)) return "witnesspubkeyhash";
      if (isP2PKH(script)) return "pubkeyhash";
      if (isP2MS(script)) return "multisig";
      if (isP2PK(script)) return "pubkey";
      return "nonstandard";
    }
    function range(n) {
      return [...Array(n).keys()];
    }
  }
});

// node_modules/bitcoinjs-lib/src/templates/multisig/input.js
var require_input = __commonJS({
  "node_modules/bitcoinjs-lib/src/templates/multisig/input.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var bscript = require_script();
    var script_1 = require_script();
    function partialSignature(value) {
      return value === script_1.OPS.OP_0 || bscript.isCanonicalScriptSignature(value);
    }
    function check(script, allowIncomplete) {
      const chunks = bscript.decompile(script);
      if (chunks.length < 2) return false;
      if (chunks[0] !== script_1.OPS.OP_0) return false;
      if (allowIncomplete) {
        return chunks.slice(1).every(partialSignature);
      }
      return chunks.slice(1).every(bscript.isCanonicalScriptSignature);
    }
    exports2.check = check;
    check.toJSON = () => {
      return "multisig input";
    };
  }
});

// node_modules/bitcoinjs-lib/src/templates/multisig/output.js
var require_output = __commonJS({
  "node_modules/bitcoinjs-lib/src/templates/multisig/output.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var bscript = require_script();
    var script_1 = require_script();
    var types = require_types();
    var OP_INT_BASE = script_1.OPS.OP_RESERVED;
    function check(script, allowIncomplete) {
      const chunks = bscript.decompile(script);
      if (chunks.length < 4) return false;
      if (chunks[chunks.length - 1] !== script_1.OPS.OP_CHECKMULTISIG) return false;
      if (!types.Number(chunks[0])) return false;
      if (!types.Number(chunks[chunks.length - 2])) return false;
      const m = chunks[0] - OP_INT_BASE;
      const n = chunks[chunks.length - 2] - OP_INT_BASE;
      if (m <= 0) return false;
      if (n > 16) return false;
      if (m > n) return false;
      if (n !== chunks.length - 3) return false;
      if (allowIncomplete) return true;
      const keys = chunks.slice(1, -2);
      return keys.every(bscript.isCanonicalPubKey);
    }
    exports2.check = check;
    check.toJSON = () => {
      return "multi-sig output";
    };
  }
});

// node_modules/bitcoinjs-lib/src/templates/multisig/index.js
var require_multisig = __commonJS({
  "node_modules/bitcoinjs-lib/src/templates/multisig/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var input = require_input();
    exports2.input = input;
    var output = require_output();
    exports2.output = output;
  }
});

// node_modules/bitcoinjs-lib/src/templates/nulldata.js
var require_nulldata = __commonJS({
  "node_modules/bitcoinjs-lib/src/templates/nulldata.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var bscript = require_script();
    var OPS = bscript.OPS;
    function check(script) {
      const buffer = bscript.compile(script);
      return buffer.length > 1 && buffer[0] === OPS.OP_RETURN;
    }
    exports2.check = check;
    check.toJSON = () => {
      return "null data output";
    };
    var output = { check };
    exports2.output = output;
  }
});

// node_modules/bitcoinjs-lib/src/templates/pubkey/input.js
var require_input2 = __commonJS({
  "node_modules/bitcoinjs-lib/src/templates/pubkey/input.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var bscript = require_script();
    function check(script) {
      const chunks = bscript.decompile(script);
      return chunks.length === 1 && bscript.isCanonicalScriptSignature(chunks[0]);
    }
    exports2.check = check;
    check.toJSON = () => {
      return "pubKey input";
    };
  }
});

// node_modules/bitcoinjs-lib/src/templates/pubkey/output.js
var require_output2 = __commonJS({
  "node_modules/bitcoinjs-lib/src/templates/pubkey/output.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var bscript = require_script();
    var script_1 = require_script();
    function check(script) {
      const chunks = bscript.decompile(script);
      return chunks.length === 2 && bscript.isCanonicalPubKey(chunks[0]) && chunks[1] === script_1.OPS.OP_CHECKSIG;
    }
    exports2.check = check;
    check.toJSON = () => {
      return "pubKey output";
    };
  }
});

// node_modules/bitcoinjs-lib/src/templates/pubkey/index.js
var require_pubkey = __commonJS({
  "node_modules/bitcoinjs-lib/src/templates/pubkey/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var input = require_input2();
    exports2.input = input;
    var output = require_output2();
    exports2.output = output;
  }
});

// node_modules/bitcoinjs-lib/src/templates/pubkeyhash/input.js
var require_input3 = __commonJS({
  "node_modules/bitcoinjs-lib/src/templates/pubkeyhash/input.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var bscript = require_script();
    function check(script) {
      const chunks = bscript.decompile(script);
      return chunks.length === 2 && bscript.isCanonicalScriptSignature(chunks[0]) && bscript.isCanonicalPubKey(chunks[1]);
    }
    exports2.check = check;
    check.toJSON = () => {
      return "pubKeyHash input";
    };
  }
});

// node_modules/bitcoinjs-lib/src/templates/pubkeyhash/output.js
var require_output3 = __commonJS({
  "node_modules/bitcoinjs-lib/src/templates/pubkeyhash/output.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var bscript = require_script();
    var script_1 = require_script();
    function check(script) {
      const buffer = bscript.compile(script);
      return buffer.length === 25 && buffer[0] === script_1.OPS.OP_DUP && buffer[1] === script_1.OPS.OP_HASH160 && buffer[2] === 20 && buffer[23] === script_1.OPS.OP_EQUALVERIFY && buffer[24] === script_1.OPS.OP_CHECKSIG;
    }
    exports2.check = check;
    check.toJSON = () => {
      return "pubKeyHash output";
    };
  }
});

// node_modules/bitcoinjs-lib/src/templates/pubkeyhash/index.js
var require_pubkeyhash = __commonJS({
  "node_modules/bitcoinjs-lib/src/templates/pubkeyhash/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var input = require_input3();
    exports2.input = input;
    var output = require_output3();
    exports2.output = output;
  }
});

// node_modules/bitcoinjs-lib/src/templates/witnesspubkeyhash/output.js
var require_output4 = __commonJS({
  "node_modules/bitcoinjs-lib/src/templates/witnesspubkeyhash/output.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var bscript = require_script();
    var script_1 = require_script();
    function check(script) {
      const buffer = bscript.compile(script);
      return buffer.length === 22 && buffer[0] === script_1.OPS.OP_0 && buffer[1] === 20;
    }
    exports2.check = check;
    check.toJSON = () => {
      return "Witness pubKeyHash output";
    };
  }
});

// node_modules/bitcoinjs-lib/src/templates/witnessscripthash/output.js
var require_output5 = __commonJS({
  "node_modules/bitcoinjs-lib/src/templates/witnessscripthash/output.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var bscript = require_script();
    var script_1 = require_script();
    function check(script) {
      const buffer = bscript.compile(script);
      return buffer.length === 34 && buffer[0] === script_1.OPS.OP_0 && buffer[1] === 32;
    }
    exports2.check = check;
    check.toJSON = () => {
      return "Witness scriptHash output";
    };
  }
});

// node_modules/bitcoinjs-lib/src/templates/scripthash/input.js
var require_input4 = __commonJS({
  "node_modules/bitcoinjs-lib/src/templates/scripthash/input.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var bscript = require_script();
    var p2ms = require_multisig();
    var p2pk = require_pubkey();
    var p2pkh2 = require_pubkeyhash();
    var p2wpkho = require_output4();
    var p2wsho = require_output5();
    function check(script, allowIncomplete) {
      const chunks = bscript.decompile(script);
      if (chunks.length < 1) return false;
      const lastChunk = chunks[chunks.length - 1];
      if (!Buffer.isBuffer(lastChunk)) return false;
      const scriptSigChunks = bscript.decompile(
        bscript.compile(chunks.slice(0, -1))
      );
      const redeemScriptChunks = bscript.decompile(lastChunk);
      if (!redeemScriptChunks) return false;
      if (!bscript.isPushOnly(scriptSigChunks)) return false;
      if (chunks.length === 1) {
        return p2wsho.check(redeemScriptChunks) || p2wpkho.check(redeemScriptChunks);
      }
      if (p2pkh2.input.check(scriptSigChunks) && p2pkh2.output.check(redeemScriptChunks))
        return true;
      if (p2ms.input.check(scriptSigChunks, allowIncomplete) && p2ms.output.check(redeemScriptChunks))
        return true;
      if (p2pk.input.check(scriptSigChunks) && p2pk.output.check(redeemScriptChunks))
        return true;
      return false;
    }
    exports2.check = check;
    check.toJSON = () => {
      return "scriptHash input";
    };
  }
});

// node_modules/bitcoinjs-lib/src/templates/scripthash/output.js
var require_output6 = __commonJS({
  "node_modules/bitcoinjs-lib/src/templates/scripthash/output.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var bscript = require_script();
    var script_1 = require_script();
    function check(script) {
      const buffer = bscript.compile(script);
      return buffer.length === 23 && buffer[0] === script_1.OPS.OP_HASH160 && buffer[1] === 20 && buffer[22] === script_1.OPS.OP_EQUAL;
    }
    exports2.check = check;
    check.toJSON = () => {
      return "scriptHash output";
    };
  }
});

// node_modules/bitcoinjs-lib/src/templates/scripthash/index.js
var require_scripthash = __commonJS({
  "node_modules/bitcoinjs-lib/src/templates/scripthash/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var input = require_input4();
    exports2.input = input;
    var output = require_output6();
    exports2.output = output;
  }
});

// node_modules/bitcoinjs-lib/src/templates/witnesscommitment/output.js
var require_output7 = __commonJS({
  "node_modules/bitcoinjs-lib/src/templates/witnesscommitment/output.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var bscript = require_script();
    var script_1 = require_script();
    var types = require_types();
    var typeforce = require_typeforce();
    var HEADER = Buffer.from("aa21a9ed", "hex");
    function check(script) {
      const buffer = bscript.compile(script);
      return buffer.length > 37 && buffer[0] === script_1.OPS.OP_RETURN && buffer[1] === 36 && buffer.slice(2, 6).equals(HEADER);
    }
    exports2.check = check;
    check.toJSON = () => {
      return "Witness commitment output";
    };
    function encode(commitment) {
      typeforce(types.Hash256bit, commitment);
      const buffer = Buffer.allocUnsafe(36);
      HEADER.copy(buffer, 0);
      commitment.copy(buffer, 4);
      return bscript.compile([script_1.OPS.OP_RETURN, buffer]);
    }
    exports2.encode = encode;
    function decode(buffer) {
      typeforce(check, buffer);
      return bscript.decompile(buffer)[1].slice(4, 36);
    }
    exports2.decode = decode;
  }
});

// node_modules/bitcoinjs-lib/src/templates/witnesscommitment/index.js
var require_witnesscommitment = __commonJS({
  "node_modules/bitcoinjs-lib/src/templates/witnesscommitment/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var output = require_output7();
    exports2.output = output;
  }
});

// node_modules/bitcoinjs-lib/src/templates/witnesspubkeyhash/input.js
var require_input5 = __commonJS({
  "node_modules/bitcoinjs-lib/src/templates/witnesspubkeyhash/input.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var bscript = require_script();
    function isCompressedCanonicalPubKey(pubKey) {
      return bscript.isCanonicalPubKey(pubKey) && pubKey.length === 33;
    }
    function check(script) {
      const chunks = bscript.decompile(script);
      return chunks.length === 2 && bscript.isCanonicalScriptSignature(chunks[0]) && isCompressedCanonicalPubKey(chunks[1]);
    }
    exports2.check = check;
    check.toJSON = () => {
      return "witnessPubKeyHash input";
    };
  }
});

// node_modules/bitcoinjs-lib/src/templates/witnesspubkeyhash/index.js
var require_witnesspubkeyhash = __commonJS({
  "node_modules/bitcoinjs-lib/src/templates/witnesspubkeyhash/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var input = require_input5();
    exports2.input = input;
    var output = require_output4();
    exports2.output = output;
  }
});

// node_modules/bitcoinjs-lib/src/templates/witnessscripthash/input.js
var require_input6 = __commonJS({
  "node_modules/bitcoinjs-lib/src/templates/witnessscripthash/input.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var bscript = require_script();
    var typeforce = require_typeforce();
    var p2ms = require_multisig();
    var p2pk = require_pubkey();
    var p2pkh2 = require_pubkeyhash();
    function check(chunks, allowIncomplete) {
      typeforce(typeforce.Array, chunks);
      if (chunks.length < 1) return false;
      const witnessScript = chunks[chunks.length - 1];
      if (!Buffer.isBuffer(witnessScript)) return false;
      const witnessScriptChunks = bscript.decompile(witnessScript);
      if (!witnessScriptChunks || witnessScriptChunks.length === 0) return false;
      const witnessRawScriptSig = bscript.compile(chunks.slice(0, -1));
      if (p2pkh2.input.check(witnessRawScriptSig) && p2pkh2.output.check(witnessScriptChunks))
        return true;
      if (p2ms.input.check(witnessRawScriptSig, allowIncomplete) && p2ms.output.check(witnessScriptChunks))
        return true;
      if (p2pk.input.check(witnessRawScriptSig) && p2pk.output.check(witnessScriptChunks))
        return true;
      return false;
    }
    exports2.check = check;
    check.toJSON = () => {
      return "witnessScriptHash input";
    };
  }
});

// node_modules/bitcoinjs-lib/src/templates/witnessscripthash/index.js
var require_witnessscripthash = __commonJS({
  "node_modules/bitcoinjs-lib/src/templates/witnessscripthash/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var input = require_input6();
    exports2.input = input;
    var output = require_output5();
    exports2.output = output;
  }
});

// node_modules/bitcoinjs-lib/src/classify.js
var require_classify = __commonJS({
  "node_modules/bitcoinjs-lib/src/classify.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var script_1 = require_script();
    var multisig = require_multisig();
    var nullData = require_nulldata();
    var pubKey = require_pubkey();
    var pubKeyHash = require_pubkeyhash();
    var scriptHash = require_scripthash();
    var witnessCommitment = require_witnesscommitment();
    var witnessPubKeyHash = require_witnesspubkeyhash();
    var witnessScriptHash = require_witnessscripthash();
    var types = {
      P2MS: "multisig",
      NONSTANDARD: "nonstandard",
      NULLDATA: "nulldata",
      P2PK: "pubkey",
      P2PKH: "pubkeyhash",
      P2SH: "scripthash",
      P2WPKH: "witnesspubkeyhash",
      P2WSH: "witnessscripthash",
      WITNESS_COMMITMENT: "witnesscommitment"
    };
    exports2.types = types;
    function classifyOutput(script) {
      if (witnessPubKeyHash.output.check(script)) return types.P2WPKH;
      if (witnessScriptHash.output.check(script)) return types.P2WSH;
      if (pubKeyHash.output.check(script)) return types.P2PKH;
      if (scriptHash.output.check(script)) return types.P2SH;
      const chunks = script_1.decompile(script);
      if (!chunks) throw new TypeError("Invalid script");
      if (multisig.output.check(chunks)) return types.P2MS;
      if (pubKey.output.check(chunks)) return types.P2PK;
      if (witnessCommitment.output.check(chunks)) return types.WITNESS_COMMITMENT;
      if (nullData.output.check(chunks)) return types.NULLDATA;
      return types.NONSTANDARD;
    }
    exports2.output = classifyOutput;
    function classifyInput(script, allowIncomplete) {
      const chunks = script_1.decompile(script);
      if (!chunks) throw new TypeError("Invalid script");
      if (pubKeyHash.input.check(chunks)) return types.P2PKH;
      if (scriptHash.input.check(chunks, allowIncomplete)) return types.P2SH;
      if (multisig.input.check(chunks, allowIncomplete)) return types.P2MS;
      if (pubKey.input.check(chunks)) return types.P2PK;
      return types.NONSTANDARD;
    }
    exports2.input = classifyInput;
    function classifyWitness(script, allowIncomplete) {
      const chunks = script_1.decompile(script);
      if (!chunks) throw new TypeError("Invalid script");
      if (witnessPubKeyHash.input.check(chunks)) return types.P2WPKH;
      if (witnessScriptHash.input.check(chunks, allowIncomplete))
        return types.P2WSH;
      return types.NONSTANDARD;
    }
    exports2.witness = classifyWitness;
  }
});

// node_modules/bitcoinjs-lib/src/transaction_builder.js
var require_transaction_builder = __commonJS({
  "node_modules/bitcoinjs-lib/src/transaction_builder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var baddress = require_address();
    var bufferutils_1 = require_bufferutils();
    var classify = require_classify();
    var bcrypto = require_crypto3();
    var ECPair = require_ecpair();
    var networks = require_networks();
    var payments = require_payments();
    var bscript = require_script();
    var script_1 = require_script();
    var transaction_1 = require_transaction();
    var types = require_types();
    var typeforce = require_typeforce();
    var SCRIPT_TYPES = classify.types;
    var PREVOUT_TYPES = /* @__PURE__ */ new Set([
      // Raw
      "p2pkh",
      "p2pk",
      "p2wpkh",
      "p2ms",
      // P2SH wrapped
      "p2sh-p2pkh",
      "p2sh-p2pk",
      "p2sh-p2wpkh",
      "p2sh-p2ms",
      // P2WSH wrapped
      "p2wsh-p2pkh",
      "p2wsh-p2pk",
      "p2wsh-p2ms",
      // P2SH-P2WSH wrapper
      "p2sh-p2wsh-p2pkh",
      "p2sh-p2wsh-p2pk",
      "p2sh-p2wsh-p2ms"
    ]);
    function tfMessage(type, value, message) {
      try {
        typeforce(type, value);
      } catch (err) {
        throw new Error(message);
      }
    }
    function txIsString(tx) {
      return typeof tx === "string" || tx instanceof String;
    }
    function txIsTransaction(tx) {
      return tx instanceof transaction_1.Transaction;
    }
    var TransactionBuilder = class _TransactionBuilder {
      // WARNING: maximumFeeRate is __NOT__ to be relied on,
      //          it's just another potential safety mechanism (safety in-depth)
      constructor(network = networks.bitcoin, maximumFeeRate = 2500) {
        this.network = network;
        this.maximumFeeRate = maximumFeeRate;
        this.__PREV_TX_SET = {};
        this.__INPUTS = [];
        this.__TX = new transaction_1.Transaction();
        this.__TX.version = 2;
        this.__USE_LOW_R = false;
        console.warn(
          "Deprecation Warning: TransactionBuilder will be removed in the future. (v6.x.x or later) Please use the Psbt class instead. Examples of usage are available in the transactions-psbt.js integration test file on our Github. A high level explanation is available in the psbt.ts and psbt.js files as well."
        );
      }
      static fromTransaction(transaction, network) {
        const txb = new _TransactionBuilder(network);
        txb.setVersion(transaction.version);
        txb.setLockTime(transaction.locktime);
        transaction.outs.forEach((txOut) => {
          txb.addOutput(txOut.script, txOut.value);
        });
        transaction.ins.forEach((txIn) => {
          txb.__addInputUnsafe(txIn.hash, txIn.index, {
            sequence: txIn.sequence,
            script: txIn.script,
            witness: txIn.witness
          });
        });
        txb.__INPUTS.forEach((input, i) => {
          fixMultisigOrder(input, transaction, i);
        });
        return txb;
      }
      setLowR(setting) {
        typeforce(typeforce.maybe(typeforce.Boolean), setting);
        if (setting === void 0) {
          setting = true;
        }
        this.__USE_LOW_R = setting;
        return setting;
      }
      setLockTime(locktime) {
        typeforce(types.UInt32, locktime);
        if (this.__INPUTS.some((input) => {
          if (!input.signatures) return false;
          return input.signatures.some((s) => s !== void 0);
        })) {
          throw new Error("No, this would invalidate signatures");
        }
        this.__TX.locktime = locktime;
      }
      setVersion(version) {
        typeforce(types.UInt32, version);
        this.__TX.version = version;
      }
      addInput(txHash, vout, sequence, prevOutScript) {
        if (!this.__canModifyInputs()) {
          throw new Error("No, this would invalidate signatures");
        }
        let value;
        if (txIsString(txHash)) {
          txHash = bufferutils_1.reverseBuffer(Buffer.from(txHash, "hex"));
        } else if (txIsTransaction(txHash)) {
          const txOut = txHash.outs[vout];
          prevOutScript = txOut.script;
          value = txOut.value;
          txHash = txHash.getHash(false);
        }
        return this.__addInputUnsafe(txHash, vout, {
          sequence,
          prevOutScript,
          value
        });
      }
      addOutput(scriptPubKey, value) {
        if (!this.__canModifyOutputs()) {
          throw new Error("No, this would invalidate signatures");
        }
        if (typeof scriptPubKey === "string") {
          scriptPubKey = baddress.toOutputScript(scriptPubKey, this.network);
        }
        return this.__TX.addOutput(scriptPubKey, value);
      }
      build() {
        return this.__build(false);
      }
      buildIncomplete() {
        return this.__build(true);
      }
      sign(signParams, keyPair, redeemScript, hashType, witnessValue, witnessScript) {
        trySign(
          getSigningData(
            this.network,
            this.__INPUTS,
            this.__needsOutputs.bind(this),
            this.__TX,
            signParams,
            keyPair,
            redeemScript,
            hashType,
            witnessValue,
            witnessScript,
            this.__USE_LOW_R
          )
        );
      }
      __addInputUnsafe(txHash, vout, options) {
        if (transaction_1.Transaction.isCoinbaseHash(txHash)) {
          throw new Error("coinbase inputs not supported");
        }
        const prevTxOut = txHash.toString("hex") + ":" + vout;
        if (this.__PREV_TX_SET[prevTxOut] !== void 0)
          throw new Error("Duplicate TxOut: " + prevTxOut);
        let input = {};
        if (options.script !== void 0) {
          input = expandInput(options.script, options.witness || []);
        }
        if (options.value !== void 0) {
          input.value = options.value;
        }
        if (!input.prevOutScript && options.prevOutScript) {
          let prevOutType;
          if (!input.pubkeys && !input.signatures) {
            const expanded = expandOutput(options.prevOutScript);
            if (expanded.pubkeys) {
              input.pubkeys = expanded.pubkeys;
              input.signatures = expanded.signatures;
            }
            prevOutType = expanded.type;
          }
          input.prevOutScript = options.prevOutScript;
          input.prevOutType = prevOutType || classify.output(options.prevOutScript);
        }
        const vin = this.__TX.addInput(
          txHash,
          vout,
          options.sequence,
          options.scriptSig
        );
        this.__INPUTS[vin] = input;
        this.__PREV_TX_SET[prevTxOut] = true;
        return vin;
      }
      __build(allowIncomplete) {
        if (!allowIncomplete) {
          if (!this.__TX.ins.length) throw new Error("Transaction has no inputs");
          if (!this.__TX.outs.length) throw new Error("Transaction has no outputs");
        }
        const tx = this.__TX.clone();
        this.__INPUTS.forEach((input, i) => {
          if (!input.prevOutType && !allowIncomplete)
            throw new Error("Transaction is not complete");
          const result = build(input.prevOutType, input, allowIncomplete);
          if (!result) {
            if (!allowIncomplete && input.prevOutType === SCRIPT_TYPES.NONSTANDARD)
              throw new Error("Unknown input type");
            if (!allowIncomplete) throw new Error("Not enough information");
            return;
          }
          tx.setInputScript(i, result.input);
          tx.setWitness(i, result.witness);
        });
        if (!allowIncomplete) {
          if (this.__overMaximumFees(tx.virtualSize())) {
            throw new Error("Transaction has absurd fees");
          }
        }
        return tx;
      }
      __canModifyInputs() {
        return this.__INPUTS.every((input) => {
          if (!input.signatures) return true;
          return input.signatures.every((signature) => {
            if (!signature) return true;
            const hashType = signatureHashType(signature);
            return (hashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY) !== 0;
          });
        });
      }
      __needsOutputs(signingHashType) {
        if (signingHashType === transaction_1.Transaction.SIGHASH_ALL) {
          return this.__TX.outs.length === 0;
        }
        return this.__TX.outs.length === 0 && this.__INPUTS.some((input) => {
          if (!input.signatures) return false;
          return input.signatures.some((signature) => {
            if (!signature) return false;
            const hashType = signatureHashType(signature);
            if (hashType & transaction_1.Transaction.SIGHASH_NONE) return false;
            return true;
          });
        });
      }
      __canModifyOutputs() {
        const nInputs = this.__TX.ins.length;
        const nOutputs = this.__TX.outs.length;
        return this.__INPUTS.every((input) => {
          if (input.signatures === void 0) return true;
          return input.signatures.every((signature) => {
            if (!signature) return true;
            const hashType = signatureHashType(signature);
            const hashTypeMod = hashType & 31;
            if (hashTypeMod === transaction_1.Transaction.SIGHASH_NONE) return true;
            if (hashTypeMod === transaction_1.Transaction.SIGHASH_SINGLE) {
              return nInputs <= nOutputs;
            }
            return false;
          });
        });
      }
      __overMaximumFees(bytes) {
        const incoming = this.__INPUTS.reduce((a, x) => a + (x.value >>> 0), 0);
        const outgoing = this.__TX.outs.reduce((a, x) => a + x.value, 0);
        const fee = incoming - outgoing;
        const feeRate = fee / bytes;
        return feeRate > this.maximumFeeRate;
      }
    };
    exports2.TransactionBuilder = TransactionBuilder;
    function expandInput(scriptSig, witnessStack, type, scriptPubKey) {
      if (scriptSig.length === 0 && witnessStack.length === 0) return {};
      if (!type) {
        let ssType = classify.input(scriptSig, true);
        let wsType = classify.witness(witnessStack, true);
        if (ssType === SCRIPT_TYPES.NONSTANDARD) ssType = void 0;
        if (wsType === SCRIPT_TYPES.NONSTANDARD) wsType = void 0;
        type = ssType || wsType;
      }
      switch (type) {
        case SCRIPT_TYPES.P2WPKH: {
          const { output, pubkey, signature } = payments.p2wpkh({
            witness: witnessStack
          });
          return {
            prevOutScript: output,
            prevOutType: SCRIPT_TYPES.P2WPKH,
            pubkeys: [pubkey],
            signatures: [signature]
          };
        }
        case SCRIPT_TYPES.P2PKH: {
          const { output, pubkey, signature } = payments.p2pkh({
            input: scriptSig
          });
          return {
            prevOutScript: output,
            prevOutType: SCRIPT_TYPES.P2PKH,
            pubkeys: [pubkey],
            signatures: [signature]
          };
        }
        case SCRIPT_TYPES.P2PK: {
          const { signature } = payments.p2pk({ input: scriptSig });
          return {
            prevOutType: SCRIPT_TYPES.P2PK,
            pubkeys: [void 0],
            signatures: [signature]
          };
        }
        case SCRIPT_TYPES.P2MS: {
          const { m, pubkeys, signatures } = payments.p2ms(
            {
              input: scriptSig,
              output: scriptPubKey
            },
            { allowIncomplete: true }
          );
          return {
            prevOutType: SCRIPT_TYPES.P2MS,
            pubkeys,
            signatures,
            maxSignatures: m
          };
        }
      }
      if (type === SCRIPT_TYPES.P2SH) {
        const { output, redeem } = payments.p2sh({
          input: scriptSig,
          witness: witnessStack
        });
        const outputType = classify.output(redeem.output);
        const expanded = expandInput(
          redeem.input,
          redeem.witness,
          outputType,
          redeem.output
        );
        if (!expanded.prevOutType) return {};
        return {
          prevOutScript: output,
          prevOutType: SCRIPT_TYPES.P2SH,
          redeemScript: redeem.output,
          redeemScriptType: expanded.prevOutType,
          witnessScript: expanded.witnessScript,
          witnessScriptType: expanded.witnessScriptType,
          pubkeys: expanded.pubkeys,
          signatures: expanded.signatures
        };
      }
      if (type === SCRIPT_TYPES.P2WSH) {
        const { output, redeem } = payments.p2wsh({
          input: scriptSig,
          witness: witnessStack
        });
        const outputType = classify.output(redeem.output);
        let expanded;
        if (outputType === SCRIPT_TYPES.P2WPKH) {
          expanded = expandInput(redeem.input, redeem.witness, outputType);
        } else {
          expanded = expandInput(
            bscript.compile(redeem.witness),
            [],
            outputType,
            redeem.output
          );
        }
        if (!expanded.prevOutType) return {};
        return {
          prevOutScript: output,
          prevOutType: SCRIPT_TYPES.P2WSH,
          witnessScript: redeem.output,
          witnessScriptType: expanded.prevOutType,
          pubkeys: expanded.pubkeys,
          signatures: expanded.signatures
        };
      }
      return {
        prevOutType: SCRIPT_TYPES.NONSTANDARD,
        prevOutScript: scriptSig
      };
    }
    function fixMultisigOrder(input, transaction, vin) {
      if (input.redeemScriptType !== SCRIPT_TYPES.P2MS || !input.redeemScript)
        return;
      if (input.pubkeys.length === input.signatures.length) return;
      const unmatched = input.signatures.concat();
      input.signatures = input.pubkeys.map((pubKey) => {
        const keyPair = ECPair.fromPublicKey(pubKey);
        let match;
        unmatched.some((signature, i) => {
          if (!signature) return false;
          const parsed = bscript.signature.decode(signature);
          const hash = transaction.hashForSignature(
            vin,
            input.redeemScript,
            parsed.hashType
          );
          if (!keyPair.verify(hash, parsed.signature)) return false;
          unmatched[i] = void 0;
          match = signature;
          return true;
        });
        return match;
      });
    }
    function expandOutput(script, ourPubKey) {
      typeforce(types.Buffer, script);
      const type = classify.output(script);
      switch (type) {
        case SCRIPT_TYPES.P2PKH: {
          if (!ourPubKey) return { type };
          const pkh1 = payments.p2pkh({ output: script }).hash;
          const pkh2 = bcrypto.hash160(ourPubKey);
          if (!pkh1.equals(pkh2)) return { type };
          return {
            type,
            pubkeys: [ourPubKey],
            signatures: [void 0]
          };
        }
        case SCRIPT_TYPES.P2WPKH: {
          if (!ourPubKey) return { type };
          const wpkh1 = payments.p2wpkh({ output: script }).hash;
          const wpkh2 = bcrypto.hash160(ourPubKey);
          if (!wpkh1.equals(wpkh2)) return { type };
          return {
            type,
            pubkeys: [ourPubKey],
            signatures: [void 0]
          };
        }
        case SCRIPT_TYPES.P2PK: {
          const p2pk = payments.p2pk({ output: script });
          return {
            type,
            pubkeys: [p2pk.pubkey],
            signatures: [void 0]
          };
        }
        case SCRIPT_TYPES.P2MS: {
          const p2ms = payments.p2ms({ output: script });
          return {
            type,
            pubkeys: p2ms.pubkeys,
            signatures: p2ms.pubkeys.map(() => void 0),
            maxSignatures: p2ms.m
          };
        }
      }
      return { type };
    }
    function prepareInput(input, ourPubKey, redeemScript, witnessScript) {
      if (redeemScript && witnessScript) {
        const p2wsh = payments.p2wsh({
          redeem: { output: witnessScript }
        });
        const p2wshAlt = payments.p2wsh({ output: redeemScript });
        const p2sh = payments.p2sh({ redeem: { output: redeemScript } });
        const p2shAlt = payments.p2sh({ redeem: p2wsh });
        if (!p2wsh.hash.equals(p2wshAlt.hash))
          throw new Error("Witness script inconsistent with prevOutScript");
        if (!p2sh.hash.equals(p2shAlt.hash))
          throw new Error("Redeem script inconsistent with prevOutScript");
        const expanded = expandOutput(p2wsh.redeem.output, ourPubKey);
        if (!expanded.pubkeys)
          throw new Error(
            expanded.type + " not supported as witnessScript (" + bscript.toASM(witnessScript) + ")"
          );
        if (input.signatures && input.signatures.some((x) => x !== void 0)) {
          expanded.signatures = input.signatures;
        }
        const signScript = witnessScript;
        if (expanded.type === SCRIPT_TYPES.P2WPKH)
          throw new Error("P2SH(P2WSH(P2WPKH)) is a consensus failure");
        return {
          redeemScript,
          redeemScriptType: SCRIPT_TYPES.P2WSH,
          witnessScript,
          witnessScriptType: expanded.type,
          prevOutType: SCRIPT_TYPES.P2SH,
          prevOutScript: p2sh.output,
          hasWitness: true,
          signScript,
          signType: expanded.type,
          pubkeys: expanded.pubkeys,
          signatures: expanded.signatures,
          maxSignatures: expanded.maxSignatures
        };
      }
      if (redeemScript) {
        const p2sh = payments.p2sh({ redeem: { output: redeemScript } });
        if (input.prevOutScript) {
          let p2shAlt;
          try {
            p2shAlt = payments.p2sh({ output: input.prevOutScript });
          } catch (e) {
            throw new Error("PrevOutScript must be P2SH");
          }
          if (!p2sh.hash.equals(p2shAlt.hash))
            throw new Error("Redeem script inconsistent with prevOutScript");
        }
        const expanded = expandOutput(p2sh.redeem.output, ourPubKey);
        if (!expanded.pubkeys)
          throw new Error(
            expanded.type + " not supported as redeemScript (" + bscript.toASM(redeemScript) + ")"
          );
        if (input.signatures && input.signatures.some((x) => x !== void 0)) {
          expanded.signatures = input.signatures;
        }
        let signScript = redeemScript;
        if (expanded.type === SCRIPT_TYPES.P2WPKH) {
          signScript = payments.p2pkh({ pubkey: expanded.pubkeys[0] }).output;
        }
        return {
          redeemScript,
          redeemScriptType: expanded.type,
          prevOutType: SCRIPT_TYPES.P2SH,
          prevOutScript: p2sh.output,
          hasWitness: expanded.type === SCRIPT_TYPES.P2WPKH,
          signScript,
          signType: expanded.type,
          pubkeys: expanded.pubkeys,
          signatures: expanded.signatures,
          maxSignatures: expanded.maxSignatures
        };
      }
      if (witnessScript) {
        const p2wsh = payments.p2wsh({ redeem: { output: witnessScript } });
        if (input.prevOutScript) {
          const p2wshAlt = payments.p2wsh({ output: input.prevOutScript });
          if (!p2wsh.hash.equals(p2wshAlt.hash))
            throw new Error("Witness script inconsistent with prevOutScript");
        }
        const expanded = expandOutput(p2wsh.redeem.output, ourPubKey);
        if (!expanded.pubkeys)
          throw new Error(
            expanded.type + " not supported as witnessScript (" + bscript.toASM(witnessScript) + ")"
          );
        if (input.signatures && input.signatures.some((x) => x !== void 0)) {
          expanded.signatures = input.signatures;
        }
        const signScript = witnessScript;
        if (expanded.type === SCRIPT_TYPES.P2WPKH)
          throw new Error("P2WSH(P2WPKH) is a consensus failure");
        return {
          witnessScript,
          witnessScriptType: expanded.type,
          prevOutType: SCRIPT_TYPES.P2WSH,
          prevOutScript: p2wsh.output,
          hasWitness: true,
          signScript,
          signType: expanded.type,
          pubkeys: expanded.pubkeys,
          signatures: expanded.signatures,
          maxSignatures: expanded.maxSignatures
        };
      }
      if (input.prevOutType && input.prevOutScript) {
        if (input.prevOutType === SCRIPT_TYPES.P2SH)
          throw new Error(
            "PrevOutScript is " + input.prevOutType + ", requires redeemScript"
          );
        if (input.prevOutType === SCRIPT_TYPES.P2WSH)
          throw new Error(
            "PrevOutScript is " + input.prevOutType + ", requires witnessScript"
          );
        if (!input.prevOutScript) throw new Error("PrevOutScript is missing");
        const expanded = expandOutput(input.prevOutScript, ourPubKey);
        if (!expanded.pubkeys)
          throw new Error(
            expanded.type + " not supported (" + bscript.toASM(input.prevOutScript) + ")"
          );
        if (input.signatures && input.signatures.some((x) => x !== void 0)) {
          expanded.signatures = input.signatures;
        }
        let signScript = input.prevOutScript;
        if (expanded.type === SCRIPT_TYPES.P2WPKH) {
          signScript = payments.p2pkh({ pubkey: expanded.pubkeys[0] }).output;
        }
        return {
          prevOutType: expanded.type,
          prevOutScript: input.prevOutScript,
          hasWitness: expanded.type === SCRIPT_TYPES.P2WPKH,
          signScript,
          signType: expanded.type,
          pubkeys: expanded.pubkeys,
          signatures: expanded.signatures,
          maxSignatures: expanded.maxSignatures
        };
      }
      const prevOutScript = payments.p2pkh({ pubkey: ourPubKey }).output;
      return {
        prevOutType: SCRIPT_TYPES.P2PKH,
        prevOutScript,
        hasWitness: false,
        signScript: prevOutScript,
        signType: SCRIPT_TYPES.P2PKH,
        pubkeys: [ourPubKey],
        signatures: [void 0]
      };
    }
    function build(type, input, allowIncomplete) {
      const pubkeys = input.pubkeys || [];
      let signatures = input.signatures || [];
      switch (type) {
        case SCRIPT_TYPES.P2PKH: {
          if (pubkeys.length === 0) break;
          if (signatures.length === 0) break;
          return payments.p2pkh({ pubkey: pubkeys[0], signature: signatures[0] });
        }
        case SCRIPT_TYPES.P2WPKH: {
          if (pubkeys.length === 0) break;
          if (signatures.length === 0) break;
          return payments.p2wpkh({ pubkey: pubkeys[0], signature: signatures[0] });
        }
        case SCRIPT_TYPES.P2PK: {
          if (pubkeys.length === 0) break;
          if (signatures.length === 0) break;
          return payments.p2pk({ signature: signatures[0] });
        }
        case SCRIPT_TYPES.P2MS: {
          const m = input.maxSignatures;
          if (allowIncomplete) {
            signatures = signatures.map((x) => x || script_1.OPS.OP_0);
          } else {
            signatures = signatures.filter((x) => x);
          }
          const validate = !allowIncomplete || m === signatures.length;
          return payments.p2ms(
            { m, pubkeys, signatures },
            { allowIncomplete, validate }
          );
        }
        case SCRIPT_TYPES.P2SH: {
          const redeem = build(input.redeemScriptType, input, allowIncomplete);
          if (!redeem) return;
          return payments.p2sh({
            redeem: {
              output: redeem.output || input.redeemScript,
              input: redeem.input,
              witness: redeem.witness
            }
          });
        }
        case SCRIPT_TYPES.P2WSH: {
          const redeem = build(input.witnessScriptType, input, allowIncomplete);
          if (!redeem) return;
          return payments.p2wsh({
            redeem: {
              output: input.witnessScript,
              input: redeem.input,
              witness: redeem.witness
            }
          });
        }
      }
    }
    function canSign(input) {
      return input.signScript !== void 0 && input.signType !== void 0 && input.pubkeys !== void 0 && input.signatures !== void 0 && input.signatures.length === input.pubkeys.length && input.pubkeys.length > 0 && (input.hasWitness === false || input.value !== void 0);
    }
    function signatureHashType(buffer) {
      return buffer.readUInt8(buffer.length - 1);
    }
    function checkSignArgs(inputs, signParams) {
      if (!PREVOUT_TYPES.has(signParams.prevOutScriptType)) {
        throw new TypeError(
          `Unknown prevOutScriptType "${signParams.prevOutScriptType}"`
        );
      }
      tfMessage(
        typeforce.Number,
        signParams.vin,
        `sign must include vin parameter as Number (input index)`
      );
      tfMessage(
        types.Signer,
        signParams.keyPair,
        `sign must include keyPair parameter as Signer interface`
      );
      tfMessage(
        typeforce.maybe(typeforce.Number),
        signParams.hashType,
        `sign hashType parameter must be a number`
      );
      const prevOutType = (inputs[signParams.vin] || []).prevOutType;
      const posType = signParams.prevOutScriptType;
      switch (posType) {
        case "p2pkh":
          if (prevOutType && prevOutType !== "pubkeyhash") {
            throw new TypeError(
              `input #${signParams.vin} is not of type p2pkh: ${prevOutType}`
            );
          }
          tfMessage(
            typeforce.value(void 0),
            signParams.witnessScript,
            `${posType} requires NO witnessScript`
          );
          tfMessage(
            typeforce.value(void 0),
            signParams.redeemScript,
            `${posType} requires NO redeemScript`
          );
          tfMessage(
            typeforce.value(void 0),
            signParams.witnessValue,
            `${posType} requires NO witnessValue`
          );
          break;
        case "p2pk":
          if (prevOutType && prevOutType !== "pubkey") {
            throw new TypeError(
              `input #${signParams.vin} is not of type p2pk: ${prevOutType}`
            );
          }
          tfMessage(
            typeforce.value(void 0),
            signParams.witnessScript,
            `${posType} requires NO witnessScript`
          );
          tfMessage(
            typeforce.value(void 0),
            signParams.redeemScript,
            `${posType} requires NO redeemScript`
          );
          tfMessage(
            typeforce.value(void 0),
            signParams.witnessValue,
            `${posType} requires NO witnessValue`
          );
          break;
        case "p2wpkh":
          if (prevOutType && prevOutType !== "witnesspubkeyhash") {
            throw new TypeError(
              `input #${signParams.vin} is not of type p2wpkh: ${prevOutType}`
            );
          }
          tfMessage(
            typeforce.value(void 0),
            signParams.witnessScript,
            `${posType} requires NO witnessScript`
          );
          tfMessage(
            typeforce.value(void 0),
            signParams.redeemScript,
            `${posType} requires NO redeemScript`
          );
          tfMessage(
            types.Satoshi,
            signParams.witnessValue,
            `${posType} requires witnessValue`
          );
          break;
        case "p2ms":
          if (prevOutType && prevOutType !== "multisig") {
            throw new TypeError(
              `input #${signParams.vin} is not of type p2ms: ${prevOutType}`
            );
          }
          tfMessage(
            typeforce.value(void 0),
            signParams.witnessScript,
            `${posType} requires NO witnessScript`
          );
          tfMessage(
            typeforce.value(void 0),
            signParams.redeemScript,
            `${posType} requires NO redeemScript`
          );
          tfMessage(
            typeforce.value(void 0),
            signParams.witnessValue,
            `${posType} requires NO witnessValue`
          );
          break;
        case "p2sh-p2wpkh":
          if (prevOutType && prevOutType !== "scripthash") {
            throw new TypeError(
              `input #${signParams.vin} is not of type p2sh-p2wpkh: ${prevOutType}`
            );
          }
          tfMessage(
            typeforce.value(void 0),
            signParams.witnessScript,
            `${posType} requires NO witnessScript`
          );
          tfMessage(
            typeforce.Buffer,
            signParams.redeemScript,
            `${posType} requires redeemScript`
          );
          tfMessage(
            types.Satoshi,
            signParams.witnessValue,
            `${posType} requires witnessValue`
          );
          break;
        case "p2sh-p2ms":
        case "p2sh-p2pk":
        case "p2sh-p2pkh":
          if (prevOutType && prevOutType !== "scripthash") {
            throw new TypeError(
              `input #${signParams.vin} is not of type ${posType}: ${prevOutType}`
            );
          }
          tfMessage(
            typeforce.value(void 0),
            signParams.witnessScript,
            `${posType} requires NO witnessScript`
          );
          tfMessage(
            typeforce.Buffer,
            signParams.redeemScript,
            `${posType} requires redeemScript`
          );
          tfMessage(
            typeforce.value(void 0),
            signParams.witnessValue,
            `${posType} requires NO witnessValue`
          );
          break;
        case "p2wsh-p2ms":
        case "p2wsh-p2pk":
        case "p2wsh-p2pkh":
          if (prevOutType && prevOutType !== "witnessscripthash") {
            throw new TypeError(
              `input #${signParams.vin} is not of type ${posType}: ${prevOutType}`
            );
          }
          tfMessage(
            typeforce.Buffer,
            signParams.witnessScript,
            `${posType} requires witnessScript`
          );
          tfMessage(
            typeforce.value(void 0),
            signParams.redeemScript,
            `${posType} requires NO redeemScript`
          );
          tfMessage(
            types.Satoshi,
            signParams.witnessValue,
            `${posType} requires witnessValue`
          );
          break;
        case "p2sh-p2wsh-p2ms":
        case "p2sh-p2wsh-p2pk":
        case "p2sh-p2wsh-p2pkh":
          if (prevOutType && prevOutType !== "scripthash") {
            throw new TypeError(
              `input #${signParams.vin} is not of type ${posType}: ${prevOutType}`
            );
          }
          tfMessage(
            typeforce.Buffer,
            signParams.witnessScript,
            `${posType} requires witnessScript`
          );
          tfMessage(
            typeforce.Buffer,
            signParams.redeemScript,
            `${posType} requires witnessScript`
          );
          tfMessage(
            types.Satoshi,
            signParams.witnessValue,
            `${posType} requires witnessScript`
          );
          break;
      }
    }
    function trySign({
      input,
      ourPubKey,
      keyPair,
      signatureHash,
      hashType,
      useLowR
    }) {
      let signed = false;
      for (const [i, pubKey] of input.pubkeys.entries()) {
        if (!ourPubKey.equals(pubKey)) continue;
        if (input.signatures[i]) throw new Error("Signature already exists");
        if (ourPubKey.length !== 33 && input.hasWitness) {
          throw new Error(
            "BIP143 rejects uncompressed public keys in P2WPKH or P2WSH"
          );
        }
        const signature = keyPair.sign(signatureHash, useLowR);
        input.signatures[i] = bscript.signature.encode(signature, hashType);
        signed = true;
      }
      if (!signed) throw new Error("Key pair cannot sign for this input");
    }
    function getSigningData(network, inputs, needsOutputs, tx, signParams, keyPair, redeemScript, hashType, witnessValue, witnessScript, useLowR) {
      let vin;
      if (typeof signParams === "number") {
        console.warn(
          "DEPRECATED: TransactionBuilder sign method arguments will change in v6, please use the TxbSignArg interface"
        );
        vin = signParams;
      } else if (typeof signParams === "object") {
        checkSignArgs(inputs, signParams);
        ({
          vin,
          keyPair,
          redeemScript,
          hashType,
          witnessValue,
          witnessScript
        } = signParams);
      } else {
        throw new TypeError(
          "TransactionBuilder sign first arg must be TxbSignArg or number"
        );
      }
      if (keyPair === void 0) {
        throw new Error("sign requires keypair");
      }
      if (keyPair.network && keyPair.network !== network)
        throw new TypeError("Inconsistent network");
      if (!inputs[vin]) throw new Error("No input at index: " + vin);
      hashType = hashType || transaction_1.Transaction.SIGHASH_ALL;
      if (needsOutputs(hashType)) throw new Error("Transaction needs outputs");
      const input = inputs[vin];
      if (input.redeemScript !== void 0 && redeemScript && !input.redeemScript.equals(redeemScript)) {
        throw new Error("Inconsistent redeemScript");
      }
      const ourPubKey = keyPair.publicKey || keyPair.getPublicKey && keyPair.getPublicKey();
      if (!canSign(input)) {
        if (witnessValue !== void 0) {
          if (input.value !== void 0 && input.value !== witnessValue)
            throw new Error("Input did not match witnessValue");
          typeforce(types.Satoshi, witnessValue);
          input.value = witnessValue;
        }
        if (!canSign(input)) {
          const prepared = prepareInput(
            input,
            ourPubKey,
            redeemScript,
            witnessScript
          );
          Object.assign(input, prepared);
        }
        if (!canSign(input)) throw Error(input.prevOutType + " not supported");
      }
      let signatureHash;
      if (input.hasWitness) {
        signatureHash = tx.hashForWitnessV0(
          vin,
          input.signScript,
          input.value,
          hashType
        );
      } else {
        signatureHash = tx.hashForSignature(vin, input.signScript, hashType);
      }
      return {
        input,
        ourPubKey,
        keyPair,
        signatureHash,
        hashType,
        useLowR: !!useLowR
      };
    }
  }
});

// node_modules/bitcoinjs-lib/src/index.js
var require_src3 = __commonJS({
  "node_modules/bitcoinjs-lib/src/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var bip32 = require_src2();
    exports2.bip32 = bip32;
    var address = require_address();
    exports2.address = address;
    var crypto8 = require_crypto3();
    exports2.crypto = crypto8;
    var ECPair = require_ecpair();
    exports2.ECPair = ECPair;
    var networks = require_networks();
    exports2.networks = networks;
    var payments = require_payments();
    exports2.payments = payments;
    var script = require_script();
    exports2.script = script;
    var block_1 = require_block();
    exports2.Block = block_1.Block;
    var psbt_1 = require_psbt2();
    exports2.Psbt = psbt_1.Psbt;
    var script_1 = require_script();
    exports2.opcodes = script_1.OPS;
    var transaction_1 = require_transaction();
    exports2.Transaction = transaction_1.Transaction;
    var transaction_builder_1 = require_transaction_builder();
    exports2.TransactionBuilder = transaction_builder_1.TransactionBuilder;
  }
});

// node_modules/@noble/hashes/esm/crypto.js
var crypto2;
var init_crypto = __esm({
  "node_modules/@noble/hashes/esm/crypto.js"() {
    crypto2 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  }
});

// node_modules/@noble/hashes/esm/utils.js
function isBytes(a) {
  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
function anumber(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error("positive integer expected, got " + n);
}
function abytes(b2, ...lengths) {
  if (!isBytes(b2))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b2.length))
    throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b2.length);
}
function ahash(h) {
  if (typeof h !== "function" || typeof h.create !== "function")
    throw new Error("Hash should be wrapped by utils.createHasher");
  anumber(h.outputLen);
  anumber(h.blockLen);
}
function aexists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput(out, instance) {
  abytes(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error("digestInto() expects output buffer of length at least " + min);
  }
}
function clean(...arrays) {
  for (let i = 0; i < arrays.length; i++) {
    arrays[i].fill(0);
  }
}
function createView(arr) {
  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
function rotr(word, shift) {
  return word << 32 - shift | word >>> shift;
}
function rotl(word, shift) {
  return word << shift | word >>> 32 - shift >>> 0;
}
function bytesToHex(bytes) {
  abytes(bytes);
  if (hasHexBuiltin)
    return bytes.toHex();
  let hex = "";
  for (let i = 0; i < bytes.length; i++) {
    hex += hexes[bytes[i]];
  }
  return hex;
}
function asciiToBase16(ch) {
  if (ch >= asciis._0 && ch <= asciis._9)
    return ch - asciis._0;
  if (ch >= asciis.A && ch <= asciis.F)
    return ch - (asciis.A - 10);
  if (ch >= asciis.a && ch <= asciis.f)
    return ch - (asciis.a - 10);
  return;
}
function hexToBytes(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  if (hasHexBuiltin)
    return Uint8Array.fromHex(hex);
  const hl = hex.length;
  const al = hl / 2;
  if (hl % 2)
    throw new Error("hex string expected, got unpadded hex of length " + hl);
  const array = new Uint8Array(al);
  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
    const n1 = asciiToBase16(hex.charCodeAt(hi));
    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
    if (n1 === void 0 || n2 === void 0) {
      const char = hex[hi] + hex[hi + 1];
      throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
    }
    array[ai] = n1 * 16 + n2;
  }
  return array;
}
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes(data) {
  if (typeof data === "string")
    data = utf8ToBytes(data);
  abytes(data);
  return data;
}
function concatBytes(...arrays) {
  let sum = 0;
  for (let i = 0; i < arrays.length; i++) {
    const a = arrays[i];
    abytes(a);
    sum += a.length;
  }
  const res = new Uint8Array(sum);
  for (let i = 0, pad = 0; i < arrays.length; i++) {
    const a = arrays[i];
    res.set(a, pad);
    pad += a.length;
  }
  return res;
}
function createHasher(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function randomBytes(bytesLength = 32) {
  if (crypto2 && typeof crypto2.getRandomValues === "function") {
    return crypto2.getRandomValues(new Uint8Array(bytesLength));
  }
  if (crypto2 && typeof crypto2.randomBytes === "function") {
    return Uint8Array.from(crypto2.randomBytes(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}
var hasHexBuiltin, hexes, asciis, Hash;
var init_utils = __esm({
  "node_modules/@noble/hashes/esm/utils.js"() {
    init_crypto();
    hasHexBuiltin = /* @__PURE__ */ (() => (
      // @ts-ignore
      typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
    ))();
    hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
    asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
    Hash = class {
    };
  }
});

// node_modules/@noble/hashes/esm/_md.js
function setBigUint64(view, byteOffset, value, isLE) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE);
  const _32n = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE ? 4 : 0;
  const l = isLE ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE);
  view.setUint32(byteOffset + l, wl, isLE);
}
function Chi(a, b2, c) {
  return a & b2 ^ ~a & c;
}
function Maj(a, b2, c) {
  return a & b2 ^ a & c ^ b2 & c;
}
var HashMD, SHA256_IV;
var init_md = __esm({
  "node_modules/@noble/hashes/esm/_md.js"() {
    init_utils();
    HashMD = class extends Hash {
      constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.buffer = new Uint8Array(blockLen);
        this.view = createView(this.buffer);
      }
      update(data) {
        aexists(this);
        data = toBytes(data);
        abytes(data);
        const { view, buffer, blockLen } = this;
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          if (take === blockLen) {
            const dataView = createView(data);
            for (; blockLen <= len - pos; pos += blockLen)
              this.process(dataView, pos);
            continue;
          }
          buffer.set(data.subarray(pos, pos + take), this.pos);
          this.pos += take;
          pos += take;
          if (this.pos === blockLen) {
            this.process(view, 0);
            this.pos = 0;
          }
        }
        this.length += data.length;
        this.roundClean();
        return this;
      }
      digestInto(out) {
        aexists(this);
        aoutput(out, this);
        this.finished = true;
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        buffer[pos++] = 128;
        clean(this.buffer.subarray(pos));
        if (this.padOffset > blockLen - pos) {
          this.process(view, 0);
          pos = 0;
        }
        for (let i = pos; i < blockLen; i++)
          buffer[i] = 0;
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = createView(out);
        const len = this.outputLen;
        if (len % 4)
          throw new Error("_sha2: outputLen should be aligned to 32bit");
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
          throw new Error("_sha2: outputLen bigger than state");
        for (let i = 0; i < outLen; i++)
          oview.setUint32(4 * i, state[i], isLE);
      }
      digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
      }
      _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.destroyed = destroyed;
        to.finished = finished;
        to.length = length;
        to.pos = pos;
        if (length % blockLen)
          to.buffer.set(buffer);
        return to;
      }
      clone() {
        return this._cloneInto();
      }
    };
    SHA256_IV = /* @__PURE__ */ Uint32Array.from([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
  }
});

// node_modules/@noble/hashes/esm/sha2.js
var SHA256_K, SHA256_W, SHA256, sha256;
var init_sha2 = __esm({
  "node_modules/@noble/hashes/esm/sha2.js"() {
    init_md();
    init_utils();
    SHA256_K = /* @__PURE__ */ Uint32Array.from([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    SHA256_W = /* @__PURE__ */ new Uint32Array(64);
    SHA256 = class extends HashMD {
      constructor(outputLen = 32) {
        super(64, outputLen, 8, false);
        this.A = SHA256_IV[0] | 0;
        this.B = SHA256_IV[1] | 0;
        this.C = SHA256_IV[2] | 0;
        this.D = SHA256_IV[3] | 0;
        this.E = SHA256_IV[4] | 0;
        this.F = SHA256_IV[5] | 0;
        this.G = SHA256_IV[6] | 0;
        this.H = SHA256_IV[7] | 0;
      }
      get() {
        const { A, B, C, D, E, F, G, H: H2 } = this;
        return [A, B, C, D, E, F, G, H2];
      }
      // prettier-ignore
      set(A, B, C, D, E, F, G, H2) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H2 | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
          SHA256_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 64; i++) {
          const W15 = SHA256_W[i - 15];
          const W2 = SHA256_W[i - 2];
          const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
          const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
          SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
        }
        let { A, B, C, D, E, F, G, H: H2 } = this;
        for (let i = 0; i < 64; i++) {
          const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
          const T1 = H2 + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
          const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
          const T2 = sigma0 + Maj(A, B, C) | 0;
          H2 = G;
          G = F;
          F = E;
          E = D + T1 | 0;
          D = C;
          C = B;
          B = A;
          A = T1 + T2 | 0;
        }
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        F = F + this.F | 0;
        G = G + this.G | 0;
        H2 = H2 + this.H | 0;
        this.set(A, B, C, D, E, F, G, H2);
      }
      roundClean() {
        clean(SHA256_W);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        clean(this.buffer);
      }
    };
    sha256 = /* @__PURE__ */ createHasher(() => new SHA256());
  }
});

// node_modules/@noble/hashes/esm/hmac.js
var HMAC, hmac;
var init_hmac = __esm({
  "node_modules/@noble/hashes/esm/hmac.js"() {
    init_utils();
    HMAC = class extends Hash {
      constructor(hash, _key) {
        super();
        this.finished = false;
        this.destroyed = false;
        ahash(hash);
        const key = toBytes(_key);
        this.iHash = hash.create();
        if (typeof this.iHash.update !== "function")
          throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad = new Uint8Array(blockLen);
        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
        for (let i = 0; i < pad.length; i++)
          pad[i] ^= 54;
        this.iHash.update(pad);
        this.oHash = hash.create();
        for (let i = 0; i < pad.length; i++)
          pad[i] ^= 54 ^ 92;
        this.oHash.update(pad);
        clean(pad);
      }
      update(buf) {
        aexists(this);
        this.iHash.update(buf);
        return this;
      }
      digestInto(out) {
        aexists(this);
        abytes(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
      }
      digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
      }
      _cloneInto(to) {
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to = to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
      }
      clone() {
        return this._cloneInto();
      }
      destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
      }
    };
    hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();
    hmac.create = (hash, key) => new HMAC(hash, key);
  }
});

// node_modules/@noble/curves/esm/utils.js
function _abool2(value, title = "") {
  if (typeof value !== "boolean") {
    const prefix = title && `"${title}"`;
    throw new Error(prefix + "expected boolean, got type=" + typeof value);
  }
  return value;
}
function _abytes2(value, length, title = "") {
  const bytes = isBytes(value);
  const len = value?.length;
  const needsLen = length !== void 0;
  if (!bytes || needsLen && len !== length) {
    const prefix = title && `"${title}" `;
    const ofLen = needsLen ? ` of length ${length}` : "";
    const got = bytes ? `length=${len}` : `type=${typeof value}`;
    throw new Error(prefix + "expected Uint8Array" + ofLen + ", got " + got);
  }
  return value;
}
function numberToHexUnpadded(num) {
  const hex = num.toString(16);
  return hex.length & 1 ? "0" + hex : hex;
}
function hexToNumber(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  return hex === "" ? _0n : BigInt("0x" + hex);
}
function bytesToNumberBE(bytes) {
  return hexToNumber(bytesToHex(bytes));
}
function bytesToNumberLE(bytes) {
  abytes(bytes);
  return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));
}
function numberToBytesBE(n, len) {
  return hexToBytes(n.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE(n, len) {
  return numberToBytesBE(n, len).reverse();
}
function ensureBytes(title, hex, expectedLength) {
  let res;
  if (typeof hex === "string") {
    try {
      res = hexToBytes(hex);
    } catch (e) {
      throw new Error(title + " must be hex string or Uint8Array, cause: " + e);
    }
  } else if (isBytes(hex)) {
    res = Uint8Array.from(hex);
  } else {
    throw new Error(title + " must be hex string or Uint8Array");
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength)
    throw new Error(title + " of length " + expectedLength + " expected, got " + len);
  return res;
}
function inRange(n, min, max) {
  return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;
}
function aInRange(title, n, min, max) {
  if (!inRange(n, min, max))
    throw new Error("expected valid " + title + ": " + min + " <= n < " + max + ", got " + n);
}
function bitLen(n) {
  let len;
  for (len = 0; n > _0n; n >>= _1n, len += 1)
    ;
  return len;
}
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  const u8n = (len) => new Uint8Array(len);
  const u8of = (byte) => Uint8Array.of(byte);
  let v = u8n(hashLen);
  let k = u8n(hashLen);
  let i = 0;
  const reset = () => {
    v.fill(1);
    k.fill(0);
    i = 0;
  };
  const h = (...b2) => hmacFn(k, v, ...b2);
  const reseed = (seed = u8n(0)) => {
    k = h(u8of(0), seed);
    v = h();
    if (seed.length === 0)
      return;
    k = h(u8of(1), seed);
    v = h();
  };
  const gen = () => {
    if (i++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v = h();
      const sl = v.slice();
      out.push(sl);
      len += v.length;
    }
    return concatBytes(...out);
  };
  const genUntil = (seed, pred) => {
    reset();
    reseed(seed);
    let res = void 0;
    while (!(res = pred(gen())))
      reseed();
    reset();
    return res;
  };
  return genUntil;
}
function _validateObject(object, fields, optFields = {}) {
  if (!object || typeof object !== "object")
    throw new Error("expected valid options object");
  function checkField(fieldName, expectedType, isOpt) {
    const val = object[fieldName];
    if (isOpt && val === void 0)
      return;
    const current = typeof val;
    if (current !== expectedType || val === null)
      throw new Error(`param "${fieldName}" is invalid: expected ${expectedType}, got ${current}`);
  }
  Object.entries(fields).forEach(([k, v]) => checkField(k, v, false));
  Object.entries(optFields).forEach(([k, v]) => checkField(k, v, true));
}
function memoized(fn) {
  const map = /* @__PURE__ */ new WeakMap();
  return (arg, ...args) => {
    const val = map.get(arg);
    if (val !== void 0)
      return val;
    const computed = fn(arg, ...args);
    map.set(arg, computed);
    return computed;
  };
}
var _0n, _1n, isPosBig, bitMask;
var init_utils2 = __esm({
  "node_modules/@noble/curves/esm/utils.js"() {
    init_utils();
    init_utils();
    _0n = /* @__PURE__ */ BigInt(0);
    _1n = /* @__PURE__ */ BigInt(1);
    isPosBig = (n) => typeof n === "bigint" && _0n <= n;
    bitMask = (n) => (_1n << BigInt(n)) - _1n;
  }
});

// node_modules/@noble/curves/esm/abstract/modular.js
function mod2(a, b2) {
  const result = a % b2;
  return result >= _0n2 ? result : b2 + result;
}
function pow2(x, power, modulo) {
  let res = x;
  while (power-- > _0n2) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert(number, modulo) {
  if (number === _0n2)
    throw new Error("invert: expected non-zero number");
  if (modulo <= _0n2)
    throw new Error("invert: expected positive modulus, got " + modulo);
  let a = mod2(number, modulo);
  let b2 = modulo;
  let x = _0n2, y = _1n2, u = _1n2, v = _0n2;
  while (a !== _0n2) {
    const q = b2 / a;
    const r = b2 % a;
    const m = x - u * q;
    const n = y - v * q;
    b2 = a, a = r, x = u, y = v, u = m, v = n;
  }
  const gcd = b2;
  if (gcd !== _1n2)
    throw new Error("invert: does not exist");
  return mod2(x, modulo);
}
function assertIsSquare(Fp, root, n) {
  if (!Fp.eql(Fp.sqr(root), n))
    throw new Error("Cannot find square root");
}
function sqrt3mod4(Fp, n) {
  const p1div4 = (Fp.ORDER + _1n2) / _4n;
  const root = Fp.pow(n, p1div4);
  assertIsSquare(Fp, root, n);
  return root;
}
function sqrt5mod8(Fp, n) {
  const p5div8 = (Fp.ORDER - _5n) / _8n;
  const n2 = Fp.mul(n, _2n);
  const v = Fp.pow(n2, p5div8);
  const nv = Fp.mul(n, v);
  const i = Fp.mul(Fp.mul(nv, _2n), v);
  const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
  assertIsSquare(Fp, root, n);
  return root;
}
function sqrt9mod16(P) {
  const Fp_ = Field(P);
  const tn = tonelliShanks(P);
  const c1 = tn(Fp_, Fp_.neg(Fp_.ONE));
  const c2 = tn(Fp_, c1);
  const c3 = tn(Fp_, Fp_.neg(c1));
  const c4 = (P + _7n) / _16n;
  return (Fp, n) => {
    let tv1 = Fp.pow(n, c4);
    let tv2 = Fp.mul(tv1, c1);
    const tv3 = Fp.mul(tv1, c2);
    const tv4 = Fp.mul(tv1, c3);
    const e1 = Fp.eql(Fp.sqr(tv2), n);
    const e2 = Fp.eql(Fp.sqr(tv3), n);
    tv1 = Fp.cmov(tv1, tv2, e1);
    tv2 = Fp.cmov(tv4, tv3, e2);
    const e3 = Fp.eql(Fp.sqr(tv2), n);
    const root = Fp.cmov(tv1, tv2, e3);
    assertIsSquare(Fp, root, n);
    return root;
  };
}
function tonelliShanks(P) {
  if (P < _3n)
    throw new Error("sqrt is not defined for small field");
  let Q = P - _1n2;
  let S = 0;
  while (Q % _2n === _0n2) {
    Q /= _2n;
    S++;
  }
  let Z = _2n;
  const _Fp = Field(P);
  while (FpLegendre(_Fp, Z) === 1) {
    if (Z++ > 1e3)
      throw new Error("Cannot find square root: probably non-prime P");
  }
  if (S === 1)
    return sqrt3mod4;
  let cc = _Fp.pow(Z, Q);
  const Q1div2 = (Q + _1n2) / _2n;
  return function tonelliSlow(Fp, n) {
    if (Fp.is0(n))
      return n;
    if (FpLegendre(Fp, n) !== 1)
      throw new Error("Cannot find square root");
    let M = S;
    let c = Fp.mul(Fp.ONE, cc);
    let t = Fp.pow(n, Q);
    let R = Fp.pow(n, Q1div2);
    while (!Fp.eql(t, Fp.ONE)) {
      if (Fp.is0(t))
        return Fp.ZERO;
      let i = 1;
      let t_tmp = Fp.sqr(t);
      while (!Fp.eql(t_tmp, Fp.ONE)) {
        i++;
        t_tmp = Fp.sqr(t_tmp);
        if (i === M)
          throw new Error("Cannot find square root");
      }
      const exponent = _1n2 << BigInt(M - i - 1);
      const b2 = Fp.pow(c, exponent);
      M = i;
      c = Fp.sqr(b2);
      t = Fp.mul(t, c);
      R = Fp.mul(R, b2);
    }
    return R;
  };
}
function FpSqrt(P) {
  if (P % _4n === _3n)
    return sqrt3mod4;
  if (P % _8n === _5n)
    return sqrt5mod8;
  if (P % _16n === _9n)
    return sqrt9mod16(P);
  return tonelliShanks(P);
}
function validateField(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "number",
    BITS: "number"
  };
  const opts = FIELD_FIELDS.reduce((map, val) => {
    map[val] = "function";
    return map;
  }, initial);
  _validateObject(field, opts);
  return field;
}
function FpPow(Fp, num, power) {
  if (power < _0n2)
    throw new Error("invalid exponent, negatives unsupported");
  if (power === _0n2)
    return Fp.ONE;
  if (power === _1n2)
    return num;
  let p = Fp.ONE;
  let d = num;
  while (power > _0n2) {
    if (power & _1n2)
      p = Fp.mul(p, d);
    d = Fp.sqr(d);
    power >>= _1n2;
  }
  return p;
}
function FpInvertBatch(Fp, nums, passZero = false) {
  const inverted = new Array(nums.length).fill(passZero ? Fp.ZERO : void 0);
  const multipliedAcc = nums.reduce((acc, num, i) => {
    if (Fp.is0(num))
      return acc;
    inverted[i] = acc;
    return Fp.mul(acc, num);
  }, Fp.ONE);
  const invertedAcc = Fp.inv(multipliedAcc);
  nums.reduceRight((acc, num, i) => {
    if (Fp.is0(num))
      return acc;
    inverted[i] = Fp.mul(acc, inverted[i]);
    return Fp.mul(acc, num);
  }, invertedAcc);
  return inverted;
}
function FpLegendre(Fp, n) {
  const p1mod2 = (Fp.ORDER - _1n2) / _2n;
  const powered = Fp.pow(n, p1mod2);
  const yes = Fp.eql(powered, Fp.ONE);
  const zero = Fp.eql(powered, Fp.ZERO);
  const no = Fp.eql(powered, Fp.neg(Fp.ONE));
  if (!yes && !zero && !no)
    throw new Error("invalid Legendre symbol result");
  return yes ? 1 : zero ? 0 : -1;
}
function nLength(n, nBitLength) {
  if (nBitLength !== void 0)
    anumber(nBitLength);
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field(ORDER, bitLenOrOpts, isLE = false, opts = {}) {
  if (ORDER <= _0n2)
    throw new Error("invalid field: expected ORDER > 0, got " + ORDER);
  let _nbitLength = void 0;
  let _sqrt = void 0;
  let modFromBytes = false;
  let allowedLengths = void 0;
  if (typeof bitLenOrOpts === "object" && bitLenOrOpts != null) {
    if (opts.sqrt || isLE)
      throw new Error("cannot specify opts in two arguments");
    const _opts = bitLenOrOpts;
    if (_opts.BITS)
      _nbitLength = _opts.BITS;
    if (_opts.sqrt)
      _sqrt = _opts.sqrt;
    if (typeof _opts.isLE === "boolean")
      isLE = _opts.isLE;
    if (typeof _opts.modFromBytes === "boolean")
      modFromBytes = _opts.modFromBytes;
    allowedLengths = _opts.allowedLengths;
  } else {
    if (typeof bitLenOrOpts === "number")
      _nbitLength = bitLenOrOpts;
    if (opts.sqrt)
      _sqrt = opts.sqrt;
  }
  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, _nbitLength);
  if (BYTES > 2048)
    throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let sqrtP;
  const f = Object.freeze({
    ORDER,
    isLE,
    BITS,
    BYTES,
    MASK: bitMask(BITS),
    ZERO: _0n2,
    ONE: _1n2,
    allowedLengths,
    create: (num) => mod2(num, ORDER),
    isValid: (num) => {
      if (typeof num !== "bigint")
        throw new Error("invalid field element: expected bigint, got " + typeof num);
      return _0n2 <= num && num < ORDER;
    },
    is0: (num) => num === _0n2,
    // is valid and invertible
    isValidNot0: (num) => !f.is0(num) && f.isValid(num),
    isOdd: (num) => (num & _1n2) === _1n2,
    neg: (num) => mod2(-num, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num) => mod2(num * num, ORDER),
    add: (lhs, rhs) => mod2(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod2(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod2(lhs * rhs, ORDER),
    pow: (num, power) => FpPow(f, num, power),
    div: (lhs, rhs) => mod2(lhs * invert(rhs, ORDER), ORDER),
    // Same as above, but doesn't normalize
    sqrN: (num) => num * num,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num) => invert(num, ORDER),
    sqrt: _sqrt || ((n) => {
      if (!sqrtP)
        sqrtP = FpSqrt(ORDER);
      return sqrtP(f, n);
    }),
    toBytes: (num) => isLE ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
    fromBytes: (bytes, skipValidation = true) => {
      if (allowedLengths) {
        if (!allowedLengths.includes(bytes.length) || bytes.length > BYTES) {
          throw new Error("Field.fromBytes: expected " + allowedLengths + " bytes, got " + bytes.length);
        }
        const padded = new Uint8Array(BYTES);
        padded.set(bytes, isLE ? 0 : padded.length - bytes.length);
        bytes = padded;
      }
      if (bytes.length !== BYTES)
        throw new Error("Field.fromBytes: expected " + BYTES + " bytes, got " + bytes.length);
      let scalar = isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);
      if (modFromBytes)
        scalar = mod2(scalar, ORDER);
      if (!skipValidation) {
        if (!f.isValid(scalar))
          throw new Error("invalid field element: outside of range 0..ORDER");
      }
      return scalar;
    },
    // TODO: we don't need it here, move out to separate fn
    invertBatch: (lst) => FpInvertBatch(f, lst),
    // We can't move this out because Fp6, Fp12 implement it
    // and it's unclear what to return in there.
    cmov: (a, b2, c) => c ? b2 : a
  });
  return Object.freeze(f);
}
function getFieldBytesLength(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength(fieldOrder) {
  const length = getFieldBytesLength(fieldOrder);
  return length + Math.ceil(length / 2);
}
function mapHashToField(key, fieldOrder, isLE = false) {
  const len = key.length;
  const fieldLen = getFieldBytesLength(fieldOrder);
  const minLen = getMinHashLength(fieldOrder);
  if (len < 16 || len < minLen || len > 1024)
    throw new Error("expected " + minLen + "-1024 bytes of input, got " + len);
  const num = isLE ? bytesToNumberLE(key) : bytesToNumberBE(key);
  const reduced = mod2(num, fieldOrder - _1n2) + _1n2;
  return isLE ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
}
var _0n2, _1n2, _2n, _3n, _4n, _5n, _7n, _8n, _9n, _16n, FIELD_FIELDS;
var init_modular = __esm({
  "node_modules/@noble/curves/esm/abstract/modular.js"() {
    init_utils2();
    _0n2 = BigInt(0);
    _1n2 = BigInt(1);
    _2n = /* @__PURE__ */ BigInt(2);
    _3n = /* @__PURE__ */ BigInt(3);
    _4n = /* @__PURE__ */ BigInt(4);
    _5n = /* @__PURE__ */ BigInt(5);
    _7n = /* @__PURE__ */ BigInt(7);
    _8n = /* @__PURE__ */ BigInt(8);
    _9n = /* @__PURE__ */ BigInt(9);
    _16n = /* @__PURE__ */ BigInt(16);
    FIELD_FIELDS = [
      "create",
      "isValid",
      "is0",
      "neg",
      "inv",
      "sqrt",
      "sqr",
      "eql",
      "add",
      "sub",
      "mul",
      "pow",
      "div",
      "addN",
      "subN",
      "mulN",
      "sqrN"
    ];
  }
});

// node_modules/@noble/curves/esm/abstract/curve.js
function negateCt(condition, item) {
  const neg = item.negate();
  return condition ? neg : item;
}
function normalizeZ(c, points) {
  const invertedZs = FpInvertBatch(c.Fp, points.map((p) => p.Z));
  return points.map((p, i) => c.fromAffine(p.toAffine(invertedZs[i])));
}
function validateW(W, bits) {
  if (!Number.isSafeInteger(W) || W <= 0 || W > bits)
    throw new Error("invalid window size, expected [1.." + bits + "], got W=" + W);
}
function calcWOpts(W, scalarBits) {
  validateW(W, scalarBits);
  const windows = Math.ceil(scalarBits / W) + 1;
  const windowSize = 2 ** (W - 1);
  const maxNumber = 2 ** W;
  const mask = bitMask(W);
  const shiftBy = BigInt(W);
  return { windows, windowSize, mask, maxNumber, shiftBy };
}
function calcOffsets(n, window2, wOpts) {
  const { windowSize, mask, maxNumber, shiftBy } = wOpts;
  let wbits = Number(n & mask);
  let nextN = n >> shiftBy;
  if (wbits > windowSize) {
    wbits -= maxNumber;
    nextN += _1n3;
  }
  const offsetStart = window2 * windowSize;
  const offset = offsetStart + Math.abs(wbits) - 1;
  const isZero = wbits === 0;
  const isNeg = wbits < 0;
  const isNegF = window2 % 2 !== 0;
  const offsetF = offsetStart;
  return { nextN, offset, isZero, isNeg, isNegF, offsetF };
}
function validateMSMPoints(points, c) {
  if (!Array.isArray(points))
    throw new Error("array expected");
  points.forEach((p, i) => {
    if (!(p instanceof c))
      throw new Error("invalid point at index " + i);
  });
}
function validateMSMScalars(scalars, field) {
  if (!Array.isArray(scalars))
    throw new Error("array of scalars expected");
  scalars.forEach((s, i) => {
    if (!field.isValid(s))
      throw new Error("invalid scalar at index " + i);
  });
}
function getW(P) {
  return pointWindowSizes.get(P) || 1;
}
function assert0(n) {
  if (n !== _0n3)
    throw new Error("invalid wNAF");
}
function mulEndoUnsafe(Point, point, k1, k2) {
  let acc = point;
  let p1 = Point.ZERO;
  let p2 = Point.ZERO;
  while (k1 > _0n3 || k2 > _0n3) {
    if (k1 & _1n3)
      p1 = p1.add(acc);
    if (k2 & _1n3)
      p2 = p2.add(acc);
    acc = acc.double();
    k1 >>= _1n3;
    k2 >>= _1n3;
  }
  return { p1, p2 };
}
function pippenger(c, fieldN, points, scalars) {
  validateMSMPoints(points, c);
  validateMSMScalars(scalars, fieldN);
  const plength = points.length;
  const slength = scalars.length;
  if (plength !== slength)
    throw new Error("arrays of points and scalars must have equal length");
  const zero = c.ZERO;
  const wbits = bitLen(BigInt(plength));
  let windowSize = 1;
  if (wbits > 12)
    windowSize = wbits - 3;
  else if (wbits > 4)
    windowSize = wbits - 2;
  else if (wbits > 0)
    windowSize = 2;
  const MASK = bitMask(windowSize);
  const buckets = new Array(Number(MASK) + 1).fill(zero);
  const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
  let sum = zero;
  for (let i = lastBits; i >= 0; i -= windowSize) {
    buckets.fill(zero);
    for (let j = 0; j < slength; j++) {
      const scalar = scalars[j];
      const wbits2 = Number(scalar >> BigInt(i) & MASK);
      buckets[wbits2] = buckets[wbits2].add(points[j]);
    }
    let resI = zero;
    for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {
      sumI = sumI.add(buckets[j]);
      resI = resI.add(sumI);
    }
    sum = sum.add(resI);
    if (i !== 0)
      for (let j = 0; j < windowSize; j++)
        sum = sum.double();
  }
  return sum;
}
function createField(order, field, isLE) {
  if (field) {
    if (field.ORDER !== order)
      throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
    validateField(field);
    return field;
  } else {
    return Field(order, { isLE });
  }
}
function _createCurveFields(type, CURVE, curveOpts = {}, FpFnLE) {
  if (FpFnLE === void 0)
    FpFnLE = type === "edwards";
  if (!CURVE || typeof CURVE !== "object")
    throw new Error(`expected valid ${type} CURVE object`);
  for (const p of ["p", "n", "h"]) {
    const val = CURVE[p];
    if (!(typeof val === "bigint" && val > _0n3))
      throw new Error(`CURVE.${p} must be positive bigint`);
  }
  const Fp = createField(CURVE.p, curveOpts.Fp, FpFnLE);
  const Fn = createField(CURVE.n, curveOpts.Fn, FpFnLE);
  const _b = type === "weierstrass" ? "b" : "d";
  const params = ["Gx", "Gy", "a", _b];
  for (const p of params) {
    if (!Fp.isValid(CURVE[p]))
      throw new Error(`CURVE.${p} must be valid field element of CURVE.Fp`);
  }
  CURVE = Object.freeze(Object.assign({}, CURVE));
  return { CURVE, Fp, Fn };
}
var _0n3, _1n3, pointPrecomputes, pointWindowSizes, wNAF;
var init_curve = __esm({
  "node_modules/@noble/curves/esm/abstract/curve.js"() {
    init_utils2();
    init_modular();
    _0n3 = BigInt(0);
    _1n3 = BigInt(1);
    pointPrecomputes = /* @__PURE__ */ new WeakMap();
    pointWindowSizes = /* @__PURE__ */ new WeakMap();
    wNAF = class {
      // Parametrized with a given Point class (not individual point)
      constructor(Point, bits) {
        this.BASE = Point.BASE;
        this.ZERO = Point.ZERO;
        this.Fn = Point.Fn;
        this.bits = bits;
      }
      // non-const time multiplication ladder
      _unsafeLadder(elm, n, p = this.ZERO) {
        let d = elm;
        while (n > _0n3) {
          if (n & _1n3)
            p = p.add(d);
          d = d.double();
          n >>= _1n3;
        }
        return p;
      }
      /**
       * Creates a wNAF precomputation window. Used for caching.
       * Default window size is set by `utils.precompute()` and is equal to 8.
       * Number of precomputed points depends on the curve size:
       * 2^(1) * (Math.ceil( / ) + 1), where:
       * -  is the window size
       * -  is the bitlength of the curve order.
       * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
       * @param point Point instance
       * @param W window size
       * @returns precomputed point tables flattened to a single array
       */
      precomputeWindow(point, W) {
        const { windows, windowSize } = calcWOpts(W, this.bits);
        const points = [];
        let p = point;
        let base = p;
        for (let window2 = 0; window2 < windows; window2++) {
          base = p;
          points.push(base);
          for (let i = 1; i < windowSize; i++) {
            base = base.add(p);
            points.push(base);
          }
          p = base.double();
        }
        return points;
      }
      /**
       * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
       * More compact implementation:
       * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541
       * @returns real and fake (for const-time) points
       */
      wNAF(W, precomputes, n) {
        if (!this.Fn.isValid(n))
          throw new Error("invalid scalar");
        let p = this.ZERO;
        let f = this.BASE;
        const wo = calcWOpts(W, this.bits);
        for (let window2 = 0; window2 < wo.windows; window2++) {
          const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window2, wo);
          n = nextN;
          if (isZero) {
            f = f.add(negateCt(isNegF, precomputes[offsetF]));
          } else {
            p = p.add(negateCt(isNeg, precomputes[offset]));
          }
        }
        assert0(n);
        return { p, f };
      }
      /**
       * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
       * @param acc accumulator point to add result of multiplication
       * @returns point
       */
      wNAFUnsafe(W, precomputes, n, acc = this.ZERO) {
        const wo = calcWOpts(W, this.bits);
        for (let window2 = 0; window2 < wo.windows; window2++) {
          if (n === _0n3)
            break;
          const { nextN, offset, isZero, isNeg } = calcOffsets(n, window2, wo);
          n = nextN;
          if (isZero) {
            continue;
          } else {
            const item = precomputes[offset];
            acc = acc.add(isNeg ? item.negate() : item);
          }
        }
        assert0(n);
        return acc;
      }
      getPrecomputes(W, point, transform) {
        let comp = pointPrecomputes.get(point);
        if (!comp) {
          comp = this.precomputeWindow(point, W);
          if (W !== 1) {
            if (typeof transform === "function")
              comp = transform(comp);
            pointPrecomputes.set(point, comp);
          }
        }
        return comp;
      }
      cached(point, scalar, transform) {
        const W = getW(point);
        return this.wNAF(W, this.getPrecomputes(W, point, transform), scalar);
      }
      unsafe(point, scalar, transform, prev) {
        const W = getW(point);
        if (W === 1)
          return this._unsafeLadder(point, scalar, prev);
        return this.wNAFUnsafe(W, this.getPrecomputes(W, point, transform), scalar, prev);
      }
      // We calculate precomputes for elliptic curve point multiplication
      // using windowed method. This specifies window size and
      // stores precomputed values. Usually only base point would be precomputed.
      createCache(P, W) {
        validateW(W, this.bits);
        pointWindowSizes.set(P, W);
        pointPrecomputes.delete(P);
      }
      hasCache(elm) {
        return getW(elm) !== 1;
      }
    };
  }
});

// node_modules/@noble/curves/esm/abstract/weierstrass.js
function _splitEndoScalar(k, basis, n) {
  const [[a1, b1], [a2, b2]] = basis;
  const c1 = divNearest(b2 * k, n);
  const c2 = divNearest(-b1 * k, n);
  let k1 = k - c1 * a1 - c2 * a2;
  let k2 = -c1 * b1 - c2 * b2;
  const k1neg = k1 < _0n4;
  const k2neg = k2 < _0n4;
  if (k1neg)
    k1 = -k1;
  if (k2neg)
    k2 = -k2;
  const MAX_NUM = bitMask(Math.ceil(bitLen(n) / 2)) + _1n4;
  if (k1 < _0n4 || k1 >= MAX_NUM || k2 < _0n4 || k2 >= MAX_NUM) {
    throw new Error("splitScalar (endomorphism): failed, k=" + k);
  }
  return { k1neg, k1, k2neg, k2 };
}
function validateSigFormat(format) {
  if (!["compact", "recovered", "der"].includes(format))
    throw new Error('Signature format must be "compact", "recovered", or "der"');
  return format;
}
function validateSigOpts(opts, def) {
  const optsn = {};
  for (let optName of Object.keys(def)) {
    optsn[optName] = opts[optName] === void 0 ? def[optName] : opts[optName];
  }
  _abool2(optsn.lowS, "lowS");
  _abool2(optsn.prehash, "prehash");
  if (optsn.format !== void 0)
    validateSigFormat(optsn.format);
  return optsn;
}
function _normFnElement(Fn, key) {
  const { BYTES: expected } = Fn;
  let num;
  if (typeof key === "bigint") {
    num = key;
  } else {
    let bytes = ensureBytes("private key", key);
    try {
      num = Fn.fromBytes(bytes);
    } catch (error) {
      throw new Error(`invalid private key: expected ui8a of size ${expected}, got ${typeof key}`);
    }
  }
  if (!Fn.isValidNot0(num))
    throw new Error("invalid private key: out of range [1..N-1]");
  return num;
}
function weierstrassN(params, extraOpts = {}) {
  const validated = _createCurveFields("weierstrass", params, extraOpts);
  const { Fp, Fn } = validated;
  let CURVE = validated.CURVE;
  const { h: cofactor, n: CURVE_ORDER } = CURVE;
  _validateObject(extraOpts, {}, {
    allowInfinityPoint: "boolean",
    clearCofactor: "function",
    isTorsionFree: "function",
    fromBytes: "function",
    toBytes: "function",
    endo: "object",
    wrapPrivateKey: "boolean"
  });
  const { endo } = extraOpts;
  if (endo) {
    if (!Fp.is0(CURVE.a) || typeof endo.beta !== "bigint" || !Array.isArray(endo.basises)) {
      throw new Error('invalid endo: expected "beta": bigint and "basises": array');
    }
  }
  const lengths = getWLengths(Fp, Fn);
  function assertCompressionIsSupported() {
    if (!Fp.isOdd)
      throw new Error("compression is not supported: Field does not have .isOdd()");
  }
  function pointToBytes(_c, point, isCompressed) {
    const { x, y } = point.toAffine();
    const bx = Fp.toBytes(x);
    _abool2(isCompressed, "isCompressed");
    if (isCompressed) {
      assertCompressionIsSupported();
      const hasEvenY = !Fp.isOdd(y);
      return concatBytes(pprefix(hasEvenY), bx);
    } else {
      return concatBytes(Uint8Array.of(4), bx, Fp.toBytes(y));
    }
  }
  function pointFromBytes(bytes) {
    _abytes2(bytes, void 0, "Point");
    const { publicKey: comp, publicKeyUncompressed: uncomp } = lengths;
    const length = bytes.length;
    const head = bytes[0];
    const tail = bytes.subarray(1);
    if (length === comp && (head === 2 || head === 3)) {
      const x = Fp.fromBytes(tail);
      if (!Fp.isValid(x))
        throw new Error("bad point: is not on curve, wrong x");
      const y2 = weierstrassEquation(x);
      let y;
      try {
        y = Fp.sqrt(y2);
      } catch (sqrtError) {
        const err = sqrtError instanceof Error ? ": " + sqrtError.message : "";
        throw new Error("bad point: is not on curve, sqrt error" + err);
      }
      assertCompressionIsSupported();
      const isYOdd = Fp.isOdd(y);
      const isHeadOdd = (head & 1) === 1;
      if (isHeadOdd !== isYOdd)
        y = Fp.neg(y);
      return { x, y };
    } else if (length === uncomp && head === 4) {
      const L = Fp.BYTES;
      const x = Fp.fromBytes(tail.subarray(0, L));
      const y = Fp.fromBytes(tail.subarray(L, L * 2));
      if (!isValidXY(x, y))
        throw new Error("bad point: is not on curve");
      return { x, y };
    } else {
      throw new Error(`bad point: got length ${length}, expected compressed=${comp} or uncompressed=${uncomp}`);
    }
  }
  const encodePoint = extraOpts.toBytes || pointToBytes;
  const decodePoint = extraOpts.fromBytes || pointFromBytes;
  function weierstrassEquation(x) {
    const x2 = Fp.sqr(x);
    const x3 = Fp.mul(x2, x);
    return Fp.add(Fp.add(x3, Fp.mul(x, CURVE.a)), CURVE.b);
  }
  function isValidXY(x, y) {
    const left = Fp.sqr(y);
    const right = weierstrassEquation(x);
    return Fp.eql(left, right);
  }
  if (!isValidXY(CURVE.Gx, CURVE.Gy))
    throw new Error("bad curve params: generator point");
  const _4a3 = Fp.mul(Fp.pow(CURVE.a, _3n2), _4n2);
  const _27b2 = Fp.mul(Fp.sqr(CURVE.b), BigInt(27));
  if (Fp.is0(Fp.add(_4a3, _27b2)))
    throw new Error("bad curve params: a or b");
  function acoord(title, n, banZero = false) {
    if (!Fp.isValid(n) || banZero && Fp.is0(n))
      throw new Error(`bad point coordinate ${title}`);
    return n;
  }
  function aprjpoint(other) {
    if (!(other instanceof Point))
      throw new Error("ProjectivePoint expected");
  }
  function splitEndoScalarN(k) {
    if (!endo || !endo.basises)
      throw new Error("no endo");
    return _splitEndoScalar(k, endo.basises, Fn.ORDER);
  }
  const toAffineMemo = memoized((p, iz) => {
    const { X, Y, Z } = p;
    if (Fp.eql(Z, Fp.ONE))
      return { x: X, y: Y };
    const is0 = p.is0();
    if (iz == null)
      iz = is0 ? Fp.ONE : Fp.inv(Z);
    const x = Fp.mul(X, iz);
    const y = Fp.mul(Y, iz);
    const zz = Fp.mul(Z, iz);
    if (is0)
      return { x: Fp.ZERO, y: Fp.ZERO };
    if (!Fp.eql(zz, Fp.ONE))
      throw new Error("invZ was invalid");
    return { x, y };
  });
  const assertValidMemo = memoized((p) => {
    if (p.is0()) {
      if (extraOpts.allowInfinityPoint && !Fp.is0(p.Y))
        return;
      throw new Error("bad point: ZERO");
    }
    const { x, y } = p.toAffine();
    if (!Fp.isValid(x) || !Fp.isValid(y))
      throw new Error("bad point: x or y not field elements");
    if (!isValidXY(x, y))
      throw new Error("bad point: equation left != right");
    if (!p.isTorsionFree())
      throw new Error("bad point: not in prime-order subgroup");
    return true;
  });
  function finishEndo(endoBeta, k1p, k2p, k1neg, k2neg) {
    k2p = new Point(Fp.mul(k2p.X, endoBeta), k2p.Y, k2p.Z);
    k1p = negateCt(k1neg, k1p);
    k2p = negateCt(k2neg, k2p);
    return k1p.add(k2p);
  }
  class Point {
    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
    constructor(X, Y, Z) {
      this.X = acoord("x", X);
      this.Y = acoord("y", Y, true);
      this.Z = acoord("z", Z);
      Object.freeze(this);
    }
    static CURVE() {
      return CURVE;
    }
    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
    static fromAffine(p) {
      const { x, y } = p || {};
      if (!p || !Fp.isValid(x) || !Fp.isValid(y))
        throw new Error("invalid affine point");
      if (p instanceof Point)
        throw new Error("projective point not allowed");
      if (Fp.is0(x) && Fp.is0(y))
        return Point.ZERO;
      return new Point(x, y, Fp.ONE);
    }
    static fromBytes(bytes) {
      const P = Point.fromAffine(decodePoint(_abytes2(bytes, void 0, "point")));
      P.assertValidity();
      return P;
    }
    static fromHex(hex) {
      return Point.fromBytes(ensureBytes("pointHex", hex));
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     *
     * @param windowSize
     * @param isLazy true will defer table computation until the first multiplication
     * @returns
     */
    precompute(windowSize = 8, isLazy = true) {
      wnaf.createCache(this, windowSize);
      if (!isLazy)
        this.multiply(_3n2);
      return this;
    }
    // TODO: return `this`
    /** A point on curve is valid if it conforms to equation. */
    assertValidity() {
      assertValidMemo(this);
    }
    hasEvenY() {
      const { y } = this.toAffine();
      if (!Fp.isOdd)
        throw new Error("Field doesn't support isOdd");
      return !Fp.isOdd(y);
    }
    /** Compare one point to another. */
    equals(other) {
      aprjpoint(other);
      const { X: X1, Y: Y1, Z: Z1 } = this;
      const { X: X2, Y: Y2, Z: Z2 } = other;
      const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
      const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
      return U1 && U2;
    }
    /** Flips point to one corresponding to (x, -y) in Affine coordinates. */
    negate() {
      return new Point(this.X, Fp.neg(this.Y), this.Z);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a, b: b2 } = CURVE;
      const b3 = Fp.mul(b2, _3n2);
      const { X: X1, Y: Y1, Z: Z1 } = this;
      let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
      let t0 = Fp.mul(X1, X1);
      let t1 = Fp.mul(Y1, Y1);
      let t2 = Fp.mul(Z1, Z1);
      let t3 = Fp.mul(X1, Y1);
      t3 = Fp.add(t3, t3);
      Z3 = Fp.mul(X1, Z1);
      Z3 = Fp.add(Z3, Z3);
      X3 = Fp.mul(a, Z3);
      Y3 = Fp.mul(b3, t2);
      Y3 = Fp.add(X3, Y3);
      X3 = Fp.sub(t1, Y3);
      Y3 = Fp.add(t1, Y3);
      Y3 = Fp.mul(X3, Y3);
      X3 = Fp.mul(t3, X3);
      Z3 = Fp.mul(b3, Z3);
      t2 = Fp.mul(a, t2);
      t3 = Fp.sub(t0, t2);
      t3 = Fp.mul(a, t3);
      t3 = Fp.add(t3, Z3);
      Z3 = Fp.add(t0, t0);
      t0 = Fp.add(Z3, t0);
      t0 = Fp.add(t0, t2);
      t0 = Fp.mul(t0, t3);
      Y3 = Fp.add(Y3, t0);
      t2 = Fp.mul(Y1, Z1);
      t2 = Fp.add(t2, t2);
      t0 = Fp.mul(t2, t3);
      X3 = Fp.sub(X3, t0);
      Z3 = Fp.mul(t2, t1);
      Z3 = Fp.add(Z3, Z3);
      Z3 = Fp.add(Z3, Z3);
      return new Point(X3, Y3, Z3);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(other) {
      aprjpoint(other);
      const { X: X1, Y: Y1, Z: Z1 } = this;
      const { X: X2, Y: Y2, Z: Z2 } = other;
      let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
      const a = CURVE.a;
      const b3 = Fp.mul(CURVE.b, _3n2);
      let t0 = Fp.mul(X1, X2);
      let t1 = Fp.mul(Y1, Y2);
      let t2 = Fp.mul(Z1, Z2);
      let t3 = Fp.add(X1, Y1);
      let t4 = Fp.add(X2, Y2);
      t3 = Fp.mul(t3, t4);
      t4 = Fp.add(t0, t1);
      t3 = Fp.sub(t3, t4);
      t4 = Fp.add(X1, Z1);
      let t5 = Fp.add(X2, Z2);
      t4 = Fp.mul(t4, t5);
      t5 = Fp.add(t0, t2);
      t4 = Fp.sub(t4, t5);
      t5 = Fp.add(Y1, Z1);
      X3 = Fp.add(Y2, Z2);
      t5 = Fp.mul(t5, X3);
      X3 = Fp.add(t1, t2);
      t5 = Fp.sub(t5, X3);
      Z3 = Fp.mul(a, t4);
      X3 = Fp.mul(b3, t2);
      Z3 = Fp.add(X3, Z3);
      X3 = Fp.sub(t1, Z3);
      Z3 = Fp.add(t1, Z3);
      Y3 = Fp.mul(X3, Z3);
      t1 = Fp.add(t0, t0);
      t1 = Fp.add(t1, t0);
      t2 = Fp.mul(a, t2);
      t4 = Fp.mul(b3, t4);
      t1 = Fp.add(t1, t2);
      t2 = Fp.sub(t0, t2);
      t2 = Fp.mul(a, t2);
      t4 = Fp.add(t4, t2);
      t0 = Fp.mul(t1, t4);
      Y3 = Fp.add(Y3, t0);
      t0 = Fp.mul(t5, t4);
      X3 = Fp.mul(t3, X3);
      X3 = Fp.sub(X3, t0);
      t0 = Fp.mul(t3, t1);
      Z3 = Fp.mul(t5, Z3);
      Z3 = Fp.add(Z3, t0);
      return new Point(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point.ZERO);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(scalar) {
      const { endo: endo2 } = extraOpts;
      if (!Fn.isValidNot0(scalar))
        throw new Error("invalid scalar: out of range");
      let point, fake;
      const mul = (n) => wnaf.cached(this, n, (p) => normalizeZ(Point, p));
      if (endo2) {
        const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(scalar);
        const { p: k1p, f: k1f } = mul(k1);
        const { p: k2p, f: k2f } = mul(k2);
        fake = k1f.add(k2f);
        point = finishEndo(endo2.beta, k1p, k2p, k1neg, k2neg);
      } else {
        const { p, f } = mul(scalar);
        point = p;
        fake = f;
      }
      return normalizeZ(Point, [point, fake])[0];
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed secret key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(sc) {
      const { endo: endo2 } = extraOpts;
      const p = this;
      if (!Fn.isValid(sc))
        throw new Error("invalid scalar: out of range");
      if (sc === _0n4 || p.is0())
        return Point.ZERO;
      if (sc === _1n4)
        return p;
      if (wnaf.hasCache(this))
        return this.multiply(sc);
      if (endo2) {
        const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(sc);
        const { p1, p2 } = mulEndoUnsafe(Point, p, k1, k2);
        return finishEndo(endo2.beta, p1, p2, k1neg, k2neg);
      } else {
        return wnaf.unsafe(p, sc);
      }
    }
    multiplyAndAddUnsafe(Q, a, b2) {
      const sum = this.multiplyUnsafe(a).add(Q.multiplyUnsafe(b2));
      return sum.is0() ? void 0 : sum;
    }
    /**
     * Converts Projective point to affine (x, y) coordinates.
     * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
     */
    toAffine(invertedZ) {
      return toAffineMemo(this, invertedZ);
    }
    /**
     * Checks whether Point is free of torsion elements (is in prime subgroup).
     * Always torsion-free for cofactor=1 curves.
     */
    isTorsionFree() {
      const { isTorsionFree } = extraOpts;
      if (cofactor === _1n4)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point, this);
      return wnaf.unsafe(this, CURVE_ORDER).is0();
    }
    clearCofactor() {
      const { clearCofactor } = extraOpts;
      if (cofactor === _1n4)
        return this;
      if (clearCofactor)
        return clearCofactor(Point, this);
      return this.multiplyUnsafe(cofactor);
    }
    isSmallOrder() {
      return this.multiplyUnsafe(cofactor).is0();
    }
    toBytes(isCompressed = true) {
      _abool2(isCompressed, "isCompressed");
      this.assertValidity();
      return encodePoint(Point, this, isCompressed);
    }
    toHex(isCompressed = true) {
      return bytesToHex(this.toBytes(isCompressed));
    }
    toString() {
      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
    }
    // TODO: remove
    get px() {
      return this.X;
    }
    get py() {
      return this.X;
    }
    get pz() {
      return this.Z;
    }
    toRawBytes(isCompressed = true) {
      return this.toBytes(isCompressed);
    }
    _setWindowSize(windowSize) {
      this.precompute(windowSize);
    }
    static normalizeZ(points) {
      return normalizeZ(Point, points);
    }
    static msm(points, scalars) {
      return pippenger(Point, Fn, points, scalars);
    }
    static fromPrivateKey(privateKey) {
      return Point.BASE.multiply(_normFnElement(Fn, privateKey));
    }
  }
  Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
  Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);
  Point.Fp = Fp;
  Point.Fn = Fn;
  const bits = Fn.BITS;
  const wnaf = new wNAF(Point, extraOpts.endo ? Math.ceil(bits / 2) : bits);
  Point.BASE.precompute(8);
  return Point;
}
function pprefix(hasEvenY) {
  return Uint8Array.of(hasEvenY ? 2 : 3);
}
function getWLengths(Fp, Fn) {
  return {
    secretKey: Fn.BYTES,
    publicKey: 1 + Fp.BYTES,
    publicKeyUncompressed: 1 + 2 * Fp.BYTES,
    publicKeyHasPrefix: true,
    signature: 2 * Fn.BYTES
  };
}
function ecdh(Point, ecdhOpts = {}) {
  const { Fn } = Point;
  const randomBytes_ = ecdhOpts.randomBytes || randomBytes;
  const lengths = Object.assign(getWLengths(Point.Fp, Fn), { seed: getMinHashLength(Fn.ORDER) });
  function isValidSecretKey(secretKey) {
    try {
      return !!_normFnElement(Fn, secretKey);
    } catch (error) {
      return false;
    }
  }
  function isValidPublicKey(publicKey, isCompressed) {
    const { publicKey: comp, publicKeyUncompressed } = lengths;
    try {
      const l = publicKey.length;
      if (isCompressed === true && l !== comp)
        return false;
      if (isCompressed === false && l !== publicKeyUncompressed)
        return false;
      return !!Point.fromBytes(publicKey);
    } catch (error) {
      return false;
    }
  }
  function randomSecretKey(seed = randomBytes_(lengths.seed)) {
    return mapHashToField(_abytes2(seed, lengths.seed, "seed"), Fn.ORDER);
  }
  function getPublicKey(secretKey, isCompressed = true) {
    return Point.BASE.multiply(_normFnElement(Fn, secretKey)).toBytes(isCompressed);
  }
  function keygen(seed) {
    const secretKey = randomSecretKey(seed);
    return { secretKey, publicKey: getPublicKey(secretKey) };
  }
  function isProbPub(item) {
    if (typeof item === "bigint")
      return false;
    if (item instanceof Point)
      return true;
    const { secretKey, publicKey, publicKeyUncompressed } = lengths;
    if (Fn.allowedLengths || secretKey === publicKey)
      return void 0;
    const l = ensureBytes("key", item).length;
    return l === publicKey || l === publicKeyUncompressed;
  }
  function getSharedSecret(secretKeyA, publicKeyB, isCompressed = true) {
    if (isProbPub(secretKeyA) === true)
      throw new Error("first arg must be private key");
    if (isProbPub(publicKeyB) === false)
      throw new Error("second arg must be public key");
    const s = _normFnElement(Fn, secretKeyA);
    const b2 = Point.fromHex(publicKeyB);
    return b2.multiply(s).toBytes(isCompressed);
  }
  const utils = {
    isValidSecretKey,
    isValidPublicKey,
    randomSecretKey,
    // TODO: remove
    isValidPrivateKey: isValidSecretKey,
    randomPrivateKey: randomSecretKey,
    normPrivateKeyToScalar: (key) => _normFnElement(Fn, key),
    precompute(windowSize = 8, point = Point.BASE) {
      return point.precompute(windowSize, false);
    }
  };
  return Object.freeze({ getPublicKey, getSharedSecret, keygen, Point, utils, lengths });
}
function ecdsa(Point, hash, ecdsaOpts = {}) {
  ahash(hash);
  _validateObject(ecdsaOpts, {}, {
    hmac: "function",
    lowS: "boolean",
    randomBytes: "function",
    bits2int: "function",
    bits2int_modN: "function"
  });
  const randomBytes2 = ecdsaOpts.randomBytes || randomBytes;
  const hmac2 = ecdsaOpts.hmac || ((key, ...msgs) => hmac(hash, key, concatBytes(...msgs)));
  const { Fp, Fn } = Point;
  const { ORDER: CURVE_ORDER, BITS: fnBits } = Fn;
  const { keygen, getPublicKey, getSharedSecret, utils, lengths } = ecdh(Point, ecdsaOpts);
  const defaultSigOpts = {
    prehash: false,
    lowS: typeof ecdsaOpts.lowS === "boolean" ? ecdsaOpts.lowS : false,
    format: void 0,
    //'compact' as ECDSASigFormat,
    extraEntropy: false
  };
  const defaultSigOpts_format = "compact";
  function isBiggerThanHalfOrder(number) {
    const HALF = CURVE_ORDER >> _1n4;
    return number > HALF;
  }
  function validateRS(title, num) {
    if (!Fn.isValidNot0(num))
      throw new Error(`invalid signature ${title}: out of range 1..Point.Fn.ORDER`);
    return num;
  }
  function validateSigLength(bytes, format) {
    validateSigFormat(format);
    const size = lengths.signature;
    const sizer = format === "compact" ? size : format === "recovered" ? size + 1 : void 0;
    return _abytes2(bytes, sizer, `${format} signature`);
  }
  class Signature {
    constructor(r, s, recovery) {
      this.r = validateRS("r", r);
      this.s = validateRS("s", s);
      if (recovery != null)
        this.recovery = recovery;
      Object.freeze(this);
    }
    static fromBytes(bytes, format = defaultSigOpts_format) {
      validateSigLength(bytes, format);
      let recid;
      if (format === "der") {
        const { r: r2, s: s2 } = DER.toSig(_abytes2(bytes));
        return new Signature(r2, s2);
      }
      if (format === "recovered") {
        recid = bytes[0];
        format = "compact";
        bytes = bytes.subarray(1);
      }
      const L = Fn.BYTES;
      const r = bytes.subarray(0, L);
      const s = bytes.subarray(L, L * 2);
      return new Signature(Fn.fromBytes(r), Fn.fromBytes(s), recid);
    }
    static fromHex(hex, format) {
      return this.fromBytes(hexToBytes(hex), format);
    }
    addRecoveryBit(recovery) {
      return new Signature(this.r, this.s, recovery);
    }
    recoverPublicKey(messageHash) {
      const FIELD_ORDER = Fp.ORDER;
      const { r, s, recovery: rec } = this;
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const hasCofactor = CURVE_ORDER * _2n2 < FIELD_ORDER;
      if (hasCofactor && rec > 1)
        throw new Error("recovery id is ambiguous for h>1 curve");
      const radj = rec === 2 || rec === 3 ? r + CURVE_ORDER : r;
      if (!Fp.isValid(radj))
        throw new Error("recovery id 2 or 3 invalid");
      const x = Fp.toBytes(radj);
      const R = Point.fromBytes(concatBytes(pprefix((rec & 1) === 0), x));
      const ir = Fn.inv(radj);
      const h = bits2int_modN(ensureBytes("msgHash", messageHash));
      const u1 = Fn.create(-h * ir);
      const u2 = Fn.create(s * ir);
      const Q = Point.BASE.multiplyUnsafe(u1).add(R.multiplyUnsafe(u2));
      if (Q.is0())
        throw new Error("point at infinify");
      Q.assertValidity();
      return Q;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    toBytes(format = defaultSigOpts_format) {
      validateSigFormat(format);
      if (format === "der")
        return hexToBytes(DER.hexFromSig(this));
      const r = Fn.toBytes(this.r);
      const s = Fn.toBytes(this.s);
      if (format === "recovered") {
        if (this.recovery == null)
          throw new Error("recovery bit must be present");
        return concatBytes(Uint8Array.of(this.recovery), r, s);
      }
      return concatBytes(r, s);
    }
    toHex(format) {
      return bytesToHex(this.toBytes(format));
    }
    // TODO: remove
    assertValidity() {
    }
    static fromCompact(hex) {
      return Signature.fromBytes(ensureBytes("sig", hex), "compact");
    }
    static fromDER(hex) {
      return Signature.fromBytes(ensureBytes("sig", hex), "der");
    }
    normalizeS() {
      return this.hasHighS() ? new Signature(this.r, Fn.neg(this.s), this.recovery) : this;
    }
    toDERRawBytes() {
      return this.toBytes("der");
    }
    toDERHex() {
      return bytesToHex(this.toBytes("der"));
    }
    toCompactRawBytes() {
      return this.toBytes("compact");
    }
    toCompactHex() {
      return bytesToHex(this.toBytes("compact"));
    }
  }
  const bits2int = ecdsaOpts.bits2int || function bits2int_def(bytes) {
    if (bytes.length > 8192)
      throw new Error("input is too large");
    const num = bytesToNumberBE(bytes);
    const delta = bytes.length * 8 - fnBits;
    return delta > 0 ? num >> BigInt(delta) : num;
  };
  const bits2int_modN = ecdsaOpts.bits2int_modN || function bits2int_modN_def(bytes) {
    return Fn.create(bits2int(bytes));
  };
  const ORDER_MASK = bitMask(fnBits);
  function int2octets(num) {
    aInRange("num < 2^" + fnBits, num, _0n4, ORDER_MASK);
    return Fn.toBytes(num);
  }
  function validateMsgAndHash(message, prehash) {
    _abytes2(message, void 0, "message");
    return prehash ? _abytes2(hash(message), void 0, "prehashed message") : message;
  }
  function prepSig(message, privateKey, opts) {
    if (["recovered", "canonical"].some((k) => k in opts))
      throw new Error("sign() legacy options not supported");
    const { lowS, prehash, extraEntropy } = validateSigOpts(opts, defaultSigOpts);
    message = validateMsgAndHash(message, prehash);
    const h1int = bits2int_modN(message);
    const d = _normFnElement(Fn, privateKey);
    const seedArgs = [int2octets(d), int2octets(h1int)];
    if (extraEntropy != null && extraEntropy !== false) {
      const e = extraEntropy === true ? randomBytes2(lengths.secretKey) : extraEntropy;
      seedArgs.push(ensureBytes("extraEntropy", e));
    }
    const seed = concatBytes(...seedArgs);
    const m = h1int;
    function k2sig(kBytes) {
      const k = bits2int(kBytes);
      if (!Fn.isValidNot0(k))
        return;
      const ik = Fn.inv(k);
      const q = Point.BASE.multiply(k).toAffine();
      const r = Fn.create(q.x);
      if (r === _0n4)
        return;
      const s = Fn.create(ik * Fn.create(m + r * d));
      if (s === _0n4)
        return;
      let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n4);
      let normS = s;
      if (lowS && isBiggerThanHalfOrder(s)) {
        normS = Fn.neg(s);
        recovery ^= 1;
      }
      return new Signature(r, normS, recovery);
    }
    return { seed, k2sig };
  }
  function sign(message, secretKey, opts = {}) {
    message = ensureBytes("message", message);
    const { seed, k2sig } = prepSig(message, secretKey, opts);
    const drbg = createHmacDrbg(hash.outputLen, Fn.BYTES, hmac2);
    const sig = drbg(seed, k2sig);
    return sig;
  }
  function tryParsingSig(sg) {
    let sig = void 0;
    const isHex = typeof sg === "string" || isBytes(sg);
    const isObj = !isHex && sg !== null && typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint";
    if (!isHex && !isObj)
      throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
    if (isObj) {
      sig = new Signature(sg.r, sg.s);
    } else if (isHex) {
      try {
        sig = Signature.fromBytes(ensureBytes("sig", sg), "der");
      } catch (derError) {
        if (!(derError instanceof DER.Err))
          throw derError;
      }
      if (!sig) {
        try {
          sig = Signature.fromBytes(ensureBytes("sig", sg), "compact");
        } catch (error) {
          return false;
        }
      }
    }
    if (!sig)
      return false;
    return sig;
  }
  function verify(signature, message, publicKey, opts = {}) {
    const { lowS, prehash, format } = validateSigOpts(opts, defaultSigOpts);
    publicKey = ensureBytes("publicKey", publicKey);
    message = validateMsgAndHash(ensureBytes("message", message), prehash);
    if ("strict" in opts)
      throw new Error("options.strict was renamed to lowS");
    const sig = format === void 0 ? tryParsingSig(signature) : Signature.fromBytes(ensureBytes("sig", signature), format);
    if (sig === false)
      return false;
    try {
      const P = Point.fromBytes(publicKey);
      if (lowS && sig.hasHighS())
        return false;
      const { r, s } = sig;
      const h = bits2int_modN(message);
      const is = Fn.inv(s);
      const u1 = Fn.create(h * is);
      const u2 = Fn.create(r * is);
      const R = Point.BASE.multiplyUnsafe(u1).add(P.multiplyUnsafe(u2));
      if (R.is0())
        return false;
      const v = Fn.create(R.x);
      return v === r;
    } catch (e) {
      return false;
    }
  }
  function recoverPublicKey(signature, message, opts = {}) {
    const { prehash } = validateSigOpts(opts, defaultSigOpts);
    message = validateMsgAndHash(message, prehash);
    return Signature.fromBytes(signature, "recovered").recoverPublicKey(message).toBytes();
  }
  return Object.freeze({
    keygen,
    getPublicKey,
    getSharedSecret,
    utils,
    lengths,
    Point,
    sign,
    verify,
    recoverPublicKey,
    Signature,
    hash
  });
}
function _weierstrass_legacy_opts_to_new(c) {
  const CURVE = {
    a: c.a,
    b: c.b,
    p: c.Fp.ORDER,
    n: c.n,
    h: c.h,
    Gx: c.Gx,
    Gy: c.Gy
  };
  const Fp = c.Fp;
  let allowedLengths = c.allowedPrivateKeyLengths ? Array.from(new Set(c.allowedPrivateKeyLengths.map((l) => Math.ceil(l / 2)))) : void 0;
  const Fn = Field(CURVE.n, {
    BITS: c.nBitLength,
    allowedLengths,
    modFromBytes: c.wrapPrivateKey
  });
  const curveOpts = {
    Fp,
    Fn,
    allowInfinityPoint: c.allowInfinityPoint,
    endo: c.endo,
    isTorsionFree: c.isTorsionFree,
    clearCofactor: c.clearCofactor,
    fromBytes: c.fromBytes,
    toBytes: c.toBytes
  };
  return { CURVE, curveOpts };
}
function _ecdsa_legacy_opts_to_new(c) {
  const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);
  const ecdsaOpts = {
    hmac: c.hmac,
    randomBytes: c.randomBytes,
    lowS: c.lowS,
    bits2int: c.bits2int,
    bits2int_modN: c.bits2int_modN
  };
  return { CURVE, curveOpts, hash: c.hash, ecdsaOpts };
}
function _ecdsa_new_output_to_legacy(c, _ecdsa) {
  const Point = _ecdsa.Point;
  return Object.assign({}, _ecdsa, {
    ProjectivePoint: Point,
    CURVE: Object.assign({}, c, nLength(Point.Fn.ORDER, Point.Fn.BITS))
  });
}
function weierstrass(c) {
  const { CURVE, curveOpts, hash, ecdsaOpts } = _ecdsa_legacy_opts_to_new(c);
  const Point = weierstrassN(CURVE, curveOpts);
  const signs = ecdsa(Point, hash, ecdsaOpts);
  return _ecdsa_new_output_to_legacy(c, signs);
}
var divNearest, DERErr, DER, _0n4, _1n4, _2n2, _3n2, _4n2;
var init_weierstrass = __esm({
  "node_modules/@noble/curves/esm/abstract/weierstrass.js"() {
    init_hmac();
    init_utils();
    init_utils2();
    init_curve();
    init_modular();
    divNearest = (num, den) => (num + (num >= 0 ? den : -den) / _2n2) / den;
    DERErr = class extends Error {
      constructor(m = "") {
        super(m);
      }
    };
    DER = {
      // asn.1 DER encoding utils
      Err: DERErr,
      // Basic building block is TLV (Tag-Length-Value)
      _tlv: {
        encode: (tag, data) => {
          const { Err: E } = DER;
          if (tag < 0 || tag > 256)
            throw new E("tlv.encode: wrong tag");
          if (data.length & 1)
            throw new E("tlv.encode: unpadded data");
          const dataLen = data.length / 2;
          const len = numberToHexUnpadded(dataLen);
          if (len.length / 2 & 128)
            throw new E("tlv.encode: long form length too big");
          const lenLen = dataLen > 127 ? numberToHexUnpadded(len.length / 2 | 128) : "";
          const t = numberToHexUnpadded(tag);
          return t + lenLen + len + data;
        },
        // v - value, l - left bytes (unparsed)
        decode(tag, data) {
          const { Err: E } = DER;
          let pos = 0;
          if (tag < 0 || tag > 256)
            throw new E("tlv.encode: wrong tag");
          if (data.length < 2 || data[pos++] !== tag)
            throw new E("tlv.decode: wrong tlv");
          const first = data[pos++];
          const isLong = !!(first & 128);
          let length = 0;
          if (!isLong)
            length = first;
          else {
            const lenLen = first & 127;
            if (!lenLen)
              throw new E("tlv.decode(long): indefinite length not supported");
            if (lenLen > 4)
              throw new E("tlv.decode(long): byte length is too big");
            const lengthBytes = data.subarray(pos, pos + lenLen);
            if (lengthBytes.length !== lenLen)
              throw new E("tlv.decode: length bytes not complete");
            if (lengthBytes[0] === 0)
              throw new E("tlv.decode(long): zero leftmost byte");
            for (const b2 of lengthBytes)
              length = length << 8 | b2;
            pos += lenLen;
            if (length < 128)
              throw new E("tlv.decode(long): not minimal encoding");
          }
          const v = data.subarray(pos, pos + length);
          if (v.length !== length)
            throw new E("tlv.decode: wrong value length");
          return { v, l: data.subarray(pos + length) };
        }
      },
      // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
      // since we always use positive integers here. It must always be empty:
      // - add zero byte if exists
      // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
      _int: {
        encode(num) {
          const { Err: E } = DER;
          if (num < _0n4)
            throw new E("integer: negative integers are not allowed");
          let hex = numberToHexUnpadded(num);
          if (Number.parseInt(hex[0], 16) & 8)
            hex = "00" + hex;
          if (hex.length & 1)
            throw new E("unexpected DER parsing assertion: unpadded hex");
          return hex;
        },
        decode(data) {
          const { Err: E } = DER;
          if (data[0] & 128)
            throw new E("invalid signature integer: negative");
          if (data[0] === 0 && !(data[1] & 128))
            throw new E("invalid signature integer: unnecessary leading zero");
          return bytesToNumberBE(data);
        }
      },
      toSig(hex) {
        const { Err: E, _int: int, _tlv: tlv } = DER;
        const data = ensureBytes("signature", hex);
        const { v: seqBytes, l: seqLeftBytes } = tlv.decode(48, data);
        if (seqLeftBytes.length)
          throw new E("invalid signature: left bytes after parsing");
        const { v: rBytes, l: rLeftBytes } = tlv.decode(2, seqBytes);
        const { v: sBytes, l: sLeftBytes } = tlv.decode(2, rLeftBytes);
        if (sLeftBytes.length)
          throw new E("invalid signature: left bytes after parsing");
        return { r: int.decode(rBytes), s: int.decode(sBytes) };
      },
      hexFromSig(sig) {
        const { _tlv: tlv, _int: int } = DER;
        const rs = tlv.encode(2, int.encode(sig.r));
        const ss = tlv.encode(2, int.encode(sig.s));
        const seq = rs + ss;
        return tlv.encode(48, seq);
      }
    };
    _0n4 = BigInt(0);
    _1n4 = BigInt(1);
    _2n2 = BigInt(2);
    _3n2 = BigInt(3);
    _4n2 = BigInt(4);
  }
});

// node_modules/@noble/curves/esm/_shortw_utils.js
function createCurve(curveDef, defHash) {
  const create = (hash) => weierstrass({ ...curveDef, hash });
  return { ...create(defHash), create };
}
var init_shortw_utils = __esm({
  "node_modules/@noble/curves/esm/_shortw_utils.js"() {
    init_weierstrass();
  }
});

// node_modules/@noble/curves/esm/secp256k1.js
function sqrtMod(y) {
  const P = secp256k1_CURVE.p;
  const _3n3 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b2 = y * y * y % P;
  const b3 = b2 * b2 * y % P;
  const b6 = pow2(b3, _3n3, P) * b3 % P;
  const b9 = pow2(b6, _3n3, P) * b3 % P;
  const b11 = pow2(b9, _2n3, P) * b2 % P;
  const b22 = pow2(b11, _11n, P) * b11 % P;
  const b44 = pow2(b22, _22n, P) * b22 % P;
  const b88 = pow2(b44, _44n, P) * b44 % P;
  const b176 = pow2(b88, _88n, P) * b88 % P;
  const b220 = pow2(b176, _44n, P) * b44 % P;
  const b223 = pow2(b220, _3n3, P) * b3 % P;
  const t1 = pow2(b223, _23n, P) * b22 % P;
  const t2 = pow2(t1, _6n, P) * b2 % P;
  const root = pow2(t2, _2n3, P);
  if (!Fpk1.eql(Fpk1.sqr(root), y))
    throw new Error("Cannot find square root");
  return root;
}
var secp256k1_CURVE, secp256k1_ENDO, _2n3, Fpk1, secp256k1;
var init_secp256k1 = __esm({
  "node_modules/@noble/curves/esm/secp256k1.js"() {
    init_sha2();
    init_shortw_utils();
    init_modular();
    secp256k1_CURVE = {
      p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
      n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
      h: BigInt(1),
      a: BigInt(0),
      b: BigInt(7),
      Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
      Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
    };
    secp256k1_ENDO = {
      beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
      basises: [
        [BigInt("0x3086d221a7d46bcde86c90e49284eb15"), -BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],
        [BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), BigInt("0x3086d221a7d46bcde86c90e49284eb15")]
      ]
    };
    _2n3 = /* @__PURE__ */ BigInt(2);
    Fpk1 = Field(secp256k1_CURVE.p, { sqrt: sqrtMod });
    secp256k1 = createCurve({ ...secp256k1_CURVE, Fp: Fpk1, lowS: true, endo: secp256k1_ENDO }, sha256);
  }
});

// node_modules/bip32-path/index.js
var require_bip32_path = __commonJS({
  "node_modules/bip32-path/index.js"(exports2, module2) {
    var HARDENED = 2147483648;
    var BIPPath = function(path) {
      if (!Array.isArray(path)) {
        throw new Error("Input must be an Array");
      }
      if (path.length === 0) {
        throw new Error("Path must contain at least one level");
      }
      for (var i = 0; i < path.length; i++) {
        if (typeof path[i] !== "number") {
          throw new Error("Path element is not a number");
        }
      }
      this.path = path;
    };
    BIPPath.validatePathArray = function(path) {
      try {
        BIPPath.fromPathArray(path);
        return true;
      } catch (e) {
        return false;
      }
    };
    BIPPath.validateString = function(text, reqRoot) {
      try {
        BIPPath.fromString(text, reqRoot);
        return true;
      } catch (e) {
        return false;
      }
    };
    BIPPath.fromPathArray = function(path) {
      return new BIPPath(path);
    };
    BIPPath.fromString = function(text, reqRoot) {
      if (/^m\//i.test(text)) {
        text = text.slice(2);
      } else if (reqRoot) {
        throw new Error("Root element is required");
      }
      var path = text.split("/");
      var ret = new Array(path.length);
      for (var i = 0; i < path.length; i++) {
        var tmp = /(\d+)([hH\']?)/.exec(path[i]);
        if (tmp === null) {
          throw new Error("Invalid input");
        }
        ret[i] = parseInt(tmp[1], 10);
        if (ret[i] >= HARDENED) {
          throw new Error("Invalid child index");
        }
        if (tmp[2] === "h" || tmp[2] === "H" || tmp[2] === "'") {
          ret[i] += HARDENED;
        } else if (tmp[2].length != 0) {
          throw new Error("Invalid modifier");
        }
      }
      return new BIPPath(ret);
    };
    BIPPath.prototype.toPathArray = function() {
      return this.path;
    };
    BIPPath.prototype.toString = function(noRoot, oldStyle) {
      var ret = new Array(this.path.length);
      for (var i = 0; i < this.path.length; i++) {
        var tmp = this.path[i];
        if (tmp & HARDENED) {
          ret[i] = (tmp & ~HARDENED) + (oldStyle ? "h" : "'");
        } else {
          ret[i] = tmp;
        }
      }
      return (noRoot ? "" : "m/") + ret.join("/");
    };
    BIPPath.prototype.inspect = function() {
      return "BIPPath <" + this.toString() + ">";
    };
    module2.exports = BIPPath;
  }
});

// node_modules/@ledgerhq/hw-app-btc/lib-es/bip32.js
function pathElementsToBuffer(paths) {
  const buffer = Buffer.alloc(1 + paths.length * 4);
  buffer[0] = paths.length;
  paths.forEach((element, index) => {
    buffer.writeUInt32BE(element, 1 + 4 * index);
  });
  return buffer;
}
function bip32asBuffer(path) {
  const pathElements = !path ? [] : pathStringToArray(path);
  return pathElementsToBuffer(pathElements);
}
function pathArrayToString(pathElements) {
  return import_bip32_path.default.fromPathArray(pathElements).toString();
}
function pathStringToArray(path) {
  return import_bip32_path.default.fromString(path).toPathArray();
}
function pubkeyFromXpub(xpub) {
  const xpubBuf = import_bs58check.default.decode(xpub);
  return xpubBuf.slice(xpubBuf.length - 33);
}
function getXpubComponents(xpub) {
  const xpubBuf = import_bs58check.default.decode(xpub);
  return {
    chaincode: xpubBuf.slice(13, 13 + 32),
    pubkey: xpubBuf.slice(xpubBuf.length - 33),
    version: xpubBuf.readUInt32BE(0)
  };
}
function hardenedPathOf(pathElements) {
  for (let i = pathElements.length - 1; i >= 0; i--) {
    if (pathElements[i] >= 2147483648) {
      return pathElements.slice(0, i + 1);
    }
  }
  return [];
}
var import_bip32_path, import_bs58check;
var init_bip32 = __esm({
  "node_modules/@ledgerhq/hw-app-btc/lib-es/bip32.js"() {
    import_bip32_path = __toESM(require_bip32_path());
    import_bs58check = __toESM(require_bs58check());
  }
});

// node_modules/@ledgerhq/hw-app-btc/lib-es/buffertools.js
function unsafeTo64bitLE(n) {
  if (n > Number.MAX_SAFE_INTEGER) {
    throw new Error("Can't convert numbers > MAX_SAFE_INT");
  }
  const byteArray = Buffer.alloc(8, 0);
  for (let index = 0; index < byteArray.length; index++) {
    const byte = n & 255;
    byteArray[index] = byte;
    n = (n - byte) / 256;
  }
  return byteArray;
}
function unsafeFrom64bitLE(byteArray) {
  let value = 0;
  if (byteArray.length != 8) {
    throw new Error("Expected Bufffer of lenght 8");
  }
  if (byteArray[7] != 0) {
    throw new Error("Can't encode numbers > MAX_SAFE_INT");
  }
  if (byteArray[6] > 31) {
    throw new Error("Can't encode numbers > MAX_SAFE_INT");
  }
  for (let i = byteArray.length - 1; i >= 0; i--) {
    value = value * 256 + byteArray[i];
  }
  return value;
}
var import_varuint_bitcoin, BufferWriter, BufferReader;
var init_buffertools = __esm({
  "node_modules/@ledgerhq/hw-app-btc/lib-es/buffertools.js"() {
    import_varuint_bitcoin = __toESM(require_varuint_bitcoin());
    BufferWriter = class {
      bufs = [];
      write(alloc, fn) {
        const b2 = Buffer.alloc(alloc);
        fn(b2);
        this.bufs.push(b2);
      }
      writeUInt8(i) {
        this.write(1, (b2) => b2.writeUInt8(i, 0));
      }
      writeInt32(i) {
        this.write(4, (b2) => b2.writeInt32LE(i, 0));
      }
      writeUInt32(i) {
        this.write(4, (b2) => b2.writeUInt32LE(i, 0));
      }
      writeUInt64(i) {
        const bytes = unsafeTo64bitLE(i);
        this.writeSlice(bytes);
      }
      writeVarInt(i) {
        this.bufs.push(import_varuint_bitcoin.default.encode(i));
      }
      writeSlice(slice) {
        this.bufs.push(Buffer.from(slice));
      }
      writeVarSlice(slice) {
        this.writeVarInt(slice.length);
        this.writeSlice(slice);
      }
      buffer() {
        return Buffer.concat(this.bufs);
      }
    };
    BufferReader = class {
      buffer;
      offset;
      constructor(buffer, offset = 0) {
        this.buffer = buffer;
        this.offset = offset;
      }
      available() {
        return this.buffer.length - this.offset;
      }
      readUInt8() {
        const result = this.buffer.readUInt8(this.offset);
        this.offset++;
        return result;
      }
      readInt32() {
        const result = this.buffer.readInt32LE(this.offset);
        this.offset += 4;
        return result;
      }
      readUInt32() {
        const result = this.buffer.readUInt32LE(this.offset);
        this.offset += 4;
        return result;
      }
      readUInt64() {
        const buf = this.readSlice(8);
        const n = unsafeFrom64bitLE(buf);
        return n;
      }
      readVarInt() {
        const vi = import_varuint_bitcoin.default.decode(this.buffer, this.offset);
        this.offset += import_varuint_bitcoin.default.decode.bytes;
        return vi;
      }
      readSlice(n) {
        if (this.buffer.length < this.offset + n) {
          throw new Error("Cannot read slice out of bounds");
        }
        const result = this.buffer.slice(this.offset, this.offset + n);
        this.offset += n;
        return result;
      }
      readVarSlice() {
        return this.readSlice(this.readVarInt());
      }
      readVector() {
        const count = this.readVarInt();
        const vector = [];
        for (let i = 0; i < count; i++)
          vector.push(this.readVarSlice());
        return vector;
      }
    };
  }
});

// node_modules/@ledgerhq/hw-app-btc/lib-es/constants.js
var MAX_SCRIPT_BLOCK, DEFAULT_VERSION, DEFAULT_LOCKTIME, DEFAULT_SEQUENCE, SIGHASH_ALL, OP_DUP, OP_HASH160, HASH_SIZE, OP_EQUAL, OP_EQUALVERIFY, OP_CHECKSIG, ZCASH_ACTIVATION_HEIGHTS, zCashEncCiphertextSize, zCashOutCiphertextSize, zCashProofsSaplingSize;
var init_constants = __esm({
  "node_modules/@ledgerhq/hw-app-btc/lib-es/constants.js"() {
    MAX_SCRIPT_BLOCK = 50;
    DEFAULT_VERSION = 1;
    DEFAULT_LOCKTIME = 0;
    DEFAULT_SEQUENCE = 4294967295;
    SIGHASH_ALL = 1;
    OP_DUP = 118;
    OP_HASH160 = 169;
    HASH_SIZE = 20;
    OP_EQUAL = 135;
    OP_EQUALVERIFY = 136;
    OP_CHECKSIG = 172;
    ZCASH_ACTIVATION_HEIGHTS = {
      // https://zcash.readthedocs.io/en/latest/rtd_pages/nu_dev_guide.html
      //
      // https://zips.z.cash/zip-0255
      // https://github.com/zcash/zcash/releases/tag/v6.10.0
      NU6_1: 3146400,
      // https://zips.z.cash/zip-0253
      NU6: 2726400,
      // https://zips.z.cash/zip-0252
      NU5: 1687104,
      // https://zips.z.cash/zip-0251
      CANOPY: 1046400,
      // https://zips.z.cash/zip-0250
      HEARTWOOD: 903e3,
      // https://z.cash/upgrade/blossom/
      // https://zips.z.cash/zip-0206
      BLOSSOM: 653600,
      // https://zips.z.cash/zip-0205
      SAPLING: 419200
    };
    zCashEncCiphertextSize = 580;
    zCashOutCiphertextSize = 80;
    zCashProofsSaplingSize = 192;
  }
});

// node_modules/@noble/hashes/esm/sha256.js
var sha2562;
var init_sha256 = __esm({
  "node_modules/@noble/hashes/esm/sha256.js"() {
    init_sha2();
    sha2562 = sha256;
  }
});

// node_modules/@noble/hashes/esm/legacy.js
function ripemd_f(group, x, y, z) {
  if (group === 0)
    return x ^ y ^ z;
  if (group === 1)
    return x & y | ~x & z;
  if (group === 2)
    return (x | ~y) ^ z;
  if (group === 3)
    return x & z | y & ~z;
  return x ^ (y | ~z);
}
var Rho160, Id160, Pi160, idxLR, idxL, idxR, shifts160, shiftsL160, shiftsR160, Kl160, Kr160, BUF_160, RIPEMD160, ripemd160;
var init_legacy = __esm({
  "node_modules/@noble/hashes/esm/legacy.js"() {
    init_md();
    init_utils();
    Rho160 = /* @__PURE__ */ Uint8Array.from([
      7,
      4,
      13,
      1,
      10,
      6,
      15,
      3,
      12,
      0,
      9,
      5,
      2,
      14,
      11,
      8
    ]);
    Id160 = /* @__PURE__ */ (() => Uint8Array.from(new Array(16).fill(0).map((_, i) => i)))();
    Pi160 = /* @__PURE__ */ (() => Id160.map((i) => (9 * i + 5) % 16))();
    idxLR = /* @__PURE__ */ (() => {
      const L = [Id160];
      const R = [Pi160];
      const res = [L, R];
      for (let i = 0; i < 4; i++)
        for (let j of res)
          j.push(j[i].map((k) => Rho160[k]));
      return res;
    })();
    idxL = /* @__PURE__ */ (() => idxLR[0])();
    idxR = /* @__PURE__ */ (() => idxLR[1])();
    shifts160 = /* @__PURE__ */ [
      [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
      [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
      [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
      [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
      [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
    ].map((i) => Uint8Array.from(i));
    shiftsL160 = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts160[i][j]));
    shiftsR160 = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts160[i][j]));
    Kl160 = /* @__PURE__ */ Uint32Array.from([
      0,
      1518500249,
      1859775393,
      2400959708,
      2840853838
    ]);
    Kr160 = /* @__PURE__ */ Uint32Array.from([
      1352829926,
      1548603684,
      1836072691,
      2053994217,
      0
    ]);
    BUF_160 = /* @__PURE__ */ new Uint32Array(16);
    RIPEMD160 = class extends HashMD {
      constructor() {
        super(64, 20, 8, true);
        this.h0 = 1732584193 | 0;
        this.h1 = 4023233417 | 0;
        this.h2 = 2562383102 | 0;
        this.h3 = 271733878 | 0;
        this.h4 = 3285377520 | 0;
      }
      get() {
        const { h0, h1, h2, h3, h4 } = this;
        return [h0, h1, h2, h3, h4];
      }
      set(h0, h1, h2, h3, h4) {
        this.h0 = h0 | 0;
        this.h1 = h1 | 0;
        this.h2 = h2 | 0;
        this.h3 = h3 | 0;
        this.h4 = h4 | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
          BUF_160[i] = view.getUint32(offset, true);
        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
        for (let group = 0; group < 5; group++) {
          const rGroup = 4 - group;
          const hbl = Kl160[group], hbr = Kr160[group];
          const rl = idxL[group], rr = idxR[group];
          const sl = shiftsL160[group], sr = shiftsR160[group];
          for (let i = 0; i < 16; i++) {
            const tl = rotl(al + ripemd_f(group, bl, cl, dl) + BUF_160[rl[i]] + hbl, sl[i]) + el | 0;
            al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl;
          }
          for (let i = 0; i < 16; i++) {
            const tr = rotl(ar + ripemd_f(rGroup, br, cr, dr) + BUF_160[rr[i]] + hbr, sr[i]) + er | 0;
            ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr;
          }
        }
        this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);
      }
      roundClean() {
        clean(BUF_160);
      }
      destroy() {
        this.destroyed = true;
        clean(this.buffer);
        this.set(0, 0, 0, 0, 0);
      }
    };
    ripemd160 = /* @__PURE__ */ createHasher(() => new RIPEMD160());
  }
});

// node_modules/@noble/hashes/esm/ripemd160.js
var ripemd1602;
var init_ripemd160 = __esm({
  "node_modules/@noble/hashes/esm/ripemd160.js"() {
    init_legacy();
    ripemd1602 = ripemd160;
  }
});

// node_modules/@ledgerhq/hw-app-btc/lib-es/hashPublicKey.js
function hashPublicKey(buffer) {
  return Buffer.from(ripemd1602(sha2562(buffer)));
}
var init_hashPublicKey = __esm({
  "node_modules/@ledgerhq/hw-app-btc/lib-es/hashPublicKey.js"() {
    init_sha256();
    init_ripemd160();
  }
});

// node_modules/@ledgerhq/hw-app-btc/lib-es/newops/accounttype.js
function bytesToBigInt(bytes) {
  const hex = Array.from(bytes).map((b2) => b2.toString(16).padStart(2, "0")).join("");
  return BigInt("0x" + hex);
}
function pointAddScalar(point, scalar) {
  try {
    const p = secp256k1.ProjectivePoint.fromHex(point);
    const s = bytesToBigInt(scalar);
    const result = p.add(secp256k1.ProjectivePoint.BASE.multiply(s));
    return result.toRawBytes(point.length === 33);
  } catch {
    return null;
  }
}
var import_bitcoinjs_lib, BaseAccount, SingleKeyAccount, p2pkh, p2tr, p2wpkhWrapped, p2wpkh;
var init_accounttype = __esm({
  "node_modules/@ledgerhq/hw-app-btc/lib-es/newops/accounttype.js"() {
    import_bitcoinjs_lib = __toESM(require_src3());
    init_secp256k1();
    init_buffertools();
    init_constants();
    init_hashPublicKey();
    BaseAccount = class {
      psbt;
      masterFp;
      constructor(psbt, masterFp) {
        this.psbt = psbt;
        this.masterFp = masterFp;
      }
    };
    SingleKeyAccount = class extends BaseAccount {
      spendingCondition(pubkeys) {
        if (pubkeys.length != 1) {
          throw new Error("Expected single key, got " + pubkeys.length);
        }
        return this.singleKeyCondition(pubkeys[0]);
      }
      setInput(i, inputTx, spentOutput, pubkeys, pathElems) {
        if (pubkeys.length != 1) {
          throw new Error("Expected single key, got " + pubkeys.length);
        }
        if (pathElems.length != 1) {
          throw new Error("Expected single path, got " + pathElems.length);
        }
        this.setSingleKeyInput(i, inputTx, spentOutput, pubkeys[0], pathElems[0]);
      }
      setOwnOutput(i, cond, pubkeys, paths) {
        if (pubkeys.length != 1) {
          throw new Error("Expected single key, got " + pubkeys.length);
        }
        if (paths.length != 1) {
          throw new Error("Expected single path, got " + paths.length);
        }
        this.setSingleKeyOutput(i, cond, pubkeys[0], paths[0]);
      }
    };
    p2pkh = class extends SingleKeyAccount {
      singleKeyCondition(pubkey) {
        const buf = new BufferWriter();
        const pubkeyHash = hashPublicKey(pubkey);
        buf.writeSlice(Buffer.from([OP_DUP, OP_HASH160, HASH_SIZE]));
        buf.writeSlice(pubkeyHash);
        buf.writeSlice(Buffer.from([OP_EQUALVERIFY, OP_CHECKSIG]));
        return { scriptPubKey: buf.buffer() };
      }
      setSingleKeyInput(i, inputTx, _spentOutput, pubkey, path) {
        if (!inputTx) {
          throw new Error("Full input base transaction required");
        }
        this.psbt.setInputNonWitnessUtxo(i, inputTx);
        this.psbt.setInputBip32Derivation(i, pubkey, this.masterFp, path);
      }
      setSingleKeyOutput(i, cond, pubkey, path) {
        this.psbt.setOutputBip32Derivation(i, pubkey, this.masterFp, path);
      }
      getDescriptorTemplate() {
        return "pkh(@0)";
      }
    };
    p2tr = class extends SingleKeyAccount {
      singleKeyCondition(pubkey) {
        const xonlyPubkey = pubkey.slice(1);
        const buf = new BufferWriter();
        const outputKey = this.getTaprootOutputKey(xonlyPubkey);
        buf.writeSlice(Buffer.from([81, 32]));
        buf.writeSlice(outputKey);
        return { scriptPubKey: buf.buffer() };
      }
      setSingleKeyInput(i, _inputTx, spentOutput, pubkey, path) {
        const xonly = pubkey.slice(1);
        this.psbt.setInputTapBip32Derivation(i, xonly, [], this.masterFp, path);
        this.psbt.setInputWitnessUtxo(i, spentOutput.amount, spentOutput.cond.scriptPubKey);
      }
      setSingleKeyOutput(i, cond, pubkey, path) {
        const xonly = pubkey.slice(1);
        this.psbt.setOutputTapBip32Derivation(i, xonly, [], this.masterFp, path);
      }
      getDescriptorTemplate() {
        return "tr(@0)";
      }
      /*
      The following two functions are copied from wallet-btc and adapted.
      They should be moved to a library to avoid code reuse.
      */
      hashTapTweak(x) {
        const h = import_bitcoinjs_lib.crypto.sha256(Buffer.from("TapTweak", "utf-8"));
        return import_bitcoinjs_lib.crypto.sha256(Buffer.concat([h, h, x]));
      }
      /**
       * Calculates a taproot output key from an internal key. This output key will be
       * used as witness program in a taproot output. The internal key is tweaked
       * according to recommendation in BIP341:
       * https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_ref-22-0
       *
       * @param internalPubkey A 32 byte x-only taproot internal key
       * @returns The output key
       */
      getTaprootOutputKey(internalPubkey) {
        if (internalPubkey.length != 32) {
          throw new Error("Expected 32 byte pubkey. Got " + internalPubkey.length);
        }
        const evenEcdsaPubkey = Buffer.concat([Buffer.from([2]), internalPubkey]);
        const tweak = this.hashTapTweak(internalPubkey);
        const tweakedKey = pointAddScalar(evenEcdsaPubkey, tweak);
        if (!tweakedKey)
          throw new Error("Point addition failed");
        const outputEcdsaKey = Buffer.from(tweakedKey);
        const outputSchnorrKey = outputEcdsaKey.slice(1);
        return outputSchnorrKey;
      }
    };
    p2wpkhWrapped = class extends SingleKeyAccount {
      singleKeyCondition(pubkey) {
        const buf = new BufferWriter();
        const redeemScript = this.createRedeemScript(pubkey);
        const scriptHash = hashPublicKey(redeemScript);
        buf.writeSlice(Buffer.from([OP_HASH160, HASH_SIZE]));
        buf.writeSlice(scriptHash);
        buf.writeUInt8(OP_EQUAL);
        return { scriptPubKey: buf.buffer(), redeemScript };
      }
      setSingleKeyInput(i, inputTx, spentOutput, pubkey, path) {
        if (!inputTx) {
          throw new Error("Full input base transaction required");
        }
        this.psbt.setInputNonWitnessUtxo(i, inputTx);
        this.psbt.setInputBip32Derivation(i, pubkey, this.masterFp, path);
        const userSuppliedRedeemScript = spentOutput.cond.redeemScript;
        const expectedRedeemScript = this.createRedeemScript(pubkey);
        if (userSuppliedRedeemScript && !expectedRedeemScript.equals(userSuppliedRedeemScript)) {
          throw new Error(`User-supplied redeemScript ${userSuppliedRedeemScript.toString("hex")} doesn't
       match expected ${expectedRedeemScript.toString("hex")} for input ${i}`);
        }
        this.psbt.setInputRedeemScript(i, expectedRedeemScript);
        this.psbt.setInputWitnessUtxo(i, spentOutput.amount, spentOutput.cond.scriptPubKey);
      }
      setSingleKeyOutput(i, cond, pubkey, path) {
        this.psbt.setOutputRedeemScript(i, cond.redeemScript);
        this.psbt.setOutputBip32Derivation(i, pubkey, this.masterFp, path);
      }
      getDescriptorTemplate() {
        return "sh(wpkh(@0))";
      }
      createRedeemScript(pubkey) {
        const pubkeyHash = hashPublicKey(pubkey);
        return Buffer.concat([Buffer.from("0014", "hex"), pubkeyHash]);
      }
    };
    p2wpkh = class extends SingleKeyAccount {
      singleKeyCondition(pubkey) {
        const buf = new BufferWriter();
        const pubkeyHash = hashPublicKey(pubkey);
        buf.writeSlice(Buffer.from([0, HASH_SIZE]));
        buf.writeSlice(pubkeyHash);
        return { scriptPubKey: buf.buffer() };
      }
      setSingleKeyInput(i, inputTx, spentOutput, pubkey, path) {
        if (!inputTx) {
          throw new Error("Full input base transaction required");
        }
        this.psbt.setInputNonWitnessUtxo(i, inputTx);
        this.psbt.setInputBip32Derivation(i, pubkey, this.masterFp, path);
        this.psbt.setInputWitnessUtxo(i, spentOutput.amount, spentOutput.cond.scriptPubKey);
      }
      setSingleKeyOutput(i, cond, pubkey, path) {
        this.psbt.setOutputBip32Derivation(i, pubkey, this.masterFp, path);
      }
      getDescriptorTemplate() {
        return "wpkh(@0)";
      }
    };
  }
});

// node_modules/@ledgerhq/hw-app-btc/lib-es/newops/merkle.js
function hashLeaf(buf, hashFunction = import_bitcoinjs_lib2.crypto.sha256) {
  return hashConcat(Buffer.from([0]), buf, hashFunction);
}
function hashConcat(bufA, bufB, hashFunction) {
  return hashFunction(Buffer.concat([bufA, bufB]));
}
function proveNode(node) {
  if (!node.parent) {
    return [];
  }
  if (node.parent.leftChild == node) {
    if (!node.parent.rightChild) {
      throw new Error("Expected right child to exist");
    }
    return [node.parent.rightChild.hash, ...proveNode(node.parent)];
  } else {
    if (!node.parent.leftChild) {
      throw new Error("Expected left child to exist");
    }
    return [node.parent.leftChild.hash, ...proveNode(node.parent)];
  }
}
function highestPowerOf2LessThan(n) {
  if (n < 2) {
    throw Error("Expected n >= 2");
  }
  if (isPowerOf2(n)) {
    return n / 2;
  }
  return 1 << Math.floor(Math.log2(n));
}
function isPowerOf2(n) {
  return (n & n - 1) == 0;
}
var import_bitcoinjs_lib2, Merkle, Node;
var init_merkle = __esm({
  "node_modules/@ledgerhq/hw-app-btc/lib-es/newops/merkle.js"() {
    import_bitcoinjs_lib2 = __toESM(require_src3());
    Merkle = class {
      leaves;
      rootNode;
      leafNodes;
      h;
      constructor(leaves, hasher = import_bitcoinjs_lib2.crypto.sha256) {
        this.leaves = leaves;
        this.h = hasher;
        const nodes = this.calculateRoot(leaves);
        this.rootNode = nodes.root;
        this.leafNodes = nodes.leaves;
      }
      getRoot() {
        return this.rootNode.hash;
      }
      size() {
        return this.leaves.length;
      }
      getLeaves() {
        return this.leaves;
      }
      getLeafHash(index) {
        return this.leafNodes[index].hash;
      }
      getProof(index) {
        if (index >= this.leaves.length)
          throw Error("Index out of bounds");
        return proveNode(this.leafNodes[index]);
      }
      calculateRoot(leaves) {
        const n = leaves.length;
        if (n == 0) {
          return {
            root: new Node(void 0, void 0, Buffer.alloc(32, 0)),
            leaves: []
          };
        }
        if (n == 1) {
          const newNode = new Node(void 0, void 0, leaves[0]);
          return { root: newNode, leaves: [newNode] };
        }
        const leftCount = highestPowerOf2LessThan(n);
        const leftBranch = this.calculateRoot(leaves.slice(0, leftCount));
        const rightBranch = this.calculateRoot(leaves.slice(leftCount));
        const leftChild = leftBranch.root;
        const rightChild = rightBranch.root;
        const hash = this.hashNode(leftChild.hash, rightChild.hash);
        const node = new Node(leftChild, rightChild, hash);
        leftChild.parent = node;
        rightChild.parent = node;
        return { root: node, leaves: leftBranch.leaves.concat(rightBranch.leaves) };
      }
      hashNode(left, right) {
        return this.h(Buffer.concat([Buffer.from([1]), left, right]));
      }
    };
    Node = class {
      leftChild;
      rightChild;
      parent;
      hash;
      constructor(left, right, hash) {
        this.leftChild = left;
        this.rightChild = right;
        this.hash = hash;
      }
      isLeaf() {
        return this.leftChild == void 0;
      }
    };
  }
});

// node_modules/@ledgerhq/hw-app-btc/lib-es/newops/policy.js
function createKey(masterFingerprint, path, xpub) {
  const accountPath = pathArrayToString(path);
  return `[${masterFingerprint.toString("hex")}${accountPath.substring(1)}]${xpub}/**`;
}
var import_bitcoinjs_lib3, WalletPolicy;
var init_policy = __esm({
  "node_modules/@ledgerhq/hw-app-btc/lib-es/newops/policy.js"() {
    import_bitcoinjs_lib3 = __toESM(require_src3());
    init_bip32();
    init_buffertools();
    init_merkle();
    WalletPolicy = class {
      descriptorTemplate;
      keys;
      /**
       * For now, we only support default descriptor templates.
       */
      constructor(descriptorTemplate, key) {
        this.descriptorTemplate = descriptorTemplate;
        this.keys = [key];
      }
      getWalletId() {
        return import_bitcoinjs_lib3.crypto.sha256(this.serialize());
      }
      serialize() {
        const keyBuffers = this.keys.map((k) => {
          return Buffer.from(k, "ascii");
        });
        const m = new Merkle(keyBuffers.map((k) => hashLeaf(k)));
        const buf = new BufferWriter();
        buf.writeUInt8(1);
        buf.writeUInt8(0);
        buf.writeVarSlice(Buffer.from(this.descriptorTemplate, "ascii"));
        buf.writeVarInt(this.keys.length), buf.writeSlice(m.getRoot());
        return buf.buffer();
      }
    };
  }
});

// node_modules/@ledgerhq/hw-app-btc/lib-es/newops/psbtExtractor.js
function extract(psbt) {
  const tx = new BufferWriter();
  tx.writeUInt32(psbt.getGlobalTxVersion());
  const isSegwit = !!psbt.getInputWitnessUtxo(0);
  if (isSegwit) {
    tx.writeSlice(Buffer.from([0, 1]));
  }
  const inputCount = psbt.getGlobalInputCount();
  tx.writeVarInt(inputCount);
  const witnessWriter = new BufferWriter();
  for (let i = 0; i < inputCount; i++) {
    tx.writeSlice(psbt.getInputPreviousTxid(i));
    tx.writeUInt32(psbt.getInputOutputIndex(i));
    tx.writeVarSlice(psbt.getInputFinalScriptsig(i) ?? Buffer.from([]));
    tx.writeUInt32(psbt.getInputSequence(i));
    if (isSegwit) {
      witnessWriter.writeSlice(psbt.getInputFinalScriptwitness(i));
    }
  }
  const outputCount = psbt.getGlobalOutputCount();
  tx.writeVarInt(outputCount);
  for (let i = 0; i < outputCount; i++) {
    tx.writeUInt64(psbt.getOutputAmount(i));
    tx.writeVarSlice(psbt.getOutputScript(i));
  }
  tx.writeSlice(witnessWriter.buffer());
  tx.writeUInt32(psbt.getGlobalFallbackLocktime() ?? 0);
  return tx.buffer();
}
var init_psbtExtractor = __esm({
  "node_modules/@ledgerhq/hw-app-btc/lib-es/newops/psbtExtractor.js"() {
    init_buffertools();
  }
});

// node_modules/@ledgerhq/hw-app-btc/lib-es/newops/psbtv2.js
function get(map, keyType, keyData, acceptUndefined) {
  if (!map)
    throw Error("No such map");
  const key = new Key(keyType, keyData);
  const value = map.get(key.toString());
  if (!value) {
    if (acceptUndefined) {
      return void 0;
    }
    throw new NoSuchEntry(key.toString());
  }
  return Buffer.from(value);
}
function createKey2(buf) {
  return new Key(buf.readUInt8(0), buf.slice(1));
}
function serializeMap(buf, map) {
  for (const k of map.keys()) {
    const value = map.get(k);
    const keyPair = new KeyPair(createKey2(Buffer.from(k, "hex")), value);
    keyPair.serialize(buf);
  }
  buf.writeUInt8(0);
}
function b() {
  return Buffer.from([]);
}
function set(map, keyType, keyData, value) {
  const key = new Key(keyType, keyData);
  map.set(key.toString(), value);
}
function uint32LE(n) {
  const b2 = Buffer.alloc(4);
  b2.writeUInt32LE(n, 0);
  return b2;
}
function uint64LE(n) {
  return unsafeTo64bitLE(n);
}
function varint(n) {
  const b2 = new BufferWriter();
  b2.writeVarInt(n);
  return b2.buffer();
}
function fromVarint(buf) {
  return new BufferReader(buf).readVarInt();
}
var psbtGlobal, psbtIn, psbtOut, PSBT_MAGIC_BYTES, NoSuchEntry, PsbtV2, Key, KeyPair;
var init_psbtv2 = __esm({
  "node_modules/@ledgerhq/hw-app-btc/lib-es/newops/psbtv2.js"() {
    init_buffertools();
    (function(psbtGlobal2) {
      psbtGlobal2[psbtGlobal2["TX_VERSION"] = 2] = "TX_VERSION";
      psbtGlobal2[psbtGlobal2["FALLBACK_LOCKTIME"] = 3] = "FALLBACK_LOCKTIME";
      psbtGlobal2[psbtGlobal2["INPUT_COUNT"] = 4] = "INPUT_COUNT";
      psbtGlobal2[psbtGlobal2["OUTPUT_COUNT"] = 5] = "OUTPUT_COUNT";
      psbtGlobal2[psbtGlobal2["TX_MODIFIABLE"] = 6] = "TX_MODIFIABLE";
      psbtGlobal2[psbtGlobal2["VERSION"] = 251] = "VERSION";
    })(psbtGlobal || (psbtGlobal = {}));
    (function(psbtIn2) {
      psbtIn2[psbtIn2["NON_WITNESS_UTXO"] = 0] = "NON_WITNESS_UTXO";
      psbtIn2[psbtIn2["WITNESS_UTXO"] = 1] = "WITNESS_UTXO";
      psbtIn2[psbtIn2["PARTIAL_SIG"] = 2] = "PARTIAL_SIG";
      psbtIn2[psbtIn2["SIGHASH_TYPE"] = 3] = "SIGHASH_TYPE";
      psbtIn2[psbtIn2["REDEEM_SCRIPT"] = 4] = "REDEEM_SCRIPT";
      psbtIn2[psbtIn2["BIP32_DERIVATION"] = 6] = "BIP32_DERIVATION";
      psbtIn2[psbtIn2["FINAL_SCRIPTSIG"] = 7] = "FINAL_SCRIPTSIG";
      psbtIn2[psbtIn2["FINAL_SCRIPTWITNESS"] = 8] = "FINAL_SCRIPTWITNESS";
      psbtIn2[psbtIn2["PREVIOUS_TXID"] = 14] = "PREVIOUS_TXID";
      psbtIn2[psbtIn2["OUTPUT_INDEX"] = 15] = "OUTPUT_INDEX";
      psbtIn2[psbtIn2["SEQUENCE"] = 16] = "SEQUENCE";
      psbtIn2[psbtIn2["TAP_KEY_SIG"] = 19] = "TAP_KEY_SIG";
      psbtIn2[psbtIn2["TAP_BIP32_DERIVATION"] = 22] = "TAP_BIP32_DERIVATION";
    })(psbtIn || (psbtIn = {}));
    (function(psbtOut2) {
      psbtOut2[psbtOut2["REDEEM_SCRIPT"] = 0] = "REDEEM_SCRIPT";
      psbtOut2[psbtOut2["BIP_32_DERIVATION"] = 2] = "BIP_32_DERIVATION";
      psbtOut2[psbtOut2["AMOUNT"] = 3] = "AMOUNT";
      psbtOut2[psbtOut2["SCRIPT"] = 4] = "SCRIPT";
      psbtOut2[psbtOut2["TAP_BIP32_DERIVATION"] = 7] = "TAP_BIP32_DERIVATION";
    })(psbtOut || (psbtOut = {}));
    PSBT_MAGIC_BYTES = Buffer.from([112, 115, 98, 116, 255]);
    NoSuchEntry = class extends Error {
    };
    PsbtV2 = class {
      globalMap = /* @__PURE__ */ new Map();
      inputMaps = [];
      outputMaps = [];
      setGlobalTxVersion(version) {
        this.setGlobal(psbtGlobal.TX_VERSION, uint32LE(version));
      }
      getGlobalTxVersion() {
        return this.getGlobal(psbtGlobal.TX_VERSION).readUInt32LE(0);
      }
      setGlobalFallbackLocktime(locktime) {
        this.setGlobal(psbtGlobal.FALLBACK_LOCKTIME, uint32LE(locktime));
      }
      getGlobalFallbackLocktime() {
        return this.getGlobalOptional(psbtGlobal.FALLBACK_LOCKTIME)?.readUInt32LE(0);
      }
      setGlobalInputCount(inputCount) {
        this.setGlobal(psbtGlobal.INPUT_COUNT, varint(inputCount));
      }
      getGlobalInputCount() {
        return fromVarint(this.getGlobal(psbtGlobal.INPUT_COUNT));
      }
      setGlobalOutputCount(outputCount) {
        this.setGlobal(psbtGlobal.OUTPUT_COUNT, varint(outputCount));
      }
      getGlobalOutputCount() {
        return fromVarint(this.getGlobal(psbtGlobal.OUTPUT_COUNT));
      }
      setGlobalTxModifiable(byte) {
        this.setGlobal(psbtGlobal.TX_MODIFIABLE, byte);
      }
      getGlobalTxModifiable() {
        return this.getGlobalOptional(psbtGlobal.TX_MODIFIABLE);
      }
      setGlobalPsbtVersion(psbtVersion) {
        this.setGlobal(psbtGlobal.VERSION, uint32LE(psbtVersion));
      }
      getGlobalPsbtVersion() {
        return this.getGlobal(psbtGlobal.VERSION).readUInt32LE(0);
      }
      setInputNonWitnessUtxo(inputIndex, transaction) {
        this.setInput(inputIndex, psbtIn.NON_WITNESS_UTXO, b(), transaction);
      }
      getInputNonWitnessUtxo(inputIndex) {
        return this.getInputOptional(inputIndex, psbtIn.NON_WITNESS_UTXO, b());
      }
      setInputWitnessUtxo(inputIndex, amount, scriptPubKey) {
        const buf = new BufferWriter();
        buf.writeSlice(amount);
        buf.writeVarSlice(scriptPubKey);
        this.setInput(inputIndex, psbtIn.WITNESS_UTXO, b(), buf.buffer());
      }
      getInputWitnessUtxo(inputIndex) {
        const utxo = this.getInputOptional(inputIndex, psbtIn.WITNESS_UTXO, b());
        if (!utxo)
          return void 0;
        const buf = new BufferReader(utxo);
        return { amount: buf.readSlice(8), scriptPubKey: buf.readVarSlice() };
      }
      setInputPartialSig(inputIndex, pubkey, signature) {
        this.setInput(inputIndex, psbtIn.PARTIAL_SIG, pubkey, signature);
      }
      getInputPartialSig(inputIndex, pubkey) {
        return this.getInputOptional(inputIndex, psbtIn.PARTIAL_SIG, pubkey);
      }
      setInputSighashType(inputIndex, sigHashtype) {
        this.setInput(inputIndex, psbtIn.SIGHASH_TYPE, b(), uint32LE(sigHashtype));
      }
      getInputSighashType(inputIndex) {
        const result = this.getInputOptional(inputIndex, psbtIn.SIGHASH_TYPE, b());
        if (!result)
          return void 0;
        return result.readUInt32LE(0);
      }
      setInputRedeemScript(inputIndex, redeemScript) {
        this.setInput(inputIndex, psbtIn.REDEEM_SCRIPT, b(), redeemScript);
      }
      getInputRedeemScript(inputIndex) {
        return this.getInputOptional(inputIndex, psbtIn.REDEEM_SCRIPT, b());
      }
      setInputBip32Derivation(inputIndex, pubkey, masterFingerprint, path) {
        if (pubkey.length != 33)
          throw new Error("Invalid pubkey length: " + pubkey.length);
        this.setInput(inputIndex, psbtIn.BIP32_DERIVATION, pubkey, this.encodeBip32Derivation(masterFingerprint, path));
      }
      getInputBip32Derivation(inputIndex, pubkey) {
        const buf = this.getInputOptional(inputIndex, psbtIn.BIP32_DERIVATION, pubkey);
        if (!buf)
          return void 0;
        return this.decodeBip32Derivation(buf);
      }
      setInputFinalScriptsig(inputIndex, scriptSig) {
        this.setInput(inputIndex, psbtIn.FINAL_SCRIPTSIG, b(), scriptSig);
      }
      getInputFinalScriptsig(inputIndex) {
        return this.getInputOptional(inputIndex, psbtIn.FINAL_SCRIPTSIG, b());
      }
      setInputFinalScriptwitness(inputIndex, scriptWitness) {
        this.setInput(inputIndex, psbtIn.FINAL_SCRIPTWITNESS, b(), scriptWitness);
      }
      getInputFinalScriptwitness(inputIndex) {
        return this.getInput(inputIndex, psbtIn.FINAL_SCRIPTWITNESS, b());
      }
      setInputPreviousTxId(inputIndex, txid) {
        this.setInput(inputIndex, psbtIn.PREVIOUS_TXID, b(), txid);
      }
      getInputPreviousTxid(inputIndex) {
        return this.getInput(inputIndex, psbtIn.PREVIOUS_TXID, b());
      }
      setInputOutputIndex(inputIndex, outputIndex) {
        this.setInput(inputIndex, psbtIn.OUTPUT_INDEX, b(), uint32LE(outputIndex));
      }
      getInputOutputIndex(inputIndex) {
        return this.getInput(inputIndex, psbtIn.OUTPUT_INDEX, b()).readUInt32LE(0);
      }
      setInputSequence(inputIndex, sequence) {
        this.setInput(inputIndex, psbtIn.SEQUENCE, b(), uint32LE(sequence));
      }
      getInputSequence(inputIndex) {
        return this.getInputOptional(inputIndex, psbtIn.SEQUENCE, b())?.readUInt32LE(0) ?? 4294967295;
      }
      setInputTapKeySig(inputIndex, sig) {
        this.setInput(inputIndex, psbtIn.TAP_KEY_SIG, b(), sig);
      }
      getInputTapKeySig(inputIndex) {
        return this.getInputOptional(inputIndex, psbtIn.TAP_KEY_SIG, b());
      }
      setInputTapBip32Derivation(inputIndex, pubkey, hashes, masterFingerprint, path) {
        if (pubkey.length != 32)
          throw new Error("Invalid pubkey length: " + pubkey.length);
        const buf = this.encodeTapBip32Derivation(hashes, masterFingerprint, path);
        this.setInput(inputIndex, psbtIn.TAP_BIP32_DERIVATION, pubkey, buf);
      }
      getInputTapBip32Derivation(inputIndex, pubkey) {
        const buf = this.getInput(inputIndex, psbtIn.TAP_BIP32_DERIVATION, pubkey);
        return this.decodeTapBip32Derivation(buf);
      }
      getInputKeyDatas(inputIndex, keyType) {
        return this.getKeyDatas(this.inputMaps[inputIndex], keyType);
      }
      setOutputRedeemScript(outputIndex, redeemScript) {
        this.setOutput(outputIndex, psbtOut.REDEEM_SCRIPT, b(), redeemScript);
      }
      getOutputRedeemScript(outputIndex) {
        return this.getOutput(outputIndex, psbtOut.REDEEM_SCRIPT, b());
      }
      setOutputBip32Derivation(outputIndex, pubkey, masterFingerprint, path) {
        this.setOutput(outputIndex, psbtOut.BIP_32_DERIVATION, pubkey, this.encodeBip32Derivation(masterFingerprint, path));
      }
      getOutputBip32Derivation(outputIndex, pubkey) {
        const buf = this.getOutput(outputIndex, psbtOut.BIP_32_DERIVATION, pubkey);
        return this.decodeBip32Derivation(buf);
      }
      setOutputAmount(outputIndex, amount) {
        this.setOutput(outputIndex, psbtOut.AMOUNT, b(), uint64LE(amount));
      }
      getOutputAmount(outputIndex) {
        const buf = this.getOutput(outputIndex, psbtOut.AMOUNT, b());
        return unsafeFrom64bitLE(buf);
      }
      setOutputScript(outputIndex, scriptPubKey) {
        this.setOutput(outputIndex, psbtOut.SCRIPT, b(), scriptPubKey);
      }
      getOutputScript(outputIndex) {
        return this.getOutput(outputIndex, psbtOut.SCRIPT, b());
      }
      setOutputTapBip32Derivation(outputIndex, pubkey, hashes, fingerprint, path) {
        const buf = this.encodeTapBip32Derivation(hashes, fingerprint, path);
        this.setOutput(outputIndex, psbtOut.TAP_BIP32_DERIVATION, pubkey, buf);
      }
      getOutputTapBip32Derivation(outputIndex, pubkey) {
        const buf = this.getOutput(outputIndex, psbtOut.TAP_BIP32_DERIVATION, pubkey);
        return this.decodeTapBip32Derivation(buf);
      }
      deleteInputEntries(inputIndex, keyTypes) {
        const map = this.inputMaps[inputIndex];
        map.forEach((_v, k, m) => {
          if (this.isKeyType(k, keyTypes)) {
            m.delete(k);
          }
        });
      }
      copy(to) {
        this.copyMap(this.globalMap, to.globalMap);
        this.copyMaps(this.inputMaps, to.inputMaps);
        this.copyMaps(this.outputMaps, to.outputMaps);
      }
      copyMaps(from, to) {
        from.forEach((m, index) => {
          const to_index = /* @__PURE__ */ new Map();
          this.copyMap(m, to_index);
          to[index] = to_index;
        });
      }
      copyMap(from, to) {
        from.forEach((v, k) => to.set(k, Buffer.from(v)));
      }
      serialize() {
        const buf = new BufferWriter();
        buf.writeSlice(Buffer.from([112, 115, 98, 116, 255]));
        serializeMap(buf, this.globalMap);
        this.inputMaps.forEach((map) => {
          serializeMap(buf, map);
        });
        this.outputMaps.forEach((map) => {
          serializeMap(buf, map);
        });
        return buf.buffer();
      }
      deserialize(psbt) {
        const buf = new BufferReader(psbt);
        if (!buf.readSlice(5).equals(PSBT_MAGIC_BYTES)) {
          throw new Error("Invalid magic bytes");
        }
        while (this.readKeyPair(this.globalMap, buf))
          ;
        for (let i = 0; i < this.getGlobalInputCount(); i++) {
          this.inputMaps[i] = /* @__PURE__ */ new Map();
          while (this.readKeyPair(this.inputMaps[i], buf))
            ;
        }
        for (let i = 0; i < this.getGlobalOutputCount(); i++) {
          this.outputMaps[i] = /* @__PURE__ */ new Map();
          while (this.readKeyPair(this.outputMaps[i], buf))
            ;
        }
      }
      readKeyPair(map, buf) {
        const keyLen = buf.readVarInt();
        if (keyLen == 0) {
          return false;
        }
        const keyType = buf.readUInt8();
        const keyData = buf.readSlice(keyLen - 1);
        const value = buf.readVarSlice();
        set(map, keyType, keyData, value);
        return true;
      }
      getKeyDatas(map, keyType) {
        const result = [];
        map.forEach((_v, k) => {
          if (this.isKeyType(k, [keyType])) {
            result.push(Buffer.from(k.substring(2), "hex"));
          }
        });
        return result;
      }
      isKeyType(hexKey, keyTypes) {
        const keyType = Buffer.from(hexKey.substring(0, 2), "hex").readUInt8(0);
        return keyTypes.some((k) => k == keyType);
      }
      setGlobal(keyType, value) {
        const key = new Key(keyType, Buffer.from([]));
        this.globalMap.set(key.toString(), value);
      }
      getGlobal(keyType) {
        return get(this.globalMap, keyType, b(), false);
      }
      getGlobalOptional(keyType) {
        return get(this.globalMap, keyType, b(), true);
      }
      setInput(index, keyType, keyData, value) {
        set(this.getMap(index, this.inputMaps), keyType, keyData, value);
      }
      getInput(index, keyType, keyData) {
        return get(this.inputMaps[index], keyType, keyData, false);
      }
      getInputOptional(index, keyType, keyData) {
        return get(this.inputMaps[index], keyType, keyData, true);
      }
      setOutput(index, keyType, keyData, value) {
        set(this.getMap(index, this.outputMaps), keyType, keyData, value);
      }
      getOutput(index, keyType, keyData) {
        return get(this.outputMaps[index], keyType, keyData, false);
      }
      getMap(index, maps) {
        if (maps[index]) {
          return maps[index];
        }
        return maps[index] = /* @__PURE__ */ new Map();
      }
      encodeBip32Derivation(masterFingerprint, path) {
        const buf = new BufferWriter();
        this.writeBip32Derivation(buf, masterFingerprint, path);
        return buf.buffer();
      }
      decodeBip32Derivation(buffer) {
        const buf = new BufferReader(buffer);
        return this.readBip32Derivation(buf);
      }
      writeBip32Derivation(buf, masterFingerprint, path) {
        buf.writeSlice(masterFingerprint);
        path.forEach((element) => {
          buf.writeUInt32(element);
        });
      }
      readBip32Derivation(buf) {
        const masterFingerprint = buf.readSlice(4);
        const path = [];
        while (buf.offset < buf.buffer.length) {
          path.push(buf.readUInt32());
        }
        return { masterFingerprint, path };
      }
      encodeTapBip32Derivation(hashes, masterFingerprint, path) {
        const buf = new BufferWriter();
        buf.writeVarInt(hashes.length);
        hashes.forEach((h) => {
          buf.writeSlice(h);
        });
        this.writeBip32Derivation(buf, masterFingerprint, path);
        return buf.buffer();
      }
      decodeTapBip32Derivation(buffer) {
        const buf = new BufferReader(buffer);
        const hashCount = buf.readVarInt();
        const hashes = [];
        for (let i = 0; i < hashCount; i++) {
          hashes.push(buf.readSlice(32));
        }
        const deriv = this.readBip32Derivation(buf);
        return { hashes, ...deriv };
      }
    };
    Key = class {
      keyType;
      keyData;
      constructor(keyType, keyData) {
        this.keyType = keyType;
        this.keyData = keyData;
      }
      toString() {
        const buf = new BufferWriter();
        this.toBuffer(buf);
        return buf.buffer().toString("hex");
      }
      serialize(buf) {
        buf.writeVarInt(1 + this.keyData.length);
        this.toBuffer(buf);
      }
      toBuffer(buf) {
        buf.writeUInt8(this.keyType);
        buf.writeSlice(this.keyData);
      }
    };
    KeyPair = class {
      key;
      value;
      constructor(key, value) {
        this.key = key;
        this.value = value;
      }
      serialize(buf) {
        this.key.serialize(buf);
        buf.writeVarSlice(this.value);
      }
    };
  }
});

// node_modules/@ledgerhq/hw-app-btc/lib-es/newops/psbtFinalizer.js
function finalize(psbt) {
  const inputCount = psbt.getGlobalInputCount();
  for (let i = 0; i < inputCount; i++) {
    const legacyPubkeys = psbt.getInputKeyDatas(i, psbtIn.PARTIAL_SIG);
    const taprootSig = psbt.getInputTapKeySig(i);
    if (legacyPubkeys.length == 0 && !taprootSig) {
      throw Error(`No signature for input ${i} present`);
    }
    if (legacyPubkeys.length > 0) {
      if (legacyPubkeys.length > 1) {
        throw Error(`Expected exactly one signature, got ${legacyPubkeys.length}`);
      }
      if (taprootSig) {
        throw Error("Both taproot and non-taproot signatures present.");
      }
      const isSegwitV0 = !!psbt.getInputWitnessUtxo(i);
      const redeemScript = psbt.getInputRedeemScript(i);
      const isWrappedSegwit = !!redeemScript;
      const signature = psbt.getInputPartialSig(i, legacyPubkeys[0]);
      if (!signature)
        throw new Error("Expected partial signature for input " + i);
      if (isSegwitV0) {
        const witnessBuf = new BufferWriter();
        witnessBuf.writeVarInt(2);
        witnessBuf.writeVarInt(signature.length);
        witnessBuf.writeSlice(signature);
        witnessBuf.writeVarInt(legacyPubkeys[0].length);
        witnessBuf.writeSlice(legacyPubkeys[0]);
        psbt.setInputFinalScriptwitness(i, witnessBuf.buffer());
        if (isWrappedSegwit) {
          if (!redeemScript || redeemScript.length == 0) {
            throw new Error("Expected non-empty redeemscript. Can't finalize intput " + i);
          }
          const scriptSigBuf = new BufferWriter();
          scriptSigBuf.writeUInt8(redeemScript.length);
          scriptSigBuf.writeSlice(redeemScript);
          psbt.setInputFinalScriptsig(i, scriptSigBuf.buffer());
        }
      } else {
        const scriptSig = new BufferWriter();
        writePush(scriptSig, signature);
        writePush(scriptSig, legacyPubkeys[0]);
        psbt.setInputFinalScriptsig(i, scriptSig.buffer());
      }
    } else {
      const signature = psbt.getInputTapKeySig(i);
      if (!signature) {
        throw Error("No taproot signature found");
      }
      if (signature.length != 64 && signature.length != 65) {
        throw Error("Unexpected length of schnorr signature.");
      }
      const witnessBuf = new BufferWriter();
      witnessBuf.writeVarInt(1);
      witnessBuf.writeVarSlice(signature);
      psbt.setInputFinalScriptwitness(i, witnessBuf.buffer());
    }
    clearFinalizedInput(psbt, i);
  }
}
function clearFinalizedInput(psbt, inputIndex) {
  const keyTypes = [
    psbtIn.BIP32_DERIVATION,
    psbtIn.PARTIAL_SIG,
    psbtIn.TAP_BIP32_DERIVATION,
    psbtIn.TAP_KEY_SIG
  ];
  const witnessUtxoAvailable = !!psbt.getInputWitnessUtxo(inputIndex);
  const nonWitnessUtxoAvailable = !!psbt.getInputNonWitnessUtxo(inputIndex);
  if (witnessUtxoAvailable && nonWitnessUtxoAvailable) {
    keyTypes.push(psbtIn.NON_WITNESS_UTXO);
  }
  psbt.deleteInputEntries(inputIndex, keyTypes);
}
function writePush(buf, data) {
  if (data.length <= 75) {
    buf.writeUInt8(data.length);
  } else if (data.length <= 256) {
    buf.writeUInt8(76);
    buf.writeUInt8(data.length);
  } else if (data.length <= 256 * 256) {
    buf.writeUInt8(77);
    const b2 = Buffer.alloc(2);
    b2.writeUInt16LE(data.length, 0);
    buf.writeSlice(b2);
  }
  buf.writeSlice(data);
}
var init_psbtFinalizer = __esm({
  "node_modules/@ledgerhq/hw-app-btc/lib-es/newops/psbtFinalizer.js"() {
    init_buffertools();
    init_psbtv2();
  }
});

// node_modules/@ledgerhq/hw-app-btc/lib-es/varint.js
function getVarint(data, offset) {
  if (data[offset] < 253) {
    return [data[offset], 1];
  }
  if (data[offset] === 253) {
    return [(data[offset + 2] << 8) + data[offset + 1], 3];
  }
  if (data[offset] === 254) {
    return [
      (data[offset + 4] << 24) + (data[offset + 3] << 16) + (data[offset + 2] << 8) + data[offset + 1],
      5
    ];
  }
  throw new Error("getVarint called with unexpected parameters");
}
function createVarint(value) {
  if (value < 253) {
    const buffer2 = Buffer.alloc(1);
    buffer2[0] = value;
    return buffer2;
  }
  if (value <= 65535) {
    const buffer2 = Buffer.alloc(3);
    buffer2[0] = 253;
    buffer2[1] = value & 255;
    buffer2[2] = value >> 8 & 255;
    return buffer2;
  }
  const buffer = Buffer.alloc(5);
  buffer[0] = 254;
  buffer[1] = value & 255;
  buffer[2] = value >> 8 & 255;
  buffer[3] = value >> 16 & 255;
  buffer[4] = value >> 24 & 255;
  return buffer;
}
var init_varint = __esm({
  "node_modules/@ledgerhq/hw-app-btc/lib-es/varint.js"() {
  }
});

// node_modules/@ledgerhq/hw-app-btc/lib-es/serializeTransaction.js
function serializeTransactionOutputs({ outputs }) {
  let outputBuffer = Buffer.alloc(0);
  if (typeof outputs !== "undefined") {
    outputBuffer = Buffer.concat([outputBuffer, createVarint(outputs.length)]);
    outputs.forEach((output) => {
      outputBuffer = Buffer.concat([
        outputBuffer,
        output.amount,
        createVarint(output.script.length),
        output.script
      ]);
    });
  }
  return outputBuffer;
}
function serializeTransaction(transaction, skipWitness, timestamp, additionals = []) {
  const isDecred = additionals.includes("decred");
  const isZcash = additionals.includes("zcash");
  const isBech32 = additionals.includes("bech32");
  let inputBuffer = Buffer.alloc(0);
  const useWitness = typeof transaction["witness"] != "undefined" && !skipWitness;
  transaction.inputs.forEach((input) => {
    inputBuffer = isDecred || isBech32 ? Buffer.concat([
      inputBuffer,
      input.prevout,
      Buffer.from([0]),
      //tree
      input.sequence
    ]) : Buffer.concat([
      inputBuffer,
      input.prevout,
      createVarint(input.script.length),
      input.script,
      input.sequence
    ]);
  });
  let outputBuffer = serializeTransactionOutputs(transaction);
  if (typeof transaction.outputs !== "undefined" && typeof transaction.locktime !== "undefined") {
    outputBuffer = Buffer.concat([
      outputBuffer,
      useWitness && transaction.witness || Buffer.alloc(0),
      transaction.locktime,
      transaction.nExpiryHeight || Buffer.alloc(0),
      transaction.extraData || Buffer.alloc(0)
    ]);
  }
  if (isZcash) {
    return Buffer.concat([
      transaction.version,
      transaction.nVersionGroupId || Buffer.alloc(0),
      transaction.consensusBranchId || Buffer.from([0, 0, 0, 0]),
      transaction.locktime || Buffer.from([0, 0, 0, 0]),
      transaction.nExpiryHeight || Buffer.from([0, 0, 0, 0]),
      useWitness ? Buffer.from("0001", "hex") : Buffer.alloc(0),
      createVarint(transaction.inputs.length),
      inputBuffer,
      outputBuffer
    ]);
  }
  return Buffer.concat([
    transaction.version,
    timestamp ? timestamp : Buffer.alloc(0),
    transaction.nVersionGroupId || Buffer.alloc(0),
    useWitness ? Buffer.from("0001", "hex") : Buffer.alloc(0),
    createVarint(transaction.inputs.length),
    inputBuffer,
    outputBuffer
  ]);
}
var init_serializeTransaction = __esm({
  "node_modules/@ledgerhq/hw-app-btc/lib-es/serializeTransaction.js"() {
    init_varint();
  }
});

// node_modules/@ledgerhq/hw-app-btc/lib-es/BtcNew.js
function pointCompress(point, compressed = true) {
  const p = secp256k1.ProjectivePoint.fromHex(point);
  return p.toRawBytes(compressed);
}
function descrTemplFrom(addressFormat) {
  if (addressFormat == "legacy")
    return "pkh(@0)";
  if (addressFormat == "p2sh")
    return "sh(wpkh(@0))";
  if (addressFormat == "bech32")
    return "wpkh(@0)";
  if (addressFormat == "bech32m")
    return "tr(@0)";
  throw new Error("Unsupported address format " + addressFormat);
}
function accountTypeFromArg(arg, psbt, masterFp) {
  if (arg.additionals.includes("bech32m"))
    return new p2tr(psbt, masterFp);
  if (arg.additionals.includes("bech32"))
    return new p2wpkh(psbt, masterFp);
  if (arg.segwit)
    return new p2wpkhWrapped(psbt, masterFp);
  return new p2pkh(psbt, masterFp);
}
function isPathNormal(path) {
  const pathElems = pathStringToArray(path);
  if (pathElems.length >= 3 && pathElems.length <= 5 && validSingleSigPurposePathPartsSet.has(pathElems[0]) && validCoinPathPartsSet.has(pathElems[1]) && hard(pathElems[2]) && change(pathElems[3]) && soft(pathElems[4])) {
    return true;
  }
  if (pathElems.length >= 4 && pathElems.length <= 6 && validMultiSigPurposePathPartsSet.has(pathElems[0]) && validCoinPathPartsSet.has(pathElems[1]) && hard(pathElems[2]) && hard(pathElems[3]) && change(pathElems[4]) && soft(pathElems[5])) {
    return true;
  }
  return false;
}
var import_bitcoinjs_lib4, BtcNew, H, VALID_COIN_TYPES, VALID_SINGLE_SIG_PURPOSES, VALID_MULTISIG_PURPOSES, hard, soft, change, validCoinPathPartsSet, validSingleSigPurposePathPartsSet, validMultiSigPurposePathPartsSet;
var init_BtcNew = __esm({
  "node_modules/@ledgerhq/hw-app-btc/lib-es/BtcNew.js"() {
    import_bitcoinjs_lib4 = __toESM(require_src3());
    init_secp256k1();
    init_bip32();
    init_buffertools();
    init_accounttype();
    init_policy();
    init_psbtExtractor();
    init_psbtFinalizer();
    init_psbtv2();
    init_serializeTransaction();
    BtcNew = class {
      client;
      constructor(client) {
        this.client = client;
      }
      /**
       * This is a new method that allow users to get an xpub at a standard path.
       * Standard paths are described at
       * https://github.com/LedgerHQ/app-bitcoin-new/blob/master/doc/bitcoin.md#description
       *
       * This boils down to paths (N=0 for Bitcoin, N=1 for Testnet):
       * M/44'/N'/x'/**
       * M/48'/N'/x'/y'/**
       * M/49'/N'/x'/**
       * M/84'/N'/x'/**
       * M/86'/N'/x'/**
       *
       * The method was added because of added security in the hardware app v2+. The
       * new hardware app will allow export of any xpub up to and including the
       * deepest hardened key of standard derivation paths, whereas the old app
       * would allow export of any key.
       *
       * This caused an issue for callers of this class, who only had
       * getWalletPublicKey() to call which means they have to constuct xpub
       * themselves:
       *
       * Suppose a user of this class wants to create an account xpub on a standard
       * path, M/44'/0'/Z'. The user must get the parent key fingerprint (see BIP32)
       * by requesting the parent key M/44'/0'. The new app won't allow that, because
       * it only allows exporting deepest level hardened path. So the options are to
       * allow requesting M/44'/0' from the app, or to add a new function
       * "getWalletXpub".
       *
       * We opted for adding a new function, which can greatly simplify client code.
       */
      async getWalletXpub({ path, xpubVersion }) {
        const pathElements = pathStringToArray(path);
        const xpub = await this.client.getExtendedPubkey(false, pathElements);
        const xpubComponents = getXpubComponents(xpub);
        if (xpubComponents.version != xpubVersion) {
          throw new Error(`Expected xpub version ${xpubVersion} doesn't match the xpub version from the device ${xpubComponents.version}`);
        }
        return xpub;
      }
      /**
       * This method returns a public key, a bitcoin address, and and a chaincode
       * for a specific derivation path.
       *
       * Limitation: If the path is not a leaf node of a standard path, the address
       * will be the empty string "", see this.getWalletAddress() for details.
       */
      async getWalletPublicKey(path, opts) {
        if (!isPathNormal(path)) {
          throw Error(`non-standard path: ${path}`);
        }
        const pathElements = pathStringToArray(path);
        const xpub = await this.client.getExtendedPubkey(false, pathElements);
        const display = opts?.verify ?? false;
        const address = await this.getWalletAddress(pathElements, descrTemplFrom(opts?.format ?? "legacy"), display);
        const components = getXpubComponents(xpub);
        const uncompressedPubkey = Buffer.from(pointCompress(components.pubkey, false));
        return {
          publicKey: uncompressedPubkey.toString("hex"),
          bitcoinAddress: address,
          chainCode: components.chaincode.toString("hex")
        };
      }
      /**
       * Get an address for the specified path.
       *
       * If display is true, we must get the address from the device, which would require
       * us to determine WalletPolicy. This requires two *extra* queries to the device, one
       * for the account xpub and one for master key fingerprint.
       *
       * If display is false we *could* generate the address ourselves, but chose to
       * get it from the device to save development time. However, it shouldn't take
       * too much time to implement local address generation.
       *
       * Moreover, if the path is not for a leaf, ie accountPath+/X/Y, there is no
       * way to get the address from the device. In this case we have to create it
       * ourselves, but we don't at this time, and instead return an empty ("") address.
       */
      async getWalletAddress(pathElements, descrTempl, display) {
        const accountPath = hardenedPathOf(pathElements);
        if (accountPath.length + 2 != pathElements.length) {
          return "";
        }
        const accountXpub = await this.client.getExtendedPubkey(false, accountPath);
        const masterFingerprint = await this.client.getMasterFingerprint();
        const policy = new WalletPolicy(descrTempl, createKey(masterFingerprint, accountPath, accountXpub));
        const changeAndIndex = pathElements.slice(-2, pathElements.length);
        return this.client.getWalletAddress(policy, Buffer.alloc(32, 0), changeAndIndex[0], changeAndIndex[1], display);
      }
      /**
       * Build and sign a transaction. See Btc.createPaymentTransaction for
       * details on how to use this method.
       *
       * This method will convert the legacy arguments, CreateTransactionArg, into
       * a psbt which is finally signed and finalized, and the extracted fully signed
       * transaction is returned.
       */
      async createPaymentTransaction(arg) {
        const inputCount = arg.inputs.length;
        if (inputCount == 0) {
          throw Error("No inputs");
        }
        const psbt = new PsbtV2();
        const masterFp = await this.client.getMasterFingerprint();
        const accountType = accountTypeFromArg(arg, psbt, masterFp);
        if (arg.lockTime != void 0) {
          psbt.setGlobalFallbackLocktime(arg.lockTime);
        }
        psbt.setGlobalInputCount(inputCount);
        psbt.setGlobalPsbtVersion(2);
        psbt.setGlobalTxVersion(2);
        let notifyCount = 0;
        const progress = () => {
          if (!arg.onDeviceStreaming)
            return;
          arg.onDeviceStreaming({
            total: 2 * inputCount,
            index: notifyCount,
            progress: ++notifyCount / (2 * inputCount)
          });
        };
        let accountXpub = "";
        let accountPath = [];
        for (let i = 0; i < inputCount; i++) {
          progress();
          const pathElems = pathStringToArray(arg.associatedKeysets[i]);
          if (accountXpub == "") {
            accountPath = pathElems.slice(0, -2);
            accountXpub = await this.client.getExtendedPubkey(false, accountPath);
          }
          await this.setInput(psbt, i, arg.inputs[i], pathElems, accountType, masterFp, arg.sigHashType);
        }
        const outputsConcat = Buffer.from(arg.outputScriptHex, "hex");
        const outputsBufferReader = new BufferReader(outputsConcat);
        const outputCount = outputsBufferReader.readVarInt();
        psbt.setGlobalOutputCount(outputCount);
        const changeData = await this.outputScriptAt(accountPath, accountType, arg.changePath);
        let changeFound = !changeData;
        for (let i = 0; i < outputCount; i++) {
          const amount = Number(outputsBufferReader.readUInt64());
          const outputScript = outputsBufferReader.readVarSlice();
          psbt.setOutputAmount(i, amount);
          psbt.setOutputScript(i, outputScript);
          const isChange = changeData && outputScript.equals(changeData?.cond.scriptPubKey);
          if (isChange) {
            changeFound = true;
            const changePath = pathStringToArray(arg.changePath);
            const pubkey = changeData.pubkey;
            accountType.setOwnOutput(i, changeData.cond, [pubkey], [changePath]);
          }
        }
        if (!changeFound) {
          throw new Error("Change script not found among outputs! " + changeData?.cond.scriptPubKey.toString("hex"));
        }
        const key = createKey(masterFp, accountPath, accountXpub);
        const p = new WalletPolicy(accountType.getDescriptorTemplate(), key);
        if (arg.onDeviceSignatureRequested)
          arg.onDeviceSignatureRequested();
        let firstSigned = false;
        const progressCallback = () => {
          if (!firstSigned) {
            firstSigned = true;
            arg.onDeviceSignatureGranted && arg.onDeviceSignatureGranted();
          }
          progress();
        };
        await this.signPsbt(psbt, p, progressCallback);
        finalize(psbt);
        const serializedTx = extract(psbt);
        return serializedTx.toString("hex");
      }
      /**
       * Signs an arbitrary hex-formatted message with the private key at
       * the provided derivation path according to the Bitcoin Signature format
       * and returns v, r, s.
       */
      async signMessage({ path, messageHex }) {
        const pathElements = pathStringToArray(path);
        const message = Buffer.from(messageHex, "hex");
        const sig = await this.client.signMessage(message, pathElements);
        const buf = Buffer.from(sig, "base64");
        const v = buf.readUInt8() - 27 - 4;
        const r = buf.slice(1, 33).toString("hex");
        const s = buf.slice(33, 65).toString("hex");
        return {
          v,
          r,
          s
        };
      }
      /**
       * Calculates an output script along with public key and possible redeemScript
       * from a path and accountType. The accountPath must be a prefix of path.
       *
       * @returns an object with output script (property "script"), redeemScript (if
       * wrapped p2wpkh), and pubkey at provided path. The values of these three
       * properties depend on the accountType used.
       */
      async outputScriptAt(accountPath, accountType, path) {
        if (!path)
          return void 0;
        const pathElems = pathStringToArray(path);
        for (let i = 0; i < accountPath.length; i++) {
          if (accountPath[i] != pathElems[i]) {
            throw new Error(`Path ${path} not in account ${pathArrayToString(accountPath)}`);
          }
        }
        const xpub = await this.client.getExtendedPubkey(false, pathElems);
        const pubkey = pubkeyFromXpub(xpub);
        const cond = accountType.spendingCondition([pubkey]);
        return { cond, pubkey };
      }
      /**
       * Adds relevant data about an input to the psbt. This includes sequence,
       * previous txid, output index, spent UTXO, redeem script for wrapped p2wpkh,
       * public key and its derivation path.
       */
      async setInput(psbt, i, input, pathElements, accountType, masterFP, sigHashType) {
        const inputTx = input[0];
        const spentOutputIndex = input[1];
        const redeemScript = input[2] ? Buffer.from(input[2], "hex") : void 0;
        const sequence = input[3];
        if (sequence != void 0) {
          psbt.setInputSequence(i, sequence);
        }
        if (sigHashType != void 0) {
          psbt.setInputSighashType(i, sigHashType);
        }
        const inputTxBuffer = serializeTransaction(inputTx, true);
        const inputTxid = import_bitcoinjs_lib4.crypto.hash256(inputTxBuffer);
        const xpubBase58 = await this.client.getExtendedPubkey(false, pathElements);
        const pubkey = pubkeyFromXpub(xpubBase58);
        if (!inputTx.outputs)
          throw Error("Missing outputs array in transaction to sign");
        const spentTxOutput = inputTx.outputs[spentOutputIndex];
        const spendCondition = {
          scriptPubKey: spentTxOutput.script,
          redeemScript
        };
        const spentOutput = { cond: spendCondition, amount: spentTxOutput.amount };
        accountType.setInput(i, inputTxBuffer, spentOutput, [pubkey], [pathElements]);
        psbt.setInputPreviousTxId(i, inputTxid);
        psbt.setInputOutputIndex(i, spentOutputIndex);
      }
      /**
       * This implements the "Signer" role of the BIP370 transaction signing
       * process.
       *
       * It ssks the hardware device to sign the a psbt using the specified wallet
       * policy. This method assumes BIP32 derived keys are used for all inputs, see
       * comment in-line. The signatures returned from the hardware device is added
       * to the appropriate input fields of the PSBT.
       */
      async signPsbt(psbt, walletPolicy, progressCallback) {
        const sigs = await this.client.signPsbt(psbt, walletPolicy, Buffer.alloc(32, 0), progressCallback);
        sigs.forEach((v, k) => {
          const pubkeys = psbt.getInputKeyDatas(k, psbtIn.BIP32_DERIVATION);
          let pubkey;
          if (pubkeys.length != 1) {
            pubkey = psbt.getInputKeyDatas(k, psbtIn.TAP_BIP32_DERIVATION);
            if (pubkey.length == 0) {
              throw Error(`Missing pubkey derivation for input ${k}`);
            }
            psbt.setInputTapKeySig(k, v);
          } else {
            pubkey = pubkeys[0];
            psbt.setInputPartialSig(k, pubkey, v);
          }
        });
      }
    };
    H = 2147483648;
    VALID_COIN_TYPES = [
      0,
      // Bitcoin
      1,
      // Bitcoin (Testnet)
      88
      // Qtum
    ];
    VALID_SINGLE_SIG_PURPOSES = [
      44,
      // BIP44 - https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki
      49,
      // BIP49 - https://github.com/bitcoin/bips/blob/master/bip-0049.mediawiki
      84,
      // BIP84 - https://github.com/bitcoin/bips/blob/master/bip-0084.mediawiki
      86
      // BIP86 - https://github.com/bitcoin/bips/blob/master/bip-0086.mediawiki
    ];
    VALID_MULTISIG_PURPOSES = [
      48
      // BIP48 - https://github.com/bitcoin/bips/blob/master/bip-0048.mediawiki
    ];
    hard = (n) => n >= H;
    soft = (n) => n === void 0 || n < H;
    change = (n) => n === void 0 || n === 0 || n === 1;
    validCoinPathPartsSet = new Set(VALID_COIN_TYPES.map((t) => t + H));
    validSingleSigPurposePathPartsSet = new Set(VALID_SINGLE_SIG_PURPOSES.map((t) => t + H));
    validMultiSigPurposePathPartsSet = new Set(VALID_MULTISIG_PURPOSES.map((t) => t + H));
  }
});

// node_modules/@ledgerhq/hw-app-btc/lib-es/getWalletPublicKey.js
async function getWalletPublicKey(transport, options) {
  const { path, verify, format } = {
    verify: false,
    format: "legacy",
    ...options
  };
  if (!(format in addressFormatMap)) {
    throw new Error("btc.getWalletPublicKey invalid format=" + format);
  }
  const buffer = bip32asBuffer(path);
  const p1 = verify ? 1 : 0;
  const p2 = addressFormatMap[format];
  const response = await transport.send(224, 64, p1, p2, buffer);
  const publicKeyLength = response[0];
  const addressLength = response[1 + publicKeyLength];
  const publicKey = response.slice(1, 1 + publicKeyLength).toString("hex");
  const bitcoinAddress = response.slice(1 + publicKeyLength + 1, 1 + publicKeyLength + 1 + addressLength).toString("ascii");
  const chainCode = response.slice(1 + publicKeyLength + 1 + addressLength, 1 + publicKeyLength + 1 + addressLength + 32).toString("hex");
  return {
    publicKey,
    bitcoinAddress,
    chainCode
  };
}
var addressFormatMap;
var init_getWalletPublicKey = __esm({
  "node_modules/@ledgerhq/hw-app-btc/lib-es/getWalletPublicKey.js"() {
    init_bip32();
    addressFormatMap = {
      legacy: 0,
      p2sh: 1,
      bech32: 2,
      cashaddr: 3
    };
  }
});

// node_modules/invariant/browser.js
var require_browser5 = __commonJS({
  "node_modules/invariant/browser.js"(exports2, module2) {
    "use strict";
    var invariant3 = function(condition, format, a, b2, c, d, e, f) {
      if (false) {
        if (format === void 0) {
          throw new Error("invariant requires an error message argument");
        }
      }
      if (!condition) {
        var error;
        if (format === void 0) {
          error = new Error(
            "Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings."
          );
        } else {
          var args = [a, b2, c, d, e, f];
          var argIndex = 0;
          error = new Error(
            format.replace(/%s/g, function() {
              return args[argIndex++];
            })
          );
          error.name = "Invariant Violation";
        }
        error.framesToPop = 1;
        throw error;
      }
    };
    module2.exports = invariant3;
  }
});

// node_modules/@ledgerhq/hw-app-btc/lib-es/getTrustedInput.js
async function getTrustedInputRaw(transport, transactionData, indexLookup) {
  let data;
  let firstRound = false;
  if (typeof indexLookup === "number") {
    firstRound = true;
    const prefix = Buffer.alloc(4);
    prefix.writeUInt32BE(indexLookup, 0);
    data = Buffer.concat([prefix, transactionData], transactionData.length + 4);
  } else {
    data = transactionData;
  }
  const trustedInput = await transport.send(224, 66, firstRound ? 0 : 128, 0, data);
  const res = trustedInput.slice(0, trustedInput.length - 2).toString("hex");
  return res;
}
async function getTrustedInput(transport, indexLookup, transaction, additionals = []) {
  const { inputs, outputs, locktime, nExpiryHeight, extraData } = transaction;
  if (!outputs || !locktime) {
    throw new Error("getTrustedInput: locktime & outputs is expected");
  }
  const isDecred = additionals.includes("decred");
  const processScriptBlocks = async (script, sequence) => {
    const seq = sequence || Buffer.alloc(0);
    const scriptBlocks = [];
    let offset = 0;
    while (offset !== script.length) {
      const blockSize = script.length - offset > MAX_SCRIPT_BLOCK ? MAX_SCRIPT_BLOCK : script.length - offset;
      if (offset + blockSize !== script.length) {
        scriptBlocks.push(script.slice(offset, offset + blockSize));
      } else {
        scriptBlocks.push(Buffer.concat([script.slice(offset, offset + blockSize), seq]));
      }
      offset += blockSize;
    }
    if (script.length === 0) {
      scriptBlocks.push(seq);
    }
    let res2;
    for (const scriptBlock of scriptBlocks) {
      res2 = await getTrustedInputRaw(transport, scriptBlock);
    }
    return res2;
  };
  const processWholeScriptBlock = (block) => getTrustedInputRaw(transport, block);
  const isZcash = additionals.includes("zcash");
  const zCashConsensusBranchId = transaction.consensusBranchId || Buffer.alloc(0);
  await getTrustedInputRaw(transport, Buffer.concat([
    transaction.version,
    transaction.timestamp || Buffer.alloc(0),
    transaction.nVersionGroupId || Buffer.alloc(0),
    isZcash ? zCashConsensusBranchId : Buffer.alloc(0),
    createVarint(inputs.length)
  ]), indexLookup);
  for (const input of inputs) {
    const treeField = isDecred ? input.tree || Buffer.from([0]) : Buffer.alloc(0);
    const data = Buffer.concat([input.prevout, treeField, createVarint(input.script.length)]);
    await getTrustedInputRaw(transport, data);
    await (isDecred ? processWholeScriptBlock(Buffer.concat([input.script, input.sequence])) : processScriptBlocks(input.script, input.sequence));
  }
  await getTrustedInputRaw(transport, createVarint(outputs.length));
  for (const output of outputs) {
    const data = Buffer.concat([
      output.amount,
      isDecred ? Buffer.from([0, 0]) : Buffer.alloc(0),
      //Version script
      createVarint(output.script.length),
      output.script
    ]);
    await getTrustedInputRaw(transport, data);
  }
  if (isZcash) {
    const data = Buffer.concat([
      createVarint(transaction.sapling?.vSpendsSapling.length || 0),
      createVarint(transaction.sapling?.vOutputSapling.length || 0),
      createVarint(transaction.orchard?.vActions.length || 0)
    ]);
    await getTrustedInputRaw(transport, data);
    if (transaction.sapling) {
      await sendSapling(transport, transaction.sapling);
    }
    if (transaction.orchard) {
      await sendOrchard(transport, transaction.orchard);
    }
  }
  const endData = [];
  if (nExpiryHeight && nExpiryHeight.length > 0) {
    endData.push(nExpiryHeight);
  }
  if (extraData && extraData.length > 0) {
    endData.push(extraData);
  }
  let extraPart;
  if (endData.length) {
    const data = Buffer.concat(endData);
    extraPart = isDecred ? data : Buffer.concat([createVarint(data.length), data]);
  }
  const res = await processScriptBlocks(Buffer.concat([locktime, extraPart || Buffer.alloc(0)]));
  (0, import_invariant.default)(res, "missing result in processScriptBlocks");
  return res;
}
async function sendSapling(transport, sapling) {
  const saplingData = Buffer.concat([sapling.valueBalanceSapling, sapling.anchorSapling]);
  await getTrustedInputRaw(transport, saplingData);
  for (const spend of sapling.vSpendsSapling) {
    const spendData = Buffer.concat([spend.cv, spend.nullifier, spend.rk]);
    await getTrustedInputRaw(transport, spendData);
  }
  for (const output of sapling.vOutputSapling) {
    const outputData = Buffer.concat([
      output.cmu,
      output.ephemeralKey,
      output.encCiphertext.slice(0, 52)
      // https://zips.z.cash/zip-0244
    ]);
    await getTrustedInputRaw(transport, outputData);
  }
  for (const output of sapling.vOutputSapling) {
    for (let i = 0; i < 4; i++) {
      const start = 52 + i * 128;
      const end = start + 128;
      const outputData = Buffer.concat([output.encCiphertext.slice(start, end)]);
      await getTrustedInputRaw(transport, outputData);
    }
  }
  for (const output of sapling.vOutputSapling) {
    const outputData = Buffer.concat([
      output.cv,
      output.encCiphertext.slice(564, zCashEncCiphertextSize),
      // https://zips.z.cash/zip-0244
      output.outCiphertext
    ]);
    await getTrustedInputRaw(transport, outputData);
  }
}
async function sendOrchard(transport, orchard) {
  for (const action of orchard.vActions) {
    const actionData = Buffer.concat([
      action.nullifier,
      action.cmx,
      action.ephemeralKey,
      action.encCiphertext.slice(0, 52)
      // https://zips.z.cash/zip-0244
    ]);
    await getTrustedInputRaw(transport, actionData);
  }
  for (const action of orchard.vActions) {
    for (let i = 0; i < 4; i++) {
      const start = 52 + i * 128;
      const end = start + 128;
      const outputData = Buffer.concat([action.encCiphertext.slice(start, end)]);
      await getTrustedInputRaw(transport, outputData);
    }
  }
  for (const action of orchard.vActions) {
    const actionData = Buffer.concat([
      action.cv,
      action.rk,
      action.encCiphertext.slice(564, zCashEncCiphertextSize),
      // https://zips.z.cash/zip-0244
      action.outCiphertext
    ]);
    await getTrustedInputRaw(transport, actionData);
  }
  const orchardData = Buffer.concat([orchard.flags, orchard.valueBalance, orchard.anchor]);
  await getTrustedInputRaw(transport, orchardData);
}
var import_invariant;
var init_getTrustedInput = __esm({
  "node_modules/@ledgerhq/hw-app-btc/lib-es/getTrustedInput.js"() {
    import_invariant = __toESM(require_browser5());
    init_constants();
    init_varint();
  }
});

// node_modules/@ledgerhq/hw-app-btc/lib-es/startUntrustedHashTransactionInput.js
function startUntrustedHashTransactionInputRaw(transport, newTransaction, firstRound, transactionData, bip143 = false, overwinter = false, additionals = []) {
  const p2 = additionals.includes("cashaddr") ? 3 : bip143 ? additionals.includes("sapling") ? 5 : overwinter ? 4 : 2 : 0;
  return transport.send(224, 68, firstRound ? 0 : 128, newTransaction ? p2 : 128, transactionData);
}
async function startUntrustedHashTransactionInput(transport, newTransaction, transaction, inputs, bip143 = false, overwinter = false, additionals = [], useTrustedInputForSegwit = false) {
  const isZcash = additionals.includes("zcash");
  const zCashConsensusBranchId = transaction.consensusBranchId || Buffer.alloc(0);
  let data = Buffer.concat([
    transaction.version,
    transaction.timestamp || Buffer.alloc(0),
    transaction.nVersionGroupId || Buffer.alloc(0),
    isZcash ? zCashConsensusBranchId : Buffer.alloc(0),
    createVarint(transaction.inputs.length)
  ]);
  await startUntrustedHashTransactionInputRaw(transport, newTransaction, true, data, bip143, overwinter, additionals);
  let i = 0;
  const isDecred = additionals.includes("decred");
  for (const input of transaction.inputs) {
    let prefix;
    const inputValue = inputs[i].value;
    if (bip143) {
      if (useTrustedInputForSegwit && inputs[i].trustedInput) {
        prefix = Buffer.from([1, inputValue.length]);
      } else {
        prefix = Buffer.from([2]);
      }
    } else {
      if (inputs[i].trustedInput) {
        prefix = Buffer.from([1, inputs[i].value.length]);
      } else {
        prefix = Buffer.from([0]);
      }
    }
    data = Buffer.concat([
      prefix,
      inputValue,
      isDecred ? Buffer.from([0]) : Buffer.alloc(0),
      createVarint(input.script.length)
    ]);
    await startUntrustedHashTransactionInputRaw(transport, newTransaction, false, data, bip143, overwinter, additionals);
    const scriptBlocks = [];
    let offset = 0;
    if (input.script.length === 0) {
      scriptBlocks.push(input.sequence);
    } else {
      while (offset !== input.script.length) {
        const blockSize = input.script.length - offset > MAX_SCRIPT_BLOCK ? MAX_SCRIPT_BLOCK : input.script.length - offset;
        if (offset + blockSize !== input.script.length) {
          scriptBlocks.push(input.script.slice(offset, offset + blockSize));
        } else {
          scriptBlocks.push(Buffer.concat([input.script.slice(offset, offset + blockSize), input.sequence]));
        }
        offset += blockSize;
      }
    }
    for (const scriptBlock of scriptBlocks) {
      await startUntrustedHashTransactionInputRaw(transport, newTransaction, false, scriptBlock, bip143, overwinter, additionals);
    }
    i++;
  }
}
var init_startUntrustedHashTransactionInput = __esm({
  "node_modules/@ledgerhq/hw-app-btc/lib-es/startUntrustedHashTransactionInput.js"() {
    init_varint();
    init_constants();
  }
});

// node_modules/@ledgerhq/hw-app-btc/lib-es/getTrustedInputBIP143.js
function getTrustedInputBIP143(transport, indexLookup, transaction, additionals = []) {
  if (!transaction) {
    throw new Error("getTrustedInputBIP143: missing tx");
  }
  const isDecred = additionals.includes("decred");
  if (isDecred) {
    throw new Error("Decred does not implement BIP143");
  }
  let hash = Buffer.from(sha2562(sha2562(serializeTransaction(transaction, true))));
  const data = Buffer.alloc(4);
  data.writeUInt32LE(indexLookup, 0);
  const { outputs, locktime } = transaction;
  if (!outputs || !locktime) {
    throw new Error("getTrustedInputBIP143: locktime & outputs is expected");
  }
  if (!outputs[indexLookup]) {
    throw new Error("getTrustedInputBIP143: wrong index");
  }
  hash = Buffer.concat([hash, data, outputs[indexLookup].amount]);
  return hash.toString("hex");
}
var init_getTrustedInputBIP143 = __esm({
  "node_modules/@ledgerhq/hw-app-btc/lib-es/getTrustedInputBIP143.js"() {
    init_sha256();
    init_serializeTransaction();
  }
});

// node_modules/@ledgerhq/hw-app-btc/lib-es/compressPublicKey.js
function compressPublicKey(publicKey) {
  const prefix = (publicKey[64] & 1) !== 0 ? 3 : 2;
  const prefixBuffer = Buffer.alloc(1);
  prefixBuffer[0] = prefix;
  return Buffer.concat([prefixBuffer, publicKey.slice(1, 1 + 32)]);
}
var init_compressPublicKey = __esm({
  "node_modules/@ledgerhq/hw-app-btc/lib-es/compressPublicKey.js"() {
  }
});

// node_modules/@ledgerhq/hw-app-btc/lib-es/signTransaction.js
function signTransaction(transport, path, lockTime, sigHashType, expiryHeight, additionals = []) {
  const isDecred = additionals.includes("decred");
  const pathsBuffer = bip32asBuffer(path);
  const lockTimeBuffer = Buffer.alloc(4);
  lockTimeBuffer.writeUInt32BE(lockTime, 0);
  let buffer = isDecred ? Buffer.concat([
    pathsBuffer,
    lockTimeBuffer,
    expiryHeight || Buffer.from([0, 0, 0, 0]),
    Buffer.from([sigHashType])
  ]) : Buffer.concat([pathsBuffer, Buffer.from([0]), lockTimeBuffer, Buffer.from([sigHashType])]);
  if (expiryHeight && !isDecred) {
    buffer = Buffer.concat([buffer, expiryHeight]);
  }
  return transport.send(224, 72, 0, 0, buffer).then((result) => {
    if (result.length > 0) {
      result[0] = 48;
      return result.slice(0, result.length - 2);
    }
    return result;
  });
}
var init_signTransaction = __esm({
  "node_modules/@ledgerhq/hw-app-btc/lib-es/signTransaction.js"() {
    init_bip32();
  }
});

// node_modules/@ledgerhq/hw-app-btc/lib-es/finalizeInput.js
function provideOutputFullChangePath(transport, path) {
  const buffer = bip32asBuffer(path);
  return transport.send(224, 74, 255, 0, buffer);
}
async function hashOutputFull(transport, outputScript, additionals = []) {
  let offset = 0;
  const p1 = Number(128);
  const isDecred = additionals.includes("decred");
  if (isDecred) {
    return transport.send(224, 74, p1, 0, outputScript);
  }
  while (offset < outputScript.length) {
    const blockSize = offset + MAX_SCRIPT_BLOCK >= outputScript.length ? outputScript.length - offset : MAX_SCRIPT_BLOCK;
    const p12 = offset + blockSize === outputScript.length ? 128 : 0;
    const data = outputScript.slice(offset, offset + blockSize);
    await transport.send(224, 74, p12, 0, data);
    offset += blockSize;
  }
}
var init_finalizeInput = __esm({
  "node_modules/@ledgerhq/hw-app-btc/lib-es/finalizeInput.js"() {
    init_bip32();
    init_constants();
  }
});

// node_modules/@ledgerhq/hw-app-btc/lib-es/getAppAndVersion.js
var import_invariant2, getAppAndVersion, checkIsBtcLegacy;
var init_getAppAndVersion = __esm({
  "node_modules/@ledgerhq/hw-app-btc/lib-es/getAppAndVersion.js"() {
    import_invariant2 = __toESM(require_browser5());
    getAppAndVersion = async (transport) => {
      const r = await transport.send(176, 1, 0, 0);
      let i = 0;
      const format = r[i++];
      (0, import_invariant2.default)(format === 1, "getAppAndVersion: format not supported");
      const nameLength = r[i++];
      const name = r.slice(i, i += nameLength).toString("ascii");
      const versionLength = r[i++];
      const version = r.slice(i, i += versionLength).toString("ascii");
      const flagLength = r[i++];
      const flags = r.slice(i, i += flagLength);
      return {
        name,
        version,
        flags
      };
    };
    checkIsBtcLegacy = async (transport) => {
      try {
        await transport.send(224, 196, 0, 0);
      } catch (e) {
        return false;
      }
      return true;
    };
  }
});

// node_modules/@ledgerhq/hw-app-btc/lib-es/shouldUseTrustedInputForSegwit.js
function shouldUseTrustedInputForSegwit({ version, name }) {
  if (name === "Decred")
    return false;
  if (name === "Exchange")
    return true;
  return import_semver2.default.gte(version, "1.4.0");
}
var import_semver2;
var init_shouldUseTrustedInputForSegwit = __esm({
  "node_modules/@ledgerhq/hw-app-btc/lib-es/shouldUseTrustedInputForSegwit.js"() {
    import_semver2 = __toESM(require_semver2());
  }
});

// node_modules/@ledgerhq/hw-app-btc/lib-es/createTransaction.js
async function createTransaction(transport, arg) {
  const signTx = { ...defaultsSignTransaction, ...arg };
  const { inputs, associatedKeysets, blockHeight, changePath, outputScriptHex, lockTime, sigHashType, segwit, additionals, expiryHeight, onDeviceStreaming, onDeviceSignatureGranted, onDeviceSignatureRequested } = signTx;
  let useTrustedInputForSegwit = signTx.useTrustedInputForSegwit;
  if (useTrustedInputForSegwit === void 0) {
    try {
      const a = await getAppAndVersion(transport);
      useTrustedInputForSegwit = shouldUseTrustedInputForSegwit(a);
    } catch (e) {
      if (e.statusCode === 27904) {
        useTrustedInputForSegwit = false;
      } else {
        throw e;
      }
    }
  }
  const notify = (loop, i) => {
    const { length } = inputs;
    if (length < 3)
      return;
    const index = length * loop + i;
    const total = 2 * length;
    const progress = index / total;
    onDeviceStreaming({
      progress,
      total,
      index
    });
  };
  const isDecred = additionals.includes("decred");
  const isZcash = additionals.includes("zcash");
  const sapling = additionals.includes("sapling");
  const bech32 = segwit && additionals.includes("bech32");
  const useBip143 = segwit || !!additionals && (additionals.includes("abc") || additionals.includes("gold") || additionals.includes("bip143")) || !!expiryHeight && !isDecred;
  const lockTimeBuffer = Buffer.alloc(4);
  lockTimeBuffer.writeUInt32LE(lockTime, 0);
  const nullScript = Buffer.alloc(0);
  const nullPrevout = Buffer.alloc(0);
  const { defaultVersion } = getDefaultVersions({
    isZcash,
    sapling,
    isDecred,
    expiryHeight
  });
  const trustedInputs = [];
  const regularOutputs = [];
  const signatures = [];
  const publicKeys = [];
  let firstRun = true;
  const resuming = false;
  const targetTransaction = {
    inputs: [],
    version: defaultVersion,
    timestamp: Buffer.alloc(0)
  };
  const getTrustedInputCall = useBip143 && !useTrustedInputForSegwit ? getTrustedInputBIP143 : getTrustedInput;
  const outputScript = Buffer.from(outputScriptHex, "hex");
  notify(0, 0);
  for (const input of inputs) {
    if (!resuming) {
      if (isZcash) {
        input[0].consensusBranchId = getZcashBranchId(input[4]);
      }
      const trustedInput = await getTrustedInputCall(transport, input[1], input[0], additionals);
      log("hw", "got trustedInput=" + trustedInput);
      const sequence = Buffer.alloc(4);
      sequence.writeUInt32LE(input.length >= 4 && typeof input[3] === "number" ? input[3] : DEFAULT_SEQUENCE, 0);
      trustedInputs.push({
        trustedInput: true,
        value: Buffer.from(trustedInput, "hex"),
        sequence
      });
    }
    const { outputs } = input[0];
    const index = input[1];
    if (outputs && index <= outputs.length - 1) {
      regularOutputs.push(outputs[index]);
    }
    if (expiryHeight && !isDecred) {
      targetTransaction.nVersionGroupId = Buffer.from(
        // nVersionGroupId is 0x26A7270A for zcash NU5 upgrade
        // refer to https://github.com/zcash/zcash/blob/master/src/primitives/transaction.h
        isZcash ? [10, 39, 167, 38] : sapling ? [133, 32, 47, 137] : [112, 130, 196, 3]
      );
      targetTransaction.nExpiryHeight = expiryHeight;
      targetTransaction.extraData = Buffer.from(sapling ? [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] : [0]);
    } else if (isDecred) {
      targetTransaction.nExpiryHeight = expiryHeight;
    }
  }
  targetTransaction.inputs = inputs.map((input, idx) => {
    const sequence = Buffer.alloc(4);
    sequence.writeUInt32LE(input.length >= 4 && typeof input[3] === "number" ? input[3] : DEFAULT_SEQUENCE, 0);
    return {
      script: isZcash ? regularOutputs[idx].script : nullScript,
      prevout: nullPrevout,
      sequence
    };
  });
  if (!resuming) {
    const result2 = [];
    for (let i = 0; i < inputs.length; i++) {
      const r = await getWalletPublicKey(transport, {
        path: associatedKeysets[i]
      });
      notify(0, i + 1);
      result2.push(r);
    }
    for (let i = 0; i < result2.length; i++) {
      publicKeys.push(compressPublicKey(Buffer.from(result2[i].publicKey, "hex")));
    }
  }
  onDeviceSignatureRequested();
  targetTransaction.consensusBranchId = getZcashBranchId(blockHeight);
  if (useBip143) {
    await startUntrustedHashTransactionInput(transport, true, targetTransaction, trustedInputs, true, !!expiryHeight, additionals, useTrustedInputForSegwit);
    if (!resuming && changePath) {
      await provideOutputFullChangePath(transport, changePath);
    }
    await hashOutputFull(transport, outputScript);
  }
  if (!!expiryHeight && !isDecred) {
    await signTransaction(transport, "", lockTime, SIGHASH_ALL, expiryHeight);
  }
  for (let i = 0; i < inputs.length; i++) {
    const input = inputs[i];
    const script = inputs[i].length >= 3 && typeof input[2] === "string" ? Buffer.from(input[2], "hex") : !segwit ? regularOutputs[i].script : Buffer.concat([
      Buffer.from([OP_DUP, OP_HASH160, HASH_SIZE]),
      hashPublicKey(publicKeys[i]),
      Buffer.from([OP_EQUALVERIFY, OP_CHECKSIG])
    ]);
    const pseudoTX = Object.assign({}, targetTransaction);
    const pseudoTrustedInputs = useBip143 ? [trustedInputs[i]] : trustedInputs;
    if (useBip143) {
      pseudoTX.inputs = [{ ...pseudoTX.inputs[i], script }];
    } else {
      pseudoTX.inputs[i].script = script;
    }
    await startUntrustedHashTransactionInput(transport, !useBip143 && firstRun, pseudoTX, pseudoTrustedInputs, useBip143, !!expiryHeight && !isDecred, additionals, useTrustedInputForSegwit);
    if (!useBip143) {
      if (!resuming && changePath) {
        await provideOutputFullChangePath(transport, changePath);
      }
      await hashOutputFull(transport, outputScript, additionals);
    }
    if (firstRun) {
      onDeviceSignatureGranted();
      notify(1, 0);
    }
    const signature = await signTransaction(transport, associatedKeysets[i], lockTime, sigHashType, expiryHeight, additionals);
    notify(1, i + 1);
    signatures.push(signature);
    targetTransaction.inputs[i].script = nullScript;
    if (firstRun) {
      firstRun = false;
    }
  }
  targetTransaction.version = defaultVersion;
  targetTransaction.consensusBranchId = getZcashBranchId(blockHeight);
  for (let i = 0; i < inputs.length; i++) {
    if (segwit) {
      targetTransaction.witness = Buffer.alloc(0);
      if (!bech32) {
        targetTransaction.inputs[i].script = Buffer.concat([
          Buffer.from("160014", "hex"),
          hashPublicKey(publicKeys[i])
        ]);
      }
    } else {
      const signatureSize = Buffer.alloc(1);
      const keySize = Buffer.alloc(1);
      signatureSize[0] = signatures[i].length;
      keySize[0] = publicKeys[i].length;
      targetTransaction.inputs[i].script = Buffer.concat([
        signatureSize,
        signatures[i],
        keySize,
        publicKeys[i]
      ]);
    }
    const offset = useBip143 && !useTrustedInputForSegwit ? 0 : 4;
    targetTransaction.inputs[i].prevout = trustedInputs[i].value.slice(offset, offset + 36);
  }
  targetTransaction.locktime = lockTimeBuffer;
  let result = Buffer.concat([
    serializeTransaction(targetTransaction, false, targetTransaction.timestamp, additionals),
    outputScript
  ]);
  if (segwit && !isDecred) {
    let witness = Buffer.alloc(0);
    for (let i = 0; i < inputs.length; i++) {
      const tmpScriptData = Buffer.concat([
        Buffer.from("02", "hex"),
        Buffer.from([signatures[i].length]),
        signatures[i],
        Buffer.from([publicKeys[i].length]),
        publicKeys[i]
      ]);
      witness = Buffer.concat([witness, tmpScriptData]);
    }
    result = Buffer.concat([result, witness]);
  }
  if (!isZcash) {
    result = Buffer.concat([result, lockTimeBuffer]);
    if (expiryHeight) {
      result = Buffer.concat([
        result,
        targetTransaction.nExpiryHeight || Buffer.alloc(0),
        targetTransaction.extraData || Buffer.alloc(0)
      ]);
    }
  }
  if (isDecred) {
    let decredWitness = Buffer.from([targetTransaction.inputs.length]);
    inputs.forEach((input, inputIndex) => {
      decredWitness = Buffer.concat([
        decredWitness,
        Buffer.from([0, 0, 0, 0, 0, 0, 0, 0]),
        Buffer.from([0, 0, 0, 0]),
        //Block height
        Buffer.from([255, 255, 255, 255]),
        //Block index
        Buffer.from([targetTransaction.inputs[inputIndex].script.length]),
        targetTransaction.inputs[inputIndex].script
      ]);
    });
    result = Buffer.concat([result, decredWitness]);
  }
  if (isZcash) {
    result = Buffer.concat([result, Buffer.from([0, 0, 0])]);
  }
  return result.toString("hex");
}
var defaultsSignTransaction, getZcashBranchId, getDefaultVersions;
var init_createTransaction = __esm({
  "node_modules/@ledgerhq/hw-app-btc/lib-es/createTransaction.js"() {
    init_lib_es2();
    init_hashPublicKey();
    init_getWalletPublicKey();
    init_getTrustedInput();
    init_startUntrustedHashTransactionInput();
    init_serializeTransaction();
    init_getTrustedInputBIP143();
    init_compressPublicKey();
    init_signTransaction();
    init_finalizeInput();
    init_getAppAndVersion();
    init_constants();
    init_shouldUseTrustedInputForSegwit();
    defaultsSignTransaction = {
      lockTime: DEFAULT_LOCKTIME,
      sigHashType: SIGHASH_ALL,
      segwit: false,
      additionals: [],
      onDeviceStreaming: (_e) => {
      },
      onDeviceSignatureGranted: () => {
      },
      onDeviceSignatureRequested: () => {
      }
    };
    getZcashBranchId = (blockHeight) => {
      const branchId = Buffer.alloc(4);
      if (!blockHeight || blockHeight >= ZCASH_ACTIVATION_HEIGHTS.NU6_1) {
        branchId.writeUInt32LE(1307332080, 0);
      } else if (blockHeight >= ZCASH_ACTIVATION_HEIGHTS.NU6) {
        branchId.writeUInt32LE(3370586197, 0);
      } else if (blockHeight >= ZCASH_ACTIVATION_HEIGHTS.NU5) {
        branchId.writeUInt32LE(3268858036, 0);
      } else if (blockHeight >= ZCASH_ACTIVATION_HEIGHTS.CANOPY) {
        branchId.writeUInt32LE(3925833126, 0);
      } else if (blockHeight >= ZCASH_ACTIVATION_HEIGHTS.HEARTWOOD) {
        branchId.writeUInt32LE(4122551051, 0);
      } else if (blockHeight >= ZCASH_ACTIVATION_HEIGHTS.BLOSSOM) {
        branchId.writeUInt32LE(733220448, 0);
      } else if (blockHeight >= ZCASH_ACTIVATION_HEIGHTS.SAPLING) {
        branchId.writeUInt32LE(1991772603, 0);
      } else {
        branchId.writeUInt32LE(1537743641, 0);
      }
      return branchId;
    };
    getDefaultVersions = ({ isZcash, sapling, isDecred, expiryHeight }) => {
      const defaultVersion = Buffer.alloc(4);
      if (!!expiryHeight && !isDecred) {
        if (isZcash) {
          defaultVersion.writeUInt32LE(2147483653, 0);
        } else if (sapling) {
          defaultVersion.writeUInt32LE(2147483652, 0);
        } else {
          defaultVersion.writeUInt32LE(2147483651, 0);
        }
      } else {
        defaultVersion.writeUInt32LE(1, 0);
      }
      return { defaultVersion };
    };
  }
});

// node_modules/@ledgerhq/hw-app-btc/lib-es/signMessage.js
async function signMessage(transport, { path, messageHex }) {
  const paths = import_bip32_path2.default.fromString(path).toPathArray();
  const message = Buffer.from(messageHex, "hex");
  let offset = 0;
  while (offset !== message.length) {
    const maxChunkSize = offset === 0 ? MAX_SCRIPT_BLOCK - 1 - paths.length * 4 - 4 : MAX_SCRIPT_BLOCK;
    const chunkSize = offset + maxChunkSize > message.length ? message.length - offset : maxChunkSize;
    const buffer = Buffer.alloc(offset === 0 ? 1 + paths.length * 4 + 2 + chunkSize : chunkSize);
    if (offset === 0) {
      buffer[0] = paths.length;
      paths.forEach((element, index) => {
        buffer.writeUInt32BE(element, 1 + 4 * index);
      });
      buffer.writeUInt16BE(message.length, 1 + 4 * paths.length);
      message.copy(buffer, 1 + 4 * paths.length + 2, offset, offset + chunkSize);
    } else {
      message.copy(buffer, 0, offset, offset + chunkSize);
    }
    await transport.send(224, 78, 0, offset === 0 ? 1 : 128, buffer);
    offset += chunkSize;
  }
  const res = await transport.send(224, 78, 128, 0, Buffer.from([0]));
  const v = res[0] - 48;
  let r = res.slice(4, 4 + res[3]);
  if (r[0] === 0) {
    r = r.slice(1);
  }
  r = r.toString("hex");
  offset = 4 + res[3] + 2;
  let s = res.slice(offset, offset + res[offset - 1]);
  if (s[0] === 0) {
    s = s.slice(1);
  }
  s = s.toString("hex");
  return {
    v,
    r,
    s
  };
}
var import_bip32_path2;
var init_signMessage = __esm({
  "node_modules/@ledgerhq/hw-app-btc/lib-es/signMessage.js"() {
    import_bip32_path2 = __toESM(require_bip32_path());
    init_constants();
  }
});

// node_modules/@ledgerhq/hw-app-btc/lib-es/BtcOld.js
function makeFingerprint(compressedPubKey) {
  return hash160(compressedPubKey).slice(0, 4);
}
function asBufferUInt32BE(n) {
  const buf = Buffer.allocUnsafe(4);
  buf.writeUInt32BE(n, 0);
  return buf;
}
function makeXpub(version, depth, parentFingerprint, index, chainCode, pubKey) {
  const indexBuffer = asBufferUInt32BE(index);
  indexBuffer[0] |= 128;
  const extendedKeyBytes = Buffer.concat([
    asBufferUInt32BE(version),
    Buffer.from([depth]),
    parentFingerprint,
    indexBuffer,
    chainCode,
    pubKey
  ]);
  const checksum = hash256(extendedKeyBytes).slice(0, 4);
  return import_bs58.default.encode(Buffer.concat([extendedKeyBytes, checksum]));
}
function sha2563(buffer) {
  return Buffer.from(sha2562(buffer));
}
function hash256(buffer) {
  return sha2563(sha2563(buffer));
}
function ripemd1603(buffer) {
  return Buffer.from(ripemd1602(buffer));
}
function hash160(buffer) {
  return ripemd1603(sha2563(buffer));
}
var import_bs58, BtcOld, compressPublicKeySECP256;
var init_BtcOld = __esm({
  "node_modules/@ledgerhq/hw-app-btc/lib-es/BtcOld.js"() {
    import_bs58 = __toESM(require_bs58());
    init_sha256();
    init_ripemd160();
    init_createTransaction();
    init_getWalletPublicKey();
    init_bip32();
    init_signMessage();
    BtcOld = class {
      transport;
      constructor(transport) {
        this.transport = transport;
      }
      derivationsCache = {};
      async derivatePath(path) {
        if (this.derivationsCache[path])
          return this.derivationsCache[path];
        const res = await getWalletPublicKey(this.transport, {
          path
        });
        this.derivationsCache[path] = res;
        return res;
      }
      async getWalletXpub({ path, xpubVersion }) {
        const pathElements = pathStringToArray(path);
        const parentPath = pathElements.slice(0, -1);
        const parentDerivation = await this.derivatePath(pathArrayToString(parentPath));
        const accountDerivation = await this.derivatePath(path);
        const fingerprint = makeFingerprint(compressPublicKeySECP256(Buffer.from(parentDerivation.publicKey, "hex")));
        const xpub = makeXpub(xpubVersion, pathElements.length, fingerprint, pathElements[pathElements.length - 1], Buffer.from(accountDerivation.chainCode, "hex"), compressPublicKeySECP256(Buffer.from(accountDerivation.publicKey, "hex")));
        return xpub;
      }
      /**
       * @param path a BIP 32 path
       * @param options an object with optional these fields:
       *
       * - verify (boolean) will ask user to confirm the address on the device
       *
       * - format ("legacy" | "p2sh" | "bech32" | "bech32m" | "cashaddr") to use different bitcoin address formatter.
       *
       * NB The normal usage is to use:
       *
       * - legacy format with 44' paths
       *
       * - p2sh format with 49' paths
       *
       * - bech32 format with 84' paths
       *
       * - bech32m format with 86' paths
       *
       * - cashaddr in case of Bitcoin Cash
       *
       * @example
       * btc.getWalletPublicKey("44'/0'/0'/0/0").then(o => o.bitcoinAddress)
       * btc.getWalletPublicKey("49'/0'/0'/0/0", { format: "p2sh" }).then(o => o.bitcoinAddress)
       */
      getWalletPublicKey(path, opts) {
        if (opts?.format === "bech32m") {
          throw new Error("Unsupported address format bech32m");
        }
        return getWalletPublicKey(this.transport, { ...opts, path });
      }
      /**
       * To sign a transaction involving standard (P2PKH) inputs, call createTransaction with the following parameters
       * @param inputs is an array of [ transaction, output_index, optional redeem script, optional sequence ] where
       *
       * * transaction is the previously computed transaction object for this UTXO
       * * output_index is the output in the transaction used as input for this UTXO (counting from 0)
       * * redeem script is the optional redeem script to use when consuming a Segregated Witness input
       * * sequence is the sequence number to use for this input (when using RBF), or non present
       * @param associatedKeysets is an array of BIP 32 paths pointing to the path to the private key used for each UTXO
       * @param changePath is an optional BIP 32 path pointing to the path to the public key used to compute the change address
       * @param outputScriptHex is the hexadecimal serialized outputs of the transaction to sign
       * @param lockTime is the optional lockTime of the transaction to sign, or default (0)
       * @param sigHashType is the hash type of the transaction to sign, or default (all)
       * @param segwit is an optional boolean indicating wether to use segwit or not
       * @param additionals list of additionnal options
       *
       * - "bech32" for spending native segwit outputs
       * - "abc" for bch
       * - "gold" for btg
       * - "decred" for decred
       * - "zcash" for zcash
       * - "bipxxx" for using BIPxxx
       * - "sapling" to indicate a zec transaction is supporting sapling (to be set over block 419200)
       * @param expiryHeight is an optional Buffer for zec overwinter / sapling Txs
       * @param useTrustedInputForSegwit trust inputs for segwit transactions
       * @return the signed transaction ready to be broadcast
       * @example
      btc.createTransaction({
       inputs: [ [tx1, 1] ],
       associatedKeysets: ["0'/0/0"],
       outputScriptHex: "01905f0100000000001976a91472a5d75c8d2d0565b656a5232703b167d50d5a2b88ac"
      }).then(res => ...);
       */
      createPaymentTransaction(arg) {
        if (arguments.length > 1) {
          throw new Error("@ledgerhq/hw-app-btc: createPaymentTransaction multi argument signature is deprecated. please switch to named parameters.");
        }
        return createTransaction(this.transport, arg);
      }
      async signMessage({ path, messageHex }) {
        return signMessage(this.transport, {
          path,
          messageHex
        });
      }
    };
    compressPublicKeySECP256 = (publicKey) => Buffer.concat([Buffer.from([2 + (publicKey[64] & 1)]), publicKey.slice(1, 33)]);
  }
});

// node_modules/@ledgerhq/hw-app-btc/lib-es/newops/merkleMap.js
var MerkleMap;
var init_merkleMap = __esm({
  "node_modules/@ledgerhq/hw-app-btc/lib-es/newops/merkleMap.js"() {
    init_varint();
    init_merkle();
    MerkleMap = class {
      keys;
      keysTree;
      values;
      valuesTree;
      /**
       * @param keys Sorted list of (unhashed) keys
       * @param values values, in corresponding order as the keys, and of equal length
       */
      constructor(keys, values) {
        if (keys.length != values.length) {
          throw new Error("keys and values should have the same length");
        }
        for (let i = 0; i < keys.length - 1; i++) {
          if (keys[i].toString("hex") >= keys[i + 1].toString("hex")) {
            throw new Error("keys must be in strictly increasing order");
          }
        }
        this.keys = keys;
        this.keysTree = new Merkle(keys.map((k) => hashLeaf(k)));
        this.values = values;
        this.valuesTree = new Merkle(values.map((v) => hashLeaf(v)));
      }
      commitment() {
        return Buffer.concat([
          createVarint(this.keys.length),
          this.keysTree.getRoot(),
          this.valuesTree.getRoot()
        ]);
      }
    };
  }
});

// node_modules/@ledgerhq/hw-app-btc/lib-es/newops/merkelizedPsbt.js
var MerkelizedPsbt;
var init_merkelizedPsbt = __esm({
  "node_modules/@ledgerhq/hw-app-btc/lib-es/newops/merkelizedPsbt.js"() {
    init_merkleMap();
    init_psbtv2();
    MerkelizedPsbt = class _MerkelizedPsbt extends PsbtV2 {
      globalMerkleMap;
      inputMerkleMaps = [];
      outputMerkleMaps = [];
      inputMapCommitments;
      outputMapCommitments;
      constructor(psbt) {
        super();
        psbt.copy(this);
        this.globalMerkleMap = _MerkelizedPsbt.createMerkleMap(this.globalMap);
        for (let i = 0; i < this.getGlobalInputCount(); i++) {
          this.inputMerkleMaps.push(_MerkelizedPsbt.createMerkleMap(this.inputMaps[i]));
        }
        this.inputMapCommitments = [...this.inputMerkleMaps.values()].map((v) => v.commitment());
        for (let i = 0; i < this.getGlobalOutputCount(); i++) {
          this.outputMerkleMaps.push(_MerkelizedPsbt.createMerkleMap(this.outputMaps[i]));
        }
        this.outputMapCommitments = [...this.outputMerkleMaps.values()].map((v) => v.commitment());
      }
      // These public functions are for MerkelizedPsbt.
      getGlobalSize() {
        return this.globalMap.size;
      }
      getGlobalKeysValuesRoot() {
        return this.globalMerkleMap.commitment();
      }
      static createMerkleMap(map) {
        const sortedKeysStrings = [...map.keys()].sort();
        const values = sortedKeysStrings.map((k) => {
          const v = map.get(k);
          if (!v) {
            throw new Error("No value for key " + k);
          }
          return v;
        });
        const sortedKeys = sortedKeysStrings.map((k) => Buffer.from(k, "hex"));
        const merkleMap = new MerkleMap(sortedKeys, values);
        return merkleMap;
      }
    };
  }
});

// node_modules/@ledgerhq/hw-app-btc/lib-es/newops/clientCommands.js
var import_bitcoinjs_lib5, ClientCommandCode, ClientCommand, YieldCommand, GetPreimageCommand, GetMerkleLeafProofCommand, GetMerkleLeafIndexCommand, GetMoreElementsCommand, ClientCommandInterpreter;
var init_clientCommands = __esm({
  "node_modules/@ledgerhq/hw-app-btc/lib-es/newops/clientCommands.js"() {
    import_bitcoinjs_lib5 = __toESM(require_src3());
    init_buffertools();
    init_varint();
    init_merkle();
    (function(ClientCommandCode2) {
      ClientCommandCode2[ClientCommandCode2["YIELD"] = 16] = "YIELD";
      ClientCommandCode2[ClientCommandCode2["GET_PREIMAGE"] = 64] = "GET_PREIMAGE";
      ClientCommandCode2[ClientCommandCode2["GET_MERKLE_LEAF_PROOF"] = 65] = "GET_MERKLE_LEAF_PROOF";
      ClientCommandCode2[ClientCommandCode2["GET_MERKLE_LEAF_INDEX"] = 66] = "GET_MERKLE_LEAF_INDEX";
      ClientCommandCode2[ClientCommandCode2["GET_MORE_ELEMENTS"] = 160] = "GET_MORE_ELEMENTS";
    })(ClientCommandCode || (ClientCommandCode = {}));
    ClientCommand = class {
    };
    YieldCommand = class extends ClientCommand {
      progressCallback;
      results;
      code = ClientCommandCode.YIELD;
      constructor(results, progressCallback) {
        super();
        this.progressCallback = progressCallback;
        this.results = results;
      }
      execute(request) {
        this.results.push(Buffer.from(request.subarray(1)));
        this.progressCallback();
        return Buffer.from("");
      }
    };
    GetPreimageCommand = class extends ClientCommand {
      known_preimages;
      queue;
      code = ClientCommandCode.GET_PREIMAGE;
      constructor(known_preimages, queue) {
        super();
        this.known_preimages = known_preimages;
        this.queue = queue;
      }
      execute(request) {
        const req = Buffer.from(request.subarray(1));
        if (req.length != 1 + 32) {
          throw new Error("Invalid request, unexpected trailing data");
        }
        if (req[0] != 0) {
          throw new Error("Unsupported request, the first byte should be 0");
        }
        const hash = Buffer.alloc(32);
        for (let i = 0; i < 32; i++) {
          hash[i] = req[1 + i];
        }
        const req_hash_hex = hash.toString("hex");
        const known_preimage = this.known_preimages.get(req_hash_hex);
        if (known_preimage != void 0) {
          const preimage_len_varint = createVarint(known_preimage.length);
          const max_payload_size = 255 - preimage_len_varint.length - 1;
          const payload_size = Math.min(max_payload_size, known_preimage.length);
          if (payload_size < known_preimage.length) {
            for (let i = payload_size; i < known_preimage.length; i++) {
              this.queue.push(Buffer.from([known_preimage[i]]));
            }
          }
          return Buffer.concat([
            preimage_len_varint,
            Buffer.from([payload_size]),
            Buffer.from(known_preimage.subarray(0, payload_size))
          ]);
        }
        throw Error(`Requested unknown preimage for: ${req_hash_hex}`);
      }
    };
    GetMerkleLeafProofCommand = class extends ClientCommand {
      known_trees;
      queue;
      code = ClientCommandCode.GET_MERKLE_LEAF_PROOF;
      constructor(known_trees, queue) {
        super();
        this.known_trees = known_trees;
        this.queue = queue;
      }
      execute(request) {
        const req = Buffer.from(request.subarray(1));
        if (req.length < 32 + 1 + 1) {
          throw new Error("Invalid request, expected at least 34 bytes");
        }
        const reqBuf = new BufferReader(req);
        const hash = reqBuf.readSlice(32);
        const hash_hex = hash.toString("hex");
        let tree_size;
        let leaf_index;
        try {
          tree_size = reqBuf.readVarInt();
          leaf_index = reqBuf.readVarInt();
        } catch (e) {
          throw new Error("Invalid request, couldn't parse tree_size or leaf_index");
        }
        const mt = this.known_trees.get(hash_hex);
        if (!mt) {
          throw Error(`Requested Merkle leaf proof for unknown tree: ${hash_hex}`);
        }
        if (leaf_index >= tree_size || mt.size() != tree_size) {
          throw Error("Invalid index or tree size.");
        }
        if (this.queue.length != 0) {
          throw Error("This command should not execute when the queue is not empty.");
        }
        const proof = mt.getProof(leaf_index);
        const n_response_elements = Math.min(Math.floor((255 - 32 - 1 - 1) / 32), proof.length);
        const n_leftover_elements = proof.length - n_response_elements;
        if (n_leftover_elements > 0) {
          this.queue.push(...proof.slice(-n_leftover_elements));
        }
        return Buffer.concat([
          mt.getLeafHash(leaf_index),
          Buffer.from([proof.length]),
          Buffer.from([n_response_elements]),
          ...proof.slice(0, n_response_elements)
        ]);
      }
    };
    GetMerkleLeafIndexCommand = class extends ClientCommand {
      known_trees;
      code = ClientCommandCode.GET_MERKLE_LEAF_INDEX;
      constructor(known_trees) {
        super();
        this.known_trees = known_trees;
      }
      execute(request) {
        const req = Buffer.from(request.subarray(1));
        if (req.length != 32 + 32) {
          throw new Error("Invalid request, unexpected trailing data");
        }
        const root_hash = Buffer.alloc(32);
        for (let i = 0; i < 32; i++) {
          root_hash[i] = req.readUInt8(i);
        }
        const root_hash_hex = root_hash.toString("hex");
        const leef_hash = Buffer.alloc(32);
        for (let i = 0; i < 32; i++) {
          leef_hash[i] = req.readUInt8(32 + i);
        }
        const leef_hash_hex = leef_hash.toString("hex");
        const mt = this.known_trees.get(root_hash_hex);
        if (!mt) {
          throw Error(`Requested Merkle leaf index for unknown root: ${root_hash_hex}`);
        }
        let leaf_index = 0;
        let found = 0;
        for (let i = 0; i < mt.size(); i++) {
          if (mt.getLeafHash(i).toString("hex") == leef_hash_hex) {
            found = 1;
            leaf_index = i;
            break;
          }
        }
        return Buffer.concat([Buffer.from([found]), createVarint(leaf_index)]);
      }
    };
    GetMoreElementsCommand = class extends ClientCommand {
      queue;
      code = ClientCommandCode.GET_MORE_ELEMENTS;
      constructor(queue) {
        super();
        this.queue = queue;
      }
      execute(request) {
        if (request.length != 1) {
          throw new Error("Invalid request, unexpected trailing data");
        }
        if (this.queue.length === 0) {
          throw new Error("No elements to get");
        }
        const element_len = this.queue[0].length;
        if (this.queue.some((el) => el.length != element_len)) {
          throw new Error("The queue contains elements with different byte length, which is not expected");
        }
        const max_elements = Math.floor(253 / element_len);
        const n_returned_elements = Math.min(max_elements, this.queue.length);
        const returned_elements = this.queue.splice(0, n_returned_elements);
        return Buffer.concat([
          Buffer.from([n_returned_elements]),
          Buffer.from([element_len]),
          ...returned_elements
        ]);
      }
    };
    ClientCommandInterpreter = class {
      roots = /* @__PURE__ */ new Map();
      preimages = /* @__PURE__ */ new Map();
      yielded = [];
      queue = [];
      commands = /* @__PURE__ */ new Map();
      constructor(progressCallback) {
        const commands = [
          new YieldCommand(this.yielded, progressCallback),
          new GetPreimageCommand(this.preimages, this.queue),
          new GetMerkleLeafIndexCommand(this.roots),
          new GetMerkleLeafProofCommand(this.roots, this.queue),
          new GetMoreElementsCommand(this.queue)
        ];
        for (const cmd of commands) {
          if (this.commands.has(cmd.code)) {
            throw new Error(`Multiple commands with code ${cmd.code}`);
          }
          this.commands.set(cmd.code, cmd);
        }
      }
      getYielded() {
        return this.yielded;
      }
      addKnownPreimage(preimage) {
        this.preimages.set(import_bitcoinjs_lib5.crypto.sha256(preimage).toString("hex"), preimage);
      }
      addKnownList(elements) {
        for (const el of elements) {
          const preimage = Buffer.concat([Buffer.from([0]), el]);
          this.addKnownPreimage(preimage);
        }
        const mt = new Merkle(elements.map((el) => hashLeaf(el)));
        this.roots.set(mt.getRoot().toString("hex"), mt);
      }
      addKnownMapping(mm) {
        this.addKnownList(mm.keys);
        this.addKnownList(mm.values);
      }
      execute(request) {
        if (request.length == 0) {
          throw new Error("Unexpected empty command");
        }
        const cmdCode = request[0];
        const cmd = this.commands.get(cmdCode);
        if (!cmd) {
          throw new Error(`Unexpected command code ${cmdCode}`);
        }
        return cmd.execute(request);
      }
    };
  }
});

// node_modules/@ledgerhq/hw-app-btc/lib-es/newops/appClient.js
var CLA_BTC, CLA_FRAMEWORK, BitcoinIns, FrameworkIns, AppClient;
var init_appClient = __esm({
  "node_modules/@ledgerhq/hw-app-btc/lib-es/newops/appClient.js"() {
    init_bip32();
    init_merkelizedPsbt();
    init_clientCommands();
    init_varint();
    init_merkle();
    CLA_BTC = 225;
    CLA_FRAMEWORK = 248;
    (function(BitcoinIns2) {
      BitcoinIns2[BitcoinIns2["GET_PUBKEY"] = 0] = "GET_PUBKEY";
      BitcoinIns2[BitcoinIns2["REGISTER_WALLET"] = 2] = "REGISTER_WALLET";
      BitcoinIns2[BitcoinIns2["GET_WALLET_ADDRESS"] = 3] = "GET_WALLET_ADDRESS";
      BitcoinIns2[BitcoinIns2["SIGN_PSBT"] = 4] = "SIGN_PSBT";
      BitcoinIns2[BitcoinIns2["GET_MASTER_FINGERPRINT"] = 5] = "GET_MASTER_FINGERPRINT";
      BitcoinIns2[BitcoinIns2["SIGN_MESSAGE"] = 16] = "SIGN_MESSAGE";
    })(BitcoinIns || (BitcoinIns = {}));
    (function(FrameworkIns2) {
      FrameworkIns2[FrameworkIns2["CONTINUE_INTERRUPTED"] = 1] = "CONTINUE_INTERRUPTED";
    })(FrameworkIns || (FrameworkIns = {}));
    AppClient = class {
      transport;
      constructor(transport) {
        this.transport = transport;
      }
      async makeRequest(ins, data, cci) {
        let response = await this.transport.send(CLA_BTC, ins, 0, 0, data, [36864, 57344]);
        while (response.readUInt16BE(response.length - 2) === 57344) {
          if (!cci) {
            throw new Error("Unexpected SW_INTERRUPTED_EXECUTION");
          }
          const hwRequest = response.slice(0, -2);
          const commandResponse = cci.execute(hwRequest);
          response = await this.transport.send(CLA_FRAMEWORK, FrameworkIns.CONTINUE_INTERRUPTED, 0, 0, commandResponse, [36864, 57344]);
        }
        return response.slice(0, -2);
      }
      async getExtendedPubkey(display, pathElements) {
        if (pathElements.length > 6) {
          throw new Error("Path too long. At most 6 levels allowed.");
        }
        const response = await this.makeRequest(BitcoinIns.GET_PUBKEY, Buffer.concat([Buffer.from(display ? [1] : [0]), pathElementsToBuffer(pathElements)]));
        return response.toString("ascii");
      }
      async getWalletAddress(walletPolicy, walletHMAC, change2, addressIndex, display) {
        if (change2 !== 0 && change2 !== 1)
          throw new Error("Change can only be 0 or 1");
        if (addressIndex < 0 || !Number.isInteger(addressIndex))
          throw new Error("Invalid address index");
        if (walletHMAC != null && walletHMAC.length != 32) {
          throw new Error("Invalid HMAC length");
        }
        const clientInterpreter = new ClientCommandInterpreter(() => {
        });
        clientInterpreter.addKnownList(walletPolicy.keys.map((k) => Buffer.from(k, "ascii")));
        clientInterpreter.addKnownPreimage(walletPolicy.serialize());
        const addressIndexBuffer = Buffer.alloc(4);
        addressIndexBuffer.writeUInt32BE(addressIndex, 0);
        const response = await this.makeRequest(BitcoinIns.GET_WALLET_ADDRESS, Buffer.concat([
          Buffer.from(display ? [1] : [0]),
          walletPolicy.getWalletId(),
          walletHMAC || Buffer.alloc(32, 0),
          Buffer.from([change2]),
          addressIndexBuffer
        ]), clientInterpreter);
        return response.toString("ascii");
      }
      async signPsbt(psbt, walletPolicy, walletHMAC, progressCallback) {
        const merkelizedPsbt = new MerkelizedPsbt(psbt);
        if (walletHMAC != null && walletHMAC.length != 32) {
          throw new Error("Invalid HMAC length");
        }
        const clientInterpreter = new ClientCommandInterpreter(progressCallback);
        clientInterpreter.addKnownList(walletPolicy.keys.map((k) => Buffer.from(k, "ascii")));
        clientInterpreter.addKnownPreimage(walletPolicy.serialize());
        clientInterpreter.addKnownMapping(merkelizedPsbt.globalMerkleMap);
        for (const map of merkelizedPsbt.inputMerkleMaps) {
          clientInterpreter.addKnownMapping(map);
        }
        for (const map of merkelizedPsbt.outputMerkleMaps) {
          clientInterpreter.addKnownMapping(map);
        }
        clientInterpreter.addKnownList(merkelizedPsbt.inputMapCommitments);
        const inputMapsRoot = new Merkle(merkelizedPsbt.inputMapCommitments.map((m) => hashLeaf(m))).getRoot();
        clientInterpreter.addKnownList(merkelizedPsbt.outputMapCommitments);
        const outputMapsRoot = new Merkle(merkelizedPsbt.outputMapCommitments.map((m) => hashLeaf(m))).getRoot();
        await this.makeRequest(BitcoinIns.SIGN_PSBT, Buffer.concat([
          merkelizedPsbt.getGlobalKeysValuesRoot(),
          createVarint(merkelizedPsbt.getGlobalInputCount()),
          inputMapsRoot,
          createVarint(merkelizedPsbt.getGlobalOutputCount()),
          outputMapsRoot,
          walletPolicy.getWalletId(),
          walletHMAC || Buffer.alloc(32, 0)
        ]), clientInterpreter);
        const yielded = clientInterpreter.getYielded();
        const ret = /* @__PURE__ */ new Map();
        for (const inputAndSig of yielded) {
          ret.set(inputAndSig[0], inputAndSig.slice(1));
        }
        return ret;
      }
      async getMasterFingerprint() {
        return this.makeRequest(BitcoinIns.GET_MASTER_FINGERPRINT, Buffer.from([]));
      }
      async signMessage(message, pathElements) {
        if (pathElements.length > 6) {
          throw new Error("Path too long. At most 6 levels allowed.");
        }
        const clientInterpreter = new ClientCommandInterpreter(() => {
        });
        const nChunks = Math.ceil(message.length / 64);
        const chunks = [];
        for (let i = 0; i < nChunks; i++) {
          chunks.push(message.subarray(64 * i, 64 * i + 64));
        }
        clientInterpreter.addKnownList(chunks);
        const chunksRoot = new Merkle(chunks.map((m) => hashLeaf(m))).getRoot();
        const response = await this.makeRequest(BitcoinIns.SIGN_MESSAGE, Buffer.concat([pathElementsToBuffer(pathElements), createVarint(message.length), chunksRoot]), clientInterpreter);
        return response.toString("base64");
      }
    };
  }
});

// node_modules/@ledgerhq/hw-app-btc/lib-es/debug.js
function formatTransactionDebug(transaction) {
  let str = "TX";
  str += " version " + transaction.version.toString("hex");
  if (transaction.locktime) {
    str += " locktime " + transaction.locktime.toString("hex");
  }
  if (transaction.witness) {
    str += " witness " + transaction.witness.toString("hex");
  }
  if (transaction.timestamp) {
    str += " timestamp " + transaction.timestamp.toString("hex");
  }
  if (transaction.nVersionGroupId) {
    str += " nVersionGroupId " + transaction.nVersionGroupId.toString("hex");
  }
  if (transaction.nExpiryHeight) {
    str += " nExpiryHeight " + transaction.nExpiryHeight.toString("hex");
  }
  if (transaction.extraData) {
    str += " extraData " + transaction.extraData.toString("hex");
  }
  transaction.inputs.forEach(({ prevout, script, sequence }, i) => {
    str += `
input ${i}:`;
    str += ` prevout ${prevout.toString("hex")}`;
    str += ` script ${script.toString("hex")}`;
    str += ` sequence ${sequence.toString("hex")}`;
  });
  (transaction.outputs || []).forEach(({ amount, script }, i) => {
    str += `
output ${i}:`;
    str += ` amount ${amount.toString("hex")}`;
    str += ` script ${script.toString("hex")}`;
  });
  return str;
}
var init_debug = __esm({
  "node_modules/@ledgerhq/hw-app-btc/lib-es/debug.js"() {
  }
});

// node_modules/@ledgerhq/hw-app-btc/lib-es/splitTransaction.js
function splitTransaction(transactionHex, isSegwitSupported = false, hasExtraData = false, additionals = []) {
  const inputs = [];
  const outputs = [];
  let witness = false;
  let offset = 0;
  const timestamp = Buffer.alloc(0);
  let nExpiryHeight = Buffer.alloc(0);
  let nVersionGroupId = Buffer.alloc(0);
  let extraData = Buffer.alloc(0);
  let witnessScript, locktime;
  const isDecred = additionals.includes("decred");
  const isZencash = additionals.includes("zencash");
  const isZcash = additionals.includes("zcash");
  const transaction = Buffer.from(transactionHex, "hex");
  const version = transaction.slice(offset, offset + 4);
  const overwinter = version.equals(Buffer.from([3, 0, 0, 128])) || version.equals(Buffer.from([4, 0, 0, 128])) || version.equals(Buffer.from([5, 0, 0, 128]));
  const isZcashv5 = isZcash && version.equals(Buffer.from([5, 0, 0, 128]));
  offset += 4;
  if (isSegwitSupported && transaction[offset] === 0 && transaction[offset + 1] !== 0 && !isZencash) {
    offset += 2;
    witness = true;
  }
  if (overwinter) {
    nVersionGroupId = transaction.slice(offset, 4 + offset);
    offset += 4;
  }
  if (isZcashv5) {
    locktime = transaction.slice(offset + 4, offset + 8);
    nExpiryHeight = transaction.slice(offset + 8, offset + 12);
    offset += 12;
  }
  let varint2 = getVarint(transaction, offset);
  const numberInputs = varint2[0];
  offset += varint2[1];
  for (let i = 0; i < numberInputs; i++) {
    const prevout = transaction.slice(offset, offset + 36);
    offset += 36;
    let script = Buffer.alloc(0);
    let tree = Buffer.alloc(0);
    if (!isDecred) {
      varint2 = getVarint(transaction, offset);
      offset += varint2[1];
      script = transaction.slice(offset, offset + varint2[0]);
      offset += varint2[0];
    } else {
      tree = transaction.slice(offset, offset + 1);
      offset += 1;
    }
    const sequence = transaction.slice(offset, offset + 4);
    offset += 4;
    inputs.push({
      prevout,
      script,
      sequence,
      tree
    });
  }
  varint2 = getVarint(transaction, offset);
  const numberOutputs = varint2[0];
  offset += varint2[1];
  for (let i = 0; i < numberOutputs; i++) {
    const amount = transaction.slice(offset, offset + 8);
    offset += 8;
    if (isDecred) {
      offset += 2;
    }
    varint2 = getVarint(transaction, offset);
    offset += varint2[1];
    const script = transaction.slice(offset, offset + varint2[0]);
    offset += varint2[0];
    outputs.push({
      amount,
      script
    });
  }
  let sapling;
  let orchard;
  if (hasExtraData) {
    if (isZcashv5) {
      ({ sapling, offset } = splitSaplingPart(transaction, offset));
      ({ orchard, offset } = splitOrchardPart(transaction, offset));
      extraData = transaction.subarray(offset);
    }
  }
  if (witness) {
    witnessScript = transaction.slice(offset, -4);
    locktime = transaction.slice(transaction.length - 4);
  } else if (!isZcashv5) {
    locktime = transaction.slice(offset, offset + 4);
  }
  offset += 4;
  if ((overwinter || isDecred) && !isZcashv5) {
    nExpiryHeight = transaction.slice(offset, offset + 4);
    offset += 4;
  }
  if (hasExtraData) {
    if (!isZcashv5) {
      extraData = transaction.slice(offset);
    }
  }
  if (isDecred) {
    varint2 = getVarint(transaction, offset);
    offset += varint2[1];
    if (varint2[0] !== numberInputs) {
      throw new Error("splitTransaction: incoherent number of witnesses");
    }
    for (let i = 0; i < numberInputs; i++) {
      offset += 8;
      offset += 4;
      offset += 4;
      varint2 = getVarint(transaction, offset);
      offset += varint2[1];
      const script = transaction.slice(offset, offset + varint2[0]);
      offset += varint2[0];
      inputs[i].script = script;
    }
  }
  const t = {
    version,
    inputs,
    outputs,
    locktime,
    witness: witnessScript,
    timestamp,
    nVersionGroupId,
    nExpiryHeight,
    extraData,
    sapling,
    orchard
  };
  log("btc", `splitTransaction ${transactionHex}:
${formatTransactionDebug(t)}`);
  return t;
}
function splitSaplingPart(transaction, offset) {
  let varint2 = getVarint(transaction, offset);
  const nSpendsSapling = varint2[0];
  offset += varint2[1];
  const vSpendsSapling = [];
  for (let i = 0; i < nSpendsSapling; i++) {
    const cv = transaction.slice(offset, offset + 32);
    offset += 32;
    const nullifier = transaction.slice(offset, offset + 32);
    offset += 32;
    const rk = transaction.slice(offset, offset + 32);
    offset += 32;
    vSpendsSapling.push({
      cv,
      nullifier,
      rk
    });
  }
  varint2 = getVarint(transaction, offset);
  const nOutputsSapling = varint2[0];
  offset += varint2[1];
  const vOutputSapling = [];
  for (let i = 0; i < nOutputsSapling; i++) {
    const cv = transaction.slice(offset, offset + 32);
    offset += 32;
    const cmu = transaction.slice(offset, offset + 32);
    offset += 32;
    const ephemeralKey = transaction.slice(offset, offset + 32);
    offset += 32;
    const encCiphertext = transaction.slice(offset, offset + zCashEncCiphertextSize);
    offset += zCashEncCiphertextSize;
    const outCiphertext = transaction.slice(offset, offset + zCashOutCiphertextSize);
    offset += zCashOutCiphertextSize;
    vOutputSapling.push({
      cv,
      cmu,
      ephemeralKey,
      encCiphertext,
      outCiphertext
    });
  }
  let valueBalanceSapling = Buffer.alloc(0);
  if (nSpendsSapling + nOutputsSapling > 0) {
    valueBalanceSapling = transaction.slice(offset, offset + 8);
    offset += 8;
  }
  let anchorSapling = Buffer.alloc(0);
  if (nSpendsSapling > 0) {
    anchorSapling = transaction.slice(offset, offset + 32);
    offset += 32;
  }
  let vSpendProofsSapling = Buffer.alloc(0);
  let vSpendAuthSigsSapling = Buffer.alloc(0);
  if (nSpendsSapling > 0) {
    vSpendProofsSapling = transaction.slice(offset, offset + zCashProofsSaplingSize * nSpendsSapling);
    offset += zCashProofsSaplingSize * nSpendsSapling;
    vSpendAuthSigsSapling = transaction.slice(offset, offset + 64 * nSpendsSapling);
    offset += 64 * nSpendsSapling;
  }
  let vOutputProofsSapling = Buffer.alloc(0);
  if (nOutputsSapling > 0) {
    vOutputProofsSapling = transaction.slice(offset, offset + zCashProofsSaplingSize * nOutputsSapling);
    offset += zCashProofsSaplingSize * nOutputsSapling;
  }
  let bindingSigSapling = Buffer.alloc(0);
  if (nSpendsSapling + nOutputsSapling > 0) {
    bindingSigSapling = transaction.slice(offset, offset + 64);
    offset += 64;
  }
  let sapling;
  if (nSpendsSapling + nOutputsSapling > 0) {
    sapling = {
      nSpendsSapling,
      vSpendsSapling,
      nOutputsSapling,
      vOutputSapling,
      valueBalanceSapling,
      anchorSapling,
      vSpendProofsSapling,
      vSpendAuthSigsSapling,
      vOutputProofsSapling,
      bindingSigSapling
    };
  }
  return { sapling, offset };
}
function splitOrchardPart(transaction, offset) {
  let varint2 = getVarint(transaction, offset);
  const nActionsOrchard = varint2[0];
  offset += varint2[1];
  let orchard;
  if (nActionsOrchard > 0) {
    const actionsOrchard = [];
    for (let i = 0; i < nActionsOrchard; i++) {
      const cv = transaction.subarray(offset, offset + 32);
      offset += 32;
      const nullifier = transaction.subarray(offset, offset + 32);
      offset += 32;
      const rk = transaction.subarray(offset, offset + 32);
      offset += 32;
      const cmx = transaction.subarray(offset, offset + 32);
      offset += 32;
      const ephemeralKey = transaction.subarray(offset, offset + 32);
      offset += 32;
      const encCiphertext = transaction.subarray(offset, offset + zCashEncCiphertextSize);
      offset += zCashEncCiphertextSize;
      const outCiphertext = transaction.subarray(offset, offset + zCashOutCiphertextSize);
      offset += zCashOutCiphertextSize;
      const action = {
        cv,
        nullifier,
        rk,
        cmx,
        ephemeralKey,
        encCiphertext,
        outCiphertext
      };
      actionsOrchard.push(action);
    }
    const flagsOrchard = transaction.subarray(offset, offset + 1);
    offset += 1;
    const valueBalanceOrchard = transaction.subarray(offset, offset + 8);
    offset += 8;
    const anchorOrchard = transaction.subarray(offset, offset + 32);
    offset += 32;
    varint2 = getVarint(transaction, offset);
    const sizeProofsOrchard = transaction.subarray(offset, offset + varint2[1]);
    offset += varint2[1];
    const proofsOrchard = transaction.subarray(offset, offset + varint2[0]);
    offset += varint2[0];
    const vSpendAuthSigsOrchard = transaction.subarray(offset, offset + nActionsOrchard * 64);
    offset += nActionsOrchard * 64;
    const bindingSigOrchard = transaction.subarray(offset, offset + 64);
    offset += 64;
    orchard = {
      vActions: actionsOrchard,
      flags: flagsOrchard,
      valueBalance: valueBalanceOrchard,
      anchor: anchorOrchard,
      sizeProofs: sizeProofsOrchard,
      proofs: proofsOrchard,
      vSpendsAuthSigs: vSpendAuthSigsOrchard,
      bindingSig: bindingSigOrchard
    };
  }
  return { orchard, offset };
}
var init_splitTransaction = __esm({
  "node_modules/@ledgerhq/hw-app-btc/lib-es/splitTransaction.js"() {
    init_lib_es2();
    init_varint();
    init_debug();
    init_constants();
  }
});

// node_modules/@ledgerhq/hw-app-btc/lib-es/signP2SHTransaction.js
async function signP2SHTransaction(transport, arg) {
  const { inputs, associatedKeysets, outputScriptHex, lockTime, sigHashType, segwit, transactionVersion } = { ...defaultArg, ...arg };
  const nullScript = Buffer.alloc(0);
  const nullPrevout = Buffer.alloc(0);
  const defaultVersion = Buffer.alloc(4);
  defaultVersion.writeUInt32LE(transactionVersion, 0);
  const trustedInputs = [];
  const regularOutputs = [];
  const signatures = [];
  let firstRun = true;
  const resuming = false;
  const targetTransaction = {
    inputs: [],
    version: defaultVersion
  };
  const getTrustedInputCall = segwit ? getTrustedInputBIP143 : getTrustedInput;
  const outputScript = Buffer.from(outputScriptHex, "hex");
  for (const input of inputs) {
    if (!resuming) {
      const trustedInput = await getTrustedInputCall(transport, input[1], input[0]);
      const sequence = Buffer.alloc(4);
      sequence.writeUInt32LE(input.length >= 4 && typeof input[3] === "number" ? input[3] : DEFAULT_SEQUENCE, 0);
      trustedInputs.push({
        trustedInput: false,
        value: segwit ? Buffer.from(trustedInput, "hex") : Buffer.from(trustedInput, "hex").slice(4, 4 + 36),
        sequence
      });
    }
    const { outputs } = input[0];
    const index = input[1];
    if (outputs && index <= outputs.length - 1) {
      regularOutputs.push(outputs[index]);
    }
  }
  for (let i = 0; i < inputs.length; i++) {
    const sequence = Buffer.alloc(4);
    sequence.writeUInt32LE(inputs[i].length >= 4 && typeof inputs[i][3] === "number" ? inputs[i][3] : DEFAULT_SEQUENCE, 0);
    targetTransaction.inputs.push({
      script: nullScript,
      prevout: nullPrevout,
      sequence
    });
  }
  if (segwit) {
    await startUntrustedHashTransactionInput(transport, true, targetTransaction, trustedInputs, true);
    await hashOutputFull(transport, outputScript);
  }
  for (let i = 0; i < inputs.length; i++) {
    const input = inputs[i];
    const script = inputs[i].length >= 3 && typeof input[2] === "string" ? Buffer.from(input[2], "hex") : regularOutputs[i].script;
    const pseudoTX = Object.assign({}, targetTransaction);
    const pseudoTrustedInputs = segwit ? [trustedInputs[i]] : trustedInputs;
    if (segwit) {
      pseudoTX.inputs = [{ ...pseudoTX.inputs[i], script }];
    } else {
      pseudoTX.inputs[i].script = script;
    }
    await startUntrustedHashTransactionInput(transport, !segwit && firstRun, pseudoTX, pseudoTrustedInputs, segwit);
    if (!segwit) {
      await hashOutputFull(transport, outputScript);
    }
    const signature = await signTransaction(transport, associatedKeysets[i], lockTime, sigHashType);
    signatures.push(segwit ? signature.toString("hex") : signature.slice(0, signature.length - 1).toString("hex"));
    targetTransaction.inputs[i].script = nullScript;
    if (firstRun) {
      firstRun = false;
    }
  }
  return signatures;
}
var defaultArg;
var init_signP2SHTransaction = __esm({
  "node_modules/@ledgerhq/hw-app-btc/lib-es/signP2SHTransaction.js"() {
    init_getTrustedInput();
    init_startUntrustedHashTransactionInput();
    init_getTrustedInputBIP143();
    init_signTransaction();
    init_finalizeInput();
    init_constants();
    defaultArg = {
      lockTime: DEFAULT_LOCKTIME,
      sigHashType: SIGHASH_ALL,
      segwit: false,
      transactionVersion: DEFAULT_VERSION
    };
  }
});

// node_modules/@ledgerhq/hw-app-btc/lib-es/Btc.js
var Btc_exports = {};
__export(Btc_exports, {
  default: () => Btc
});
var import_semver3, Btc;
var init_Btc = __esm({
  "node_modules/@ledgerhq/hw-app-btc/lib-es/Btc.js"() {
    import_semver3 = __toESM(require_semver2());
    init_BtcNew();
    init_BtcOld();
    init_getTrustedInput();
    init_getTrustedInputBIP143();
    init_appClient();
    init_serializeTransaction();
    init_splitTransaction();
    init_signP2SHTransaction();
    init_getAppAndVersion();
    Btc = class {
      // Transport instance
      _transport;
      // The specific implementation used, determined by the nano app and its version.
      // It chooses between BtcNew (new interface) and BtcOld (old interface).
      _impl;
      constructor({ transport, scrambleKey = "BTC", currency = "bitcoin" }) {
        this._transport = transport;
        this._transport.decorateAppAPIMethods(this, [
          "getWalletXpub",
          "getWalletPublicKey",
          "signP2SHTransaction",
          "signMessage",
          "createPaymentTransaction",
          "getTrustedInput",
          "getTrustedInputBIP143"
        ], scrambleKey);
        this._impl = (() => {
          switch (currency) {
            case "bitcoin":
            case "bitcoin_testnet":
            case "bitcoin_regtest":
            case "qtum":
              return new BtcNew(new AppClient(this._transport));
            default:
              return new BtcOld(this._transport);
          }
        })();
      }
      /**
       * Get an XPUB with a ledger device
       * @param arg derivation parameter
       * - path: a BIP 32 path of the account level. (e.g. The derivation path `84'/0'/0'`
       * follows the `purpose' / coin_type' / account'` standard, with purpose=84, coin_type=0, account=0)
       * - xpubVersion: the XPUBVersion of the coin used. (refer to ledgerjs/packages/cryptoassets/src/currencies.ts
       * for the XPUBVersion value if needed)
       * @returns XPUB of the account
       */
      getWalletXpub(arg) {
        return this.changeImplIfNecessary().then((impl) => {
          return impl.getWalletXpub(arg);
        });
      }
      /**
       * @param path a BIP 32 path (i.e. the `purpose / coin_type / account / change / address_index` standard)
       * @param options an object with optional these fields:
       *
       * - verify (boolean) whether ask user to confirm the address on the device
       *
       * - format ("legacy" | "p2sh" | "bech32" | "bech32m" | "cashaddr") to use different bitcoin address formatter.
       *
       * NB The normal usage is to use:
       *
       * - legacy format with 44' paths
       *
       * - p2sh format with 49' paths
       *
       * - bech32 format with 84' paths
       *
       * - bech32m format with 86' paths
       *
       * - cashaddr in case of Bitcoin Cash
       *
       * @example
       * btc.getWalletPublicKey("44'/0'/0'/0/0").then(o => o.bitcoinAddress)
       * btc.getWalletPublicKey("49'/0'/0'/0/0", { format: "p2sh" }).then(o => o.bitcoinAddress)
       */
      getWalletPublicKey(path, opts) {
        let options;
        if (arguments.length > 2 || typeof opts === "boolean") {
          console.warn("btc.getWalletPublicKey deprecated signature used. Please switch to getWalletPublicKey(path, { format, verify })");
          options = {
            verify: !!opts,
            // eslint-disable-next-line prefer-rest-params
            format: arguments[2] ? "p2sh" : "legacy"
          };
        } else {
          options = opts || {};
        }
        return this.changeImplIfNecessary().then((impl) => {
          return impl.getWalletPublicKey(path, options);
        });
      }
      /**
       * You can sign a message according to the Bitcoin Signature format and retrieve v, r, s given the message and the BIP 32 path of the account to sign.
       * @example
       btc.signMessage("44'/60'/0'/0'/0", Buffer.from("test").toString("hex")).then(function(result) {
         var v = result['v'] + 27 + 4;
         var signature = Buffer.from(v.toString(16) + result['r'] + result['s'], 'hex').toString('base64');
         console.log("Signature : " + signature);
       }).catch(function(ex) {console.log(ex);});
       */
      signMessage(path, messageHex) {
        return this.changeImplIfNecessary().then((impl) => {
          return impl.signMessage({
            path,
            messageHex
          });
        });
      }
      /**
       * To sign a transaction involving standard (P2PKH) inputs, call createTransaction with the following parameters
       * @param inputs is an array of [ transaction, output_index, optional redeem script, optional sequence ] where
       *
       * * transaction is the previously computed transaction object for this UTXO
       * * output_index is the output in the transaction used as input for this UTXO (counting from 0)
       * * redeem script is the optional redeem script to use when consuming a Segregated Witness input
       * * sequence is the sequence number to use for this input (when using RBF), or non present
       * @param associatedKeysets is an array of BIP 32 paths pointing to the path to the private key used for each UTXO
       * @param changePath is an optional BIP 32 path pointing to the path to the public key used to compute the change address
       * @param outputScriptHex is the hexadecimal serialized outputs of the transaction to sign, including leading vararg voutCount
       * @param lockTime is the optional lockTime of the transaction to sign, or default (0)
       * @param sigHashType is the hash type of the transaction to sign, or default (all)
       * @param segwit is an optional boolean indicating wether to use segwit or not. This includes wrapped segwit.
       * @param additionals list of additionnal options
       *
       * - "bech32" for spending native segwit outputs
       * - "bech32m" for spending segwit v1+ outputs
       * - "abc" for bch
       * - "gold" for btg
       * - "decred" for decred
       * - "zcash" for zcash
       * - "bipxxx" for using BIPxxx
       * - "sapling" to indicate a zec transaction is supporting sapling (to be set over block 419200)
       * @param expiryHeight is an optional Buffer for zec overwinter / sapling Txs
       * @param useTrustedInputForSegwit trust inputs for segwit transactions. If app version >= 1.4.0 this should be true.
       * @return the signed transaction ready to be broadcast
       * @example
      btc.createTransaction({
       inputs: [ [tx1, 1] ],
       associatedKeysets: ["0'/0/0"],
       outputScriptHex: "01905f0100000000001976a91472a5d75c8d2d0565b656a5232703b167d50d5a2b88ac"
      }).then(res => ...);
       */
      createPaymentTransaction(arg) {
        if (arguments.length > 1) {
          throw new Error("@ledgerhq/hw-app-btc: createPaymentTransaction multi argument signature is deprecated. please switch to named parameters.");
        }
        return this.changeImplIfNecessary().then((impl) => {
          return impl.createPaymentTransaction(arg);
        });
      }
      /**
       * To obtain the signature of multisignature (P2SH) inputs, call signP2SHTransaction_async with the folowing parameters
       * @param inputs is an array of [ transaction, output_index, redeem script, optional sequence ] where
       * * transaction is the previously computed transaction object for this UTXO
       * * output_index is the output in the transaction used as input for this UTXO (counting from 0)
       * * redeem script is the mandatory redeem script associated to the current P2SH input
       * * sequence is the sequence number to use for this input (when using RBF), or non present
       * @param associatedKeysets is an array of BIP 32 paths pointing to the path to the private key used for each UTXO
       * @param outputScriptHex is the hexadecimal serialized outputs of the transaction to sign
       * @param lockTime is the optional lockTime of the transaction to sign, or default (0)
       * @param sigHashType is the hash type of the transaction to sign, or default (all)
       * @return the signed transaction ready to be broadcast
       * @example
      btc.signP2SHTransaction({
      inputs: [ [tx, 1, "52210289b4a3ad52a919abd2bdd6920d8a6879b1e788c38aa76f0440a6f32a9f1996d02103a3393b1439d1693b063482c04bd40142db97bdf139eedd1b51ffb7070a37eac321030b9a409a1e476b0d5d17b804fcdb81cf30f9b99c6f3ae1178206e08bc500639853ae"] ],
      associatedKeysets: ["0'/0/0"],
      outputScriptHex: "01905f0100000000001976a91472a5d75c8d2d0565b656a5232703b167d50d5a2b88ac"
      }).then(result => ...);
       */
      signP2SHTransaction(arg) {
        return signP2SHTransaction(this._transport, arg);
      }
      /**
       * For each UTXO included in your transaction, create a transaction object from the raw serialized version of the transaction used in this UTXO.
       * @param transactionHex a raw hexadecimal serialized transaction
       * @param isSegwitSupported is a boolean indicating if the segwit is supported
       * @param hasExtraData is a boolean (komodo, zencash and zcash include extraData in their transactions, others don't)
       * @param additionals list of additionnal options
       * @return the transaction object deserialized from the raw hexadecimal transaction
       * @example
      const tx1 = btc.splitTransaction("01000000014ea60aeac5252c14291d428915bd7ccd1bfc4af009f4d4dc57ae597ed0420b71010000008a47304402201f36a12c240dbf9e566bc04321050b1984cd6eaf6caee8f02bb0bfec08e3354b022012ee2aeadcbbfd1e92959f57c15c1c6debb757b798451b104665aa3010569b49014104090b15bde569386734abf2a2b99f9ca6a50656627e77de663ca7325702769986cf26cc9dd7fdea0af432c8e2becc867c932e1b9dd742f2a108997c2252e2bdebffffffff0281b72e00000000001976a91472a5d75c8d2d0565b656a5232703b167d50d5a2b88aca0860100000000001976a9144533f5fb9b4817f713c48f0bfe96b9f50c476c9b88ac00000000");
       */
      splitTransaction(transactionHex, isSegwitSupported = false, hasExtraData = false, additionals = []) {
        return splitTransaction(transactionHex, isSegwitSupported, hasExtraData, additionals);
      }
      /**
       * Serialize a transaction's outputs to hexadecimal
       * @example
      const tx1 = btc.splitTransaction("01000000014ea60aeac5252c14291d428915bd7ccd1bfc4af009f4d4dc57ae597ed0420b71010000008a47304402201f36a12c240dbf9e566bc04321050b1984cd6eaf6caee8f02bb0bfec08e3354b022012ee2aeadcbbfd1e92959f57c15c1c6debb757b798451b104665aa3010569b49014104090b15bde569386734abf2a2b99f9ca6a50656627e77de663ca7325702769986cf26cc9dd7fdea0af432c8e2becc867c932e1b9dd742f2a108997c2252e2bdebffffffff0281b72e00000000001976a91472a5d75c8d2d0565b656a5232703b167d50d5a2b88aca0860100000000001976a9144533f5fb9b4817f713c48f0bfe96b9f50c476c9b88ac00000000");
      const outputScript = btc.serializeTransactionOutputs(tx1).toString('hex');
      */
      serializeTransactionOutputs(t) {
        return serializeTransactionOutputs(t);
      }
      /**
       * Trusted input is the hash of a UTXO that needs to be signed
       * For Legacy transactions, the app has some APDUs flows that do the amount check for an UTXO,
       * by parsing the transaction that created this UTXO
       */
      getTrustedInput(indexLookup, transaction, additionals = []) {
        return getTrustedInput(this._transport, indexLookup, transaction, additionals);
      }
      /**
       * Trusted input is the hash of a UTXO that needs to be signed. BIP143 is used for Segwit inputs.
       */
      getTrustedInputBIP143(indexLookup, transaction, additionals = []) {
        return getTrustedInputBIP143(this._transport, indexLookup, transaction, additionals);
      }
      async changeImplIfNecessary() {
        if (this._impl instanceof BtcOld)
          return this._impl;
        const { name, version } = await getAppAndVersion(this._transport);
        const isBtcLegacy = await (async () => {
          switch (name) {
            case "Bitcoin":
            case "Bitcoin Test": {
              return import_semver3.default.lt(version, "2.1.0");
            }
            case "Bitcoin Legacy":
            case "Bitcoin Test Legacy":
              return true;
            case "Exchange":
              return await checkIsBtcLegacy(this._transport);
            case "Qtum":
              return import_semver3.default.lt(version, "3.0.0");
            default:
              return true;
          }
        })();
        if (isBtcLegacy) {
          this._impl = new BtcOld(this._transport);
        }
        return this._impl;
      }
    };
  }
});

// node_modules/tslib/tslib.es6.mjs
var tslib_es6_exports = {};
__export(tslib_es6_exports, {
  __addDisposableResource: () => __addDisposableResource,
  __assign: () => __assign,
  __asyncDelegator: () => __asyncDelegator,
  __asyncGenerator: () => __asyncGenerator,
  __asyncValues: () => __asyncValues,
  __await: () => __await,
  __awaiter: () => __awaiter,
  __classPrivateFieldGet: () => __classPrivateFieldGet,
  __classPrivateFieldIn: () => __classPrivateFieldIn,
  __classPrivateFieldSet: () => __classPrivateFieldSet,
  __createBinding: () => __createBinding,
  __decorate: () => __decorate,
  __disposeResources: () => __disposeResources,
  __esDecorate: () => __esDecorate,
  __exportStar: () => __exportStar,
  __extends: () => __extends,
  __generator: () => __generator,
  __importDefault: () => __importDefault,
  __importStar: () => __importStar,
  __makeTemplateObject: () => __makeTemplateObject,
  __metadata: () => __metadata,
  __param: () => __param,
  __propKey: () => __propKey,
  __read: () => __read,
  __rest: () => __rest,
  __rewriteRelativeImportExtension: () => __rewriteRelativeImportExtension,
  __runInitializers: () => __runInitializers,
  __setFunctionName: () => __setFunctionName,
  __spread: () => __spread,
  __spreadArray: () => __spreadArray,
  __spreadArrays: () => __spreadArrays,
  __values: () => __values,
  default: () => tslib_es6_default
});
function __extends(d, b2) {
  if (typeof b2 !== "function" && b2 !== null)
    throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
  extendStatics(d, b2);
  function __() {
    this.constructor = d;
  }
  d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __decorate(decorators2, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators2, target, key, desc);
  else for (var i = decorators2.length - 1; i >= 0; i--) if (d = decorators2[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __esDecorate(ctor, descriptorIn, decorators2, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators2.length - 1; i >= 0; i--) {
    var context = {};
    for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access) context.access[p] = contextIn.access[p];
    context.addInitializer = function(f) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators2[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor.get = _;
      if (_ = accept(result.set)) descriptor.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
}
function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
}
function __propKey(x) {
  return typeof x === "symbol" ? x : "".concat(x);
}
function __setFunctionName(f, name, prefix) {
  if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
  return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __exportStar(m, o) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function() {
      if (o && i >= o.length) o = void 0;
      return { value: o && o[i++], done: !o };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read(arguments[i]));
  return ar;
}
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function awaitReturn(f) {
    return function(v) {
      return Promise.resolve(v).then(f, reject);
    };
  }
  function verb(n, f) {
    if (g[n]) {
      i[n] = function(v) {
        return new Promise(function(a, b2) {
          q.push([n, v, a, b2]) > 1 || resume(n, v);
        });
      };
      if (f) i[n] = f(i[n]);
    }
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
}
function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function(e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function() {
    return this;
  }, i;
  function verb(n, f) {
    i[n] = o[n] ? function(v) {
      return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
    } : f;
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
function __importStar(mod3) {
  if (mod3 && mod3.__esModule) return mod3;
  var result = {};
  if (mod3 != null) {
    for (var k = ownKeys(mod3), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod3, k[i]);
  }
  __setModuleDefault(result, mod3);
  return result;
}
function __importDefault(mod3) {
  return mod3 && mod3.__esModule ? mod3 : { default: mod3 };
}
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state === "function" ? receiver === state : state.has(receiver);
}
function __addDisposableResource(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose, inner;
    if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    if (inner) dispose = function() {
      try {
        inner.call(this);
      } catch (e) {
        return Promise.reject(e);
      }
    };
    env.stack.push({ value, dispose, async });
  } else if (async) {
    env.stack.push({ async: true });
  }
  return value;
}
function __disposeResources(env) {
  function fail(e) {
    env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
    env.hasError = true;
  }
  var r, s = 0;
  function next() {
    while (r = env.stack.pop()) {
      try {
        if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
        if (r.dispose) {
          var result = r.dispose.call(r.value);
          if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
            fail(e);
            return next();
          });
        } else s |= 1;
      } catch (e) {
        fail(e);
      }
    }
    if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
    if (env.hasError) throw env.error;
  }
  return next();
}
function __rewriteRelativeImportExtension(path, preserveJsx) {
  if (typeof path === "string" && /^\.\.?\//.test(path)) {
    return path.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(m, tsx, d, ext, cm) {
      return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : d + ext + "." + cm.toLowerCase() + "js";
    });
  }
  return path;
}
var extendStatics, __assign, __createBinding, __setModuleDefault, ownKeys, _SuppressedError, tslib_es6_default;
var init_tslib_es6 = __esm({
  "node_modules/tslib/tslib.es6.mjs"() {
    extendStatics = function(d, b2) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
        d2.__proto__ = b3;
      } || function(d2, b3) {
        for (var p in b3) if (Object.prototype.hasOwnProperty.call(b3, p)) d2[p] = b3[p];
      };
      return extendStatics(d, b2);
    };
    __assign = function() {
      __assign = Object.assign || function __assign2(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    __createBinding = Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    };
    __setModuleDefault = Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    };
    ownKeys = function(o) {
      ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };
    tslib_es6_default = {
      __extends,
      __assign,
      __rest,
      __decorate,
      __param,
      __esDecorate,
      __runInitializers,
      __propKey,
      __setFunctionName,
      __metadata,
      __awaiter,
      __generator,
      __createBinding,
      __exportStar,
      __values,
      __read,
      __spread,
      __spreadArrays,
      __spreadArray,
      __await,
      __asyncGenerator,
      __asyncDelegator,
      __asyncValues,
      __makeTemplateObject,
      __importStar,
      __importDefault,
      __classPrivateFieldGet,
      __classPrivateFieldSet,
      __classPrivateFieldIn,
      __addDisposableResource,
      __disposeResources,
      __rewriteRelativeImportExtension
    };
  }
});

// node_modules/@trezor/connect/lib/events/ui-request.js
var require_ui_request = __commonJS({
  "node_modules/@trezor/connect/lib/events/ui-request.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createUiMessage = exports2.UI_REQUEST = exports2.UI_EVENT = void 0;
    exports2.UI_EVENT = "UI_EVENT";
    exports2.UI_REQUEST = {
      TRANSPORT: "ui-no_transport",
      BOOTLOADER: "ui-device_bootloader_mode",
      NOT_IN_BOOTLOADER: "ui-device_not_in_bootloader_mode",
      REQUIRE_MODE: "ui-device_require_mode",
      INITIALIZE: "ui-device_not_initialized",
      SEEDLESS: "ui-device_seedless",
      FIRMWARE_OLD: "ui-device_firmware_old",
      FIRMWARE_OUTDATED: "ui-device_firmware_outdated",
      FIRMWARE_NOT_SUPPORTED: "ui-device_firmware_unsupported",
      FIRMWARE_NOT_COMPATIBLE: "ui-device_firmware_not_compatible",
      FIRMWARE_NOT_INSTALLED: "ui-device_firmware_not_installed",
      FIRMWARE_PROGRESS: "ui-firmware-progress",
      FIRMWARE_PROGRESS_UNEXPECTED_DELAY: "ui-firmware-progress-unexpected-delay",
      FIRMWARE_RECONNECT: "ui-firmware_reconnect",
      FIRMWARE_DISCONNECT: "ui-firmware_disconnect",
      FIRMWARE_DOWNLOADED: "ui-firmware_downloaded",
      DEVICE_NEEDS_BACKUP: "ui-device_needs_backup",
      REQUEST_UI_WINDOW: "ui-request_window",
      CLOSE_UI_WINDOW: "ui-close_window",
      REQUEST_PERMISSION: "ui-request_permission",
      REQUEST_CONFIRMATION: "ui-request_confirmation",
      REQUEST_PIN: "ui-request_pin",
      INVALID_PIN: "ui-invalid_pin",
      INVALID_PIN_ATTEMPTS_DEPLETED: "ui-invalid_pin_attempts_depleted",
      REQUEST_PASSPHRASE: "ui-request_passphrase",
      REQUEST_PASSPHRASE_ON_DEVICE: "ui-request_passphrase_on_device",
      INVALID_PASSPHRASE: "ui-invalid_passphrase",
      REQUEST_THP_PAIRING: "ui-request_thp_pairing",
      CONNECT: "ui-connect",
      LOADING: "ui-loading",
      SET_OPERATION: "ui-set_operation",
      SELECT_DEVICE: "ui-select_device",
      SELECT_ACCOUNT: "ui-select_account",
      SELECT_FEE: "ui-select_fee",
      UPDATE_CUSTOM_FEE: "ui-update_custom_fee",
      INSUFFICIENT_FUNDS: "ui-insufficient_funds",
      REQUEST_BUTTON: "ui-button",
      REQUEST_WORD: "ui-request_word",
      LOGIN_CHALLENGE_REQUEST: "ui-login_challenge_request",
      BUNDLE_PROGRESS: "ui-bundle_progress",
      ADDRESS_VALIDATION: "ui-address_validation",
      IFRAME_FAILURE: "ui-iframe_failure"
    };
    var createUiMessage = (type, payload) => ({
      event: exports2.UI_EVENT,
      type,
      payload
    });
    exports2.createUiMessage = createUiMessage;
  }
});

// node_modules/@trezor/connect/lib/events/ui-response.js
var require_ui_response = __commonJS({
  "node_modules/@trezor/connect/lib/events/ui-response.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createUiResponse = exports2.UI_RESPONSE = void 0;
    var ui_request_1 = require_ui_request();
    exports2.UI_RESPONSE = {
      RECEIVE_PERMISSION: "ui-receive_permission",
      RECEIVE_CONFIRMATION: "ui-receive_confirmation",
      RECEIVE_FIRMWARE: "ui-receive_firmware",
      RECEIVE_PIN: "ui-receive_pin",
      RECEIVE_PASSPHRASE: "ui-receive_passphrase",
      RECEIVE_THP_PAIRING_TAG: "ui-receive_thp_pairing_tag",
      RECEIVE_DEVICE: "ui-receive_device",
      RECEIVE_ACCOUNT: "ui-receive_account",
      RECEIVE_FEE: "ui-receive_fee",
      RECEIVE_WORD: "ui-receive_word",
      INVALID_PASSPHRASE_ACTION: "ui-invalid_passphrase_action",
      CHANGE_SETTINGS: "ui-change_settings",
      LOGIN_CHALLENGE_RESPONSE: "ui-login_challenge_response"
    };
    var createUiResponse = (type, payload) => ({
      event: ui_request_1.UI_EVENT,
      type,
      payload
    });
    exports2.createUiResponse = createUiResponse;
  }
});

// node_modules/@trezor/connect/lib/events/blockchain.js
var require_blockchain = __commonJS({
  "node_modules/@trezor/connect/lib/events/blockchain.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createBlockchainMessage = exports2.BLOCKCHAIN = exports2.BLOCKCHAIN_EVENT = void 0;
    exports2.BLOCKCHAIN_EVENT = "BLOCKCHAIN_EVENT";
    exports2.BLOCKCHAIN = {
      CONNECT: "blockchain-connect",
      RECONNECTING: "blockchain-reconnecting",
      ERROR: "blockchain-error",
      BLOCK: "blockchain-block",
      NOTIFICATION: "blockchain-notification",
      FIAT_RATES_UPDATE: "fiat-rates-update"
    };
    var createBlockchainMessage = (type, payload) => ({
      event: exports2.BLOCKCHAIN_EVENT,
      type,
      payload
    });
    exports2.createBlockchainMessage = createBlockchainMessage;
  }
});

// node_modules/@trezor/connect/lib/constants/errors.js
var require_errors2 = __commonJS({
  "node_modules/@trezor/connect/lib/constants/errors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LIBUSB_ERROR_MESSAGE = exports2.serializeError = exports2.TypedError = exports2.TransportError = exports2.nestError = exports2.TrezorError = exports2.ERROR_CODES = void 0;
    exports2.ERROR_CODES = {
      Init_NotInitialized: "TrezorConnect not initialized",
      Init_AlreadyInitialized: "TrezorConnect has been already initialized",
      Init_IframeBlocked: "Iframe blocked",
      Init_IframeTimeout: "Iframe timeout",
      Init_ManifestMissing: "Manifest not set. Read more at https://github.com/trezor/trezor-suite/blob/develop/docs/packages/connect/index.md",
      Popup_ConnectionMissing: "Unable to establish connection with iframe",
      Desktop_ConnectionMissing: "Unable to establish connection with Suite",
      Transport_Missing: "Transport is missing",
      Method_InvalidPackage: "This package is not suitable to work with browser. Use @trezor/connect-web package instead",
      Method_InvalidParameter: "",
      Method_NotAllowed: "Method not allowed for this configuration",
      Method_PermissionsNotGranted: "Permissions not granted",
      Method_Cancel: "Canceled",
      Method_Interrupted: "Popup closed",
      Method_UnknownCoin: "Coin not found",
      Method_AddressNotMatch: "Addresses do not match",
      Method_Discovery_BundleException: "",
      Method_Override: "override",
      Method_NoResponse: "Call resolved without response",
      Method_Unsupported: "Unsupported method",
      Backend_NotSupported: "BlockchainLink settings not found in coins.json",
      Backend_WorkerMissing: "",
      Backend_Disconnected: "Backend disconnected",
      Backend_Invalid: "Invalid backend",
      Backend_Error: "",
      Runtime: "",
      Device_NotFound: "Device not found",
      Device_InitializeFailed: "",
      Device_FwException: "",
      Device_ModeException: "",
      Device_Disconnected: "Device disconnected",
      Device_UsedElsewhere: "Device is used in another window",
      Device_InvalidState: "Passphrase is incorrect",
      Device_CallInProgress: "Device call in progress",
      Device_MultipleNotSupported: "Multiple devices are not supported",
      Device_MissingCapability: "Device is missing capability",
      Device_MissingCapabilityBtcOnly: "Device is missing capability (BTC only)",
      Device_ThpPairingTagInvalid: "Pairing tag mismatch",
      Device_ThpStateMissing: "ThpState missing",
      Device_ThpPairingMethodsException: "No common pairing methods",
      Failure_UnknownCode: "Unknown error",
      Failure_EntropyCheck: "",
      Deeplink_VersionMismatch: "Not compatible with current version of the app"
    };
    var TrezorError = class extends Error {
      code;
      message;
      constructor(code, message, options) {
        super(message, options);
        this.code = code;
        this.message = message;
      }
      toString() {
        return `${this.name} (code: ${this.code}): ${this.message}`;
      }
    };
    exports2.TrezorError = TrezorError;
    var nestError = (cause) => cause instanceof TrezorError ? new TrezorError(cause.code, cause.message, { cause }) : new Error(cause.message, { cause });
    exports2.nestError = nestError;
    var TransportError2 = class extends Error {
    };
    exports2.TransportError = TransportError2;
    var TypedError = (id2, message) => new TrezorError(id2, message || exports2.ERROR_CODES[id2] || id2);
    exports2.TypedError = TypedError;
    var serializeError2 = (payload) => {
      const error = payload?.error instanceof Error ? payload.error : payload;
      return error instanceof Error ? { error: error.message, code: "code" in error ? error.code : "Failure_UnknownCode" } : { ...payload };
    };
    exports2.serializeError = serializeError2;
    exports2.LIBUSB_ERROR_MESSAGE = "LIBUSB_ERROR";
  }
});

// node_modules/@trezor/connect/lib/events/call.js
var require_call = __commonJS({
  "node_modules/@trezor/connect/lib/events/call.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createResponseMessage = exports2.RESPONSE_EVENT = void 0;
    var errors_1 = require_errors2();
    exports2.RESPONSE_EVENT = "RESPONSE_EVENT";
    var createResponseMessage = (id2, success, payload, device) => ({
      event: exports2.RESPONSE_EVENT,
      type: exports2.RESPONSE_EVENT,
      id: id2,
      success,
      payload: success ? payload : (0, errors_1.serializeError)(payload),
      device: device ? {
        path: device?.getUniquePath(),
        state: device?.getState(),
        instance: device?.getInstance()
      } : void 0
    });
    exports2.createResponseMessage = createResponseMessage;
  }
});

// node_modules/@trezor/connect/lib/events/core.js
var require_core = __commonJS({
  "node_modules/@trezor/connect/lib/events/core.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createErrorMessage = exports2.parseMessage = exports2.CORE_EVENT = void 0;
    exports2.CORE_EVENT = "CORE_EVENT";
    var parseMessage = (messageData) => {
      const message = {
        event: messageData.event,
        type: messageData.type,
        payload: messageData.payload,
        device: messageData.device
      };
      if (typeof messageData.id === "number") {
        message.id = messageData.id;
      }
      if (typeof messageData.success === "boolean") {
        message.success = messageData.success;
      }
      return message;
    };
    exports2.parseMessage = parseMessage;
    var createErrorMessage = (error) => ({
      success: false,
      payload: {
        error: error.message,
        code: error.code
      }
    });
    exports2.createErrorMessage = createErrorMessage;
  }
});

// node_modules/@trezor/protocol/lib/errors.js
var require_errors3 = __commonJS({
  "node_modules/@trezor/protocol/lib/errors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PROTOCOL_MISSMATCH_VERSION = exports2.PROTOCOL_MALFORMED = void 0;
    exports2.PROTOCOL_MALFORMED = "Malformed protocol format";
    exports2.PROTOCOL_MISSMATCH_VERSION = "Protocol missmatch version";
  }
});

// node_modules/@trezor/protocol/lib/protocol-tpn/constants.js
var require_constants2 = __commonJS({
  "node_modules/@trezor/protocol/lib/protocol-tpn/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TPN_VERSION = exports2.MESSAGE_LENGTH = void 0;
    exports2.MESSAGE_LENGTH = 3;
    exports2.TPN_VERSION = 1;
  }
});

// node_modules/@trezor/protocol/lib/protocol-tpn/decode.js
var require_decode = __commonJS({
  "node_modules/@trezor/protocol/lib/protocol-tpn/decode.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decode = exports2.TrezorPushNotificationMode = exports2.TrezorPushNotificationType = exports2.Version = void 0;
    var errors_1 = require_errors3();
    var constants_1 = require_constants2();
    var Version;
    (function(Version2) {
      Version2[Version2["v1"] = 1] = "v1";
    })(Version || (exports2.Version = Version = {}));
    var TrezorPushNotificationType;
    (function(TrezorPushNotificationType2) {
      TrezorPushNotificationType2[TrezorPushNotificationType2["BOOT"] = 0] = "BOOT";
      TrezorPushNotificationType2[TrezorPushNotificationType2["UNLOCK"] = 1] = "UNLOCK";
      TrezorPushNotificationType2[TrezorPushNotificationType2["LOCK"] = 2] = "LOCK";
      TrezorPushNotificationType2[TrezorPushNotificationType2["DISCONNECT"] = 3] = "DISCONNECT";
      TrezorPushNotificationType2[TrezorPushNotificationType2["SETTING_CHANGE"] = 4] = "SETTING_CHANGE";
      TrezorPushNotificationType2[TrezorPushNotificationType2["SOFTLOCK"] = 5] = "SOFTLOCK";
      TrezorPushNotificationType2[TrezorPushNotificationType2["SOFTUNLOCK"] = 6] = "SOFTUNLOCK";
      TrezorPushNotificationType2[TrezorPushNotificationType2["PIN_CHANGE"] = 7] = "PIN_CHANGE";
      TrezorPushNotificationType2[TrezorPushNotificationType2["WIPE"] = 8] = "WIPE";
      TrezorPushNotificationType2[TrezorPushNotificationType2["UNPAIR"] = 9] = "UNPAIR";
    })(TrezorPushNotificationType || (exports2.TrezorPushNotificationType = TrezorPushNotificationType = {}));
    var TrezorPushNotificationMode;
    (function(TrezorPushNotificationMode2) {
      TrezorPushNotificationMode2[TrezorPushNotificationMode2["NormalMode"] = 0] = "NormalMode";
      TrezorPushNotificationMode2[TrezorPushNotificationMode2["BootloaderMode"] = 1] = "BootloaderMode";
    })(TrezorPushNotificationMode || (exports2.TrezorPushNotificationMode = TrezorPushNotificationMode = {}));
    var decode = (message) => {
      const [version, type, mode] = message;
      if (!version || version !== constants_1.TPN_VERSION) {
        throw new Error(errors_1.PROTOCOL_MISSMATCH_VERSION);
      }
      if (message.length !== constants_1.MESSAGE_LENGTH || !Object.values(Version).includes(version) || !Object.values(TrezorPushNotificationType).includes(type) || !Object.values(TrezorPushNotificationMode).includes(mode)) {
        throw new Error(errors_1.PROTOCOL_MALFORMED);
      }
      return {
        type,
        mode
      };
    };
    exports2.decode = decode;
  }
});

// node_modules/@trezor/protocol/lib/protocol-tpn/index.js
var require_protocol_tpn = __commonJS({
  "node_modules/@trezor/protocol/lib/protocol-tpn/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_decode(), exports2);
  }
});

// node_modules/@trezor/connect/lib/events/device.js
var require_device = __commonJS({
  "node_modules/@trezor/connect/lib/events/device.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createDeviceMessage = exports2.DEVICE = exports2.DEVICE_EVENT = exports2.TrezorPushNotificationType = exports2.TrezorPushNotificationMode = void 0;
    var protocol_tpn_1 = require_protocol_tpn();
    Object.defineProperty(exports2, "TrezorPushNotificationMode", { enumerable: true, get: function() {
      return protocol_tpn_1.TrezorPushNotificationMode;
    } });
    Object.defineProperty(exports2, "TrezorPushNotificationType", { enumerable: true, get: function() {
      return protocol_tpn_1.TrezorPushNotificationType;
    } });
    exports2.DEVICE_EVENT = "DEVICE_EVENT";
    exports2.DEVICE = {
      CONNECT: "device-connect",
      CONNECT_UNACQUIRED: "device-connect_unacquired",
      DISCONNECT: "device-disconnect",
      CHANGED: "device-changed",
      FIRMWARE_VERSION_CHANGED: "device-firmware_version_changed",
      TREZOR_PUSH_NOTIFICATION: "device-trezor_push_notification",
      THP_CREDENTIALS_CHANGED: "device-thp_credentials_changed",
      BUTTON: "button",
      PIN: "pin",
      PASSPHRASE: "passphrase",
      PASSPHRASE_ON_DEVICE: "passphrase_on_device",
      WORD: "word",
      THP_PAIRING: "thp_pairing"
    };
    var createDeviceMessage = (type, payload) => ({
      event: exports2.DEVICE_EVENT,
      type,
      payload
    });
    exports2.createDeviceMessage = createDeviceMessage;
  }
});

// node_modules/@trezor/connect/lib/events/iframe.js
var require_iframe = __commonJS({
  "node_modules/@trezor/connect/lib/events/iframe.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createIFrameMessage = exports2.IFRAME = void 0;
    var ui_request_1 = require_ui_request();
    exports2.IFRAME = {
      BOOTSTRAP: "iframe-bootstrap",
      LOADED: "iframe-loaded",
      INIT: "iframe-init",
      ERROR: "iframe-error",
      CALL: "iframe-call",
      LOG: "iframe-log"
    };
    var createIFrameMessage = (type, payload) => ({
      event: ui_request_1.UI_EVENT,
      type,
      payload
    });
    exports2.createIFrameMessage = createIFrameMessage;
  }
});

// node_modules/@trezor/connect/lib/events/popup.js
var require_popup = __commonJS({
  "node_modules/@trezor/connect/lib/events/popup.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createPopupMessage = exports2.POPUP = void 0;
    var ui_request_1 = require_ui_request();
    exports2.POPUP = {
      BOOTSTRAP: "popup-bootstrap",
      LOADED: "popup-loaded",
      CORE_LOADED: "popup-core-loaded",
      INIT: "popup-init",
      ERROR: "popup-error",
      EXTENSION_USB_PERMISSIONS: "open-usb-permissions",
      HANDSHAKE: "popup-handshake",
      CLOSED: "popup-closed",
      CANCEL_POPUP_REQUEST: "ui-cancel-popup-request",
      CLOSE_WINDOW: "window.close",
      ANALYTICS_RESPONSE: "popup-analytics-response",
      CONTENT_SCRIPT_LOADED: "popup-content-script-loaded",
      METHOD_INFO: "popup-method-info"
    };
    var createPopupMessage = (type, payload) => ({
      event: ui_request_1.UI_EVENT,
      type,
      payload
    });
    exports2.createPopupMessage = createPopupMessage;
  }
});

// node_modules/@trezor/connect/lib/data/transportInfo.js
var require_transportInfo = __commonJS({
  "node_modules/@trezor/connect/lib/data/transportInfo.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.suggestBridgeInstaller = void 0;
    var info = {
      version: [2, 0, 27],
      packages: [
        {
          name: "Linux 64-bit (deb)",
          platform: ["deb64"],
          url: "bridge/2.0.27/trezor-bridge_2.0.27_amd64.deb"
        },
        {
          name: "Linux 64-bit (rpm)",
          platform: ["rpm64"],
          url: "bridge/2.0.27/trezor-bridge-2.0.27-1.x86_64.rpm"
        },
        {
          name: "Linux 32-bit (deb)",
          platform: ["deb32"],
          url: "bridge/2.0.27/trezor-bridge_2.0.27_i386.deb"
        },
        {
          name: "Linux 32-bit (rpm)",
          platform: ["rpm32"],
          url: "bridge/2.0.27/trezor-bridge-2.0.27-1.i386.rpm"
        },
        {
          name: "macOS",
          platform: ["mac"],
          signature: "bridge/2.0.27/trezor-bridge-2.0.27.pkg.asc",
          url: "bridge/2.0.27/trezor-bridge-2.0.27.pkg"
        },
        {
          name: "Windows",
          platform: ["win32", "win64"],
          signature: "bridge/2.0.27/trezor-bridge-2.0.27-win32-install.exe.asc",
          url: "bridge/2.0.27/trezor-bridge-2.0.27-win32-install.exe"
        }
      ],
      changelog: ""
    };
    var getBridgeInfo = () => info;
    var suggestBridgeInstaller = (platform) => {
      const info2 = getBridgeInfo();
      if (platform) {
        info2.packages = info2.packages.map((p) => ({
          ...p,
          preferred: p.platform.indexOf(platform) >= 0
        }));
      }
      return info2;
    };
    exports2.suggestBridgeInstaller = suggestBridgeInstaller;
  }
});

// node_modules/@trezor/connect/lib/data/udevInfo.js
var require_udevInfo = __commonJS({
  "node_modules/@trezor/connect/lib/data/udevInfo.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.suggestUdevInstaller = void 0;
    var info = {
      packages: [
        {
          name: "RPM package",
          platform: ["rpm32", "rpm64"],
          url: "/udev/trezor-udev-2-1.noarch.rpm"
        },
        {
          name: "DEB package",
          platform: ["deb32", "deb64"],
          url: "/udev/trezor-udev_2_all.deb",
          preferred: true
        }
      ]
    };
    var suggestUdevInstaller = (platform) => {
      if (platform !== void 0) {
        return {
          packages: info.packages.map((it) => ({
            ...it,
            preferred: it.platform.indexOf(platform) >= 0
          }))
        };
      }
      return info;
    };
    exports2.suggestUdevInstaller = suggestUdevInstaller;
  }
});

// node_modules/@trezor/transport/lib/constants.js
var require_constants3 = __commonJS({
  "node_modules/@trezor/transport/lib/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DEVICE_TYPE = exports2.TRANSPORT = exports2.ACTION_TIMEOUT = exports2.TREZOR_USB_DESCRIPTORS = exports2.WEBUSB_BOOTLOADER_PRODUCT = exports2.T1_HID_PRODUCT = exports2.T1_HID_VENDOR = exports2.DEBUGLINK_ENDPOINT_ID = exports2.DEBUGLINK_INTERFACE_ID = exports2.ENDPOINT_ID = exports2.INTERFACE_ID = exports2.CONFIGURATION_ID = void 0;
    exports2.CONFIGURATION_ID = 1;
    exports2.INTERFACE_ID = 0;
    exports2.ENDPOINT_ID = 1;
    exports2.DEBUGLINK_INTERFACE_ID = 1;
    exports2.DEBUGLINK_ENDPOINT_ID = 2;
    exports2.T1_HID_VENDOR = 21324;
    exports2.T1_HID_PRODUCT = 1;
    var WEBUSB_FIRMWARE_PRODUCT = 21441;
    exports2.WEBUSB_BOOTLOADER_PRODUCT = 21440;
    exports2.TREZOR_USB_DESCRIPTORS = [
      { vendorId: 21324, productId: exports2.T1_HID_PRODUCT },
      { vendorId: 4617, productId: exports2.WEBUSB_BOOTLOADER_PRODUCT },
      { vendorId: 4617, productId: WEBUSB_FIRMWARE_PRODUCT }
    ];
    exports2.ACTION_TIMEOUT = 1e4;
    exports2.TRANSPORT = {
      START: "transport-start",
      ERROR: "transport-error",
      STOPPED: "transport-stopped",
      DEVICE_CONNECTED: "transport-device_connected",
      DEVICE_DISCONNECTED: "transport-device_disconnected",
      DEVICE_SESSION_CHANGED: "transport-device_session_changed",
      DEVICE_REQUEST_RELEASE: "transport-device_request_release",
      SEND_MESSAGE_PROGRESS: "transport-send_message_progress",
      TREZOR_PUSH_NOTIFICATION: "trezor-push-notification",
      BATTERY_LEVEL: "battery-level",
      DISABLE_WEBUSB: "transport-disable_webusb",
      REQUEST_DEVICE: "transport-request_device",
      GET_INFO: "transport-get_info",
      SET_TRANSPORTS: "transport-set_transports"
    };
    var DEVICE_TYPE;
    (function(DEVICE_TYPE2) {
      DEVICE_TYPE2[DEVICE_TYPE2["TypeT1Hid"] = 0] = "TypeT1Hid";
      DEVICE_TYPE2[DEVICE_TYPE2["TypeT1Webusb"] = 1] = "TypeT1Webusb";
      DEVICE_TYPE2[DEVICE_TYPE2["TypeT1WebusbBoot"] = 2] = "TypeT1WebusbBoot";
      DEVICE_TYPE2[DEVICE_TYPE2["TypeT2"] = 3] = "TypeT2";
      DEVICE_TYPE2[DEVICE_TYPE2["TypeT2Boot"] = 4] = "TypeT2Boot";
      DEVICE_TYPE2[DEVICE_TYPE2["TypeEmulator"] = 5] = "TypeEmulator";
      DEVICE_TYPE2[DEVICE_TYPE2["TypeBluetooth"] = 6] = "TypeBluetooth";
    })(DEVICE_TYPE || (exports2.DEVICE_TYPE = DEVICE_TYPE = {}));
  }
});

// node_modules/@trezor/connect/lib/events/transport.js
var require_transport = __commonJS({
  "node_modules/@trezor/connect/lib/events/transport.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createTransportMessage = exports2.TRANSPORT_EVENT = exports2.TRANSPORT = void 0;
    var errors_1 = require_errors2();
    var transportInfo_1 = require_transportInfo();
    var udevInfo_1 = require_udevInfo();
    var constants_1 = require_constants3();
    Object.defineProperty(exports2, "TRANSPORT", { enumerable: true, get: function() {
      return constants_1.TRANSPORT;
    } });
    exports2.TRANSPORT_EVENT = "TRANSPORT_EVENT";
    var createTransportMessage = (type, payload) => ({
      event: exports2.TRANSPORT_EVENT,
      type,
      payload: "error" in payload ? (0, errors_1.serializeError)(payload) : {
        ...payload,
        udev: (0, udevInfo_1.suggestUdevInstaller)(),
        bridge: (0, transportInfo_1.suggestBridgeInstaller)()
      }
    });
    exports2.createTransportMessage = createTransportMessage;
  }
});

// node_modules/@trezor/connect/lib/events/ui-promise.js
var require_ui_promise = __commonJS({
  "node_modules/@trezor/connect/lib/events/ui-promise.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@trezor/connect/lib/events/webextension.js
var require_webextension = __commonJS({
  "node_modules/@trezor/connect/lib/events/webextension.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WEBEXTENSION = void 0;
    exports2.WEBEXTENSION = {
      USB_PERMISSIONS_BROADCAST: "usb-permissions",
      USB_PERMISSIONS_INIT: "usb-permissions-init",
      USB_PERMISSIONS_CLOSE: "usb-permissions-close",
      USB_PERMISSIONS_FINISHED: "usb-permissions-finished",
      CHANNEL_HANDSHAKE_CONFIRM: "channel-handshake-confirm"
    };
  }
});

// node_modules/@trezor/connect/lib/events/index.js
var require_events2 = __commonJS({
  "node_modules/@trezor/connect/lib/events/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UI = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var ui_request_1 = require_ui_request();
    var ui_response_1 = require_ui_response();
    tslib_1.__exportStar(require_blockchain(), exports2);
    tslib_1.__exportStar(require_call(), exports2);
    tslib_1.__exportStar(require_core(), exports2);
    tslib_1.__exportStar(require_device(), exports2);
    tslib_1.__exportStar(require_iframe(), exports2);
    tslib_1.__exportStar(require_popup(), exports2);
    tslib_1.__exportStar(require_transport(), exports2);
    tslib_1.__exportStar(require_ui_promise(), exports2);
    tslib_1.__exportStar(require_ui_request(), exports2);
    tslib_1.__exportStar(require_ui_response(), exports2);
    tslib_1.__exportStar(require_webextension(), exports2);
    exports2.UI = {
      ...ui_request_1.UI_REQUEST,
      ...ui_response_1.UI_RESPONSE
    };
  }
});

// node_modules/@trezor/connect/lib/factory.js
var require_factory = __commonJS({
  "node_modules/@trezor/connect/lib/factory.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.factory = void 0;
    var events_1 = require_events2();
    var factory = ({ eventEmitter, manifest, init, call, setTransports, requestLogin, uiResponse, cancel, dispose }, extraMethods = {}) => ({
      manifest,
      init,
      setTransports,
      on: (type, fn) => {
        eventEmitter.on(type, fn);
      },
      off: (type, fn) => {
        eventEmitter.removeListener(type, fn);
      },
      removeAllListeners: (type) => {
        if (typeof type === "string") {
          eventEmitter.removeAllListeners(type);
        } else {
          eventEmitter.removeAllListeners();
        }
      },
      uiResponse,
      bleUnpair: (params) => call({ ...params, method: "bleUnpair" }),
      blockchainGetAccountBalanceHistory: (params) => call({ ...params, method: "blockchainGetAccountBalanceHistory" }),
      blockchainGetCurrentFiatRates: (params) => call({ ...params, method: "blockchainGetCurrentFiatRates" }),
      blockchainGetFiatRatesForTimestamps: (params) => call({ ...params, method: "blockchainGetFiatRatesForTimestamps" }),
      blockchainGetInfo: (params) => call({ ...params, method: "blockchainGetInfo" }),
      blockchainEvmRpcCall: (params) => call({ ...params, method: "blockchainEvmRpcCall" }),
      blockchainDisconnect: (params) => call({ ...params, method: "blockchainDisconnect" }),
      blockchainEstimateFee: (params) => call({ ...params, method: "blockchainEstimateFee" }),
      blockchainGetTransactions: (params) => call({ ...params, method: "blockchainGetTransactions" }),
      blockchainSetCustomBackend: (params) => call({ ...params, method: "blockchainSetCustomBackend" }),
      blockchainSubscribe: (params) => call({ ...params, method: "blockchainSubscribe" }),
      blockchainSubscribeFiatRates: (params) => call({ ...params, method: "blockchainSubscribeFiatRates" }),
      blockchainUnsubscribe: (params) => call({ ...params, method: "blockchainUnsubscribe" }),
      blockchainUnsubscribeFiatRates: (params) => call({ ...params, method: "blockchainUnsubscribeFiatRates" }),
      requestLogin: (params) => requestLogin(params),
      cardanoGetAddress: (params) => call({
        ...params,
        method: "cardanoGetAddress",
        useEventListener: eventEmitter.listenerCount(events_1.UI.ADDRESS_VALIDATION) > 0
      }),
      cardanoGetNativeScriptHash: (params) => call({ ...params, method: "cardanoGetNativeScriptHash" }),
      cardanoGetPublicKey: (params) => call({ ...params, method: "cardanoGetPublicKey" }),
      cardanoSignTransaction: (params) => call({ ...params, method: "cardanoSignTransaction" }),
      cardanoSignMessage: (params) => call({ ...params, method: "cardanoSignMessage" }),
      cardanoComposeTransaction: (params) => call({ ...params, method: "cardanoComposeTransaction" }),
      cipherKeyValue: (params) => call({ ...params, method: "cipherKeyValue" }),
      evoluGetNode: (params) => call({ ...params, method: "evoluGetNode" }),
      composeTransaction: (params) => call({ ...params, method: "composeTransaction" }),
      discoverAccounts: (params) => call({ ...params, method: "discoverAccounts" }),
      ethereumGetAddress: (params) => call({
        ...params,
        method: "ethereumGetAddress",
        useEventListener: eventEmitter.listenerCount(events_1.UI.ADDRESS_VALIDATION) > 0
      }),
      ethereumGetPublicKey: (params) => call({ ...params, method: "ethereumGetPublicKey" }),
      ethereumSignMessage: (params) => call({ ...params, method: "ethereumSignMessage" }),
      ethereumSignTransaction: (params) => call({ ...params, method: "ethereumSignTransaction" }),
      ethereumSignTypedData: (params) => call({ ...params, method: "ethereumSignTypedData" }),
      ethereumVerifyMessage: (params) => call({ ...params, method: "ethereumVerifyMessage" }),
      getAccountDescriptor: (params) => call({ ...params, method: "getAccountDescriptor" }),
      getAccountInfo: (params) => call({ ...params, method: "getAccountInfo" }),
      getAddress: (params) => call({
        ...params,
        method: "getAddress",
        useEventListener: eventEmitter.listenerCount(events_1.UI.ADDRESS_VALIDATION) > 0
      }),
      getDeviceState: (params) => call({ ...params, method: "getDeviceState" }),
      getFeatures: (params) => call({ ...params, method: "getFeatures" }),
      getFirmwareHash: (params) => call({ ...params, method: "getFirmwareHash" }),
      getOwnershipId: (params) => call({ ...params, method: "getOwnershipId" }),
      getOwnershipProof: (params) => call({ ...params, method: "getOwnershipProof" }),
      getPublicKey: (params) => call({ ...params, method: "getPublicKey" }),
      getNonce: (params) => call({ ...params, method: "getNonce" }),
      nemGetAddress: (params) => call({
        ...params,
        method: "nemGetAddress",
        useEventListener: eventEmitter.listenerCount(events_1.UI.ADDRESS_VALIDATION) > 0
      }),
      nemSignTransaction: (params) => call({ ...params, method: "nemSignTransaction" }),
      pushTransaction: (params) => call({ ...params, method: "pushTransaction" }),
      rippleGetAddress: (params) => call({
        ...params,
        method: "rippleGetAddress",
        useEventListener: eventEmitter.listenerCount(events_1.UI.ADDRESS_VALIDATION) > 0
      }),
      rippleSignTransaction: (params) => call({ ...params, method: "rippleSignTransaction" }),
      signMessage: (params) => call({ ...params, method: "signMessage" }),
      signTransaction: (params) => call({ ...params, method: "signTransaction" }),
      solanaComposeTransaction: (params) => call({ ...params, method: "solanaComposeTransaction" }),
      solanaGetPublicKey: (params) => call({ ...params, method: "solanaGetPublicKey" }),
      solanaGetAddress: (params) => call({ ...params, method: "solanaGetAddress" }),
      solanaSignTransaction: (params) => call({ ...params, method: "solanaSignTransaction" }),
      stellarGetAddress: (params) => call({
        ...params,
        method: "stellarGetAddress",
        useEventListener: eventEmitter.listenerCount(events_1.UI.ADDRESS_VALIDATION) > 0
      }),
      stellarSignTransaction: (params) => call({ ...params, method: "stellarSignTransaction" }),
      tezosGetAddress: (params) => call({
        ...params,
        method: "tezosGetAddress",
        useEventListener: eventEmitter.listenerCount(events_1.UI.ADDRESS_VALIDATION) > 0
      }),
      tezosGetPublicKey: (params) => call({ ...params, method: "tezosGetPublicKey" }),
      tezosSignTransaction: (params) => call({ ...params, method: "tezosSignTransaction" }),
      unlockPath: (params) => call({ ...params, method: "unlockPath" }),
      eosGetPublicKey: (params) => call({ ...params, method: "eosGetPublicKey" }),
      eosSignTransaction: (params) => call({ ...params, method: "eosSignTransaction" }),
      verifyMessage: (params) => call({ ...params, method: "verifyMessage" }),
      resetDevice: (params) => call({ ...params, method: "resetDevice" }),
      loadDevice: (params) => call({ ...params, method: "loadDevice" }),
      wipeDevice: (params) => call({ ...params, method: "wipeDevice" }),
      applyFlags: (params) => call({ ...params, method: "applyFlags" }),
      applySettings: (params) => call({ ...params, method: "applySettings" }),
      getSettings: () => call({ method: "getSettings" }),
      authenticateDevice: (params) => call({ ...params, method: "authenticateDevice" }),
      authorizeCoinjoin: (params) => call({ ...params, method: "authorizeCoinjoin" }),
      cancelCoinjoinAuthorization: (params) => call({ ...params, method: "cancelCoinjoinAuthorization" }),
      showDeviceTutorial: (params) => call({ ...params, method: "showDeviceTutorial" }),
      backupDevice: (params) => call({ ...params, method: "backupDevice" }),
      changeLanguage: (params) => call({ ...params, method: "changeLanguage" }),
      changePin: (params) => call({ ...params, method: "changePin" }),
      changeWipeCode: (params) => call({ ...params, method: "changeWipeCode" }),
      firmwareUpdate: (params) => call({ ...params, method: "firmwareUpdate" }),
      recoveryDevice: (params) => call({ ...params, method: "recoveryDevice" }),
      getCoinInfo: (params) => call({ ...params, method: "getCoinInfo" }),
      setBrightness: (params) => call({ ...params, method: "setBrightness" }),
      setBusy: (params) => call({ ...params, method: "setBusy" }),
      setProxy: (params) => call({ ...params, method: "setProxy" }),
      thpGetCredentials: (params) => call({ ...params, method: "thpGetCredentials" }),
      thpRemoveCredentials: (params) => call({ ...params, method: "thpRemoveCredentials" }),
      dispose,
      cancel,
      ...extraMethods
    });
    exports2.factory = factory;
  }
});

// node_modules/@trezor/utils/lib/bufferUtils.js
var require_bufferUtils = __commonJS({
  "node_modules/@trezor/utils/lib/bufferUtils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getChunkSize = exports2.reverseBuffer = void 0;
    var reverseBuffer = (src) => {
      if (src.length < 1)
        return src;
      const buffer = Buffer.alloc(src.length);
      let j = buffer.length - 1;
      for (let i = 0; i < buffer.length / 2; i++) {
        buffer[i] = src[j];
        buffer[j] = src[i];
        j--;
      }
      return buffer;
    };
    exports2.reverseBuffer = reverseBuffer;
    var getChunkSize = (n) => {
      const buf = Buffer.allocUnsafe(1);
      buf.writeUInt8(n);
      return buf;
    };
    exports2.getChunkSize = getChunkSize;
  }
});

// node_modules/@trezor/utils/lib/enumUtils.js
var require_enumUtils = __commonJS({
  "node_modules/@trezor/utils/lib/enumUtils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getKeyByValue = getKeyByValue;
    exports2.getValueByKey = getValueByKey;
    function getKeyByValue(obj, value) {
      return obj && Object.keys(obj).find((x) => obj[x] === value);
    }
    function getValueByKey(obj, enumKey) {
      const key = obj && Object.keys(obj).find((x) => x === enumKey);
      return key && obj[key];
    }
  }
});

// node_modules/@trezor/utils/lib/throwError.js
var require_throwError = __commonJS({
  "node_modules/@trezor/utils/lib/throwError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.throwError = void 0;
    var throwError = (reason) => {
      throw new Error(reason);
    };
    exports2.throwError = throwError;
  }
});

// node_modules/@trezor/utils/lib/versionUtils.js
var require_versionUtils = __commonJS({
  "node_modules/@trezor/utils/lib/versionUtils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.normalizeVersion = exports2.isNewerOrEqual = exports2.isEqual = exports2.isNewer = exports2.tryParse = exports2.isVersionArray = void 0;
    var throwError_1 = require_throwError();
    var isVersionArray = (arr) => Array.isArray(arr) && arr.length === 3 && arr.every((number) => typeof number === "number" && number >= 0);
    exports2.isVersionArray = isVersionArray;
    var tryParse = (version) => version.match(/^(\d+)\.(\d+)\.(\d+)([+-].*)?$/)?.slice(1, 4).map((n) => Number(n));
    exports2.tryParse = tryParse;
    var validateArray = (version) => (0, exports2.isVersionArray)(version) ? version : null;
    var ensureArray = (version) => (typeof version === "string" ? (0, exports2.tryParse)(version) : validateArray(version)) ?? (0, throwError_1.throwError)(`version string is in wrong format: ${version}`);
    var compare = ([majorX, minorX, patchX], [majorY, minorY, patchY]) => majorX - majorY || minorX - minorY || patchX - patchY;
    var isNewer = (versionX, versionY) => compare(ensureArray(versionX), ensureArray(versionY)) > 0;
    exports2.isNewer = isNewer;
    var isEqual = (versionX, versionY) => compare(ensureArray(versionX), ensureArray(versionY)) === 0;
    exports2.isEqual = isEqual;
    var isNewerOrEqual = (versionX, versionY) => compare(ensureArray(versionX), ensureArray(versionY)) >= 0;
    exports2.isNewerOrEqual = isNewerOrEqual;
    var normalizeVersion = (version) => version.replace(/\b0+(\d)/g, "$1");
    exports2.normalizeVersion = normalizeVersion;
  }
});

// node_modules/@trezor/utils/lib/xssFilters.js
var require_xssFilters = __commonJS({
  "node_modules/@trezor/utils/lib/xssFilters.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.inDoubleQuotes = exports2.inSingleQuotes = exports2.inHTML = void 0;
    var LT = /</g;
    var SQUOT = /'/g;
    var QUOT = /"/g;
    var inHTML = (value) => value.replace(LT, "&lt;");
    exports2.inHTML = inHTML;
    var inSingleQuotes = (value) => value.replace(SQUOT, "&#39;");
    exports2.inSingleQuotes = inSingleQuotes;
    var inDoubleQuotes = (value) => value.replace(QUOT, "&quot;");
    exports2.inDoubleQuotes = inDoubleQuotes;
  }
});

// node_modules/@trezor/utils/lib/addDashesToSpaces.js
var require_addDashesToSpaces = __commonJS({
  "node_modules/@trezor/utils/lib/addDashesToSpaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.addDashesToSpaces = void 0;
    var addDashesToSpaces = (inputString) => inputString.replace(/\s+/g, "-");
    exports2.addDashesToSpaces = addDashesToSpaces;
  }
});

// node_modules/@trezor/utils/lib/arrayDistinct.js
var require_arrayDistinct = __commonJS({
  "node_modules/@trezor/utils/lib/arrayDistinct.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.arrayDistinct = void 0;
    var arrayDistinct = (item, index, self2) => self2.indexOf(item) === index;
    exports2.arrayDistinct = arrayDistinct;
  }
});

// node_modules/@trezor/utils/lib/arrayPartition.js
var require_arrayPartition = __commonJS({
  "node_modules/@trezor/utils/lib/arrayPartition.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.arrayPartition = void 0;
    var arrayPartition = (array, condition) => array.reduce(([pass, fail], elem) => condition(elem) ? [[...pass, elem], fail] : [pass, [...fail, elem]], [[], []]);
    exports2.arrayPartition = arrayPartition;
  }
});

// node_modules/@trezor/utils/lib/arrayShuffle.js
var require_arrayShuffle = __commonJS({
  "node_modules/@trezor/utils/lib/arrayShuffle.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.arrayShuffle = void 0;
    var arrayShuffle = (array, { randomInt }) => {
      const shuffled = array.slice();
      for (let i = shuffled.length - 1; i > 0; i--) {
        const j = randomInt(0, i + 1);
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
      }
      return shuffled;
    };
    exports2.arrayShuffle = arrayShuffle;
  }
});

// node_modules/@trezor/utils/lib/arrayToDictionary.js
var require_arrayToDictionary = __commonJS({
  "node_modules/@trezor/utils/lib/arrayToDictionary.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.arrayToDictionary = void 0;
    var validateKey = (key) => {
      if (["string", "number"].includes(typeof key)) {
        return true;
      }
      return false;
    };
    var arrayToDictionary = (array, getKey, multiple) => multiple ? array.reduce((prev, cur) => {
      const key = getKey(cur);
      if (validateKey(key)) {
        return {
          ...prev,
          [key]: [...prev[key] ?? [], cur]
        };
      }
      return prev;
    }, {}) : array.reduce((prev, cur) => {
      const key = getKey(cur);
      if (validateKey(key)) {
        return {
          ...prev,
          [key]: cur
        };
      }
      return prev;
    }, {});
    exports2.arrayToDictionary = arrayToDictionary;
  }
});

// node_modules/@trezor/utils/lib/asciiUtils.js
var require_asciiUtils = __commonJS({
  "node_modules/@trezor/utils/lib/asciiUtils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isAscii = isAscii;
    exports2.getNonAsciiChars = getNonAsciiChars;
    var ASCII_RANGE = "[^ -~]";
    var nonAsciiPattern = new RegExp(ASCII_RANGE);
    var nonAsciiPatternGlobal = new RegExp(ASCII_RANGE, "g");
    function isAscii(value) {
      if (!value)
        return true;
      return !nonAsciiPattern.test(value);
    }
    function getNonAsciiChars(value) {
      if (!value)
        return null;
      return value.match(nonAsciiPatternGlobal);
    }
  }
});

// node_modules/bignumber.js/bignumber.js
var require_bignumber = __commonJS({
  "node_modules/bignumber.js/bignumber.js"(exports2, module2) {
    (function(globalObject) {
      "use strict";
      var BigNumber, isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
      function clone(configObject) {
        var div, convertBase, parseNumeric, P = BigNumber2.prototype = { constructor: BigNumber2, toString: null, valueOf: null }, ONE = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
          prefix: "",
          groupSize: 3,
          secondaryGroupSize: 0,
          groupSeparator: ",",
          decimalSeparator: ".",
          fractionGroupSize: 0,
          fractionGroupSeparator: "\xA0",
          // non-breaking space
          suffix: ""
        }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
        function BigNumber2(v, b2) {
          var alphabet, c, caseChanged, e, i, isNum, len, str, x = this;
          if (!(x instanceof BigNumber2)) return new BigNumber2(v, b2);
          if (b2 == null) {
            if (v && v._isBigNumber === true) {
              x.s = v.s;
              if (!v.c || v.e > MAX_EXP) {
                x.c = x.e = null;
              } else if (v.e < MIN_EXP) {
                x.c = [x.e = 0];
              } else {
                x.e = v.e;
                x.c = v.c.slice();
              }
              return;
            }
            if ((isNum = typeof v == "number") && v * 0 == 0) {
              x.s = 1 / v < 0 ? (v = -v, -1) : 1;
              if (v === ~~v) {
                for (e = 0, i = v; i >= 10; i /= 10, e++) ;
                if (e > MAX_EXP) {
                  x.c = x.e = null;
                } else {
                  x.e = e;
                  x.c = [v];
                }
                return;
              }
              str = String(v);
            } else {
              if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);
              x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
            }
            if ((e = str.indexOf(".")) > -1) str = str.replace(".", "");
            if ((i = str.search(/e/i)) > 0) {
              if (e < 0) e = i;
              e += +str.slice(i + 1);
              str = str.substring(0, i);
            } else if (e < 0) {
              e = str.length;
            }
          } else {
            intCheck(b2, 2, ALPHABET.length, "Base");
            if (b2 == 10 && alphabetHasNormalDecimalDigits) {
              x = new BigNumber2(v);
              return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
            }
            str = String(v);
            if (isNum = typeof v == "number") {
              if (v * 0 != 0) return parseNumeric(x, str, isNum, b2);
              x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;
              if (BigNumber2.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
                throw Error(tooManyDigits + v);
              }
            } else {
              x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
            }
            alphabet = ALPHABET.slice(0, b2);
            e = i = 0;
            for (len = str.length; i < len; i++) {
              if (alphabet.indexOf(c = str.charAt(i)) < 0) {
                if (c == ".") {
                  if (i > e) {
                    e = len;
                    continue;
                  }
                } else if (!caseChanged) {
                  if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
                    caseChanged = true;
                    i = -1;
                    e = 0;
                    continue;
                  }
                }
                return parseNumeric(x, String(v), isNum, b2);
              }
            }
            isNum = false;
            str = convertBase(str, b2, 10, x.s);
            if ((e = str.indexOf(".")) > -1) str = str.replace(".", "");
            else e = str.length;
          }
          for (i = 0; str.charCodeAt(i) === 48; i++) ;
          for (len = str.length; str.charCodeAt(--len) === 48; ) ;
          if (str = str.slice(i, ++len)) {
            len -= i;
            if (isNum && BigNumber2.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
              throw Error(tooManyDigits + x.s * v);
            }
            if ((e = e - i - 1) > MAX_EXP) {
              x.c = x.e = null;
            } else if (e < MIN_EXP) {
              x.c = [x.e = 0];
            } else {
              x.e = e;
              x.c = [];
              i = (e + 1) % LOG_BASE;
              if (e < 0) i += LOG_BASE;
              if (i < len) {
                if (i) x.c.push(+str.slice(0, i));
                for (len -= LOG_BASE; i < len; ) {
                  x.c.push(+str.slice(i, i += LOG_BASE));
                }
                i = LOG_BASE - (str = str.slice(i)).length;
              } else {
                i -= len;
              }
              for (; i--; str += "0") ;
              x.c.push(+str);
            }
          } else {
            x.c = [x.e = 0];
          }
        }
        BigNumber2.clone = clone;
        BigNumber2.ROUND_UP = 0;
        BigNumber2.ROUND_DOWN = 1;
        BigNumber2.ROUND_CEIL = 2;
        BigNumber2.ROUND_FLOOR = 3;
        BigNumber2.ROUND_HALF_UP = 4;
        BigNumber2.ROUND_HALF_DOWN = 5;
        BigNumber2.ROUND_HALF_EVEN = 6;
        BigNumber2.ROUND_HALF_CEIL = 7;
        BigNumber2.ROUND_HALF_FLOOR = 8;
        BigNumber2.EUCLID = 9;
        BigNumber2.config = BigNumber2.set = function(obj) {
          var p, v;
          if (obj != null) {
            if (typeof obj == "object") {
              if (obj.hasOwnProperty(p = "DECIMAL_PLACES")) {
                v = obj[p];
                intCheck(v, 0, MAX, p);
                DECIMAL_PLACES = v;
              }
              if (obj.hasOwnProperty(p = "ROUNDING_MODE")) {
                v = obj[p];
                intCheck(v, 0, 8, p);
                ROUNDING_MODE = v;
              }
              if (obj.hasOwnProperty(p = "EXPONENTIAL_AT")) {
                v = obj[p];
                if (v && v.pop) {
                  intCheck(v[0], -MAX, 0, p);
                  intCheck(v[1], 0, MAX, p);
                  TO_EXP_NEG = v[0];
                  TO_EXP_POS = v[1];
                } else {
                  intCheck(v, -MAX, MAX, p);
                  TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
                }
              }
              if (obj.hasOwnProperty(p = "RANGE")) {
                v = obj[p];
                if (v && v.pop) {
                  intCheck(v[0], -MAX, -1, p);
                  intCheck(v[1], 1, MAX, p);
                  MIN_EXP = v[0];
                  MAX_EXP = v[1];
                } else {
                  intCheck(v, -MAX, MAX, p);
                  if (v) {
                    MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
                  } else {
                    throw Error(bignumberError + p + " cannot be zero: " + v);
                  }
                }
              }
              if (obj.hasOwnProperty(p = "CRYPTO")) {
                v = obj[p];
                if (v === !!v) {
                  if (v) {
                    if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                      CRYPTO = v;
                    } else {
                      CRYPTO = !v;
                      throw Error(bignumberError + "crypto unavailable");
                    }
                  } else {
                    CRYPTO = v;
                  }
                } else {
                  throw Error(bignumberError + p + " not true or false: " + v);
                }
              }
              if (obj.hasOwnProperty(p = "MODULO_MODE")) {
                v = obj[p];
                intCheck(v, 0, 9, p);
                MODULO_MODE = v;
              }
              if (obj.hasOwnProperty(p = "POW_PRECISION")) {
                v = obj[p];
                intCheck(v, 0, MAX, p);
                POW_PRECISION = v;
              }
              if (obj.hasOwnProperty(p = "FORMAT")) {
                v = obj[p];
                if (typeof v == "object") FORMAT = v;
                else throw Error(bignumberError + p + " not an object: " + v);
              }
              if (obj.hasOwnProperty(p = "ALPHABET")) {
                v = obj[p];
                if (typeof v == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
                  alphabetHasNormalDecimalDigits = v.slice(0, 10) == "0123456789";
                  ALPHABET = v;
                } else {
                  throw Error(bignumberError + p + " invalid: " + v);
                }
              }
            } else {
              throw Error(bignumberError + "Object expected: " + obj);
            }
          }
          return {
            DECIMAL_PLACES,
            ROUNDING_MODE,
            EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
            RANGE: [MIN_EXP, MAX_EXP],
            CRYPTO,
            MODULO_MODE,
            POW_PRECISION,
            FORMAT,
            ALPHABET
          };
        };
        BigNumber2.isBigNumber = function(v) {
          if (!v || v._isBigNumber !== true) return false;
          if (!BigNumber2.DEBUG) return true;
          var i, n, c = v.c, e = v.e, s = v.s;
          out: if ({}.toString.call(c) == "[object Array]") {
            if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
              if (c[0] === 0) {
                if (e === 0 && c.length === 1) return true;
                break out;
              }
              i = (e + 1) % LOG_BASE;
              if (i < 1) i += LOG_BASE;
              if (String(c[0]).length == i) {
                for (i = 0; i < c.length; i++) {
                  n = c[i];
                  if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
                }
                if (n !== 0) return true;
              }
            }
          } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
            return true;
          }
          throw Error(bignumberError + "Invalid BigNumber: " + v);
        };
        BigNumber2.maximum = BigNumber2.max = function() {
          return maxOrMin(arguments, -1);
        };
        BigNumber2.minimum = BigNumber2.min = function() {
          return maxOrMin(arguments, 1);
        };
        BigNumber2.random = function() {
          var pow2_53 = 9007199254740992;
          var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
            return mathfloor(Math.random() * pow2_53);
          } : function() {
            return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
          };
          return function(dp) {
            var a, b2, e, k, v, i = 0, c = [], rand = new BigNumber2(ONE);
            if (dp == null) dp = DECIMAL_PLACES;
            else intCheck(dp, 0, MAX);
            k = mathceil(dp / LOG_BASE);
            if (CRYPTO) {
              if (crypto.getRandomValues) {
                a = crypto.getRandomValues(new Uint32Array(k *= 2));
                for (; i < k; ) {
                  v = a[i] * 131072 + (a[i + 1] >>> 11);
                  if (v >= 9e15) {
                    b2 = crypto.getRandomValues(new Uint32Array(2));
                    a[i] = b2[0];
                    a[i + 1] = b2[1];
                  } else {
                    c.push(v % 1e14);
                    i += 2;
                  }
                }
                i = k / 2;
              } else if (crypto.randomBytes) {
                a = crypto.randomBytes(k *= 7);
                for (; i < k; ) {
                  v = (a[i] & 31) * 281474976710656 + a[i + 1] * 1099511627776 + a[i + 2] * 4294967296 + a[i + 3] * 16777216 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
                  if (v >= 9e15) {
                    crypto.randomBytes(7).copy(a, i);
                  } else {
                    c.push(v % 1e14);
                    i += 7;
                  }
                }
                i = k / 7;
              } else {
                CRYPTO = false;
                throw Error(bignumberError + "crypto unavailable");
              }
            }
            if (!CRYPTO) {
              for (; i < k; ) {
                v = random53bitInt();
                if (v < 9e15) c[i++] = v % 1e14;
              }
            }
            k = c[--i];
            dp %= LOG_BASE;
            if (k && dp) {
              v = POWS_TEN[LOG_BASE - dp];
              c[i] = mathfloor(k / v) * v;
            }
            for (; c[i] === 0; c.pop(), i--) ;
            if (i < 0) {
              c = [e = 0];
            } else {
              for (e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE) ;
              for (i = 1, v = c[0]; v >= 10; v /= 10, i++) ;
              if (i < LOG_BASE) e -= LOG_BASE - i;
            }
            rand.e = e;
            rand.c = c;
            return rand;
          };
        }();
        BigNumber2.sum = function() {
          var i = 1, args = arguments, sum = new BigNumber2(args[0]);
          for (; i < args.length; ) sum = sum.plus(args[i++]);
          return sum;
        };
        convertBase = /* @__PURE__ */ function() {
          var decimal = "0123456789";
          function toBaseOut(str, baseIn, baseOut, alphabet) {
            var j, arr = [0], arrL, i = 0, len = str.length;
            for (; i < len; ) {
              for (arrL = arr.length; arrL--; arr[arrL] *= baseIn) ;
              arr[0] += alphabet.indexOf(str.charAt(i++));
              for (j = 0; j < arr.length; j++) {
                if (arr[j] > baseOut - 1) {
                  if (arr[j + 1] == null) arr[j + 1] = 0;
                  arr[j + 1] += arr[j] / baseOut | 0;
                  arr[j] %= baseOut;
                }
              }
            }
            return arr.reverse();
          }
          return function(str, baseIn, baseOut, sign, callerIsToString) {
            var alphabet, d, e, k, r, x, xc, y, i = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
            if (i >= 0) {
              k = POW_PRECISION;
              POW_PRECISION = 0;
              str = str.replace(".", "");
              y = new BigNumber2(baseIn);
              x = y.pow(str.length - i);
              POW_PRECISION = k;
              y.c = toBaseOut(
                toFixedPoint(coeffToString(x.c), x.e, "0"),
                10,
                baseOut,
                decimal
              );
              y.e = y.c.length;
            }
            xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));
            e = k = xc.length;
            for (; xc[--k] == 0; xc.pop()) ;
            if (!xc[0]) return alphabet.charAt(0);
            if (i < 0) {
              --e;
            } else {
              x.c = xc;
              x.e = e;
              x.s = sign;
              x = div(x, y, dp, rm, baseOut);
              xc = x.c;
              r = x.r;
              e = x.e;
            }
            d = e + dp + 1;
            i = xc[d];
            k = baseOut / 2;
            r = r || d < 0 || xc[d + 1] != null;
            r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));
            if (d < 1 || !xc[0]) {
              str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
            } else {
              xc.length = d;
              if (r) {
                for (--baseOut; ++xc[--d] > baseOut; ) {
                  xc[d] = 0;
                  if (!d) {
                    ++e;
                    xc = [1].concat(xc);
                  }
                }
              }
              for (k = xc.length; !xc[--k]; ) ;
              for (i = 0, str = ""; i <= k; str += alphabet.charAt(xc[i++])) ;
              str = toFixedPoint(str, e, alphabet.charAt(0));
            }
            return str;
          };
        }();
        div = /* @__PURE__ */ function() {
          function multiply(x, k, base) {
            var m, temp, xlo, xhi, carry = 0, i = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;
            for (x = x.slice(); i--; ) {
              xlo = x[i] % SQRT_BASE;
              xhi = x[i] / SQRT_BASE | 0;
              m = khi * xlo + xhi * klo;
              temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
              carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
              x[i] = temp % base;
            }
            if (carry) x = [carry].concat(x);
            return x;
          }
          function compare2(a, b2, aL, bL) {
            var i, cmp;
            if (aL != bL) {
              cmp = aL > bL ? 1 : -1;
            } else {
              for (i = cmp = 0; i < aL; i++) {
                if (a[i] != b2[i]) {
                  cmp = a[i] > b2[i] ? 1 : -1;
                  break;
                }
              }
            }
            return cmp;
          }
          function subtract(a, b2, aL, base) {
            var i = 0;
            for (; aL--; ) {
              a[aL] -= i;
              i = a[aL] < b2[aL] ? 1 : 0;
              a[aL] = i * base + a[aL] - b2[aL];
            }
            for (; !a[0] && a.length > 1; a.splice(0, 1)) ;
          }
          return function(x, y, dp, rm, base) {
            var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;
            if (!xc || !xc[0] || !yc || !yc[0]) {
              return new BigNumber2(
                // Return NaN if either NaN, or both Infinity or 0.
                !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : (
                  // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
                  xc && xc[0] == 0 || !yc ? s * 0 : s / 0
                )
              );
            }
            q = new BigNumber2(s);
            qc = q.c = [];
            e = x.e - y.e;
            s = dp + e + 1;
            if (!base) {
              base = BASE;
              e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
              s = s / LOG_BASE | 0;
            }
            for (i = 0; yc[i] == (xc[i] || 0); i++) ;
            if (yc[i] > (xc[i] || 0)) e--;
            if (s < 0) {
              qc.push(1);
              more = true;
            } else {
              xL = xc.length;
              yL = yc.length;
              i = 0;
              s += 2;
              n = mathfloor(base / (yc[0] + 1));
              if (n > 1) {
                yc = multiply(yc, n, base);
                xc = multiply(xc, n, base);
                yL = yc.length;
                xL = xc.length;
              }
              xi = yL;
              rem = xc.slice(0, yL);
              remL = rem.length;
              for (; remL < yL; rem[remL++] = 0) ;
              yz = yc.slice();
              yz = [0].concat(yz);
              yc0 = yc[0];
              if (yc[1] >= base / 2) yc0++;
              do {
                n = 0;
                cmp = compare2(yc, rem, yL, remL);
                if (cmp < 0) {
                  rem0 = rem[0];
                  if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);
                  n = mathfloor(rem0 / yc0);
                  if (n > 1) {
                    if (n >= base) n = base - 1;
                    prod = multiply(yc, n, base);
                    prodL = prod.length;
                    remL = rem.length;
                    while (compare2(prod, rem, prodL, remL) == 1) {
                      n--;
                      subtract(prod, yL < prodL ? yz : yc, prodL, base);
                      prodL = prod.length;
                      cmp = 1;
                    }
                  } else {
                    if (n == 0) {
                      cmp = n = 1;
                    }
                    prod = yc.slice();
                    prodL = prod.length;
                  }
                  if (prodL < remL) prod = [0].concat(prod);
                  subtract(rem, prod, remL, base);
                  remL = rem.length;
                  if (cmp == -1) {
                    while (compare2(yc, rem, yL, remL) < 1) {
                      n++;
                      subtract(rem, yL < remL ? yz : yc, remL, base);
                      remL = rem.length;
                    }
                  }
                } else if (cmp === 0) {
                  n++;
                  rem = [0];
                }
                qc[i++] = n;
                if (rem[0]) {
                  rem[remL++] = xc[xi] || 0;
                } else {
                  rem = [xc[xi]];
                  remL = 1;
                }
              } while ((xi++ < xL || rem[0] != null) && s--);
              more = rem[0] != null;
              if (!qc[0]) qc.splice(0, 1);
            }
            if (base == BASE) {
              for (i = 1, s = qc[0]; s >= 10; s /= 10, i++) ;
              round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);
            } else {
              q.e = e;
              q.r = +more;
            }
            return q;
          };
        }();
        function format(n, i, rm, id2) {
          var c0, e, ne, len, str;
          if (rm == null) rm = ROUNDING_MODE;
          else intCheck(rm, 0, 8);
          if (!n.c) return n.toString();
          c0 = n.c[0];
          ne = n.e;
          if (i == null) {
            str = coeffToString(n.c);
            str = id2 == 1 || id2 == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
          } else {
            n = round(new BigNumber2(n), i, rm);
            e = n.e;
            str = coeffToString(n.c);
            len = str.length;
            if (id2 == 1 || id2 == 2 && (i <= e || e <= TO_EXP_NEG)) {
              for (; len < i; str += "0", len++) ;
              str = toExponential(str, e);
            } else {
              i -= ne + (id2 === 2 && e > ne);
              str = toFixedPoint(str, e, "0");
              if (e + 1 > len) {
                if (--i > 0) for (str += "."; i--; str += "0") ;
              } else {
                i += e - len;
                if (i > 0) {
                  if (e + 1 == len) str += ".";
                  for (; i--; str += "0") ;
                }
              }
            }
          }
          return n.s < 0 && c0 ? "-" + str : str;
        }
        function maxOrMin(args, n) {
          var k, y, i = 1, x = new BigNumber2(args[0]);
          for (; i < args.length; i++) {
            y = new BigNumber2(args[i]);
            if (!y.s || (k = compare(x, y)) === n || k === 0 && x.s === n) {
              x = y;
            }
          }
          return x;
        }
        function normalise(n, c, e) {
          var i = 1, j = c.length;
          for (; !c[--j]; c.pop()) ;
          for (j = c[0]; j >= 10; j /= 10, i++) ;
          if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {
            n.c = n.e = null;
          } else if (e < MIN_EXP) {
            n.c = [n.e = 0];
          } else {
            n.e = e;
            n.c = c;
          }
          return n;
        }
        parseNumeric = /* @__PURE__ */ function() {
          var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
          return function(x, str, isNum, b2) {
            var base, s = isNum ? str : str.replace(whitespaceOrPlus, "");
            if (isInfinityOrNaN.test(s)) {
              x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
            } else {
              if (!isNum) {
                s = s.replace(basePrefix, function(m, p1, p2) {
                  base = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
                  return !b2 || b2 == base ? p1 : m;
                });
                if (b2) {
                  base = b2;
                  s = s.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
                }
                if (str != s) return new BigNumber2(s, base);
              }
              if (BigNumber2.DEBUG) {
                throw Error(bignumberError + "Not a" + (b2 ? " base " + b2 : "") + " number: " + str);
              }
              x.s = null;
            }
            x.c = x.e = null;
          };
        }();
        function round(x, sd, rm, r) {
          var d, i, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN;
          if (xc) {
            out: {
              for (d = 1, k = xc[0]; k >= 10; k /= 10, d++) ;
              i = sd - d;
              if (i < 0) {
                i += LOG_BASE;
                j = sd;
                n = xc[ni = 0];
                rd = mathfloor(n / pows10[d - j - 1] % 10);
              } else {
                ni = mathceil((i + 1) / LOG_BASE);
                if (ni >= xc.length) {
                  if (r) {
                    for (; xc.length <= ni; xc.push(0)) ;
                    n = rd = 0;
                    d = 1;
                    i %= LOG_BASE;
                    j = i - LOG_BASE + 1;
                  } else {
                    break out;
                  }
                } else {
                  n = k = xc[ni];
                  for (d = 1; k >= 10; k /= 10, d++) ;
                  i %= LOG_BASE;
                  j = i - LOG_BASE + d;
                  rd = j < 0 ? 0 : mathfloor(n / pows10[d - j - 1] % 10);
                }
              }
              r = r || sd < 0 || // Are there any non-zero digits after the rounding digit?
              // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
              // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
              xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
              r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
              (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
              if (sd < 1 || !xc[0]) {
                xc.length = 0;
                if (r) {
                  sd -= x.e + 1;
                  xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
                  x.e = -sd || 0;
                } else {
                  xc[0] = x.e = 0;
                }
                return x;
              }
              if (i == 0) {
                xc.length = ni;
                k = 1;
                ni--;
              } else {
                xc.length = ni + 1;
                k = pows10[LOG_BASE - i];
                xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
              }
              if (r) {
                for (; ; ) {
                  if (ni == 0) {
                    for (i = 1, j = xc[0]; j >= 10; j /= 10, i++) ;
                    j = xc[0] += k;
                    for (k = 1; j >= 10; j /= 10, k++) ;
                    if (i != k) {
                      x.e++;
                      if (xc[0] == BASE) xc[0] = 1;
                    }
                    break;
                  } else {
                    xc[ni] += k;
                    if (xc[ni] != BASE) break;
                    xc[ni--] = 0;
                    k = 1;
                  }
                }
              }
              for (i = xc.length; xc[--i] === 0; xc.pop()) ;
            }
            if (x.e > MAX_EXP) {
              x.c = x.e = null;
            } else if (x.e < MIN_EXP) {
              x.c = [x.e = 0];
            }
          }
          return x;
        }
        function valueOf(n) {
          var str, e = n.e;
          if (e === null) return n.toString();
          str = coeffToString(n.c);
          str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, "0");
          return n.s < 0 ? "-" + str : str;
        }
        P.absoluteValue = P.abs = function() {
          var x = new BigNumber2(this);
          if (x.s < 0) x.s = 1;
          return x;
        };
        P.comparedTo = function(y, b2) {
          return compare(this, new BigNumber2(y, b2));
        };
        P.decimalPlaces = P.dp = function(dp, rm) {
          var c, n, v, x = this;
          if (dp != null) {
            intCheck(dp, 0, MAX);
            if (rm == null) rm = ROUNDING_MODE;
            else intCheck(rm, 0, 8);
            return round(new BigNumber2(x), dp + x.e + 1, rm);
          }
          if (!(c = x.c)) return null;
          n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
          if (v = c[v]) for (; v % 10 == 0; v /= 10, n--) ;
          if (n < 0) n = 0;
          return n;
        };
        P.dividedBy = P.div = function(y, b2) {
          return div(this, new BigNumber2(y, b2), DECIMAL_PLACES, ROUNDING_MODE);
        };
        P.dividedToIntegerBy = P.idiv = function(y, b2) {
          return div(this, new BigNumber2(y, b2), 0, 1);
        };
        P.exponentiatedBy = P.pow = function(n, m) {
          var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y, x = this;
          n = new BigNumber2(n);
          if (n.c && !n.isInteger()) {
            throw Error(bignumberError + "Exponent not an integer: " + valueOf(n));
          }
          if (m != null) m = new BigNumber2(m);
          nIsBig = n.e > 14;
          if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
            y = new BigNumber2(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));
            return m ? y.mod(m) : y;
          }
          nIsNeg = n.s < 0;
          if (m) {
            if (m.c ? !m.c[0] : !m.s) return new BigNumber2(NaN);
            isModExp = !nIsNeg && x.isInteger() && m.isInteger();
            if (isModExp) x = x.mod(m);
          } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
            k = x.s < 0 && isOdd(n) ? -0 : 0;
            if (x.e > -1) k = 1 / k;
            return new BigNumber2(nIsNeg ? 1 / k : k);
          } else if (POW_PRECISION) {
            k = mathceil(POW_PRECISION / LOG_BASE + 2);
          }
          if (nIsBig) {
            half = new BigNumber2(0.5);
            if (nIsNeg) n.s = 1;
            nIsOdd = isOdd(n);
          } else {
            i = Math.abs(+valueOf(n));
            nIsOdd = i % 2;
          }
          y = new BigNumber2(ONE);
          for (; ; ) {
            if (nIsOdd) {
              y = y.times(x);
              if (!y.c) break;
              if (k) {
                if (y.c.length > k) y.c.length = k;
              } else if (isModExp) {
                y = y.mod(m);
              }
            }
            if (i) {
              i = mathfloor(i / 2);
              if (i === 0) break;
              nIsOdd = i % 2;
            } else {
              n = n.times(half);
              round(n, n.e + 1, 1);
              if (n.e > 14) {
                nIsOdd = isOdd(n);
              } else {
                i = +valueOf(n);
                if (i === 0) break;
                nIsOdd = i % 2;
              }
            }
            x = x.times(x);
            if (k) {
              if (x.c && x.c.length > k) x.c.length = k;
            } else if (isModExp) {
              x = x.mod(m);
            }
          }
          if (isModExp) return y;
          if (nIsNeg) y = ONE.div(y);
          return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
        };
        P.integerValue = function(rm) {
          var n = new BigNumber2(this);
          if (rm == null) rm = ROUNDING_MODE;
          else intCheck(rm, 0, 8);
          return round(n, n.e + 1, rm);
        };
        P.isEqualTo = P.eq = function(y, b2) {
          return compare(this, new BigNumber2(y, b2)) === 0;
        };
        P.isFinite = function() {
          return !!this.c;
        };
        P.isGreaterThan = P.gt = function(y, b2) {
          return compare(this, new BigNumber2(y, b2)) > 0;
        };
        P.isGreaterThanOrEqualTo = P.gte = function(y, b2) {
          return (b2 = compare(this, new BigNumber2(y, b2))) === 1 || b2 === 0;
        };
        P.isInteger = function() {
          return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
        };
        P.isLessThan = P.lt = function(y, b2) {
          return compare(this, new BigNumber2(y, b2)) < 0;
        };
        P.isLessThanOrEqualTo = P.lte = function(y, b2) {
          return (b2 = compare(this, new BigNumber2(y, b2))) === -1 || b2 === 0;
        };
        P.isNaN = function() {
          return !this.s;
        };
        P.isNegative = function() {
          return this.s < 0;
        };
        P.isPositive = function() {
          return this.s > 0;
        };
        P.isZero = function() {
          return !!this.c && this.c[0] == 0;
        };
        P.minus = function(y, b2) {
          var i, j, t, xLTy, x = this, a = x.s;
          y = new BigNumber2(y, b2);
          b2 = y.s;
          if (!a || !b2) return new BigNumber2(NaN);
          if (a != b2) {
            y.s = -b2;
            return x.plus(y);
          }
          var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
          if (!xe || !ye) {
            if (!xc || !yc) return xc ? (y.s = -b2, y) : new BigNumber2(yc ? x : NaN);
            if (!xc[0] || !yc[0]) {
              return yc[0] ? (y.s = -b2, y) : new BigNumber2(xc[0] ? x : (
                // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
                ROUNDING_MODE == 3 ? -0 : 0
              ));
            }
          }
          xe = bitFloor(xe);
          ye = bitFloor(ye);
          xc = xc.slice();
          if (a = xe - ye) {
            if (xLTy = a < 0) {
              a = -a;
              t = xc;
            } else {
              ye = xe;
              t = yc;
            }
            t.reverse();
            for (b2 = a; b2--; t.push(0)) ;
            t.reverse();
          } else {
            j = (xLTy = (a = xc.length) < (b2 = yc.length)) ? a : b2;
            for (a = b2 = 0; b2 < j; b2++) {
              if (xc[b2] != yc[b2]) {
                xLTy = xc[b2] < yc[b2];
                break;
              }
            }
          }
          if (xLTy) {
            t = xc;
            xc = yc;
            yc = t;
            y.s = -y.s;
          }
          b2 = (j = yc.length) - (i = xc.length);
          if (b2 > 0) for (; b2--; xc[i++] = 0) ;
          b2 = BASE - 1;
          for (; j > a; ) {
            if (xc[--j] < yc[j]) {
              for (i = j; i && !xc[--i]; xc[i] = b2) ;
              --xc[i];
              xc[j] += BASE;
            }
            xc[j] -= yc[j];
          }
          for (; xc[0] == 0; xc.splice(0, 1), --ye) ;
          if (!xc[0]) {
            y.s = ROUNDING_MODE == 3 ? -1 : 1;
            y.c = [y.e = 0];
            return y;
          }
          return normalise(y, xc, ye);
        };
        P.modulo = P.mod = function(y, b2) {
          var q, s, x = this;
          y = new BigNumber2(y, b2);
          if (!x.c || !y.s || y.c && !y.c[0]) {
            return new BigNumber2(NaN);
          } else if (!y.c || x.c && !x.c[0]) {
            return new BigNumber2(x);
          }
          if (MODULO_MODE == 9) {
            s = y.s;
            y.s = 1;
            q = div(x, y, 0, 3);
            y.s = s;
            q.s *= s;
          } else {
            q = div(x, y, 0, MODULO_MODE);
          }
          y = x.minus(q.times(y));
          if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;
          return y;
        };
        P.multipliedBy = P.times = function(y, b2) {
          var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x = this, xc = x.c, yc = (y = new BigNumber2(y, b2)).c;
          if (!xc || !yc || !xc[0] || !yc[0]) {
            if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
              y.c = y.e = y.s = null;
            } else {
              y.s *= x.s;
              if (!xc || !yc) {
                y.c = y.e = null;
              } else {
                y.c = [0];
                y.e = 0;
              }
            }
            return y;
          }
          e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
          y.s *= x.s;
          xcL = xc.length;
          ycL = yc.length;
          if (xcL < ycL) {
            zc = xc;
            xc = yc;
            yc = zc;
            i = xcL;
            xcL = ycL;
            ycL = i;
          }
          for (i = xcL + ycL, zc = []; i--; zc.push(0)) ;
          base = BASE;
          sqrtBase = SQRT_BASE;
          for (i = ycL; --i >= 0; ) {
            c = 0;
            ylo = yc[i] % sqrtBase;
            yhi = yc[i] / sqrtBase | 0;
            for (k = xcL, j = i + k; j > i; ) {
              xlo = xc[--k] % sqrtBase;
              xhi = xc[k] / sqrtBase | 0;
              m = yhi * xlo + xhi * ylo;
              xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
              c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
              zc[j--] = xlo % base;
            }
            zc[j] = c;
          }
          if (c) {
            ++e;
          } else {
            zc.splice(0, 1);
          }
          return normalise(y, zc, e);
        };
        P.negated = function() {
          var x = new BigNumber2(this);
          x.s = -x.s || null;
          return x;
        };
        P.plus = function(y, b2) {
          var t, x = this, a = x.s;
          y = new BigNumber2(y, b2);
          b2 = y.s;
          if (!a || !b2) return new BigNumber2(NaN);
          if (a != b2) {
            y.s = -b2;
            return x.minus(y);
          }
          var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
          if (!xe || !ye) {
            if (!xc || !yc) return new BigNumber2(a / 0);
            if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber2(xc[0] ? x : a * 0);
          }
          xe = bitFloor(xe);
          ye = bitFloor(ye);
          xc = xc.slice();
          if (a = xe - ye) {
            if (a > 0) {
              ye = xe;
              t = yc;
            } else {
              a = -a;
              t = xc;
            }
            t.reverse();
            for (; a--; t.push(0)) ;
            t.reverse();
          }
          a = xc.length;
          b2 = yc.length;
          if (a - b2 < 0) {
            t = yc;
            yc = xc;
            xc = t;
            b2 = a;
          }
          for (a = 0; b2; ) {
            a = (xc[--b2] = xc[b2] + yc[b2] + a) / BASE | 0;
            xc[b2] = BASE === xc[b2] ? 0 : xc[b2] % BASE;
          }
          if (a) {
            xc = [a].concat(xc);
            ++ye;
          }
          return normalise(y, xc, ye);
        };
        P.precision = P.sd = function(sd, rm) {
          var c, n, v, x = this;
          if (sd != null && sd !== !!sd) {
            intCheck(sd, 1, MAX);
            if (rm == null) rm = ROUNDING_MODE;
            else intCheck(rm, 0, 8);
            return round(new BigNumber2(x), sd, rm);
          }
          if (!(c = x.c)) return null;
          v = c.length - 1;
          n = v * LOG_BASE + 1;
          if (v = c[v]) {
            for (; v % 10 == 0; v /= 10, n--) ;
            for (v = c[0]; v >= 10; v /= 10, n++) ;
          }
          if (sd && x.e + 1 > n) n = x.e + 1;
          return n;
        };
        P.shiftedBy = function(k) {
          intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
          return this.times("1e" + k);
        };
        P.squareRoot = P.sqrt = function() {
          var m, n, r, rep, t, x = this, c = x.c, s = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
          if (s !== 1 || !c || !c[0]) {
            return new BigNumber2(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
          }
          s = Math.sqrt(+valueOf(x));
          if (s == 0 || s == 1 / 0) {
            n = coeffToString(c);
            if ((n.length + e) % 2 == 0) n += "0";
            s = Math.sqrt(+n);
            e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
            if (s == 1 / 0) {
              n = "5e" + e;
            } else {
              n = s.toExponential();
              n = n.slice(0, n.indexOf("e") + 1) + e;
            }
            r = new BigNumber2(n);
          } else {
            r = new BigNumber2(s + "");
          }
          if (r.c[0]) {
            e = r.e;
            s = e + dp;
            if (s < 3) s = 0;
            for (; ; ) {
              t = r;
              r = half.times(t.plus(div(x, t, dp, 1)));
              if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
                if (r.e < e) --s;
                n = n.slice(s - 3, s + 1);
                if (n == "9999" || !rep && n == "4999") {
                  if (!rep) {
                    round(t, t.e + DECIMAL_PLACES + 2, 0);
                    if (t.times(t).eq(x)) {
                      r = t;
                      break;
                    }
                  }
                  dp += 4;
                  s += 4;
                  rep = 1;
                } else {
                  if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                    round(r, r.e + DECIMAL_PLACES + 2, 1);
                    m = !r.times(r).eq(x);
                  }
                  break;
                }
              }
            }
          }
          return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
        };
        P.toExponential = function(dp, rm) {
          if (dp != null) {
            intCheck(dp, 0, MAX);
            dp++;
          }
          return format(this, dp, rm, 1);
        };
        P.toFixed = function(dp, rm) {
          if (dp != null) {
            intCheck(dp, 0, MAX);
            dp = dp + this.e + 1;
          }
          return format(this, dp, rm);
        };
        P.toFormat = function(dp, rm, format2) {
          var str, x = this;
          if (format2 == null) {
            if (dp != null && rm && typeof rm == "object") {
              format2 = rm;
              rm = null;
            } else if (dp && typeof dp == "object") {
              format2 = dp;
              dp = rm = null;
            } else {
              format2 = FORMAT;
            }
          } else if (typeof format2 != "object") {
            throw Error(bignumberError + "Argument not an object: " + format2);
          }
          str = x.toFixed(dp, rm);
          if (x.c) {
            var i, arr = str.split("."), g1 = +format2.groupSize, g2 = +format2.secondaryGroupSize, groupSeparator = format2.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
            if (g2) {
              i = g1;
              g1 = g2;
              g2 = i;
              len -= i;
            }
            if (g1 > 0 && len > 0) {
              i = len % g1 || g1;
              intPart = intDigits.substr(0, i);
              for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);
              if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
              if (isNeg) intPart = "-" + intPart;
            }
            str = fractionPart ? intPart + (format2.decimalSeparator || "") + ((g2 = +format2.fractionGroupSize) ? fractionPart.replace(
              new RegExp("\\d{" + g2 + "}\\B", "g"),
              "$&" + (format2.fractionGroupSeparator || "")
            ) : fractionPart) : intPart;
          }
          return (format2.prefix || "") + str + (format2.suffix || "");
        };
        P.toFraction = function(md) {
          var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s, x = this, xc = x.c;
          if (md != null) {
            n = new BigNumber2(md);
            if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
              throw Error(bignumberError + "Argument " + (n.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n));
            }
          }
          if (!xc) return new BigNumber2(x);
          d = new BigNumber2(ONE);
          n1 = d0 = new BigNumber2(ONE);
          d1 = n0 = new BigNumber2(ONE);
          s = coeffToString(xc);
          e = d.e = s.length - x.e - 1;
          d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
          md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n;
          exp = MAX_EXP;
          MAX_EXP = 1 / 0;
          n = new BigNumber2(s);
          n0.c[0] = 0;
          for (; ; ) {
            q = div(n, d, 0, 1);
            d2 = d0.plus(q.times(d1));
            if (d2.comparedTo(md) == 1) break;
            d0 = d1;
            d1 = d2;
            n1 = n0.plus(q.times(d2 = n1));
            n0 = d2;
            d = n.minus(q.times(d2 = d));
            n = d2;
          }
          d2 = div(md.minus(d0), d1, 0, 1);
          n0 = n0.plus(d2.times(n1));
          d0 = d0.plus(d2.times(d1));
          n0.s = n1.s = x.s;
          e = e * 2;
          r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
            div(n0, d0, e, ROUNDING_MODE).minus(x).abs()
          ) < 1 ? [n1, d1] : [n0, d0];
          MAX_EXP = exp;
          return r;
        };
        P.toNumber = function() {
          return +valueOf(this);
        };
        P.toPrecision = function(sd, rm) {
          if (sd != null) intCheck(sd, 1, MAX);
          return format(this, sd, rm, 2);
        };
        P.toString = function(b2) {
          var str, n = this, s = n.s, e = n.e;
          if (e === null) {
            if (s) {
              str = "Infinity";
              if (s < 0) str = "-" + str;
            } else {
              str = "NaN";
            }
          } else {
            if (b2 == null) {
              str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, "0");
            } else if (b2 === 10 && alphabetHasNormalDecimalDigits) {
              n = round(new BigNumber2(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
              str = toFixedPoint(coeffToString(n.c), n.e, "0");
            } else {
              intCheck(b2, 2, ALPHABET.length, "Base");
              str = convertBase(toFixedPoint(coeffToString(n.c), e, "0"), 10, b2, s, true);
            }
            if (s < 0 && n.c[0]) str = "-" + str;
          }
          return str;
        };
        P.valueOf = P.toJSON = function() {
          return valueOf(this);
        };
        P._isBigNumber = true;
        if (configObject != null) BigNumber2.set(configObject);
        return BigNumber2;
      }
      function bitFloor(n) {
        var i = n | 0;
        return n > 0 || n === i ? i : i - 1;
      }
      function coeffToString(a) {
        var s, z, i = 1, j = a.length, r = a[0] + "";
        for (; i < j; ) {
          s = a[i++] + "";
          z = LOG_BASE - s.length;
          for (; z--; s = "0" + s) ;
          r += s;
        }
        for (j = r.length; r.charCodeAt(--j) === 48; ) ;
        return r.slice(0, j + 1 || 1);
      }
      function compare(x, y) {
        var a, b2, xc = x.c, yc = y.c, i = x.s, j = y.s, k = x.e, l = y.e;
        if (!i || !j) return null;
        a = xc && !xc[0];
        b2 = yc && !yc[0];
        if (a || b2) return a ? b2 ? 0 : -j : i;
        if (i != j) return i;
        a = i < 0;
        b2 = k == l;
        if (!xc || !yc) return b2 ? 0 : !xc ^ a ? 1 : -1;
        if (!b2) return k > l ^ a ? 1 : -1;
        j = (k = xc.length) < (l = yc.length) ? k : l;
        for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;
        return k == l ? 0 : k > l ^ a ? 1 : -1;
      }
      function intCheck(n, min, max, name) {
        if (n < min || n > max || n !== mathfloor(n)) {
          throw Error(bignumberError + (name || "Argument") + (typeof n == "number" ? n < min || n > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n));
        }
      }
      function isOdd(n) {
        var k = n.c.length - 1;
        return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
      }
      function toExponential(str, e) {
        return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e < 0 ? "e" : "e+") + e;
      }
      function toFixedPoint(str, e, z) {
        var len, zs;
        if (e < 0) {
          for (zs = z + "."; ++e; zs += z) ;
          str = zs + str;
        } else {
          len = str.length;
          if (++e > len) {
            for (zs = z, e -= len; --e; zs += z) ;
            str += zs;
          } else if (e < len) {
            str = str.slice(0, e) + "." + str.slice(e);
          }
        }
        return str;
      }
      BigNumber = clone();
      BigNumber["default"] = BigNumber.BigNumber = BigNumber;
      if (typeof define == "function" && define.amd) {
        define(function() {
          return BigNumber;
        });
      } else if (typeof module2 != "undefined" && module2.exports) {
        module2.exports = BigNumber;
      } else {
        if (!globalObject) {
          globalObject = typeof self != "undefined" && self ? self : window;
        }
        globalObject.BigNumber = BigNumber;
      }
    })(exports2);
  }
});

// node_modules/@trezor/utils/lib/bigNumber.js
var require_bigNumber = __commonJS({
  "node_modules/@trezor/utils/lib/bigNumber.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BigNumber = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var bignumber_js_1 = tslib_1.__importDefault(require_bignumber());
    exports2.BigNumber = bignumber_js_1.default.clone({
      EXPONENTIAL_AT: 1e9
    });
  }
});

// node_modules/@trezor/utils/lib/bytesToHumanReadable.js
var require_bytesToHumanReadable = __commonJS({
  "node_modules/@trezor/utils/lib/bytesToHumanReadable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.bytesToHumanReadable = void 0;
    var units = ["B", "KB", "MB", "GB", "TB"];
    var bytesToHumanReadable = (bytes) => {
      let size = Math.abs(bytes);
      let i = 0;
      while (size >= 1024 || i >= units.length) {
        size /= 1024;
        i++;
      }
      return `${size.toFixed(1)} ${units[i]}`;
    };
    exports2.bytesToHumanReadable = bytesToHumanReadable;
  }
});

// node_modules/@trezor/utils/lib/cache.js
var require_cache = __commonJS({
  "node_modules/@trezor/utils/lib/cache.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Cache = void 0;
    var Cache = class {
      store;
      constructor() {
        this.store = /* @__PURE__ */ new Map();
      }
      set(key, value, ttl) {
        this.store.set(key, { value, ttl: Date.now() + ttl });
      }
      get(key) {
        const entry = this.store.get(key);
        if (!entry)
          return;
        if (entry.ttl < Date.now()) {
          this.store.delete(key);
          return;
        }
        return entry.value;
      }
      delete(key) {
        this.store.delete(key);
      }
    };
    exports2.Cache = Cache;
  }
});

// node_modules/@trezor/utils/lib/capitalizeFirstLetter.js
var require_capitalizeFirstLetter = __commonJS({
  "node_modules/@trezor/utils/lib/capitalizeFirstLetter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.capitalizeFirstLetter = void 0;
    var capitalizeFirstLetter = (str) => str.charAt(0).toUpperCase() + str.slice(1);
    exports2.capitalizeFirstLetter = capitalizeFirstLetter;
  }
});

// node_modules/@trezor/utils/lib/cloneObject.js
var require_cloneObject = __commonJS({
  "node_modules/@trezor/utils/lib/cloneObject.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.cloneObject = void 0;
    var cloneObject = (obj, seen = /* @__PURE__ */ new WeakMap()) => {
      if (obj === null || typeof obj !== "object") {
        return obj;
      }
      if (seen.has(obj)) {
        return seen.get(obj);
      }
      if (obj instanceof ArrayBuffer) {
        return obj.slice(0);
      }
      if (ArrayBuffer.isView(obj)) {
        const TypedArrayConstructor = obj.constructor;
        return new TypedArrayConstructor(obj);
      }
      const clone = Array.isArray(obj) ? [] : {};
      seen.set(obj, clone);
      for (const key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          const value = obj[key];
          if (typeof value === "function" || typeof value === "symbol") {
            continue;
          }
          clone[key] = (0, exports2.cloneObject)(value, seen);
        }
      }
      return clone;
    };
    exports2.cloneObject = cloneObject;
  }
});

// node_modules/@trezor/utils/lib/comparison.js
var require_comparison = __commonJS({
  "node_modules/@trezor/utils/lib/comparison.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isChanged = exports2.deepEqual = void 0;
    var deepEqual = (a, b2) => {
      if (a === b2)
        return true;
      if (typeof a !== typeof b2)
        return false;
      if (a === null || b2 === null)
        return false;
      if (typeof a !== "object")
        return false;
      if (Array.isArray(a) !== Array.isArray(b2))
        return false;
      if (Array.isArray(a)) {
        if (a.length !== b2.length)
          return false;
        for (let i = 0; i < a.length; i++) {
          if (!(0, exports2.deepEqual)(a[i], b2[i]))
            return false;
        }
        return true;
      }
      const keysA = Object.keys(a);
      const keysB = Object.keys(b2);
      if (keysA.length !== keysB.length)
        return false;
      for (const key of keysA) {
        if (!Object.prototype.hasOwnProperty.call(b2, key))
          return false;
        if (!(0, exports2.deepEqual)(a[key], b2[key]))
          return false;
      }
      return true;
    };
    exports2.deepEqual = deepEqual;
    var isChanged = (prev, current, filter) => {
      if (prev === current)
        return false;
      if (!prev || !current)
        return true;
      const prevType = Object.prototype.toString.call(prev);
      const currentType = Object.prototype.toString.call(current);
      if (prevType !== currentType)
        return true;
      if (currentType === "[object Array]") {
        if (prev.length !== current.length)
          return true;
        for (let i = 0; i < current.length; i++) {
          if ((0, exports2.isChanged)(prev[i], current[i], filter))
            return true;
        }
      } else if (currentType === "[object Object]") {
        const prevKeys = Object.keys(prev);
        const currentKeys = Object.keys(current);
        if (prevKeys.length !== currentKeys.length)
          return true;
        const prevDifference = prevKeys.find((k) => currentKeys.indexOf(k) < 0);
        if (prevDifference)
          return true;
        for (let i = 0; i < currentKeys.length; i++) {
          const key = currentKeys[i];
          if (filter && Object.prototype.hasOwnProperty.call(filter, key) && prev[key] && current[key]) {
            const prevFiltered = {};
            const currentFiltered = {};
            for (let i2 = 0; i2 < filter[key].length; i2++) {
              const field = filter[key][i2];
              prevFiltered[field] = prev[key][field];
              currentFiltered[field] = current[key][field];
            }
            if ((0, exports2.isChanged)(prevFiltered, currentFiltered))
              return true;
          } else if ((0, exports2.isChanged)(prev[key], current[key])) {
            return true;
          }
        }
      } else if (prev !== current) {
        return true;
      }
      return false;
    };
    exports2.isChanged = isChanged;
  }
});

// node_modules/@trezor/utils/lib/convertTaprootXpub.js
var require_convertTaprootXpub = __commonJS({
  "node_modules/@trezor/utils/lib/convertTaprootXpub.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.convertTaprootXpub = void 0;
    var convertTaprootXpub = ({ xpub, direction }) => {
      const find = direction === "h-to-apostrophe" ? "h" : "'";
      const replace = direction === "h-to-apostrophe" ? "'" : "h";
      const openingSquareBracketSplit = xpub.split("[");
      if (openingSquareBracketSplit.length === 2) {
        const [beforeOpeningBracket, afterOpeningBracket] = openingSquareBracketSplit;
        const closingSquareBracketSplit = afterOpeningBracket.split("]");
        if (closingSquareBracketSplit.length === 2) {
          const [path, afterClosingBracket] = closingSquareBracketSplit;
          const correctedPath = path.replace(new RegExp(find, "g"), replace);
          return `${beforeOpeningBracket}[${correctedPath}]${afterClosingBracket}`;
        }
      }
      return null;
    };
    exports2.convertTaprootXpub = convertTaprootXpub;
  }
});

// node_modules/@trezor/utils/lib/countBytesInString.js
var require_countBytesInString = __commonJS({
  "node_modules/@trezor/utils/lib/countBytesInString.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.countBytesInString = void 0;
    var countBytesInString = (input) => encodeURI(input).split(/%..|./).length - 1;
    exports2.countBytesInString = countBytesInString;
  }
});

// node_modules/@trezor/utils/lib/createCooldown.js
var require_createCooldown = __commonJS({
  "node_modules/@trezor/utils/lib/createCooldown.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createCooldown = void 0;
    var createCooldown = (cooldownMs) => {
      let last = 0;
      return () => {
        const now = Date.now();
        if (now - last >= cooldownMs) {
          last = now;
          return true;
        }
        return false;
      };
    };
    exports2.createCooldown = createCooldown;
  }
});

// node_modules/@trezor/utils/lib/createDeferred.js
var require_createDeferred = __commonJS({
  "node_modules/@trezor/utils/lib/createDeferred.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createDeferred = void 0;
    var createDeferred = (id2) => {
      let localResolve = () => {
      };
      let localReject = () => {
      };
      const promise = new Promise((resolve, reject) => {
        localResolve = resolve;
        localReject = reject;
      });
      return {
        id: id2,
        resolve: localResolve,
        reject: localReject,
        promise
      };
    };
    exports2.createDeferred = createDeferred;
  }
});

// node_modules/@trezor/utils/lib/createDeferredManager.js
var require_createDeferredManager = __commonJS({
  "node_modules/@trezor/utils/lib/createDeferredManager.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createDeferredManager = void 0;
    var createDeferred_1 = require_createDeferred();
    var createDeferredManager = (options) => {
      const { initialId = 0, timeout: defaultTimeout = 0, onTimeout } = options ?? {};
      const promises = [];
      let ID = initialId;
      let timeoutHandle;
      const length = () => promises.length;
      const nextId = () => ID;
      const replanTimeout = () => {
        const now = Date.now();
        const nearestDeadline = promises.reduce((prev, { deadline }) => (prev && deadline ? Math.min : Math.max)(prev, deadline), 0);
        if (timeoutHandle)
          clearTimeout(timeoutHandle);
        timeoutHandle = nearestDeadline ? setTimeout(timeoutCallback, Math.max(nearestDeadline - now, 0)) : void 0;
      };
      const timeoutCallback = () => {
        const now = Date.now();
        promises.filter((promise) => promise.deadline && promise.deadline <= now).forEach((promise) => {
          onTimeout?.(promise.id);
          promise.deadline = 0;
        });
        replanTimeout();
      };
      const create = (timeout = defaultTimeout) => {
        const promiseId = ID++;
        const deferred = (0, createDeferred_1.createDeferred)(promiseId);
        const deadline = timeout && Date.now() + timeout;
        promises.push({ ...deferred, deadline });
        if (timeout)
          replanTimeout();
        return { promiseId, promise: deferred.promise };
      };
      const extract2 = (promiseId) => {
        const index = promises.findIndex(({ id: id2 }) => id2 === promiseId);
        const [promise] = index >= 0 ? promises.splice(index, 1) : [void 0];
        if (promise?.deadline)
          replanTimeout();
        return promise;
      };
      const resolve = (promiseId, value) => {
        const promise = extract2(promiseId);
        promise?.resolve(value);
        return !!promise;
      };
      const reject = (promiseId, error) => {
        const promise = extract2(promiseId);
        promise?.reject(error);
        return !!promise;
      };
      const rejectAll = (error) => {
        promises.forEach((promise) => promise.reject(error));
        const deleted = promises.splice(0, promises.length);
        if (deleted.length)
          replanTimeout();
      };
      return { length, nextId, create, resolve, reject, rejectAll };
    };
    exports2.createDeferredManager = createDeferredManager;
  }
});

// node_modules/@trezor/utils/lib/createLazy.js
var require_createLazy = __commonJS({
  "node_modules/@trezor/utils/lib/createLazy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createLazy = void 0;
    var createDeferred_1 = require_createDeferred();
    var createLazy = (initLazy, disposeLazy) => {
      let value;
      let valuePromise;
      const get2 = () => value;
      const getPending = () => valuePromise?.promise;
      const dispose = () => {
        if (valuePromise) {
          valuePromise.reject(new Error("Disposed during initialization"));
          valuePromise = void 0;
        }
        if (value !== void 0) {
          disposeLazy?.(value);
          value = void 0;
        }
      };
      const getOrInit = (...args) => {
        if (value !== void 0)
          return Promise.resolve(value);
        if (!valuePromise) {
          const deferred = (0, createDeferred_1.createDeferred)();
          valuePromise = deferred;
          initLazy(...args).then((val) => {
            value = val;
            valuePromise = void 0;
            deferred.resolve(val);
          }).catch((err) => {
            valuePromise = void 0;
            deferred.reject(err);
          });
        }
        return valuePromise.promise;
      };
      return { get: get2, getPending, getOrInit, dispose };
    };
    exports2.createLazy = createLazy;
  }
});

// node_modules/@trezor/utils/lib/extractUrlsFromText.js
var require_extractUrlsFromText = __commonJS({
  "node_modules/@trezor/utils/lib/extractUrlsFromText.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.extractUrlsFromText = void 0;
    var URL_REGEX = /\b(?:https?:\/\/|www\.)[a-zA-Z0-9-._~:/?#[\]@!$&'()*+,;=%]+\b|(?:[a-zA-Z0-9-]+\.)+[a-zA-Z]{2,}(?=\b|\s|$|\])/gi;
    var extractUrlsFromText = (text) => {
      const urls = [];
      const textParts = [];
      let lastIndex = 0;
      const matches = [...text.matchAll(URL_REGEX)];
      matches.forEach((match) => {
        const url = match[0];
        const index = match.index !== void 0 ? match.index : -1;
        if (lastIndex < index) {
          textParts.push(text.slice(lastIndex, index));
        }
        urls.push(url);
        lastIndex = index + url.length;
      });
      if (lastIndex < text.length) {
        textParts.push(text.slice(lastIndex));
      }
      if (textParts.length === 0 && urls.length > 0) {
        textParts.push("");
      }
      return { textParts, urls };
    };
    exports2.extractUrlsFromText = extractUrlsFromText;
  }
});

// node_modules/@trezor/utils/lib/getLocaleSeparators.js
var require_getLocaleSeparators = __commonJS({
  "node_modules/@trezor/utils/lib/getLocaleSeparators.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getLocaleSeparators = void 0;
    var getLocaleSeparators = (locale) => {
      const numberFormat = new Intl.NumberFormat(locale);
      const parts = numberFormat.formatToParts(10000.1);
      const decimalSeparator = parts.find(({ type }) => type === "decimal")?.value;
      const thousandsSeparator = parts.find(({ type }) => type === "group")?.value;
      return { decimalSeparator, thousandsSeparator };
    };
    exports2.getLocaleSeparators = getLocaleSeparators;
  }
});

// node_modules/@trezor/utils/lib/getMutex.js
var require_getMutex = __commonJS({
  "node_modules/@trezor/utils/lib/getMutex.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getMutex = void 0;
    var getMutex = () => {
      const DEFAULT_ID = Symbol();
      const locks = {};
      return async (lockId = DEFAULT_ID) => {
        while (locks[lockId]) {
          await locks[lockId];
        }
        let resolve = () => {
        };
        locks[lockId] = new Promise((res) => {
          resolve = res;
        }).finally(() => {
          delete locks[lockId];
        });
        return resolve;
      };
    };
    exports2.getMutex = getMutex;
  }
});

// node_modules/@trezor/utils/lib/getNumberFromPixelString.js
var require_getNumberFromPixelString = __commonJS({
  "node_modules/@trezor/utils/lib/getNumberFromPixelString.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getNumberFromPixelString = void 0;
    var getNumberFromPixelString = (size) => parseInt(size.replace("px", ""), 10);
    exports2.getNumberFromPixelString = getNumberFromPixelString;
  }
});

// node_modules/@trezor/utils/lib/getRandomInt.js
var require_getRandomInt = __commonJS({
  "node_modules/@trezor/utils/lib/getRandomInt.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getRandomInt = void 0;
    var crypto_1 = require_crypto2();
    var getRandomInt = (min, max) => {
      if (!Number.isSafeInteger(min)) {
        throw new RangeError(`The "min" argument must be a safe integer. Received type ${typeof min} (${min})`);
      }
      if (!Number.isSafeInteger(max)) {
        throw new RangeError(`The "max" argument must be a safe integer. Received type ${typeof max} (${max})`);
      }
      if (min >= max) {
        throw new RangeError(`The value of "max" is out of range. It must be greater than the value of "min" (${min}). Received ${max}`);
      }
      const MAX_RANGE_32_BITS = 4294967295 + 1;
      const range = max - min;
      if (range > MAX_RANGE_32_BITS) {
        throw new RangeError(`This function only provide 32 bits of entropy, therefore range cannot be more then 2^32.`);
      }
      const getRandomValues = typeof window !== "undefined" ? (array2) => window.crypto.getRandomValues(array2) : (array2) => (0, crypto_1.getRandomValues)(array2);
      const array = new Uint32Array(1);
      const maxRange = MAX_RANGE_32_BITS - MAX_RANGE_32_BITS % range;
      let randomValue;
      do {
        getRandomValues(array);
        randomValue = array[0];
      } while (randomValue >= maxRange);
      return min + randomValue % range;
    };
    exports2.getRandomInt = getRandomInt;
  }
});

// node_modules/@trezor/utils/lib/getSynchronize.js
var require_getSynchronize = __commonJS({
  "node_modules/@trezor/utils/lib/getSynchronize.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getSynchronize = void 0;
    var getMutex_1 = require_getMutex();
    var getSynchronize = (mutex) => {
      const lock = mutex ?? (0, getMutex_1.getMutex)();
      return (action, lockId) => lock(lockId).then((unlock) => Promise.resolve().then(action).finally(unlock));
    };
    exports2.getSynchronize = getSynchronize;
  }
});

// node_modules/@trezor/utils/lib/getWeakRandomId.js
var require_getWeakRandomId = __commonJS({
  "node_modules/@trezor/utils/lib/getWeakRandomId.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getWeakRandomId = void 0;
    var getWeakRandomId = (length) => {
      let id2 = "";
      const list = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
      for (let i = 0; i < length; i++) {
        id2 += list.charAt(Math.floor(Math.random() * list.length));
      }
      return id2;
    };
    exports2.getWeakRandomId = getWeakRandomId;
  }
});

// node_modules/@trezor/utils/lib/getWeakRandomInt.js
var require_getWeakRandomInt = __commonJS({
  "node_modules/@trezor/utils/lib/getWeakRandomInt.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getWeakRandomInt = void 0;
    var getWeakRandomInt = (min, max) => {
      if (min >= max) {
        throw new RangeError(`The value of "max" is out of range. It must be greater than the value of "min" (${min}). Received ${max}`);
      }
      return Math.floor(Math.random() * (max - min) + min);
    };
    exports2.getWeakRandomInt = getWeakRandomInt;
  }
});

// node_modules/@trezor/utils/lib/getWeakRandomNumberInRange.js
var require_getWeakRandomNumberInRange = __commonJS({
  "node_modules/@trezor/utils/lib/getWeakRandomNumberInRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getWeakRandomNumberInRange = void 0;
    var getWeakRandomNumberInRange = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
    exports2.getWeakRandomNumberInRange = getWeakRandomNumberInRange;
  }
});

// node_modules/@trezor/utils/lib/hasUppercaseLetter.js
var require_hasUppercaseLetter = __commonJS({
  "node_modules/@trezor/utils/lib/hasUppercaseLetter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hasUppercaseLetter = void 0;
    var HAS_UPPERCASE_LATER_REGEXP = new RegExp("^(.*[A-Z].*)$");
    var hasUppercaseLetter = (value) => HAS_UPPERCASE_LATER_REGEXP.test(value);
    exports2.hasUppercaseLetter = hasUppercaseLetter;
  }
});

// node_modules/@trezor/utils/lib/hexToRgba.js
var require_hexToRgba = __commonJS({
  "node_modules/@trezor/utils/lib/hexToRgba.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hexToRgba = hexToRgba;
    function hexToRgba(hex, alpha) {
      const r = parseInt(hex.slice(1, 3), 16);
      const g = parseInt(hex.slice(3, 5), 16);
      const b2 = parseInt(hex.slice(5, 7), 16);
      if (alpha && alpha > 0) {
        return `rgba(${r}, ${g}, ${b2}, ${alpha})`;
      }
      return `rgb(${r}, ${g}, ${b2})`;
    }
  }
});

// node_modules/@trezor/utils/lib/hexToRgbaArray.js
var require_hexToRgbaArray = __commonJS({
  "node_modules/@trezor/utils/lib/hexToRgbaArray.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hexToRgbaArray = void 0;
    var hexToRgbaArray = (hex) => {
      const norm = hex.replace("#", "");
      const full = norm.length === 6 ? norm + "FF" : norm;
      return [
        parseInt(full.slice(0, 2), 16) / 255,
        parseInt(full.slice(2, 4), 16) / 255,
        parseInt(full.slice(4, 6), 16) / 255,
        parseInt(full.slice(6, 8), 16) / 255
      ];
    };
    exports2.hexToRgbaArray = hexToRgbaArray;
  }
});

// node_modules/@trezor/utils/lib/isApproximatelyEqual.js
var require_isApproximatelyEqual = __commonJS({
  "node_modules/@trezor/utils/lib/isApproximatelyEqual.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isApproximatelyEqual = void 0;
    var bigNumber_1 = require_bigNumber();
    var isApproximatelyEqual = (value1, value2, relativeTolerance) => {
      value1 = new bigNumber_1.BigNumber(value1);
      value2 = new bigNumber_1.BigNumber(value2);
      relativeTolerance = new bigNumber_1.BigNumber(relativeTolerance);
      if (value1.eq(0))
        return value1.eq(value2);
      const relativeDifference = value2.minus(value1).abs().dividedBy(value1);
      return relativeDifference.lte(relativeTolerance);
    };
    exports2.isApproximatelyEqual = isApproximatelyEqual;
  }
});

// node_modules/@trezor/utils/lib/isArrayMember.js
var require_isArrayMember = __commonJS({
  "node_modules/@trezor/utils/lib/isArrayMember.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isArrayMember = void 0;
    var isArrayMember = (value, arr) => arr.some((v) => v === value);
    exports2.isArrayMember = isArrayMember;
  }
});

// node_modules/@trezor/utils/lib/isFullPath.js
var require_isFullPath = __commonJS({
  "node_modules/@trezor/utils/lib/isFullPath.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isFullPath = void 0;
    var isFullPath = (path) => {
      const fullPathPattern = /^(\/|([a-zA-Z]:\\))/;
      return fullPathPattern.test(path);
    };
    exports2.isFullPath = isFullPath;
  }
});

// node_modules/@trezor/utils/lib/isHex.js
var require_isHex = __commonJS({
  "node_modules/@trezor/utils/lib/isHex.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isHex = void 0;
    var isHex = (str) => {
      const regExp = /^(0x|0X)?[0-9A-Fa-f]+$/g;
      return regExp.test(str);
    };
    exports2.isHex = isHex;
  }
});

// node_modules/@trezor/utils/lib/isNotUndefined.js
var require_isNotUndefined = __commonJS({
  "node_modules/@trezor/utils/lib/isNotUndefined.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isNotUndefined = void 0;
    var isNotUndefined = (item) => typeof item !== "undefined";
    exports2.isNotUndefined = isNotUndefined;
  }
});

// node_modules/@trezor/utils/lib/isUrl.js
var require_isUrl = __commonJS({
  "node_modules/@trezor/utils/lib/isUrl.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isUrlWithQuery = exports2.isUrl = void 0;
    var URL_REGEXP = /^(http|ws)s?:\/\/[a-z0-9]([a-z0-9.-]+)?(:[0-9]{1,5})?(\/[a-z0-9-_]+)*\/?$/i;
    var URL_WITH_QUERY_REGEXP = /^(http|ws)s?:\/\/[a-z0-9]([a-z0-9.-]+)?(:[0-9]{1,5})?(\/[a-z0-9-_]+)*\/?(\?[a-z0-9-_]+=[a-z0-9-_]+(&[a-z0-9-_]+=[a-z0-9-_]+)*)?$/i;
    var isUrl = (value) => URL_REGEXP.test(value);
    exports2.isUrl = isUrl;
    var isUrlWithQuery = (value) => URL_WITH_QUERY_REGEXP.test(value);
    exports2.isUrlWithQuery = isUrlWithQuery;
  }
});

// node_modules/@trezor/utils/lib/isWhitelistedHost.js
var require_isWhitelistedHost = __commonJS({
  "node_modules/@trezor/utils/lib/isWhitelistedHost.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isWhitelistedHost = void 0;
    var isWhitelistedHost = (hostname, whitelist = ["127.0.0.1", "localhost"]) => {
      if (typeof hostname !== "string") {
        return false;
      }
      if (hostname.trim() === "") {
        return false;
      }
      return whitelist.some((whitelistedUrl) => whitelistedUrl === hostname || hostname.endsWith(`.${whitelistedUrl}`));
    };
    exports2.isWhitelistedHost = isWhitelistedHost;
  }
});

// node_modules/@trezor/utils/lib/logs.js
var require_logs = __commonJS({
  "node_modules/@trezor/utils/lib/logs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Log = void 0;
    var Log = class {
      prefix;
      enabled;
      css = "";
      messages;
      logWriter;
      MAX_ENTRIES = 100;
      constructor(prefix, enabled, logWriter) {
        this.prefix = prefix;
        this.enabled = enabled;
        this.messages = [];
        if (logWriter) {
          this.logWriter = logWriter;
        }
      }
      setColors(colors) {
        this.css = typeof window !== "undefined" && colors[this.prefix] ? colors[this.prefix] : "";
      }
      addMessage({ level, prefix, timestamp }, ...args) {
        const message = {
          level,
          prefix,
          css: this.css,
          message: args,
          timestamp: timestamp || Date.now()
        };
        this.messages.push(message);
        if (this.logWriter) {
          try {
            this.logWriter.add(message);
          } catch (err) {
            console.error("There was an error adding log message", err, message);
          }
        }
        if (this.messages.length > this.MAX_ENTRIES) {
          this.messages.shift();
        }
      }
      setWriter(logWriter) {
        this.logWriter = logWriter;
      }
      log(...args) {
        this.addMessage({ level: "log", prefix: this.prefix }, ...args);
        if (this.enabled) {
          console.log(`%c${this.prefix}`, this.css, ...args);
        }
      }
      error(...args) {
        this.addMessage({ level: "error", prefix: this.prefix }, ...args);
        if (this.enabled) {
          console.error(`%c${this.prefix}`, this.css, ...args);
        }
      }
      info(...args) {
        this.addMessage({ level: "info", prefix: this.prefix }, ...args);
        if (this.enabled) {
          console.info(`%c${this.prefix}`, this.css, ...args);
        }
      }
      warn(...args) {
        this.addMessage({ level: "warn", prefix: this.prefix }, ...args);
        if (this.enabled) {
          console.warn(`%c${this.prefix}`, this.css, ...args);
        }
      }
      debug(...args) {
        this.addMessage({ level: "debug", prefix: this.prefix }, ...args);
        if (this.enabled) {
          if (this.css) {
            console.log(`%c${this.prefix}`, this.css, ...args);
          } else {
            console.log(this.prefix, ...args);
          }
        }
      }
      getLog() {
        return this.messages;
      }
    };
    exports2.Log = Log;
  }
});

// node_modules/@trezor/utils/lib/logsManager.js
var require_logsManager = __commonJS({
  "node_modules/@trezor/utils/lib/logsManager.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LogsManager = void 0;
    var logs_1 = require_logs();
    var LogsManager = class {
      logs = {};
      writer;
      colors = {};
      constructor({ colors }) {
        this.colors = colors;
      }
      initLog(prefix, enabled, logWriter) {
        const instanceWriter = logWriter || this.writer;
        const instance = new logs_1.Log(prefix, !!enabled, instanceWriter);
        if (this.colors) {
          instance.setColors(this.colors);
        }
        this.logs[prefix] = instance;
        return instance;
      }
      setLogWriter(logWriterFactory) {
        Object.keys(this.logs).forEach((key) => {
          this.writer = logWriterFactory();
          if (this.writer) {
            this.logs[key].setWriter(this.writer);
            const { messages } = this.logs[key];
            messages.forEach((message) => {
              this.writer?.add(message);
            });
          }
        });
      }
      enableLog(enabled) {
        Object.keys(this.logs).forEach((key) => {
          this.logs[key].enabled = !!enabled;
        });
      }
      enableLogByPrefix(prefix, enabled) {
        if (this.logs[prefix]) {
          this.logs[prefix].enabled = enabled;
        }
      }
      getLog() {
        let logs = [];
        Object.keys(this.logs).forEach((key) => {
          logs = logs.concat(this.logs[key].messages);
        });
        logs.sort((a, b2) => a.timestamp - b2.timestamp);
        return logs;
      }
    };
    exports2.LogsManager = LogsManager;
  }
});

// node_modules/@trezor/utils/lib/mergeDeepObject.js
var require_mergeDeepObject = __commonJS({
  "node_modules/@trezor/utils/lib/mergeDeepObject.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeDeepObject = void 0;
    var isObject2 = (obj) => {
      if (typeof obj === "object" && obj !== null) {
        if (typeof Object.getPrototypeOf === "function") {
          const prototype = Object.getPrototypeOf(obj);
          return prototype === Object.prototype || prototype === null;
        }
        return Object.prototype.toString.call(obj) === "[object Object]";
      }
      return false;
    };
    var mergeValuesWithPath = (target, value, [key, ...rest]) => {
      if (key === void 0) {
        return mergeValues(target, value);
      } else if (!isObject2(target)) {
        return { [key]: mergeValuesWithPath({}, value, rest) };
      } else {
        return { ...target, [key]: mergeValuesWithPath(target[key], value, rest) };
      }
    };
    var mergeValues = (target, value) => {
      if (Array.isArray(target) && Array.isArray(value)) {
        return exports2.mergeDeepObject.options.mergeArrays ? Array.from(new Set(target.concat(value))) : value;
      } else if (isObject2(target) && isObject2(value)) {
        return (0, exports2.mergeDeepObject)(target, value);
      } else {
        return value;
      }
    };
    var mergeDeepObject = (...objects) => objects.reduce((result, current) => {
      if (Array.isArray(current)) {
        throw new TypeError("Arguments provided to ts-deepmerge must be objects, not arrays.");
      }
      Object.keys(current).forEach((key) => {
        if (["__proto__", "constructor", "prototype"].includes(key)) {
          return;
        }
        if (exports2.mergeDeepObject.options.dotNotation) {
          const [first, ...rest] = key.split(".");
          result[first] = mergeValuesWithPath(result[first], current[key], rest);
        } else {
          result[key] = mergeValues(result[key], current[key]);
        }
      });
      return result;
    }, {});
    exports2.mergeDeepObject = mergeDeepObject;
    var defaultOptions = {
      mergeArrays: true,
      dotNotation: false
    };
    exports2.mergeDeepObject.options = defaultOptions;
    exports2.mergeDeepObject.withOptions = (options, ...objects) => {
      exports2.mergeDeepObject.options = {
        ...defaultOptions,
        ...options
      };
      const result = (0, exports2.mergeDeepObject)(...objects);
      exports2.mergeDeepObject.options = defaultOptions;
      return result;
    };
  }
});

// node_modules/@trezor/utils/lib/objectPartition.js
var require_objectPartition = __commonJS({
  "node_modules/@trezor/utils/lib/objectPartition.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.objectPartition = void 0;
    var objectPartition = (obj, keys) => keys.reduce(([included, excluded], key) => {
      const { [key]: value, ...rest } = excluded;
      return typeof value !== "undefined" ? [{ ...included, [key]: value }, rest] : [included, excluded];
    }, [{}, obj]);
    exports2.objectPartition = objectPartition;
  }
});

// node_modules/@trezor/utils/lib/parseElectrumUrl.js
var require_parseElectrumUrl = __commonJS({
  "node_modules/@trezor/utils/lib/parseElectrumUrl.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseElectrumUrl = void 0;
    var ELECTRUM_URL_REGEX = /^(?:([a-zA-Z0-9.-]+)|\[([a-f0-9:]+)\]):([0-9]{1,5}):([ts])$/;
    var parseElectrumUrl = (url) => {
      const match = url.match(ELECTRUM_URL_REGEX);
      if (!match)
        return void 0;
      return {
        host: match[1] ?? match[2],
        port: Number.parseInt(match[3], 10),
        protocol: match[4]
      };
    };
    exports2.parseElectrumUrl = parseElectrumUrl;
  }
});

// node_modules/@trezor/utils/lib/parseHostname.js
var require_parseHostname = __commonJS({
  "node_modules/@trezor/utils/lib/parseHostname.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseHostname = void 0;
    var HOSTNAME_REGEX = /^([a-z0-9.+-]+:\/\/)?([a-z0-9.-]+)([:/][^:/]+)*\/?$/i;
    var parseHostname = (url) => url.match(HOSTNAME_REGEX)?.[2]?.toLowerCase();
    exports2.parseHostname = parseHostname;
  }
});

// node_modules/@trezor/utils/lib/promiseAllSequence.js
var require_promiseAllSequence = __commonJS({
  "node_modules/@trezor/utils/lib/promiseAllSequence.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.promiseAllSequence = void 0;
    var promiseAllSequence = async (actions) => {
      const results = [];
      for (let i = 0; i < actions.length; ++i) {
        const result = await actions[i]();
        results.push(result);
      }
      return results;
    };
    exports2.promiseAllSequence = promiseAllSequence;
  }
});

// node_modules/@trezor/utils/lib/redactUserPath.js
var require_redactUserPath = __commonJS({
  "node_modules/@trezor/utils/lib/redactUserPath.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.redactUserPathFromString = exports2.startOfUserPathRegex = void 0;
    exports2.startOfUserPathRegex = /([/\\][Uu]sers[/\\]{1,4})([^"^'^[^\]^/^\\]*)/g;
    var redactUserPathFromString = (text) => text.replace(exports2.startOfUserPathRegex, "$1[*]");
    exports2.redactUserPathFromString = redactUserPathFromString;
  }
});

// node_modules/@trezor/utils/lib/resolveAfter.js
var require_resolveAfter = __commonJS({
  "node_modules/@trezor/utils/lib/resolveAfter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolveAfter = void 0;
    var createDeferred_1 = require_createDeferred();
    var resolveAfter = (msec, signal, value) => {
      const { promise, reject, resolve } = (0, createDeferred_1.createDeferred)();
      const timeout = setTimeout(resolve, msec, value);
      const onAbort = () => reject(signal?.reason);
      signal?.addEventListener("abort", onAbort);
      if (signal?.aborted)
        onAbort();
      return promise.finally(() => {
        clearTimeout(timeout);
        signal?.removeEventListener("abort", onAbort);
      });
    };
    exports2.resolveAfter = resolveAfter;
  }
});

// node_modules/@trezor/utils/lib/scheduleAction.js
var require_scheduleAction = __commonJS({
  "node_modules/@trezor/utils/lib/scheduleAction.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.scheduleAction = exports2.ScheduleActionDeadlineError = exports2.SCHEDULE_ACTION_DEADLINE_ERROR_MESSAGE = exports2.ScheduleActionTimeoutError = exports2.SCHEDULE_ACTION_TIMEOUT_ERROR_MESSAGE = exports2.RejectWhenAbortedError = exports2.SCHEDULE_ACTION_ABORTED_ERROR_MESSAGE = void 0;
    exports2.SCHEDULE_ACTION_ABORTED_ERROR_MESSAGE = "Aborted by signal";
    var RejectWhenAbortedError = class extends Error {
      constructor() {
        super(exports2.SCHEDULE_ACTION_ABORTED_ERROR_MESSAGE);
      }
    };
    exports2.RejectWhenAbortedError = RejectWhenAbortedError;
    var isArray = (attempts) => Array.isArray(attempts);
    var resolveAfterMs = (ms, clear) => new Promise((resolve, reject) => {
      const errorSignal = new RejectWhenAbortedError();
      if (clear.aborted)
        return reject(errorSignal);
      if (ms === void 0)
        return resolve();
      let timeout;
      const onClear = () => {
        clearTimeout(timeout);
        clear.removeEventListener("abort", onClear);
        reject(errorSignal);
      };
      timeout = setTimeout(() => {
        clear.removeEventListener("abort", onClear);
        resolve();
      }, ms);
      clear.addEventListener("abort", onClear);
    });
    var rejectAfterMs = (ms, reason, clear) => new Promise((_, reject) => {
      const errorSignal = new RejectWhenAbortedError();
      if (clear.aborted)
        return reject(errorSignal);
      let timeout;
      const onClear = () => {
        clearTimeout(timeout);
        clear.removeEventListener("abort", onClear);
        reject(errorSignal);
      };
      timeout = setTimeout(() => {
        clear.removeEventListener("abort", onClear);
        reject(reason);
      }, ms);
      clear.addEventListener("abort", onClear);
    });
    var maybeRejectAfterMs = (ms, reason, clear) => ms === void 0 ? [] : [rejectAfterMs(ms, reason, clear)];
    var rejectWhenAborted = (signal, clear) => new Promise((_, reject) => {
      const errorSignal = new RejectWhenAbortedError();
      if (clear.aborted)
        return reject(errorSignal);
      if (signal?.aborted)
        return reject(errorSignal);
      const onAbort = () => reject(errorSignal);
      signal?.addEventListener("abort", onAbort);
      const onClear = () => {
        signal?.removeEventListener("abort", onAbort);
        clear.removeEventListener("abort", onClear);
        reject(errorSignal);
      };
      clear.addEventListener("abort", onClear);
    });
    var resolveAction = async (action, clear) => {
      const aborter = new AbortController();
      if (clear.aborted)
        aborter.abort();
      const onClear = () => {
        clear.removeEventListener("abort", onClear);
        aborter.abort();
      };
      clear.addEventListener("abort", onClear);
      try {
        return await new Promise((resolve) => resolve(action(aborter.signal)));
      } finally {
        if (!clear.aborted)
          clear.removeEventListener("abort", onClear);
      }
    };
    var attemptLoop = async (attempts, attempt, failure, clear) => {
      for (let a = 0; a < attempts - 1; a++) {
        if (clear.aborted)
          break;
        const aborter = new AbortController();
        const onClear = () => aborter.abort();
        clear.addEventListener("abort", onClear);
        try {
          return await attempt(a, aborter.signal);
        } catch (error) {
          onClear();
          await failure(a, error);
        } finally {
          clear.removeEventListener("abort", onClear);
        }
      }
      return clear.aborted ? Promise.reject(new RejectWhenAbortedError()) : attempt(attempts - 1, clear);
    };
    exports2.SCHEDULE_ACTION_TIMEOUT_ERROR_MESSAGE = "Aborted by timeout";
    var ScheduleActionTimeoutError = class extends Error {
      constructor() {
        super(exports2.SCHEDULE_ACTION_TIMEOUT_ERROR_MESSAGE);
      }
    };
    exports2.ScheduleActionTimeoutError = ScheduleActionTimeoutError;
    exports2.SCHEDULE_ACTION_DEADLINE_ERROR_MESSAGE = "Aborted by deadline";
    var ScheduleActionDeadlineError = class extends Error {
      constructor() {
        super(exports2.SCHEDULE_ACTION_DEADLINE_ERROR_MESSAGE);
      }
    };
    exports2.ScheduleActionDeadlineError = ScheduleActionDeadlineError;
    var scheduleAction = async (action, params) => {
      const { signal, delay, attempts, timeout, deadline, gap, attemptFailureHandler } = params;
      const deadlineMs = deadline && deadline - Date.now();
      const attemptCount = isArray(attempts) ? attempts.length : attempts ?? (deadline ? Infinity : 1);
      const clearAborter = new AbortController();
      const clear = clearAborter.signal;
      const getParams = isArray(attempts) ? (attempt) => attempts[attempt] : () => ({ timeout, gap });
      const errorDeadline = new ScheduleActionDeadlineError();
      const errorTimeout = new ScheduleActionTimeoutError();
      const graceful = params.graceful && signal;
      const actionAborter = new AbortController();
      if (graceful) {
        if (signal.aborted) {
          actionAborter.abort();
        } else {
          const onAbort = () => {
            signal.removeEventListener("abort", onAbort);
            clear.removeEventListener("abort", onAbort);
            actionAborter.abort();
          };
          signal.addEventListener("abort", onAbort);
          clear.addEventListener("abort", onAbort);
        }
      }
      try {
        return await Promise.race([
          ...graceful ? [] : [rejectWhenAborted(signal, clear)],
          ...maybeRejectAfterMs(deadlineMs, errorDeadline, clear),
          resolveAfterMs(delay, clear).then(() => attemptLoop(attemptCount, (attempt, abort) => Promise.race([
            ...maybeRejectAfterMs(getParams(attempt).timeout, errorTimeout, clear),
            resolveAction(action, abort)
          ]), (attempt, error) => {
            const errorHandlerResult = attemptFailureHandler?.(error);
            return errorHandlerResult ? Promise.reject(errorHandlerResult) : resolveAfterMs(getParams(attempt).gap ?? 0, clear);
          }, graceful ? actionAborter.signal : clear))
        ]);
      } finally {
        clearAborter.abort();
      }
    };
    exports2.scheduleAction = scheduleAction;
  }
});

// node_modules/@trezor/utils/lib/serializeError.js
var require_serializeError = __commonJS({
  "node_modules/@trezor/utils/lib/serializeError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.serializeError = void 0;
    var serializeError2 = (error) => {
      if (error instanceof Error) {
        return JSON.stringify({ message: error.toString(), stackTrace: error.stack });
      }
      if (typeof error === "object") {
        return JSON.stringify(error);
      }
      return `${error}`;
    };
    exports2.serializeError = serializeError2;
  }
});

// node_modules/@trezor/utils/lib/splitStringEveryNCharacters.js
var require_splitStringEveryNCharacters = __commonJS({
  "node_modules/@trezor/utils/lib/splitStringEveryNCharacters.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.splitStringEveryNCharacters = splitStringEveryNCharacters;
    function splitStringEveryNCharacters(value, n) {
      if (n === 0) {
        return [];
      }
      const regex = new RegExp(`.{1,${n}}`, "g");
      return value.match(regex) ?? [];
    }
  }
});

// node_modules/@trezor/utils/lib/throttler.js
var require_throttler = __commonJS({
  "node_modules/@trezor/utils/lib/throttler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Throttler = void 0;
    var Throttler = class {
      delay;
      intervals;
      callbacks;
      constructor(delay) {
        this.delay = delay;
        this.intervals = {};
        this.callbacks = {};
      }
      throttle(id2, callback) {
        if (this.intervals[id2]) {
          this.callbacks[id2] = callback;
        } else {
          callback();
          this.intervals[id2] = setInterval(() => this.tick(id2), this.delay);
        }
      }
      tick(id2) {
        if (this.callbacks[id2]) {
          this.callbacks[id2]();
          delete this.callbacks[id2];
        } else {
          this.cancel(id2);
        }
      }
      cancel(id2) {
        clearInterval(this.intervals[id2]);
        delete this.intervals[id2];
        delete this.callbacks[id2];
      }
      dispose() {
        Object.keys(this.intervals).forEach(this.cancel, this);
      }
    };
    exports2.Throttler = Throttler;
  }
});

// node_modules/@trezor/utils/lib/topologicalSort.js
var require_topologicalSort = __commonJS({
  "node_modules/@trezor/utils/lib/topologicalSort.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.topologicalSort = void 0;
    var arrayPartition_1 = require_arrayPartition();
    var topologicalSort = (elements, precedes, tie) => {
      const result = [];
      const filterRoots = (verts) => (0, arrayPartition_1.arrayPartition)(verts, (succ) => !verts.some((pred) => precedes(pred, succ)));
      let elem = elements;
      while (elem.length) {
        const [roots, rest] = filterRoots(elem);
        if (!roots.length)
          throw new Error("Cycle detected");
        result.push(...tie ? roots.sort(tie) : roots);
        elem = rest;
      }
      return result;
    };
    exports2.topologicalSort = topologicalSort;
  }
});

// node_modules/@trezor/utils/lib/typedObject.js
var require_typedObject = __commonJS({
  "node_modules/@trezor/utils/lib/typedObject.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.typedObjectValues = exports2.typedObjectKeys = exports2.typedObjectEntries = void 0;
    exports2.typedObjectFromEntries = typedObjectFromEntries;
    var typedObjectEntries = (obj) => Object.entries(obj);
    exports2.typedObjectEntries = typedObjectEntries;
    function typedObjectFromEntries(entries) {
      return Object.fromEntries(entries);
    }
    var typedObjectKeys = (obj) => Object.keys(obj);
    exports2.typedObjectKeys = typedObjectKeys;
    var typedObjectValues = (obj) => Object.values(obj);
    exports2.typedObjectValues = typedObjectValues;
  }
});

// node_modules/@trezor/utils/lib/typedEventEmitter.js
var require_typedEventEmitter = __commonJS({
  "node_modules/@trezor/utils/lib/typedEventEmitter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypedEmitter = void 0;
    var events_1 = require_events();
    var TypedEmitter = class extends events_1.EventEmitter {
      listenerCount(eventName) {
        return super.listenerCount(eventName);
      }
    };
    exports2.TypedEmitter = TypedEmitter;
  }
});

// node_modules/@trezor/utils/lib/urlToOnion.js
var require_urlToOnion = __commonJS({
  "node_modules/@trezor/utils/lib/urlToOnion.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.urlToOnion = void 0;
    var urlToOnion = (url, onionDomains) => {
      const [, protocol, subdomain, domain, rest] = url.match(/^(http|ws)s?:\/\/([^:/]+\.)?([^/.]+\.[^/.]+)(\/.*)?$/i) ?? [];
      if (!domain || !onionDomains[domain])
        return;
      return `${protocol}://${subdomain ?? ""}${onionDomains[domain]}${rest ?? ""}`;
    };
    exports2.urlToOnion = urlToOnion;
  }
});

// node_modules/@trezor/utils/lib/zip.js
var require_zip = __commonJS({
  "node_modules/@trezor/utils/lib/zip.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createZip = void 0;
    var createZip = (buffers) => {
      const fileEntries = [];
      const centralDirectory = [];
      let offset = 0;
      buffers.forEach(({ name, content }) => {
        const fileData = content;
        const fileHeader = new Uint8Array(30 + name.length);
        const localFileHeader = new DataView(fileHeader.buffer);
        localFileHeader.setUint32(0, 67324752, true);
        localFileHeader.setUint16(4, 0, true);
        localFileHeader.setUint16(6, 0, true);
        localFileHeader.setUint16(8, 0, true);
        localFileHeader.setUint16(10, 0, true);
        localFileHeader.setUint16(12, 0, true);
        localFileHeader.setUint32(14, 0, true);
        localFileHeader.setUint32(18, fileData.byteLength, true);
        localFileHeader.setUint32(22, fileData.byteLength, true);
        localFileHeader.setUint16(26, name.length, true);
        fileHeader.set(new TextEncoder().encode(name), 30);
        fileEntries.push(fileHeader, fileData);
        const centralHeader = new Uint8Array(46 + name.length);
        const centralView = new DataView(centralHeader.buffer);
        centralView.setUint32(0, 33639248, true);
        centralView.setUint16(4, 0, true);
        centralView.setUint16(6, 0, true);
        centralView.setUint16(8, 0, true);
        centralView.setUint16(10, 0, true);
        centralView.setUint16(12, 0, true);
        centralView.setUint16(14, 0, true);
        centralView.setUint32(16, 0, true);
        centralView.setUint32(20, fileData.byteLength, true);
        centralView.setUint32(24, fileData.byteLength, true);
        centralView.setUint16(28, name.length, true);
        centralView.setUint32(42, offset, true);
        centralHeader.set(new TextEncoder().encode(name), 46);
        centralDirectory.push(centralHeader);
        offset += fileHeader.length + fileData.byteLength;
      });
      const eocd = new Uint8Array(22);
      const eocdView = new DataView(eocd.buffer);
      eocdView.setUint32(0, 101010256, true);
      eocdView.setUint16(8, centralDirectory.length, true);
      eocdView.setUint16(10, centralDirectory.length, true);
      eocdView.setUint32(12, centralDirectory.reduce((sum, cd) => sum + cd.byteLength, 0), true);
      eocdView.setUint32(16, offset, true);
      return new Blob([...fileEntries, ...centralDirectory, eocd], {
        type: "application/zip"
      });
    };
    exports2.createZip = createZip;
  }
});

// node_modules/@trezor/utils/lib/removeTrailingSlashes.js
var require_removeTrailingSlashes = __commonJS({
  "node_modules/@trezor/utils/lib/removeTrailingSlashes.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.removeTrailingSlashes = void 0;
    var removeTrailingSlashes = (input) => {
      if (!input) {
        return input || "";
      }
      let i = input.length;
      while (i > 0 && input[i - 1] === "/") {
        i--;
      }
      return input.substring(0, i);
    };
    exports2.removeTrailingSlashes = removeTrailingSlashes;
  }
});

// node_modules/@trezor/utils/lib/getIntegerInRangeFromString.js
var require_getIntegerInRangeFromString = __commonJS({
  "node_modules/@trezor/utils/lib/getIntegerInRangeFromString.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getIntegerInRangeFromString = void 0;
    var getIntegerInRangeFromString = (input, max) => {
      let hash = 0;
      if (input.length === 0) {
        return 0;
      }
      for (let i = 0; i < input.length; i++) {
        const char = input.charCodeAt(i);
        hash = (hash << 5) - hash + char;
        hash |= 0;
      }
      return Math.abs(hash % max);
    };
    exports2.getIntegerInRangeFromString = getIntegerInRangeFromString;
  }
});

// node_modules/@trezor/utils/lib/safeBigIntStringify.js
var require_safeBigIntStringify = __commonJS({
  "node_modules/@trezor/utils/lib/safeBigIntStringify.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.safeBigIntStringify = void 0;
    var safeBigIntStringify = (v) => JSON.stringify(v, (_k, val) => typeof val === "bigint" ? val.toString() : val);
    exports2.safeBigIntStringify = safeBigIntStringify;
  }
});

// node_modules/@trezor/utils/lib/union.js
var require_union = __commonJS({
  "node_modules/@trezor/utils/lib/union.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.union = union;
    function union(data) {
      return [...new Set(data)];
    }
  }
});

// node_modules/@trezor/utils/lib/isInt.js
var require_isInt = __commonJS({
  "node_modules/@trezor/utils/lib/isInt.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isInt = isInt;
    function isInt(value) {
      return Number.isInteger(value);
    }
  }
});

// node_modules/@trezor/utils/lib/index.js
var require_lib = __commonJS({
  "node_modules/@trezor/utils/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isApproximatelyEqual = exports2.hexToRgbaArray = exports2.hexToRgba = exports2.xssFilters = exports2.versionUtils = exports2.enumUtils = exports2.bufferUtils = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    exports2.bufferUtils = tslib_1.__importStar(require_bufferUtils());
    exports2.enumUtils = tslib_1.__importStar(require_enumUtils());
    exports2.versionUtils = tslib_1.__importStar(require_versionUtils());
    exports2.xssFilters = tslib_1.__importStar(require_xssFilters());
    tslib_1.__exportStar(require_addDashesToSpaces(), exports2);
    tslib_1.__exportStar(require_arrayDistinct(), exports2);
    tslib_1.__exportStar(require_arrayPartition(), exports2);
    tslib_1.__exportStar(require_arrayShuffle(), exports2);
    tslib_1.__exportStar(require_arrayToDictionary(), exports2);
    tslib_1.__exportStar(require_asciiUtils(), exports2);
    tslib_1.__exportStar(require_bigNumber(), exports2);
    tslib_1.__exportStar(require_bytesToHumanReadable(), exports2);
    tslib_1.__exportStar(require_cache(), exports2);
    tslib_1.__exportStar(require_capitalizeFirstLetter(), exports2);
    tslib_1.__exportStar(require_cloneObject(), exports2);
    tslib_1.__exportStar(require_comparison(), exports2);
    tslib_1.__exportStar(require_convertTaprootXpub(), exports2);
    tslib_1.__exportStar(require_countBytesInString(), exports2);
    tslib_1.__exportStar(require_createCooldown(), exports2);
    tslib_1.__exportStar(require_createDeferred(), exports2);
    tslib_1.__exportStar(require_createDeferredManager(), exports2);
    tslib_1.__exportStar(require_createLazy(), exports2);
    tslib_1.__exportStar(require_extractUrlsFromText(), exports2);
    tslib_1.__exportStar(require_getLocaleSeparators(), exports2);
    tslib_1.__exportStar(require_getMutex(), exports2);
    tslib_1.__exportStar(require_getNumberFromPixelString(), exports2);
    tslib_1.__exportStar(require_getRandomInt(), exports2);
    tslib_1.__exportStar(require_getSynchronize(), exports2);
    tslib_1.__exportStar(require_getWeakRandomId(), exports2);
    tslib_1.__exportStar(require_getWeakRandomInt(), exports2);
    tslib_1.__exportStar(require_getWeakRandomNumberInRange(), exports2);
    tslib_1.__exportStar(require_hasUppercaseLetter(), exports2);
    var hexToRgba_1 = require_hexToRgba();
    Object.defineProperty(exports2, "hexToRgba", { enumerable: true, get: function() {
      return hexToRgba_1.hexToRgba;
    } });
    var hexToRgbaArray_1 = require_hexToRgbaArray();
    Object.defineProperty(exports2, "hexToRgbaArray", { enumerable: true, get: function() {
      return hexToRgbaArray_1.hexToRgbaArray;
    } });
    var isApproximatelyEqual_1 = require_isApproximatelyEqual();
    Object.defineProperty(exports2, "isApproximatelyEqual", { enumerable: true, get: function() {
      return isApproximatelyEqual_1.isApproximatelyEqual;
    } });
    tslib_1.__exportStar(require_isArrayMember(), exports2);
    tslib_1.__exportStar(require_isFullPath(), exports2);
    tslib_1.__exportStar(require_isHex(), exports2);
    tslib_1.__exportStar(require_isNotUndefined(), exports2);
    tslib_1.__exportStar(require_isUrl(), exports2);
    tslib_1.__exportStar(require_isWhitelistedHost(), exports2);
    tslib_1.__exportStar(require_logs(), exports2);
    tslib_1.__exportStar(require_logsManager(), exports2);
    tslib_1.__exportStar(require_mergeDeepObject(), exports2);
    tslib_1.__exportStar(require_objectPartition(), exports2);
    tslib_1.__exportStar(require_parseElectrumUrl(), exports2);
    tslib_1.__exportStar(require_parseHostname(), exports2);
    tslib_1.__exportStar(require_promiseAllSequence(), exports2);
    tslib_1.__exportStar(require_redactUserPath(), exports2);
    tslib_1.__exportStar(require_resolveAfter(), exports2);
    tslib_1.__exportStar(require_scheduleAction(), exports2);
    tslib_1.__exportStar(require_serializeError(), exports2);
    tslib_1.__exportStar(require_splitStringEveryNCharacters(), exports2);
    tslib_1.__exportStar(require_throttler(), exports2);
    tslib_1.__exportStar(require_throwError(), exports2);
    tslib_1.__exportStar(require_topologicalSort(), exports2);
    tslib_1.__exportStar(require_typedObject(), exports2);
    tslib_1.__exportStar(require_typedEventEmitter(), exports2);
    tslib_1.__exportStar(require_urlToOnion(), exports2);
    tslib_1.__exportStar(require_zip(), exports2);
    tslib_1.__exportStar(require_removeTrailingSlashes(), exports2);
    tslib_1.__exportStar(require_getIntegerInRangeFromString(), exports2);
    tslib_1.__exportStar(require_safeBigIntStringify(), exports2);
    tslib_1.__exportStar(require_union(), exports2);
    tslib_1.__exportStar(require_isInt(), exports2);
  }
});

// node_modules/@trezor/connect/lib/constants/network.js
var require_network = __commonJS({
  "node_modules/@trezor/connect/lib/constants/network.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MODULES = exports2.TYPES = void 0;
    exports2.TYPES = {
      bitcoin: "Bitcoin",
      ethereum: "Ethereum",
      eos: "Eos",
      nem: "NEM",
      stellar: "Stellar",
      cardano: "Cardano",
      ripple: "Ripple",
      tezos: "Tezos",
      binance: "Binance",
      solana: "Solana"
    };
    exports2.MODULES = [
      "cardano",
      "eos",
      "ethereum",
      "nem",
      "ripple",
      "solana",
      "stellar",
      "tezos"
    ];
  }
});

// node_modules/@trezor/connect/lib/constants/cardano.js
var require_cardano = __commonJS({
  "node_modules/@trezor/connect/lib/constants/cardano.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ALGORITHM_IDS = exports2.NETWORK_IDS = exports2.PROTOCOL_MAGICS = void 0;
    var PROTOCOL_MAGICS;
    (function(PROTOCOL_MAGICS2) {
      PROTOCOL_MAGICS2[PROTOCOL_MAGICS2["mainnet"] = 764824073] = "mainnet";
      PROTOCOL_MAGICS2[PROTOCOL_MAGICS2["testnet_preprod"] = 1] = "testnet_preprod";
      PROTOCOL_MAGICS2[PROTOCOL_MAGICS2["testnet_preview"] = 2] = "testnet_preview";
      PROTOCOL_MAGICS2[PROTOCOL_MAGICS2["testnet_legacy"] = 1097911063] = "testnet_legacy";
    })(PROTOCOL_MAGICS || (exports2.PROTOCOL_MAGICS = PROTOCOL_MAGICS = {}));
    var NETWORK_IDS;
    (function(NETWORK_IDS2) {
      NETWORK_IDS2[NETWORK_IDS2["mainnet"] = 1] = "mainnet";
      NETWORK_IDS2[NETWORK_IDS2["testnet"] = 0] = "testnet";
    })(NETWORK_IDS || (exports2.NETWORK_IDS = NETWORK_IDS = {}));
    var ALGORITHM_IDS;
    (function(ALGORITHM_IDS2) {
      ALGORITHM_IDS2[ALGORITHM_IDS2["EdDSA"] = -8] = "EdDSA";
    })(ALGORITHM_IDS || (exports2.ALGORITHM_IDS = ALGORITHM_IDS = {}));
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/guard/value.js
var require_value = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/guard/value.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.HasPropertyKey = HasPropertyKey;
    exports2.IsAsyncIterator = IsAsyncIterator;
    exports2.IsArray = IsArray;
    exports2.IsBigInt = IsBigInt;
    exports2.IsBoolean = IsBoolean;
    exports2.IsDate = IsDate;
    exports2.IsFunction = IsFunction;
    exports2.IsIterator = IsIterator;
    exports2.IsNull = IsNull;
    exports2.IsNumber = IsNumber;
    exports2.IsObject = IsObject;
    exports2.IsRegExp = IsRegExp;
    exports2.IsString = IsString;
    exports2.IsSymbol = IsSymbol;
    exports2.IsUint8Array = IsUint8Array;
    exports2.IsUndefined = IsUndefined;
    function HasPropertyKey(value, key) {
      return key in value;
    }
    function IsAsyncIterator(value) {
      return IsObject(value) && !IsArray(value) && !IsUint8Array(value) && Symbol.asyncIterator in value;
    }
    function IsArray(value) {
      return Array.isArray(value);
    }
    function IsBigInt(value) {
      return typeof value === "bigint";
    }
    function IsBoolean(value) {
      return typeof value === "boolean";
    }
    function IsDate(value) {
      return value instanceof globalThis.Date;
    }
    function IsFunction(value) {
      return typeof value === "function";
    }
    function IsIterator(value) {
      return IsObject(value) && !IsArray(value) && !IsUint8Array(value) && Symbol.iterator in value;
    }
    function IsNull(value) {
      return value === null;
    }
    function IsNumber(value) {
      return typeof value === "number";
    }
    function IsObject(value) {
      return typeof value === "object" && value !== null;
    }
    function IsRegExp(value) {
      return value instanceof globalThis.RegExp;
    }
    function IsString(value) {
      return typeof value === "string";
    }
    function IsSymbol(value) {
      return typeof value === "symbol";
    }
    function IsUint8Array(value) {
      return value instanceof globalThis.Uint8Array;
    }
    function IsUndefined(value) {
      return value === void 0;
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/clone/value.js
var require_value2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/clone/value.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Clone = Clone;
    var ValueGuard = require_value();
    function ArrayType(value) {
      return value.map((value2) => Visit(value2));
    }
    function DateType(value) {
      return new Date(value.getTime());
    }
    function Uint8ArrayType(value) {
      return new Uint8Array(value);
    }
    function RegExpType(value) {
      return new RegExp(value.source, value.flags);
    }
    function ObjectType(value) {
      const result = {};
      for (const key of Object.getOwnPropertyNames(value)) {
        result[key] = Visit(value[key]);
      }
      for (const key of Object.getOwnPropertySymbols(value)) {
        result[key] = Visit(value[key]);
      }
      return result;
    }
    function Visit(value) {
      return ValueGuard.IsArray(value) ? ArrayType(value) : ValueGuard.IsDate(value) ? DateType(value) : ValueGuard.IsUint8Array(value) ? Uint8ArrayType(value) : ValueGuard.IsRegExp(value) ? RegExpType(value) : ValueGuard.IsObject(value) ? ObjectType(value) : value;
    }
    function Clone(value) {
      return Visit(value);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/clone/type.js
var require_type2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/clone/type.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CloneRest = CloneRest;
    exports2.CloneType = CloneType;
    var value_1 = require_value2();
    function CloneRest(schemas) {
      return schemas.map((schema) => CloneType(schema));
    }
    function CloneType(schema, options) {
      return options === void 0 ? (0, value_1.Clone)(schema) : (0, value_1.Clone)({ ...options, ...schema });
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/clone/index.js
var require_clone = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/clone/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_type2(), exports2);
    __exportStar2(require_value2(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/guard/guard.js
var require_guard = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/value/guard/guard.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsAsyncIterator = IsAsyncIterator;
    exports2.IsIterator = IsIterator;
    exports2.IsStandardObject = IsStandardObject;
    exports2.IsInstanceObject = IsInstanceObject;
    exports2.IsPromise = IsPromise;
    exports2.IsDate = IsDate;
    exports2.IsMap = IsMap;
    exports2.IsSet = IsSet;
    exports2.IsRegExp = IsRegExp;
    exports2.IsTypedArray = IsTypedArray;
    exports2.IsInt8Array = IsInt8Array;
    exports2.IsUint8Array = IsUint8Array;
    exports2.IsUint8ClampedArray = IsUint8ClampedArray;
    exports2.IsInt16Array = IsInt16Array;
    exports2.IsUint16Array = IsUint16Array;
    exports2.IsInt32Array = IsInt32Array;
    exports2.IsUint32Array = IsUint32Array;
    exports2.IsFloat32Array = IsFloat32Array;
    exports2.IsFloat64Array = IsFloat64Array;
    exports2.IsBigInt64Array = IsBigInt64Array;
    exports2.IsBigUint64Array = IsBigUint64Array;
    exports2.HasPropertyKey = HasPropertyKey;
    exports2.IsObject = IsObject;
    exports2.IsArray = IsArray;
    exports2.IsUndefined = IsUndefined;
    exports2.IsNull = IsNull;
    exports2.IsBoolean = IsBoolean;
    exports2.IsNumber = IsNumber;
    exports2.IsInteger = IsInteger;
    exports2.IsBigInt = IsBigInt;
    exports2.IsString = IsString;
    exports2.IsFunction = IsFunction;
    exports2.IsSymbol = IsSymbol;
    exports2.IsValueType = IsValueType;
    function IsAsyncIterator(value) {
      return IsObject(value) && Symbol.asyncIterator in value;
    }
    function IsIterator(value) {
      return IsObject(value) && Symbol.iterator in value;
    }
    function IsStandardObject(value) {
      return IsObject(value) && (Object.getPrototypeOf(value) === Object.prototype || Object.getPrototypeOf(value) === null);
    }
    function IsInstanceObject(value) {
      return IsObject(value) && !IsArray(value) && IsFunction(value.constructor) && value.constructor.name !== "Object";
    }
    function IsPromise(value) {
      return value instanceof Promise;
    }
    function IsDate(value) {
      return value instanceof Date && Number.isFinite(value.getTime());
    }
    function IsMap(value) {
      return value instanceof globalThis.Map;
    }
    function IsSet(value) {
      return value instanceof globalThis.Set;
    }
    function IsRegExp(value) {
      return value instanceof globalThis.RegExp;
    }
    function IsTypedArray(value) {
      return ArrayBuffer.isView(value);
    }
    function IsInt8Array(value) {
      return value instanceof globalThis.Int8Array;
    }
    function IsUint8Array(value) {
      return value instanceof globalThis.Uint8Array;
    }
    function IsUint8ClampedArray(value) {
      return value instanceof globalThis.Uint8ClampedArray;
    }
    function IsInt16Array(value) {
      return value instanceof globalThis.Int16Array;
    }
    function IsUint16Array(value) {
      return value instanceof globalThis.Uint16Array;
    }
    function IsInt32Array(value) {
      return value instanceof globalThis.Int32Array;
    }
    function IsUint32Array(value) {
      return value instanceof globalThis.Uint32Array;
    }
    function IsFloat32Array(value) {
      return value instanceof globalThis.Float32Array;
    }
    function IsFloat64Array(value) {
      return value instanceof globalThis.Float64Array;
    }
    function IsBigInt64Array(value) {
      return value instanceof globalThis.BigInt64Array;
    }
    function IsBigUint64Array(value) {
      return value instanceof globalThis.BigUint64Array;
    }
    function HasPropertyKey(value, key) {
      return key in value;
    }
    function IsObject(value) {
      return value !== null && typeof value === "object";
    }
    function IsArray(value) {
      return Array.isArray(value) && !ArrayBuffer.isView(value);
    }
    function IsUndefined(value) {
      return value === void 0;
    }
    function IsNull(value) {
      return value === null;
    }
    function IsBoolean(value) {
      return typeof value === "boolean";
    }
    function IsNumber(value) {
      return typeof value === "number";
    }
    function IsInteger(value) {
      return Number.isInteger(value);
    }
    function IsBigInt(value) {
      return typeof value === "bigint";
    }
    function IsString(value) {
      return typeof value === "string";
    }
    function IsFunction(value) {
      return typeof value === "function";
    }
    function IsSymbol(value) {
      return typeof value === "symbol";
    }
    function IsValueType(value) {
      return IsBigInt(value) || IsBoolean(value) || IsNull(value) || IsNumber(value) || IsString(value) || IsSymbol(value) || IsUndefined(value);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/guard/index.js
var require_guard2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/value/guard/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_guard(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/system/policy.js
var require_policy = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/system/policy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeSystemPolicy = void 0;
    var index_1 = require_guard2();
    var TypeSystemPolicy;
    (function(TypeSystemPolicy2) {
      TypeSystemPolicy2.InstanceMode = "default";
      TypeSystemPolicy2.ExactOptionalPropertyTypes = false;
      TypeSystemPolicy2.AllowArrayObject = false;
      TypeSystemPolicy2.AllowNaN = false;
      TypeSystemPolicy2.AllowNullVoid = false;
      function IsExactOptionalProperty(value, key) {
        return TypeSystemPolicy2.ExactOptionalPropertyTypes ? key in value : value[key] !== void 0;
      }
      TypeSystemPolicy2.IsExactOptionalProperty = IsExactOptionalProperty;
      function IsObjectLike(value) {
        const isObject2 = (0, index_1.IsObject)(value);
        return TypeSystemPolicy2.AllowArrayObject ? isObject2 : isObject2 && !(0, index_1.IsArray)(value);
      }
      TypeSystemPolicy2.IsObjectLike = IsObjectLike;
      function IsRecordLike(value) {
        return IsObjectLike(value) && !(value instanceof Date) && !(value instanceof Uint8Array);
      }
      TypeSystemPolicy2.IsRecordLike = IsRecordLike;
      function IsNumberLike(value) {
        return TypeSystemPolicy2.AllowNaN ? (0, index_1.IsNumber)(value) : Number.isFinite(value);
      }
      TypeSystemPolicy2.IsNumberLike = IsNumberLike;
      function IsVoidLike(value) {
        const isUndefined = (0, index_1.IsUndefined)(value);
        return TypeSystemPolicy2.AllowNullVoid ? isUndefined || value === null : isUndefined;
      }
      TypeSystemPolicy2.IsVoidLike = IsVoidLike;
    })(TypeSystemPolicy || (exports2.TypeSystemPolicy = TypeSystemPolicy = {}));
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/create/immutable.js
var require_immutable = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/create/immutable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Immutable = Immutable;
    var ValueGuard = require_value();
    function ImmutableArray(value) {
      return globalThis.Object.freeze(value).map((value2) => Immutable(value2));
    }
    function ImmutableDate(value) {
      return value;
    }
    function ImmutableUint8Array(value) {
      return value;
    }
    function ImmutableRegExp(value) {
      return value;
    }
    function ImmutableObject(value) {
      const result = {};
      for (const key of Object.getOwnPropertyNames(value)) {
        result[key] = Immutable(value[key]);
      }
      for (const key of Object.getOwnPropertySymbols(value)) {
        result[key] = Immutable(value[key]);
      }
      return globalThis.Object.freeze(result);
    }
    function Immutable(value) {
      return ValueGuard.IsArray(value) ? ImmutableArray(value) : ValueGuard.IsDate(value) ? ImmutableDate(value) : ValueGuard.IsUint8Array(value) ? ImmutableUint8Array(value) : ValueGuard.IsRegExp(value) ? ImmutableRegExp(value) : ValueGuard.IsObject(value) ? ImmutableObject(value) : value;
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/create/type.js
var require_type3 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/create/type.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CreateType = CreateType;
    var policy_1 = require_policy();
    var immutable_1 = require_immutable();
    var value_1 = require_value2();
    function CreateType(schema, options) {
      const result = options !== void 0 ? { ...options, ...schema } : schema;
      switch (policy_1.TypeSystemPolicy.InstanceMode) {
        case "freeze":
          return (0, immutable_1.Immutable)(result);
        case "clone":
          return (0, value_1.Clone)(result);
        default:
          return result;
      }
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/create/index.js
var require_create = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/create/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_type3(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/error/error.js
var require_error = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/error/error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeBoxError = void 0;
    var TypeBoxError = class extends Error {
      constructor(message) {
        super(message);
      }
    };
    exports2.TypeBoxError = TypeBoxError;
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/error/index.js
var require_error2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/error/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_error(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/symbols/symbols.js
var require_symbols = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/symbols/symbols.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Kind = exports2.Hint = exports2.OptionalKind = exports2.ReadonlyKind = exports2.TransformKind = void 0;
    exports2.TransformKind = Symbol.for("TypeBox.Transform");
    exports2.ReadonlyKind = Symbol.for("TypeBox.Readonly");
    exports2.OptionalKind = Symbol.for("TypeBox.Optional");
    exports2.Hint = Symbol.for("TypeBox.Hint");
    exports2.Kind = Symbol.for("TypeBox.Kind");
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/symbols/index.js
var require_symbols2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/symbols/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_symbols(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/guard/kind.js
var require_kind = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/guard/kind.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsReadonly = IsReadonly;
    exports2.IsOptional = IsOptional;
    exports2.IsAny = IsAny;
    exports2.IsArray = IsArray;
    exports2.IsAsyncIterator = IsAsyncIterator;
    exports2.IsBigInt = IsBigInt;
    exports2.IsBoolean = IsBoolean;
    exports2.IsConstructor = IsConstructor;
    exports2.IsDate = IsDate;
    exports2.IsFunction = IsFunction;
    exports2.IsInteger = IsInteger;
    exports2.IsProperties = IsProperties;
    exports2.IsIntersect = IsIntersect;
    exports2.IsIterator = IsIterator;
    exports2.IsKindOf = IsKindOf;
    exports2.IsLiteralString = IsLiteralString;
    exports2.IsLiteralNumber = IsLiteralNumber;
    exports2.IsLiteralBoolean = IsLiteralBoolean;
    exports2.IsLiteral = IsLiteral;
    exports2.IsMappedKey = IsMappedKey;
    exports2.IsMappedResult = IsMappedResult;
    exports2.IsNever = IsNever;
    exports2.IsNot = IsNot;
    exports2.IsNull = IsNull;
    exports2.IsNumber = IsNumber;
    exports2.IsObject = IsObject;
    exports2.IsPromise = IsPromise;
    exports2.IsRecord = IsRecord;
    exports2.IsRecursive = IsRecursive;
    exports2.IsRef = IsRef;
    exports2.IsRegExp = IsRegExp;
    exports2.IsString = IsString;
    exports2.IsSymbol = IsSymbol;
    exports2.IsTemplateLiteral = IsTemplateLiteral;
    exports2.IsThis = IsThis;
    exports2.IsTransform = IsTransform;
    exports2.IsTuple = IsTuple;
    exports2.IsUndefined = IsUndefined;
    exports2.IsUnion = IsUnion;
    exports2.IsUint8Array = IsUint8Array;
    exports2.IsUnknown = IsUnknown;
    exports2.IsUnsafe = IsUnsafe;
    exports2.IsVoid = IsVoid;
    exports2.IsKind = IsKind;
    exports2.IsSchema = IsSchema;
    var ValueGuard = require_value();
    var index_1 = require_symbols2();
    function IsReadonly(value) {
      return ValueGuard.IsObject(value) && value[index_1.ReadonlyKind] === "Readonly";
    }
    function IsOptional(value) {
      return ValueGuard.IsObject(value) && value[index_1.OptionalKind] === "Optional";
    }
    function IsAny(value) {
      return IsKindOf(value, "Any");
    }
    function IsArray(value) {
      return IsKindOf(value, "Array");
    }
    function IsAsyncIterator(value) {
      return IsKindOf(value, "AsyncIterator");
    }
    function IsBigInt(value) {
      return IsKindOf(value, "BigInt");
    }
    function IsBoolean(value) {
      return IsKindOf(value, "Boolean");
    }
    function IsConstructor(value) {
      return IsKindOf(value, "Constructor");
    }
    function IsDate(value) {
      return IsKindOf(value, "Date");
    }
    function IsFunction(value) {
      return IsKindOf(value, "Function");
    }
    function IsInteger(value) {
      return IsKindOf(value, "Integer");
    }
    function IsProperties(value) {
      return ValueGuard.IsObject(value);
    }
    function IsIntersect(value) {
      return IsKindOf(value, "Intersect");
    }
    function IsIterator(value) {
      return IsKindOf(value, "Iterator");
    }
    function IsKindOf(value, kind) {
      return ValueGuard.IsObject(value) && index_1.Kind in value && value[index_1.Kind] === kind;
    }
    function IsLiteralString(value) {
      return IsLiteral(value) && ValueGuard.IsString(value.const);
    }
    function IsLiteralNumber(value) {
      return IsLiteral(value) && ValueGuard.IsNumber(value.const);
    }
    function IsLiteralBoolean(value) {
      return IsLiteral(value) && ValueGuard.IsBoolean(value.const);
    }
    function IsLiteral(value) {
      return IsKindOf(value, "Literal");
    }
    function IsMappedKey(value) {
      return IsKindOf(value, "MappedKey");
    }
    function IsMappedResult(value) {
      return IsKindOf(value, "MappedResult");
    }
    function IsNever(value) {
      return IsKindOf(value, "Never");
    }
    function IsNot(value) {
      return IsKindOf(value, "Not");
    }
    function IsNull(value) {
      return IsKindOf(value, "Null");
    }
    function IsNumber(value) {
      return IsKindOf(value, "Number");
    }
    function IsObject(value) {
      return IsKindOf(value, "Object");
    }
    function IsPromise(value) {
      return IsKindOf(value, "Promise");
    }
    function IsRecord(value) {
      return IsKindOf(value, "Record");
    }
    function IsRecursive(value) {
      return ValueGuard.IsObject(value) && index_1.Hint in value && value[index_1.Hint] === "Recursive";
    }
    function IsRef(value) {
      return IsKindOf(value, "Ref");
    }
    function IsRegExp(value) {
      return IsKindOf(value, "RegExp");
    }
    function IsString(value) {
      return IsKindOf(value, "String");
    }
    function IsSymbol(value) {
      return IsKindOf(value, "Symbol");
    }
    function IsTemplateLiteral(value) {
      return IsKindOf(value, "TemplateLiteral");
    }
    function IsThis(value) {
      return IsKindOf(value, "This");
    }
    function IsTransform(value) {
      return ValueGuard.IsObject(value) && index_1.TransformKind in value;
    }
    function IsTuple(value) {
      return IsKindOf(value, "Tuple");
    }
    function IsUndefined(value) {
      return IsKindOf(value, "Undefined");
    }
    function IsUnion(value) {
      return IsKindOf(value, "Union");
    }
    function IsUint8Array(value) {
      return IsKindOf(value, "Uint8Array");
    }
    function IsUnknown(value) {
      return IsKindOf(value, "Unknown");
    }
    function IsUnsafe(value) {
      return IsKindOf(value, "Unsafe");
    }
    function IsVoid(value) {
      return IsKindOf(value, "Void");
    }
    function IsKind(value) {
      return ValueGuard.IsObject(value) && index_1.Kind in value && ValueGuard.IsString(value[index_1.Kind]);
    }
    function IsSchema(value) {
      return IsAny(value) || IsArray(value) || IsBoolean(value) || IsBigInt(value) || IsAsyncIterator(value) || IsConstructor(value) || IsDate(value) || IsFunction(value) || IsInteger(value) || IsIntersect(value) || IsIterator(value) || IsLiteral(value) || IsMappedKey(value) || IsMappedResult(value) || IsNever(value) || IsNot(value) || IsNull(value) || IsNumber(value) || IsObject(value) || IsPromise(value) || IsRecord(value) || IsRef(value) || IsRegExp(value) || IsString(value) || IsSymbol(value) || IsTemplateLiteral(value) || IsThis(value) || IsTuple(value) || IsUndefined(value) || IsUnion(value) || IsUint8Array(value) || IsUnknown(value) || IsUnsafe(value) || IsVoid(value) || IsKind(value);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/guard/type.js
var require_type4 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/guard/type.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeGuardUnknownTypeError = void 0;
    exports2.IsReadonly = IsReadonly;
    exports2.IsOptional = IsOptional;
    exports2.IsAny = IsAny;
    exports2.IsArray = IsArray;
    exports2.IsAsyncIterator = IsAsyncIterator;
    exports2.IsBigInt = IsBigInt;
    exports2.IsBoolean = IsBoolean;
    exports2.IsConstructor = IsConstructor;
    exports2.IsDate = IsDate;
    exports2.IsFunction = IsFunction;
    exports2.IsInteger = IsInteger;
    exports2.IsProperties = IsProperties;
    exports2.IsIntersect = IsIntersect;
    exports2.IsIterator = IsIterator;
    exports2.IsKindOf = IsKindOf;
    exports2.IsLiteralString = IsLiteralString;
    exports2.IsLiteralNumber = IsLiteralNumber;
    exports2.IsLiteralBoolean = IsLiteralBoolean;
    exports2.IsLiteral = IsLiteral;
    exports2.IsLiteralValue = IsLiteralValue;
    exports2.IsMappedKey = IsMappedKey;
    exports2.IsMappedResult = IsMappedResult;
    exports2.IsNever = IsNever;
    exports2.IsNot = IsNot;
    exports2.IsNull = IsNull;
    exports2.IsNumber = IsNumber;
    exports2.IsObject = IsObject;
    exports2.IsPromise = IsPromise;
    exports2.IsRecord = IsRecord;
    exports2.IsRecursive = IsRecursive;
    exports2.IsRef = IsRef;
    exports2.IsRegExp = IsRegExp;
    exports2.IsString = IsString;
    exports2.IsSymbol = IsSymbol;
    exports2.IsTemplateLiteral = IsTemplateLiteral;
    exports2.IsThis = IsThis;
    exports2.IsTransform = IsTransform;
    exports2.IsTuple = IsTuple;
    exports2.IsUndefined = IsUndefined;
    exports2.IsUnionLiteral = IsUnionLiteral;
    exports2.IsUnion = IsUnion;
    exports2.IsUint8Array = IsUint8Array;
    exports2.IsUnknown = IsUnknown;
    exports2.IsUnsafe = IsUnsafe;
    exports2.IsVoid = IsVoid;
    exports2.IsKind = IsKind;
    exports2.IsSchema = IsSchema;
    var ValueGuard = require_value();
    var index_1 = require_symbols2();
    var index_2 = require_error2();
    var TypeGuardUnknownTypeError = class extends index_2.TypeBoxError {
    };
    exports2.TypeGuardUnknownTypeError = TypeGuardUnknownTypeError;
    var KnownTypes = [
      "Any",
      "Array",
      "AsyncIterator",
      "BigInt",
      "Boolean",
      "Constructor",
      "Date",
      "Enum",
      "Function",
      "Integer",
      "Intersect",
      "Iterator",
      "Literal",
      "MappedKey",
      "MappedResult",
      "Not",
      "Null",
      "Number",
      "Object",
      "Promise",
      "Record",
      "Ref",
      "RegExp",
      "String",
      "Symbol",
      "TemplateLiteral",
      "This",
      "Tuple",
      "Undefined",
      "Union",
      "Uint8Array",
      "Unknown",
      "Void"
    ];
    function IsPattern(value) {
      try {
        new RegExp(value);
        return true;
      } catch {
        return false;
      }
    }
    function IsControlCharacterFree(value) {
      if (!ValueGuard.IsString(value))
        return false;
      for (let i = 0; i < value.length; i++) {
        const code = value.charCodeAt(i);
        if (code >= 7 && code <= 13 || code === 27 || code === 127) {
          return false;
        }
      }
      return true;
    }
    function IsAdditionalProperties(value) {
      return IsOptionalBoolean(value) || IsSchema(value);
    }
    function IsOptionalBigInt(value) {
      return ValueGuard.IsUndefined(value) || ValueGuard.IsBigInt(value);
    }
    function IsOptionalNumber(value) {
      return ValueGuard.IsUndefined(value) || ValueGuard.IsNumber(value);
    }
    function IsOptionalBoolean(value) {
      return ValueGuard.IsUndefined(value) || ValueGuard.IsBoolean(value);
    }
    function IsOptionalString(value) {
      return ValueGuard.IsUndefined(value) || ValueGuard.IsString(value);
    }
    function IsOptionalPattern(value) {
      return ValueGuard.IsUndefined(value) || ValueGuard.IsString(value) && IsControlCharacterFree(value) && IsPattern(value);
    }
    function IsOptionalFormat(value) {
      return ValueGuard.IsUndefined(value) || ValueGuard.IsString(value) && IsControlCharacterFree(value);
    }
    function IsOptionalSchema(value) {
      return ValueGuard.IsUndefined(value) || IsSchema(value);
    }
    function IsReadonly(value) {
      return ValueGuard.IsObject(value) && value[index_1.ReadonlyKind] === "Readonly";
    }
    function IsOptional(value) {
      return ValueGuard.IsObject(value) && value[index_1.OptionalKind] === "Optional";
    }
    function IsAny(value) {
      return IsKindOf(value, "Any") && IsOptionalString(value.$id);
    }
    function IsArray(value) {
      return IsKindOf(value, "Array") && value.type === "array" && IsOptionalString(value.$id) && IsSchema(value.items) && IsOptionalNumber(value.minItems) && IsOptionalNumber(value.maxItems) && IsOptionalBoolean(value.uniqueItems) && IsOptionalSchema(value.contains) && IsOptionalNumber(value.minContains) && IsOptionalNumber(value.maxContains);
    }
    function IsAsyncIterator(value) {
      return IsKindOf(value, "AsyncIterator") && value.type === "AsyncIterator" && IsOptionalString(value.$id) && IsSchema(value.items);
    }
    function IsBigInt(value) {
      return IsKindOf(value, "BigInt") && value.type === "bigint" && IsOptionalString(value.$id) && IsOptionalBigInt(value.exclusiveMaximum) && IsOptionalBigInt(value.exclusiveMinimum) && IsOptionalBigInt(value.maximum) && IsOptionalBigInt(value.minimum) && IsOptionalBigInt(value.multipleOf);
    }
    function IsBoolean(value) {
      return IsKindOf(value, "Boolean") && value.type === "boolean" && IsOptionalString(value.$id);
    }
    function IsConstructor(value) {
      return IsKindOf(value, "Constructor") && value.type === "Constructor" && IsOptionalString(value.$id) && ValueGuard.IsArray(value.parameters) && value.parameters.every((schema) => IsSchema(schema)) && IsSchema(value.returns);
    }
    function IsDate(value) {
      return IsKindOf(value, "Date") && value.type === "Date" && IsOptionalString(value.$id) && IsOptionalNumber(value.exclusiveMaximumTimestamp) && IsOptionalNumber(value.exclusiveMinimumTimestamp) && IsOptionalNumber(value.maximumTimestamp) && IsOptionalNumber(value.minimumTimestamp) && IsOptionalNumber(value.multipleOfTimestamp);
    }
    function IsFunction(value) {
      return IsKindOf(value, "Function") && value.type === "Function" && IsOptionalString(value.$id) && ValueGuard.IsArray(value.parameters) && value.parameters.every((schema) => IsSchema(schema)) && IsSchema(value.returns);
    }
    function IsInteger(value) {
      return IsKindOf(value, "Integer") && value.type === "integer" && IsOptionalString(value.$id) && IsOptionalNumber(value.exclusiveMaximum) && IsOptionalNumber(value.exclusiveMinimum) && IsOptionalNumber(value.maximum) && IsOptionalNumber(value.minimum) && IsOptionalNumber(value.multipleOf);
    }
    function IsProperties(value) {
      return ValueGuard.IsObject(value) && Object.entries(value).every(([key, schema]) => IsControlCharacterFree(key) && IsSchema(schema));
    }
    function IsIntersect(value) {
      return IsKindOf(value, "Intersect") && (ValueGuard.IsString(value.type) && value.type !== "object" ? false : true) && ValueGuard.IsArray(value.allOf) && value.allOf.every((schema) => IsSchema(schema) && !IsTransform(schema)) && IsOptionalString(value.type) && (IsOptionalBoolean(value.unevaluatedProperties) || IsOptionalSchema(value.unevaluatedProperties)) && IsOptionalString(value.$id);
    }
    function IsIterator(value) {
      return IsKindOf(value, "Iterator") && value.type === "Iterator" && IsOptionalString(value.$id) && IsSchema(value.items);
    }
    function IsKindOf(value, kind) {
      return ValueGuard.IsObject(value) && index_1.Kind in value && value[index_1.Kind] === kind;
    }
    function IsLiteralString(value) {
      return IsLiteral(value) && ValueGuard.IsString(value.const);
    }
    function IsLiteralNumber(value) {
      return IsLiteral(value) && ValueGuard.IsNumber(value.const);
    }
    function IsLiteralBoolean(value) {
      return IsLiteral(value) && ValueGuard.IsBoolean(value.const);
    }
    function IsLiteral(value) {
      return IsKindOf(value, "Literal") && IsOptionalString(value.$id) && IsLiteralValue(value.const);
    }
    function IsLiteralValue(value) {
      return ValueGuard.IsBoolean(value) || ValueGuard.IsNumber(value) || ValueGuard.IsString(value);
    }
    function IsMappedKey(value) {
      return IsKindOf(value, "MappedKey") && ValueGuard.IsArray(value.keys) && value.keys.every((key) => ValueGuard.IsNumber(key) || ValueGuard.IsString(key));
    }
    function IsMappedResult(value) {
      return IsKindOf(value, "MappedResult") && IsProperties(value.properties);
    }
    function IsNever(value) {
      return IsKindOf(value, "Never") && ValueGuard.IsObject(value.not) && Object.getOwnPropertyNames(value.not).length === 0;
    }
    function IsNot(value) {
      return IsKindOf(value, "Not") && IsSchema(value.not);
    }
    function IsNull(value) {
      return IsKindOf(value, "Null") && value.type === "null" && IsOptionalString(value.$id);
    }
    function IsNumber(value) {
      return IsKindOf(value, "Number") && value.type === "number" && IsOptionalString(value.$id) && IsOptionalNumber(value.exclusiveMaximum) && IsOptionalNumber(value.exclusiveMinimum) && IsOptionalNumber(value.maximum) && IsOptionalNumber(value.minimum) && IsOptionalNumber(value.multipleOf);
    }
    function IsObject(value) {
      return IsKindOf(value, "Object") && value.type === "object" && IsOptionalString(value.$id) && IsProperties(value.properties) && IsAdditionalProperties(value.additionalProperties) && IsOptionalNumber(value.minProperties) && IsOptionalNumber(value.maxProperties);
    }
    function IsPromise(value) {
      return IsKindOf(value, "Promise") && value.type === "Promise" && IsOptionalString(value.$id) && IsSchema(value.item);
    }
    function IsRecord(value) {
      return IsKindOf(value, "Record") && value.type === "object" && IsOptionalString(value.$id) && IsAdditionalProperties(value.additionalProperties) && ValueGuard.IsObject(value.patternProperties) && ((schema) => {
        const keys = Object.getOwnPropertyNames(schema.patternProperties);
        return keys.length === 1 && IsPattern(keys[0]) && ValueGuard.IsObject(schema.patternProperties) && IsSchema(schema.patternProperties[keys[0]]);
      })(value);
    }
    function IsRecursive(value) {
      return ValueGuard.IsObject(value) && index_1.Hint in value && value[index_1.Hint] === "Recursive";
    }
    function IsRef(value) {
      return IsKindOf(value, "Ref") && IsOptionalString(value.$id) && ValueGuard.IsString(value.$ref);
    }
    function IsRegExp(value) {
      return IsKindOf(value, "RegExp") && IsOptionalString(value.$id) && ValueGuard.IsString(value.source) && ValueGuard.IsString(value.flags) && IsOptionalNumber(value.maxLength) && IsOptionalNumber(value.minLength);
    }
    function IsString(value) {
      return IsKindOf(value, "String") && value.type === "string" && IsOptionalString(value.$id) && IsOptionalNumber(value.minLength) && IsOptionalNumber(value.maxLength) && IsOptionalPattern(value.pattern) && IsOptionalFormat(value.format);
    }
    function IsSymbol(value) {
      return IsKindOf(value, "Symbol") && value.type === "symbol" && IsOptionalString(value.$id);
    }
    function IsTemplateLiteral(value) {
      return IsKindOf(value, "TemplateLiteral") && value.type === "string" && ValueGuard.IsString(value.pattern) && value.pattern[0] === "^" && value.pattern[value.pattern.length - 1] === "$";
    }
    function IsThis(value) {
      return IsKindOf(value, "This") && IsOptionalString(value.$id) && ValueGuard.IsString(value.$ref);
    }
    function IsTransform(value) {
      return ValueGuard.IsObject(value) && index_1.TransformKind in value;
    }
    function IsTuple(value) {
      return IsKindOf(value, "Tuple") && value.type === "array" && IsOptionalString(value.$id) && ValueGuard.IsNumber(value.minItems) && ValueGuard.IsNumber(value.maxItems) && value.minItems === value.maxItems && // empty
      (ValueGuard.IsUndefined(value.items) && ValueGuard.IsUndefined(value.additionalItems) && value.minItems === 0 || ValueGuard.IsArray(value.items) && value.items.every((schema) => IsSchema(schema)));
    }
    function IsUndefined(value) {
      return IsKindOf(value, "Undefined") && value.type === "undefined" && IsOptionalString(value.$id);
    }
    function IsUnionLiteral(value) {
      return IsUnion(value) && value.anyOf.every((schema) => IsLiteralString(schema) || IsLiteralNumber(schema));
    }
    function IsUnion(value) {
      return IsKindOf(value, "Union") && IsOptionalString(value.$id) && ValueGuard.IsObject(value) && ValueGuard.IsArray(value.anyOf) && value.anyOf.every((schema) => IsSchema(schema));
    }
    function IsUint8Array(value) {
      return IsKindOf(value, "Uint8Array") && value.type === "Uint8Array" && IsOptionalString(value.$id) && IsOptionalNumber(value.minByteLength) && IsOptionalNumber(value.maxByteLength);
    }
    function IsUnknown(value) {
      return IsKindOf(value, "Unknown") && IsOptionalString(value.$id);
    }
    function IsUnsafe(value) {
      return IsKindOf(value, "Unsafe");
    }
    function IsVoid(value) {
      return IsKindOf(value, "Void") && value.type === "void" && IsOptionalString(value.$id);
    }
    function IsKind(value) {
      return ValueGuard.IsObject(value) && index_1.Kind in value && ValueGuard.IsString(value[index_1.Kind]) && !KnownTypes.includes(value[index_1.Kind]);
    }
    function IsSchema(value) {
      return ValueGuard.IsObject(value) && (IsAny(value) || IsArray(value) || IsBoolean(value) || IsBigInt(value) || IsAsyncIterator(value) || IsConstructor(value) || IsDate(value) || IsFunction(value) || IsInteger(value) || IsIntersect(value) || IsIterator(value) || IsLiteral(value) || IsMappedKey(value) || IsMappedResult(value) || IsNever(value) || IsNot(value) || IsNull(value) || IsNumber(value) || IsObject(value) || IsPromise(value) || IsRecord(value) || IsRef(value) || IsRegExp(value) || IsString(value) || IsSymbol(value) || IsTemplateLiteral(value) || IsThis(value) || IsTuple(value) || IsUndefined(value) || IsUnion(value) || IsUint8Array(value) || IsUnknown(value) || IsUnsafe(value) || IsVoid(value) || IsKind(value));
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/guard/index.js
var require_guard3 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/guard/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ValueGuard = exports2.TypeGuard = exports2.KindGuard = void 0;
    exports2.KindGuard = require_kind();
    exports2.TypeGuard = require_type4();
    exports2.ValueGuard = require_value();
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/helpers/helpers.js
var require_helpers = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/helpers/helpers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Increment = Increment;
    function Increment(T) {
      return (parseInt(T) + 1).toString();
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/helpers/index.js
var require_helpers2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/helpers/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_helpers(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/patterns/patterns.js
var require_patterns = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/patterns/patterns.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PatternNeverExact = exports2.PatternStringExact = exports2.PatternNumberExact = exports2.PatternBooleanExact = exports2.PatternNever = exports2.PatternString = exports2.PatternNumber = exports2.PatternBoolean = void 0;
    exports2.PatternBoolean = "(true|false)";
    exports2.PatternNumber = "(0|[1-9][0-9]*)";
    exports2.PatternString = "(.*)";
    exports2.PatternNever = "(?!.*)";
    exports2.PatternBooleanExact = `^${exports2.PatternBoolean}$`;
    exports2.PatternNumberExact = `^${exports2.PatternNumber}$`;
    exports2.PatternStringExact = `^${exports2.PatternString}$`;
    exports2.PatternNeverExact = `^${exports2.PatternNever}$`;
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/patterns/index.js
var require_patterns2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/patterns/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_patterns(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/registry/format.js
var require_format = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/registry/format.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Entries = Entries;
    exports2.Clear = Clear;
    exports2.Delete = Delete;
    exports2.Has = Has;
    exports2.Set = Set2;
    exports2.Get = Get;
    var map = /* @__PURE__ */ new Map();
    function Entries() {
      return new Map(map);
    }
    function Clear() {
      return map.clear();
    }
    function Delete(format) {
      return map.delete(format);
    }
    function Has(format) {
      return map.has(format);
    }
    function Set2(format, func) {
      map.set(format, func);
    }
    function Get(format) {
      return map.get(format);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/registry/type.js
var require_type5 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/registry/type.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Entries = Entries;
    exports2.Clear = Clear;
    exports2.Delete = Delete;
    exports2.Has = Has;
    exports2.Set = Set2;
    exports2.Get = Get;
    var map = /* @__PURE__ */ new Map();
    function Entries() {
      return new Map(map);
    }
    function Clear() {
      return map.clear();
    }
    function Delete(kind) {
      return map.delete(kind);
    }
    function Has(kind) {
      return map.has(kind);
    }
    function Set2(kind, func) {
      map.set(kind, func);
    }
    function Get(kind) {
      return map.get(kind);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/registry/index.js
var require_registry = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/registry/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeRegistry = exports2.FormatRegistry = void 0;
    exports2.FormatRegistry = require_format();
    exports2.TypeRegistry = require_type5();
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/sets/set.js
var require_set = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/sets/set.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SetIncludes = SetIncludes;
    exports2.SetIsSubset = SetIsSubset;
    exports2.SetDistinct = SetDistinct;
    exports2.SetIntersect = SetIntersect;
    exports2.SetUnion = SetUnion;
    exports2.SetComplement = SetComplement;
    exports2.SetIntersectMany = SetIntersectMany;
    exports2.SetUnionMany = SetUnionMany;
    function SetIncludes(T, S) {
      return T.includes(S);
    }
    function SetIsSubset(T, S) {
      return T.every((L) => SetIncludes(S, L));
    }
    function SetDistinct(T) {
      return [...new Set(T)];
    }
    function SetIntersect(T, S) {
      return T.filter((L) => S.includes(L));
    }
    function SetUnion(T, S) {
      return [...T, ...S];
    }
    function SetComplement(T, S) {
      return T.filter((L) => !S.includes(L));
    }
    function SetIntersectManyResolve(T, Init) {
      return T.reduce((Acc, L) => {
        return SetIntersect(Acc, L);
      }, Init);
    }
    function SetIntersectMany(T) {
      return T.length === 1 ? T[0] : T.length > 1 ? SetIntersectManyResolve(T.slice(1), T[0]) : [];
    }
    function SetUnionMany(T) {
      const Acc = [];
      for (const L of T)
        Acc.push(...L);
      return Acc;
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/sets/index.js
var require_sets = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/sets/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_set(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/any/any.js
var require_any = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/any/any.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Any = Any;
    var index_1 = require_create();
    var index_2 = require_symbols2();
    function Any(options) {
      return (0, index_1.CreateType)({ [index_2.Kind]: "Any" }, options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/any/index.js
var require_any2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/any/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_any(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/array/array.js
var require_array = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/array/array.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Array = Array2;
    var type_1 = require_type3();
    var index_1 = require_symbols2();
    function Array2(items, options) {
      return (0, type_1.CreateType)({ [index_1.Kind]: "Array", type: "array", items }, options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/array/index.js
var require_array2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/array/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_array(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/async-iterator/async-iterator.js
var require_async_iterator2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/async-iterator/async-iterator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AsyncIterator = AsyncIterator2;
    var index_1 = require_symbols2();
    var type_1 = require_type3();
    function AsyncIterator2(items, options) {
      return (0, type_1.CreateType)({ [index_1.Kind]: "AsyncIterator", type: "AsyncIterator", items }, options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/async-iterator/index.js
var require_async_iterator3 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/async-iterator/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_async_iterator2(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/discard/discard.js
var require_discard = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/discard/discard.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Discard = Discard;
    function DiscardKey(value, key) {
      const { [key]: _, ...rest } = value;
      return rest;
    }
    function Discard(value, keys) {
      return keys.reduce((acc, key) => DiscardKey(acc, key), value);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/discard/index.js
var require_discard2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/discard/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_discard(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/never/never.js
var require_never = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/never/never.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Never = Never;
    var type_1 = require_type3();
    var index_1 = require_symbols2();
    function Never(options) {
      return (0, type_1.CreateType)({ [index_1.Kind]: "Never", not: {} }, options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/never/index.js
var require_never2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/never/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_never(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/mapped/mapped-key.js
var require_mapped_key = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/mapped/mapped-key.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MappedKey = MappedKey;
    var type_1 = require_type3();
    var index_1 = require_symbols2();
    function MappedKey(T) {
      return (0, type_1.CreateType)({
        [index_1.Kind]: "MappedKey",
        keys: T
      });
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/mapped/mapped-result.js
var require_mapped_result = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/mapped/mapped-result.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MappedResult = MappedResult;
    var type_1 = require_type3();
    var index_1 = require_symbols2();
    function MappedResult(properties) {
      return (0, type_1.CreateType)({
        [index_1.Kind]: "MappedResult",
        properties
      });
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/constructor/constructor.js
var require_constructor = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/constructor/constructor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Constructor = Constructor;
    var type_1 = require_type3();
    var index_1 = require_symbols2();
    function Constructor(parameters, returns, options) {
      return (0, type_1.CreateType)({ [index_1.Kind]: "Constructor", type: "Constructor", parameters, returns }, options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/constructor/index.js
var require_constructor2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/constructor/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_constructor(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/function/function.js
var require_function = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/function/function.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Function = Function2;
    var type_1 = require_type3();
    var index_1 = require_symbols2();
    function Function2(parameters, returns, options) {
      return (0, type_1.CreateType)({ [index_1.Kind]: "Function", type: "Function", parameters, returns }, options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/function/index.js
var require_function2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/function/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_function(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/union/union-create.js
var require_union_create = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/union/union-create.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UnionCreate = UnionCreate;
    var type_1 = require_type3();
    var index_1 = require_symbols2();
    function UnionCreate(T, options) {
      return (0, type_1.CreateType)({ [index_1.Kind]: "Union", anyOf: T }, options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/union/union-evaluated.js
var require_union_evaluated = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/union/union-evaluated.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UnionEvaluated = UnionEvaluated;
    var type_1 = require_type3();
    var index_1 = require_symbols2();
    var index_2 = require_discard2();
    var index_3 = require_never2();
    var index_4 = require_optional2();
    var union_create_1 = require_union_create();
    var kind_1 = require_kind();
    function IsUnionOptional(T) {
      return T.some((L) => (0, kind_1.IsOptional)(L));
    }
    function RemoveOptionalFromRest(T) {
      return T.map((L) => (0, kind_1.IsOptional)(L) ? RemoveOptionalFromType(L) : L);
    }
    function RemoveOptionalFromType(T) {
      return (0, index_2.Discard)(T, [index_1.OptionalKind]);
    }
    function ResolveUnion(T, options) {
      return IsUnionOptional(T) ? (0, index_4.Optional)((0, union_create_1.UnionCreate)(RemoveOptionalFromRest(T), options)) : (0, union_create_1.UnionCreate)(RemoveOptionalFromRest(T), options);
    }
    function UnionEvaluated(T, options) {
      return T.length === 0 ? (0, index_3.Never)(options) : T.length === 1 ? (0, type_1.CreateType)(T[0], options) : ResolveUnion(T, options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/union/union-type.js
var require_union_type = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/union/union-type.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var index_1 = require_symbols2();
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/union/union.js
var require_union2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/union/union.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Union = Union;
    var index_1 = require_never2();
    var type_1 = require_type3();
    var union_create_1 = require_union_create();
    function Union(T, options) {
      return T.length === 0 ? (0, index_1.Never)(options) : T.length === 1 ? (0, type_1.CreateType)(T[0], options) : (0, union_create_1.UnionCreate)(T, options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/union/index.js
var require_union3 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/union/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_union_evaluated(), exports2);
    __exportStar2(require_union_type(), exports2);
    __exportStar2(require_union2(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/template-literal/parse.js
var require_parse2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/template-literal/parse.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TemplateLiteralParserError = void 0;
    exports2.TemplateLiteralParse = TemplateLiteralParse;
    exports2.TemplateLiteralParseExact = TemplateLiteralParseExact;
    var index_1 = require_error2();
    var TemplateLiteralParserError = class extends index_1.TypeBoxError {
    };
    exports2.TemplateLiteralParserError = TemplateLiteralParserError;
    function Unescape(pattern) {
      return pattern.replace(/\\\$/g, "$").replace(/\\\*/g, "*").replace(/\\\^/g, "^").replace(/\\\|/g, "|").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
    }
    function IsNonEscaped(pattern, index, char) {
      return pattern[index] === char && pattern.charCodeAt(index - 1) !== 92;
    }
    function IsOpenParen(pattern, index) {
      return IsNonEscaped(pattern, index, "(");
    }
    function IsCloseParen(pattern, index) {
      return IsNonEscaped(pattern, index, ")");
    }
    function IsSeparator(pattern, index) {
      return IsNonEscaped(pattern, index, "|");
    }
    function IsGroup(pattern) {
      if (!(IsOpenParen(pattern, 0) && IsCloseParen(pattern, pattern.length - 1)))
        return false;
      let count = 0;
      for (let index = 0; index < pattern.length; index++) {
        if (IsOpenParen(pattern, index))
          count += 1;
        if (IsCloseParen(pattern, index))
          count -= 1;
        if (count === 0 && index !== pattern.length - 1)
          return false;
      }
      return true;
    }
    function InGroup(pattern) {
      return pattern.slice(1, pattern.length - 1);
    }
    function IsPrecedenceOr(pattern) {
      let count = 0;
      for (let index = 0; index < pattern.length; index++) {
        if (IsOpenParen(pattern, index))
          count += 1;
        if (IsCloseParen(pattern, index))
          count -= 1;
        if (IsSeparator(pattern, index) && count === 0)
          return true;
      }
      return false;
    }
    function IsPrecedenceAnd(pattern) {
      for (let index = 0; index < pattern.length; index++) {
        if (IsOpenParen(pattern, index))
          return true;
      }
      return false;
    }
    function Or(pattern) {
      let [count, start] = [0, 0];
      const expressions = [];
      for (let index = 0; index < pattern.length; index++) {
        if (IsOpenParen(pattern, index))
          count += 1;
        if (IsCloseParen(pattern, index))
          count -= 1;
        if (IsSeparator(pattern, index) && count === 0) {
          const range2 = pattern.slice(start, index);
          if (range2.length > 0)
            expressions.push(TemplateLiteralParse(range2));
          start = index + 1;
        }
      }
      const range = pattern.slice(start);
      if (range.length > 0)
        expressions.push(TemplateLiteralParse(range));
      if (expressions.length === 0)
        return { type: "const", const: "" };
      if (expressions.length === 1)
        return expressions[0];
      return { type: "or", expr: expressions };
    }
    function And(pattern) {
      function Group(value, index) {
        if (!IsOpenParen(value, index))
          throw new TemplateLiteralParserError(`TemplateLiteralParser: Index must point to open parens`);
        let count = 0;
        for (let scan = index; scan < value.length; scan++) {
          if (IsOpenParen(value, scan))
            count += 1;
          if (IsCloseParen(value, scan))
            count -= 1;
          if (count === 0)
            return [index, scan];
        }
        throw new TemplateLiteralParserError(`TemplateLiteralParser: Unclosed group parens in expression`);
      }
      function Range(pattern2, index) {
        for (let scan = index; scan < pattern2.length; scan++) {
          if (IsOpenParen(pattern2, scan))
            return [index, scan];
        }
        return [index, pattern2.length];
      }
      const expressions = [];
      for (let index = 0; index < pattern.length; index++) {
        if (IsOpenParen(pattern, index)) {
          const [start, end] = Group(pattern, index);
          const range = pattern.slice(start, end + 1);
          expressions.push(TemplateLiteralParse(range));
          index = end;
        } else {
          const [start, end] = Range(pattern, index);
          const range = pattern.slice(start, end);
          if (range.length > 0)
            expressions.push(TemplateLiteralParse(range));
          index = end - 1;
        }
      }
      return expressions.length === 0 ? { type: "const", const: "" } : expressions.length === 1 ? expressions[0] : { type: "and", expr: expressions };
    }
    function TemplateLiteralParse(pattern) {
      return IsGroup(pattern) ? TemplateLiteralParse(InGroup(pattern)) : IsPrecedenceOr(pattern) ? Or(pattern) : IsPrecedenceAnd(pattern) ? And(pattern) : { type: "const", const: Unescape(pattern) };
    }
    function TemplateLiteralParseExact(pattern) {
      return TemplateLiteralParse(pattern.slice(1, pattern.length - 1));
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/template-literal/finite.js
var require_finite = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/template-literal/finite.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TemplateLiteralFiniteError = void 0;
    exports2.IsTemplateLiteralExpressionFinite = IsTemplateLiteralExpressionFinite;
    exports2.IsTemplateLiteralFinite = IsTemplateLiteralFinite;
    var parse_1 = require_parse2();
    var index_1 = require_error2();
    var TemplateLiteralFiniteError = class extends index_1.TypeBoxError {
    };
    exports2.TemplateLiteralFiniteError = TemplateLiteralFiniteError;
    function IsNumberExpression(expression) {
      return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "0" && expression.expr[1].type === "const" && expression.expr[1].const === "[1-9][0-9]*";
    }
    function IsBooleanExpression(expression) {
      return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "true" && expression.expr[1].type === "const" && expression.expr[1].const === "false";
    }
    function IsStringExpression(expression) {
      return expression.type === "const" && expression.const === ".*";
    }
    function IsTemplateLiteralExpressionFinite(expression) {
      return IsNumberExpression(expression) || IsStringExpression(expression) ? false : IsBooleanExpression(expression) ? true : expression.type === "and" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) : expression.type === "or" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) : expression.type === "const" ? true : (() => {
        throw new TemplateLiteralFiniteError(`Unknown expression type`);
      })();
    }
    function IsTemplateLiteralFinite(schema) {
      const expression = (0, parse_1.TemplateLiteralParseExact)(schema.pattern);
      return IsTemplateLiteralExpressionFinite(expression);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/template-literal/generate.js
var require_generate = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/template-literal/generate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TemplateLiteralGenerateError = void 0;
    exports2.TemplateLiteralExpressionGenerate = TemplateLiteralExpressionGenerate;
    exports2.TemplateLiteralGenerate = TemplateLiteralGenerate;
    var finite_1 = require_finite();
    var parse_1 = require_parse2();
    var index_1 = require_error2();
    var TemplateLiteralGenerateError = class extends index_1.TypeBoxError {
    };
    exports2.TemplateLiteralGenerateError = TemplateLiteralGenerateError;
    function* GenerateReduce(buffer) {
      if (buffer.length === 1)
        return yield* buffer[0];
      for (const left of buffer[0]) {
        for (const right of GenerateReduce(buffer.slice(1))) {
          yield `${left}${right}`;
        }
      }
    }
    function* GenerateAnd(expression) {
      return yield* GenerateReduce(expression.expr.map((expr) => [...TemplateLiteralExpressionGenerate(expr)]));
    }
    function* GenerateOr(expression) {
      for (const expr of expression.expr)
        yield* TemplateLiteralExpressionGenerate(expr);
    }
    function* GenerateConst(expression) {
      return yield expression.const;
    }
    function* TemplateLiteralExpressionGenerate(expression) {
      return expression.type === "and" ? yield* GenerateAnd(expression) : expression.type === "or" ? yield* GenerateOr(expression) : expression.type === "const" ? yield* GenerateConst(expression) : (() => {
        throw new TemplateLiteralGenerateError("Unknown expression");
      })();
    }
    function TemplateLiteralGenerate(schema) {
      const expression = (0, parse_1.TemplateLiteralParseExact)(schema.pattern);
      return (0, finite_1.IsTemplateLiteralExpressionFinite)(expression) ? [...TemplateLiteralExpressionGenerate(expression)] : [];
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/literal/literal.js
var require_literal = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/literal/literal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Literal = Literal;
    var type_1 = require_type3();
    var index_1 = require_symbols2();
    function Literal(value, options) {
      return (0, type_1.CreateType)({
        [index_1.Kind]: "Literal",
        const: value,
        type: typeof value
      }, options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/literal/index.js
var require_literal2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/literal/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_literal(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/boolean/boolean.js
var require_boolean = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/boolean/boolean.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Boolean = Boolean2;
    var index_1 = require_symbols2();
    var index_2 = require_create();
    function Boolean2(options) {
      return (0, index_2.CreateType)({ [index_1.Kind]: "Boolean", type: "boolean" }, options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/boolean/index.js
var require_boolean2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/boolean/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_boolean(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/bigint/bigint.js
var require_bigint = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/bigint/bigint.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BigInt = BigInt2;
    var index_1 = require_symbols2();
    var index_2 = require_create();
    function BigInt2(options) {
      return (0, index_2.CreateType)({ [index_1.Kind]: "BigInt", type: "bigint" }, options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/bigint/index.js
var require_bigint2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/bigint/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_bigint(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/number/number.js
var require_number = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/number/number.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Number = Number2;
    var type_1 = require_type3();
    var index_1 = require_symbols2();
    function Number2(options) {
      return (0, type_1.CreateType)({ [index_1.Kind]: "Number", type: "number" }, options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/number/index.js
var require_number2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/number/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_number(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/string/string.js
var require_string = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/string/string.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.String = String2;
    var type_1 = require_type3();
    var index_1 = require_symbols2();
    function String2(options) {
      return (0, type_1.CreateType)({ [index_1.Kind]: "String", type: "string" }, options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/string/index.js
var require_string2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/string/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_string(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/template-literal/syntax.js
var require_syntax2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/template-literal/syntax.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TemplateLiteralSyntax = TemplateLiteralSyntax;
    var index_1 = require_literal2();
    var index_2 = require_boolean2();
    var index_3 = require_bigint2();
    var index_4 = require_number2();
    var index_5 = require_string2();
    var index_6 = require_union3();
    var index_7 = require_never2();
    function* FromUnion(syntax) {
      const trim = syntax.trim().replace(/"|'/g, "");
      return trim === "boolean" ? yield (0, index_2.Boolean)() : trim === "number" ? yield (0, index_4.Number)() : trim === "bigint" ? yield (0, index_3.BigInt)() : trim === "string" ? yield (0, index_5.String)() : yield (() => {
        const literals = trim.split("|").map((literal) => (0, index_1.Literal)(literal.trim()));
        return literals.length === 0 ? (0, index_7.Never)() : literals.length === 1 ? literals[0] : (0, index_6.UnionEvaluated)(literals);
      })();
    }
    function* FromTerminal(syntax) {
      if (syntax[1] !== "{") {
        const L = (0, index_1.Literal)("$");
        const R = FromSyntax(syntax.slice(1));
        return yield* [L, ...R];
      }
      for (let i = 2; i < syntax.length; i++) {
        if (syntax[i] === "}") {
          const L = FromUnion(syntax.slice(2, i));
          const R = FromSyntax(syntax.slice(i + 1));
          return yield* [...L, ...R];
        }
      }
      yield (0, index_1.Literal)(syntax);
    }
    function* FromSyntax(syntax) {
      for (let i = 0; i < syntax.length; i++) {
        if (syntax[i] === "$") {
          const L = (0, index_1.Literal)(syntax.slice(0, i));
          const R = FromTerminal(syntax.slice(i));
          return yield* [L, ...R];
        }
      }
      yield (0, index_1.Literal)(syntax);
    }
    function TemplateLiteralSyntax(syntax) {
      return [...FromSyntax(syntax)];
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/template-literal/pattern.js
var require_pattern = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/template-literal/pattern.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TemplateLiteralPatternError = void 0;
    exports2.TemplateLiteralPattern = TemplateLiteralPattern;
    var index_1 = require_patterns2();
    var index_2 = require_symbols2();
    var index_3 = require_error2();
    var kind_1 = require_kind();
    var TemplateLiteralPatternError = class extends index_3.TypeBoxError {
    };
    exports2.TemplateLiteralPatternError = TemplateLiteralPatternError;
    function Escape(value) {
      return value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    function Visit(schema, acc) {
      return (0, kind_1.IsTemplateLiteral)(schema) ? schema.pattern.slice(1, schema.pattern.length - 1) : (0, kind_1.IsUnion)(schema) ? `(${schema.anyOf.map((schema2) => Visit(schema2, acc)).join("|")})` : (0, kind_1.IsNumber)(schema) ? `${acc}${index_1.PatternNumber}` : (0, kind_1.IsInteger)(schema) ? `${acc}${index_1.PatternNumber}` : (0, kind_1.IsBigInt)(schema) ? `${acc}${index_1.PatternNumber}` : (0, kind_1.IsString)(schema) ? `${acc}${index_1.PatternString}` : (0, kind_1.IsLiteral)(schema) ? `${acc}${Escape(schema.const.toString())}` : (0, kind_1.IsBoolean)(schema) ? `${acc}${index_1.PatternBoolean}` : (() => {
        throw new TemplateLiteralPatternError(`Unexpected Kind '${schema[index_2.Kind]}'`);
      })();
    }
    function TemplateLiteralPattern(kinds) {
      return `^${kinds.map((schema) => Visit(schema, "")).join("")}$`;
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/template-literal/union.js
var require_union4 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/template-literal/union.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TemplateLiteralToUnion = TemplateLiteralToUnion;
    var index_1 = require_union3();
    var index_2 = require_literal2();
    var generate_1 = require_generate();
    function TemplateLiteralToUnion(schema) {
      const R = (0, generate_1.TemplateLiteralGenerate)(schema);
      const L = R.map((S) => (0, index_2.Literal)(S));
      return (0, index_1.UnionEvaluated)(L);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/template-literal/template-literal.js
var require_template_literal = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/template-literal/template-literal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TemplateLiteral = TemplateLiteral;
    var type_1 = require_type3();
    var syntax_1 = require_syntax2();
    var pattern_1 = require_pattern();
    var value_1 = require_value();
    var index_1 = require_symbols2();
    function TemplateLiteral(unresolved, options) {
      const pattern = (0, value_1.IsString)(unresolved) ? (0, pattern_1.TemplateLiteralPattern)((0, syntax_1.TemplateLiteralSyntax)(unresolved)) : (0, pattern_1.TemplateLiteralPattern)(unresolved);
      return (0, type_1.CreateType)({ [index_1.Kind]: "TemplateLiteral", type: "string", pattern }, options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/template-literal/index.js
var require_template_literal2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/template-literal/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_finite(), exports2);
    __exportStar2(require_generate(), exports2);
    __exportStar2(require_syntax2(), exports2);
    __exportStar2(require_parse2(), exports2);
    __exportStar2(require_pattern(), exports2);
    __exportStar2(require_union4(), exports2);
    __exportStar2(require_template_literal(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/indexed/indexed-property-keys.js
var require_indexed_property_keys = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/indexed/indexed-property-keys.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IndexPropertyKeys = IndexPropertyKeys;
    var index_1 = require_template_literal2();
    var kind_1 = require_kind();
    function FromTemplateLiteral(T) {
      const R = (0, index_1.TemplateLiteralGenerate)(T);
      return R.map((S) => S.toString());
    }
    function FromUnion(T) {
      const Acc = [];
      for (const L of T)
        Acc.push(...IndexPropertyKeys(L));
      return Acc;
    }
    function FromLiteral(T) {
      return [T.toString()];
    }
    function IndexPropertyKeys(T) {
      return [...new Set((0, kind_1.IsTemplateLiteral)(T) ? FromTemplateLiteral(T) : (0, kind_1.IsUnion)(T) ? FromUnion(T.anyOf) : (0, kind_1.IsLiteral)(T) ? FromLiteral(T.const) : (0, kind_1.IsNumber)(T) ? ["[number]"] : (0, kind_1.IsInteger)(T) ? ["[number]"] : [])];
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/indexed/indexed-from-mapped-result.js
var require_indexed_from_mapped_result = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/indexed/indexed-from-mapped-result.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IndexFromMappedResult = IndexFromMappedResult;
    var index_1 = require_mapped2();
    var indexed_property_keys_1 = require_indexed_property_keys();
    var index_2 = require_indexed2();
    function FromProperties(T, P, options) {
      const Acc = {};
      for (const K2 of Object.getOwnPropertyNames(P)) {
        Acc[K2] = (0, index_2.Index)(T, (0, indexed_property_keys_1.IndexPropertyKeys)(P[K2]), options);
      }
      return Acc;
    }
    function FromMappedResult(T, R, options) {
      return FromProperties(T, R.properties, options);
    }
    function IndexFromMappedResult(T, R, options) {
      const P = FromMappedResult(T, R, options);
      return (0, index_1.MappedResult)(P);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/indexed/indexed.js
var require_indexed = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/indexed/indexed.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IndexFromPropertyKey = IndexFromPropertyKey;
    exports2.IndexFromPropertyKeys = IndexFromPropertyKeys;
    exports2.Index = Index;
    var type_1 = require_type3();
    var index_1 = require_never2();
    var index_2 = require_intersect2();
    var index_3 = require_union3();
    var indexed_property_keys_1 = require_indexed_property_keys();
    var indexed_from_mapped_key_1 = require_indexed_from_mapped_key();
    var indexed_from_mapped_result_1 = require_indexed_from_mapped_result();
    var kind_1 = require_kind();
    function FromRest(T, K) {
      return T.map((L) => IndexFromPropertyKey(L, K));
    }
    function FromIntersectRest(T) {
      return T.filter((L) => !(0, kind_1.IsNever)(L));
    }
    function FromIntersect(T, K) {
      return (0, index_2.IntersectEvaluated)(FromIntersectRest(FromRest(T, K)));
    }
    function FromUnionRest(T) {
      return T.some((L) => (0, kind_1.IsNever)(L)) ? [] : T;
    }
    function FromUnion(T, K) {
      return (0, index_3.UnionEvaluated)(FromUnionRest(FromRest(T, K)));
    }
    function FromTuple(T, K) {
      return K in T ? T[K] : K === "[number]" ? (0, index_3.UnionEvaluated)(T) : (0, index_1.Never)();
    }
    function FromArray(T, K) {
      return K === "[number]" ? T : (0, index_1.Never)();
    }
    function FromProperty(T, K) {
      return K in T ? T[K] : (0, index_1.Never)();
    }
    function IndexFromPropertyKey(T, K) {
      return (0, kind_1.IsIntersect)(T) ? FromIntersect(T.allOf, K) : (0, kind_1.IsUnion)(T) ? FromUnion(T.anyOf, K) : (0, kind_1.IsTuple)(T) ? FromTuple(T.items ?? [], K) : (0, kind_1.IsArray)(T) ? FromArray(T.items, K) : (0, kind_1.IsObject)(T) ? FromProperty(T.properties, K) : (0, index_1.Never)();
    }
    function IndexFromPropertyKeys(T, K) {
      return K.map((L) => IndexFromPropertyKey(T, L));
    }
    function FromSchema(T, K) {
      return (0, index_3.UnionEvaluated)(IndexFromPropertyKeys(T, K));
    }
    function Index(T, K, options) {
      if ((0, kind_1.IsMappedResult)(K))
        return (0, indexed_from_mapped_result_1.IndexFromMappedResult)(T, K, options);
      if ((0, kind_1.IsMappedKey)(K))
        return (0, indexed_from_mapped_key_1.IndexFromMappedKey)(T, K, options);
      return (0, type_1.CreateType)((0, kind_1.IsSchema)(K) ? FromSchema(T, (0, indexed_property_keys_1.IndexPropertyKeys)(K)) : FromSchema(T, K), options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/indexed/indexed-from-mapped-key.js
var require_indexed_from_mapped_key = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/indexed/indexed-from-mapped-key.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IndexFromMappedKey = IndexFromMappedKey;
    var indexed_1 = require_indexed();
    var index_1 = require_mapped2();
    var value_1 = require_value2();
    function MappedIndexPropertyKey(T, K, options) {
      return { [K]: (0, indexed_1.Index)(T, [K], (0, value_1.Clone)(options)) };
    }
    function MappedIndexPropertyKeys(T, K, options) {
      return K.reduce((Acc, L) => {
        return { ...Acc, ...MappedIndexPropertyKey(T, L, options) };
      }, {});
    }
    function MappedIndexProperties(T, K, options) {
      return MappedIndexPropertyKeys(T, K.keys, options);
    }
    function IndexFromMappedKey(T, K, options) {
      const P = MappedIndexProperties(T, K, options);
      return (0, index_1.MappedResult)(P);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/indexed/index.js
var require_indexed2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/indexed/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_indexed_from_mapped_key(), exports2);
    __exportStar2(require_indexed_from_mapped_result(), exports2);
    __exportStar2(require_indexed_property_keys(), exports2);
    __exportStar2(require_indexed(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/iterator/iterator.js
var require_iterator = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/iterator/iterator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Iterator = Iterator2;
    var type_1 = require_type3();
    var index_1 = require_symbols2();
    function Iterator2(items, options) {
      return (0, type_1.CreateType)({ [index_1.Kind]: "Iterator", type: "Iterator", items }, options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/iterator/index.js
var require_iterator2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/iterator/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_iterator(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/object/object.js
var require_object = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/object/object.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Object = void 0;
    var type_1 = require_type3();
    var index_1 = require_symbols2();
    var kind_1 = require_kind();
    function RequiredKeys(properties) {
      const keys = [];
      for (let key in properties) {
        if (!(0, kind_1.IsOptional)(properties[key]))
          keys.push(key);
      }
      return keys;
    }
    function _Object(properties, options) {
      const required = RequiredKeys(properties);
      const schematic = required.length > 0 ? { [index_1.Kind]: "Object", type: "object", properties, required } : { [index_1.Kind]: "Object", type: "object", properties };
      return (0, type_1.CreateType)(schematic, options);
    }
    exports2.Object = _Object;
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/object/index.js
var require_object2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/object/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_object(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/promise/promise.js
var require_promise = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/promise/promise.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Promise = Promise2;
    var type_1 = require_type3();
    var index_1 = require_symbols2();
    function Promise2(item, options) {
      return (0, type_1.CreateType)({ [index_1.Kind]: "Promise", type: "Promise", item }, options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/promise/index.js
var require_promise2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/promise/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_promise(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/readonly/readonly.js
var require_readonly = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/readonly/readonly.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Readonly = Readonly;
    var type_1 = require_type3();
    var index_1 = require_symbols2();
    var index_2 = require_discard2();
    var readonly_from_mapped_result_1 = require_readonly_from_mapped_result();
    var kind_1 = require_kind();
    function RemoveReadonly(schema) {
      return (0, type_1.CreateType)((0, index_2.Discard)(schema, [index_1.ReadonlyKind]));
    }
    function AddReadonly(schema) {
      return (0, type_1.CreateType)({ ...schema, [index_1.ReadonlyKind]: "Readonly" });
    }
    function ReadonlyWithFlag(schema, F) {
      return F === false ? RemoveReadonly(schema) : AddReadonly(schema);
    }
    function Readonly(schema, enable) {
      const F = enable ?? true;
      return (0, kind_1.IsMappedResult)(schema) ? (0, readonly_from_mapped_result_1.ReadonlyFromMappedResult)(schema, F) : ReadonlyWithFlag(schema, F);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/readonly/readonly-from-mapped-result.js
var require_readonly_from_mapped_result = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/readonly/readonly-from-mapped-result.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ReadonlyFromMappedResult = ReadonlyFromMappedResult;
    var index_1 = require_mapped2();
    var readonly_1 = require_readonly();
    function FromProperties(K, F) {
      const Acc = {};
      for (const K2 of globalThis.Object.getOwnPropertyNames(K))
        Acc[K2] = (0, readonly_1.Readonly)(K[K2], F);
      return Acc;
    }
    function FromMappedResult(R, F) {
      return FromProperties(R.properties, F);
    }
    function ReadonlyFromMappedResult(R, F) {
      const P = FromMappedResult(R, F);
      return (0, index_1.MappedResult)(P);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/readonly/index.js
var require_readonly2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/readonly/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_readonly_from_mapped_result(), exports2);
    __exportStar2(require_readonly(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/tuple/tuple.js
var require_tuple = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/tuple/tuple.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Tuple = Tuple;
    var type_1 = require_type3();
    var index_1 = require_symbols2();
    function Tuple(items, options) {
      return (0, type_1.CreateType)(items.length > 0 ? { [index_1.Kind]: "Tuple", type: "array", items, additionalItems: false, minItems: items.length, maxItems: items.length } : { [index_1.Kind]: "Tuple", type: "array", minItems: items.length, maxItems: items.length }, options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/tuple/index.js
var require_tuple2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/tuple/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_tuple(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/mapped/mapped.js
var require_mapped = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/mapped/mapped.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MappedFunctionReturnType = MappedFunctionReturnType;
    exports2.Mapped = Mapped;
    var index_1 = require_symbols2();
    var index_2 = require_discard2();
    var index_3 = require_array2();
    var index_4 = require_async_iterator3();
    var index_5 = require_constructor2();
    var index_6 = require_function2();
    var index_7 = require_indexed2();
    var index_8 = require_intersect2();
    var index_9 = require_iterator2();
    var index_10 = require_literal2();
    var index_11 = require_object2();
    var index_12 = require_optional2();
    var index_13 = require_promise2();
    var index_14 = require_readonly2();
    var index_15 = require_tuple2();
    var index_16 = require_union3();
    var index_17 = require_sets();
    var mapped_result_1 = require_mapped_result();
    var kind_1 = require_kind();
    function FromMappedResult(K, P) {
      return K in P ? FromSchemaType(K, P[K]) : (0, mapped_result_1.MappedResult)(P);
    }
    function MappedKeyToKnownMappedResultProperties(K) {
      return { [K]: (0, index_10.Literal)(K) };
    }
    function MappedKeyToUnknownMappedResultProperties(P) {
      const Acc = {};
      for (const L of P)
        Acc[L] = (0, index_10.Literal)(L);
      return Acc;
    }
    function MappedKeyToMappedResultProperties(K, P) {
      return (0, index_17.SetIncludes)(P, K) ? MappedKeyToKnownMappedResultProperties(K) : MappedKeyToUnknownMappedResultProperties(P);
    }
    function FromMappedKey(K, P) {
      const R = MappedKeyToMappedResultProperties(K, P);
      return FromMappedResult(K, R);
    }
    function FromRest(K, T) {
      return T.map((L) => FromSchemaType(K, L));
    }
    function FromProperties(K, T) {
      const Acc = {};
      for (const K2 of globalThis.Object.getOwnPropertyNames(T))
        Acc[K2] = FromSchemaType(K, T[K2]);
      return Acc;
    }
    function FromSchemaType(K, T) {
      const options = { ...T };
      return (
        // unevaluated modifier types
        (0, kind_1.IsOptional)(T) ? (0, index_12.Optional)(FromSchemaType(K, (0, index_2.Discard)(T, [index_1.OptionalKind]))) : (0, kind_1.IsReadonly)(T) ? (0, index_14.Readonly)(FromSchemaType(K, (0, index_2.Discard)(T, [index_1.ReadonlyKind]))) : (
          // unevaluated mapped types
          (0, kind_1.IsMappedResult)(T) ? FromMappedResult(K, T.properties) : (0, kind_1.IsMappedKey)(T) ? FromMappedKey(K, T.keys) : (
            // unevaluated types
            (0, kind_1.IsConstructor)(T) ? (0, index_5.Constructor)(FromRest(K, T.parameters), FromSchemaType(K, T.returns), options) : (0, kind_1.IsFunction)(T) ? (0, index_6.Function)(FromRest(K, T.parameters), FromSchemaType(K, T.returns), options) : (0, kind_1.IsAsyncIterator)(T) ? (0, index_4.AsyncIterator)(FromSchemaType(K, T.items), options) : (0, kind_1.IsIterator)(T) ? (0, index_9.Iterator)(FromSchemaType(K, T.items), options) : (0, kind_1.IsIntersect)(T) ? (0, index_8.Intersect)(FromRest(K, T.allOf), options) : (0, kind_1.IsUnion)(T) ? (0, index_16.Union)(FromRest(K, T.anyOf), options) : (0, kind_1.IsTuple)(T) ? (0, index_15.Tuple)(FromRest(K, T.items ?? []), options) : (0, kind_1.IsObject)(T) ? (0, index_11.Object)(FromProperties(K, T.properties), options) : (0, kind_1.IsArray)(T) ? (0, index_3.Array)(FromSchemaType(K, T.items), options) : (0, kind_1.IsPromise)(T) ? (0, index_13.Promise)(FromSchemaType(K, T.item), options) : T
          )
        )
      );
    }
    function MappedFunctionReturnType(K, T) {
      const Acc = {};
      for (const L of K)
        Acc[L] = FromSchemaType(L, T);
      return Acc;
    }
    function Mapped(key, map, options) {
      const K = (0, kind_1.IsSchema)(key) ? (0, index_7.IndexPropertyKeys)(key) : key;
      const RT = map({ [index_1.Kind]: "MappedKey", keys: K });
      const R = MappedFunctionReturnType(K, RT);
      return (0, index_11.Object)(R, options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/mapped/index.js
var require_mapped2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/mapped/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_mapped_key(), exports2);
    __exportStar2(require_mapped_result(), exports2);
    __exportStar2(require_mapped(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/optional/optional.js
var require_optional = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/optional/optional.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Optional = Optional;
    var type_1 = require_type3();
    var index_1 = require_symbols2();
    var index_2 = require_discard2();
    var optional_from_mapped_result_1 = require_optional_from_mapped_result();
    var kind_1 = require_kind();
    function RemoveOptional(schema) {
      return (0, type_1.CreateType)((0, index_2.Discard)(schema, [index_1.OptionalKind]));
    }
    function AddOptional(schema) {
      return (0, type_1.CreateType)({ ...schema, [index_1.OptionalKind]: "Optional" });
    }
    function OptionalWithFlag(schema, F) {
      return F === false ? RemoveOptional(schema) : AddOptional(schema);
    }
    function Optional(schema, enable) {
      const F = enable ?? true;
      return (0, kind_1.IsMappedResult)(schema) ? (0, optional_from_mapped_result_1.OptionalFromMappedResult)(schema, F) : OptionalWithFlag(schema, F);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/optional/optional-from-mapped-result.js
var require_optional_from_mapped_result = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/optional/optional-from-mapped-result.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OptionalFromMappedResult = OptionalFromMappedResult;
    var index_1 = require_mapped2();
    var optional_1 = require_optional();
    function FromProperties(P, F) {
      const Acc = {};
      for (const K2 of globalThis.Object.getOwnPropertyNames(P))
        Acc[K2] = (0, optional_1.Optional)(P[K2], F);
      return Acc;
    }
    function FromMappedResult(R, F) {
      return FromProperties(R.properties, F);
    }
    function OptionalFromMappedResult(R, F) {
      const P = FromMappedResult(R, F);
      return (0, index_1.MappedResult)(P);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/optional/index.js
var require_optional2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/optional/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_optional_from_mapped_result(), exports2);
    __exportStar2(require_optional(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/intersect/intersect-create.js
var require_intersect_create = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/intersect/intersect-create.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IntersectCreate = IntersectCreate;
    var type_1 = require_type3();
    var index_1 = require_symbols2();
    var kind_1 = require_kind();
    function IntersectCreate(T, options = {}) {
      const allObjects = T.every((schema) => (0, kind_1.IsObject)(schema));
      const clonedUnevaluatedProperties = (0, kind_1.IsSchema)(options.unevaluatedProperties) ? { unevaluatedProperties: options.unevaluatedProperties } : {};
      return (0, type_1.CreateType)(options.unevaluatedProperties === false || (0, kind_1.IsSchema)(options.unevaluatedProperties) || allObjects ? { ...clonedUnevaluatedProperties, [index_1.Kind]: "Intersect", type: "object", allOf: T } : { ...clonedUnevaluatedProperties, [index_1.Kind]: "Intersect", allOf: T }, options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/intersect/intersect-evaluated.js
var require_intersect_evaluated = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/intersect/intersect-evaluated.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IntersectEvaluated = IntersectEvaluated;
    var index_1 = require_symbols2();
    var type_1 = require_type3();
    var index_2 = require_discard2();
    var index_3 = require_never2();
    var index_4 = require_optional2();
    var intersect_create_1 = require_intersect_create();
    var kind_1 = require_kind();
    function IsIntersectOptional(T) {
      return T.every((L) => (0, kind_1.IsOptional)(L));
    }
    function RemoveOptionalFromType(T) {
      return (0, index_2.Discard)(T, [index_1.OptionalKind]);
    }
    function RemoveOptionalFromRest(T) {
      return T.map((L) => (0, kind_1.IsOptional)(L) ? RemoveOptionalFromType(L) : L);
    }
    function ResolveIntersect(T, options) {
      return IsIntersectOptional(T) ? (0, index_4.Optional)((0, intersect_create_1.IntersectCreate)(RemoveOptionalFromRest(T), options)) : (0, intersect_create_1.IntersectCreate)(RemoveOptionalFromRest(T), options);
    }
    function IntersectEvaluated(T, options = {}) {
      if (T.length === 0)
        return (0, index_3.Never)(options);
      if (T.length === 1)
        return (0, type_1.CreateType)(T[0], options);
      if (T.some((schema) => (0, kind_1.IsTransform)(schema)))
        throw new Error("Cannot intersect transform types");
      return ResolveIntersect(T, options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/intersect/intersect-type.js
var require_intersect_type = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/intersect/intersect-type.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var index_1 = require_symbols2();
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/intersect/intersect.js
var require_intersect = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/intersect/intersect.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Intersect = Intersect;
    var type_1 = require_type3();
    var index_1 = require_never2();
    var intersect_create_1 = require_intersect_create();
    var kind_1 = require_kind();
    function Intersect(T, options) {
      if (T.length === 0)
        return (0, index_1.Never)(options);
      if (T.length === 1)
        return (0, type_1.CreateType)(T[0], options);
      if (T.some((schema) => (0, kind_1.IsTransform)(schema)))
        throw new Error("Cannot intersect transform types");
      return (0, intersect_create_1.IntersectCreate)(T, options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/intersect/index.js
var require_intersect2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/intersect/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_intersect_evaluated(), exports2);
    __exportStar2(require_intersect_type(), exports2);
    __exportStar2(require_intersect(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/awaited/awaited.js
var require_awaited = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/awaited/awaited.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Awaited = Awaited;
    var index_1 = require_intersect2();
    var index_2 = require_union3();
    var type_1 = require_type3();
    var kind_1 = require_kind();
    function FromRest(T) {
      return T.map((L) => AwaitedResolve(L));
    }
    function FromIntersect(T) {
      return (0, index_1.Intersect)(FromRest(T));
    }
    function FromUnion(T) {
      return (0, index_2.Union)(FromRest(T));
    }
    function FromPromise(T) {
      return AwaitedResolve(T);
    }
    function AwaitedResolve(T) {
      return (0, kind_1.IsIntersect)(T) ? FromIntersect(T.allOf) : (0, kind_1.IsUnion)(T) ? FromUnion(T.anyOf) : (0, kind_1.IsPromise)(T) ? FromPromise(T.item) : T;
    }
    function Awaited(T, options) {
      return (0, type_1.CreateType)(AwaitedResolve(T), options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/awaited/index.js
var require_awaited2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/awaited/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_awaited(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/keyof/keyof-property-keys.js
var require_keyof_property_keys = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/keyof/keyof-property-keys.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KeyOfPropertyKeys = KeyOfPropertyKeys;
    exports2.KeyOfPattern = KeyOfPattern;
    var index_1 = require_sets();
    var kind_1 = require_kind();
    function FromRest(T) {
      const Acc = [];
      for (const L of T)
        Acc.push(KeyOfPropertyKeys(L));
      return Acc;
    }
    function FromIntersect(T) {
      const C = FromRest(T);
      const R = (0, index_1.SetUnionMany)(C);
      return R;
    }
    function FromUnion(T) {
      const C = FromRest(T);
      const R = (0, index_1.SetIntersectMany)(C);
      return R;
    }
    function FromTuple(T) {
      return T.map((_, I) => I.toString());
    }
    function FromArray(_) {
      return ["[number]"];
    }
    function FromProperties(T) {
      return globalThis.Object.getOwnPropertyNames(T);
    }
    function FromPatternProperties(patternProperties) {
      if (!includePatternProperties)
        return [];
      const patternPropertyKeys = globalThis.Object.getOwnPropertyNames(patternProperties);
      return patternPropertyKeys.map((key) => {
        return key[0] === "^" && key[key.length - 1] === "$" ? key.slice(1, key.length - 1) : key;
      });
    }
    function KeyOfPropertyKeys(T) {
      return (0, kind_1.IsIntersect)(T) ? FromIntersect(T.allOf) : (0, kind_1.IsUnion)(T) ? FromUnion(T.anyOf) : (0, kind_1.IsTuple)(T) ? FromTuple(T.items ?? []) : (0, kind_1.IsArray)(T) ? FromArray(T.items) : (0, kind_1.IsObject)(T) ? FromProperties(T.properties) : (0, kind_1.IsRecord)(T) ? FromPatternProperties(T.patternProperties) : [];
    }
    var includePatternProperties = false;
    function KeyOfPattern(schema) {
      includePatternProperties = true;
      const keys = KeyOfPropertyKeys(schema);
      includePatternProperties = false;
      const pattern = keys.map((key) => `(${key})`);
      return `^(${pattern.join("|")})$`;
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/keyof/keyof.js
var require_keyof = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/keyof/keyof.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KeyOfPropertyKeysToRest = KeyOfPropertyKeysToRest;
    exports2.KeyOf = KeyOf;
    var type_1 = require_type3();
    var index_1 = require_literal2();
    var index_2 = require_number2();
    var keyof_property_keys_1 = require_keyof_property_keys();
    var index_3 = require_union3();
    var keyof_from_mapped_result_1 = require_keyof_from_mapped_result();
    var kind_1 = require_kind();
    function KeyOfPropertyKeysToRest(T) {
      return T.map((L) => L === "[number]" ? (0, index_2.Number)() : (0, index_1.Literal)(L));
    }
    function KeyOf(T, options) {
      if ((0, kind_1.IsMappedResult)(T)) {
        return (0, keyof_from_mapped_result_1.KeyOfFromMappedResult)(T, options);
      } else {
        const K = (0, keyof_property_keys_1.KeyOfPropertyKeys)(T);
        const S = KeyOfPropertyKeysToRest(K);
        const U = (0, index_3.UnionEvaluated)(S);
        return (0, type_1.CreateType)(U, options);
      }
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/keyof/keyof-from-mapped-result.js
var require_keyof_from_mapped_result = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/keyof/keyof-from-mapped-result.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KeyOfFromMappedResult = KeyOfFromMappedResult;
    var index_1 = require_mapped2();
    var keyof_1 = require_keyof();
    var value_1 = require_value2();
    function FromProperties(K, options) {
      const Acc = {};
      for (const K2 of globalThis.Object.getOwnPropertyNames(K))
        Acc[K2] = (0, keyof_1.KeyOf)(K[K2], (0, value_1.Clone)(options));
      return Acc;
    }
    function FromMappedResult(R, options) {
      return FromProperties(R.properties, options);
    }
    function KeyOfFromMappedResult(R, options) {
      const P = FromMappedResult(R, options);
      return (0, index_1.MappedResult)(P);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/keyof/keyof-property-entries.js
var require_keyof_property_entries = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/keyof/keyof-property-entries.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KeyOfPropertyEntries = KeyOfPropertyEntries;
    var indexed_1 = require_indexed();
    var keyof_property_keys_1 = require_keyof_property_keys();
    function KeyOfPropertyEntries(schema) {
      const keys = (0, keyof_property_keys_1.KeyOfPropertyKeys)(schema);
      const schemas = (0, indexed_1.IndexFromPropertyKeys)(schema, keys);
      return keys.map((_, index) => [keys[index], schemas[index]]);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/keyof/index.js
var require_keyof2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/keyof/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_keyof_from_mapped_result(), exports2);
    __exportStar2(require_keyof_property_entries(), exports2);
    __exportStar2(require_keyof_property_keys(), exports2);
    __exportStar2(require_keyof(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/composite/composite.js
var require_composite = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/composite/composite.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Composite = Composite;
    var index_1 = require_intersect2();
    var index_2 = require_indexed2();
    var index_3 = require_keyof2();
    var index_4 = require_object2();
    var index_5 = require_sets();
    var kind_1 = require_kind();
    function CompositeKeys(T) {
      const Acc = [];
      for (const L of T)
        Acc.push(...(0, index_3.KeyOfPropertyKeys)(L));
      return (0, index_5.SetDistinct)(Acc);
    }
    function FilterNever(T) {
      return T.filter((L) => !(0, kind_1.IsNever)(L));
    }
    function CompositeProperty(T, K) {
      const Acc = [];
      for (const L of T)
        Acc.push(...(0, index_2.IndexFromPropertyKeys)(L, [K]));
      return FilterNever(Acc);
    }
    function CompositeProperties(T, K) {
      const Acc = {};
      for (const L of K) {
        Acc[L] = (0, index_1.IntersectEvaluated)(CompositeProperty(T, L));
      }
      return Acc;
    }
    function Composite(T, options) {
      const K = CompositeKeys(T);
      const P = CompositeProperties(T, K);
      const R = (0, index_4.Object)(P, options);
      return R;
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/composite/index.js
var require_composite2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/composite/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_composite(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/date/date.js
var require_date = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/date/date.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Date = Date2;
    var index_1 = require_symbols2();
    var type_1 = require_type3();
    function Date2(options) {
      return (0, type_1.CreateType)({ [index_1.Kind]: "Date", type: "Date" }, options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/date/index.js
var require_date2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/date/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_date(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/null/null.js
var require_null = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/null/null.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Null = Null;
    var type_1 = require_type3();
    var index_1 = require_symbols2();
    function Null(options) {
      return (0, type_1.CreateType)({ [index_1.Kind]: "Null", type: "null" }, options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/null/index.js
var require_null2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/null/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_null(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/symbol/symbol.js
var require_symbol = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/symbol/symbol.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Symbol = Symbol2;
    var type_1 = require_type3();
    var index_1 = require_symbols2();
    function Symbol2(options) {
      return (0, type_1.CreateType)({ [index_1.Kind]: "Symbol", type: "symbol" }, options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/symbol/index.js
var require_symbol2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/symbol/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_symbol(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/undefined/undefined.js
var require_undefined = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/undefined/undefined.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Undefined = Undefined;
    var type_1 = require_type3();
    var index_1 = require_symbols2();
    function Undefined(options) {
      return (0, type_1.CreateType)({ [index_1.Kind]: "Undefined", type: "undefined" }, options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/undefined/index.js
var require_undefined2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/undefined/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_undefined(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/uint8array/uint8array.js
var require_uint8array = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/uint8array/uint8array.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Uint8Array = Uint8Array2;
    var type_1 = require_type3();
    var index_1 = require_symbols2();
    function Uint8Array2(options) {
      return (0, type_1.CreateType)({ [index_1.Kind]: "Uint8Array", type: "Uint8Array" }, options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/uint8array/index.js
var require_uint8array2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/uint8array/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_uint8array(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/unknown/unknown.js
var require_unknown = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/unknown/unknown.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Unknown = Unknown;
    var type_1 = require_type3();
    var index_1 = require_symbols2();
    function Unknown(options) {
      return (0, type_1.CreateType)({ [index_1.Kind]: "Unknown" }, options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/unknown/index.js
var require_unknown2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/unknown/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_unknown(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/const/const.js
var require_const = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/const/const.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Const = Const;
    var index_1 = require_any2();
    var index_2 = require_bigint2();
    var index_3 = require_date2();
    var index_4 = require_function2();
    var index_5 = require_literal2();
    var index_6 = require_null2();
    var index_7 = require_object2();
    var index_8 = require_symbol2();
    var index_9 = require_tuple2();
    var index_10 = require_readonly2();
    var index_11 = require_undefined2();
    var index_12 = require_uint8array2();
    var index_13 = require_unknown2();
    var index_14 = require_create();
    var value_1 = require_value();
    function FromArray(T) {
      return T.map((L) => FromValue(L, false));
    }
    function FromProperties(value) {
      const Acc = {};
      for (const K of globalThis.Object.getOwnPropertyNames(value))
        Acc[K] = (0, index_10.Readonly)(FromValue(value[K], false));
      return Acc;
    }
    function ConditionalReadonly(T, root) {
      return root === true ? T : (0, index_10.Readonly)(T);
    }
    function FromValue(value, root) {
      return (0, value_1.IsAsyncIterator)(value) ? ConditionalReadonly((0, index_1.Any)(), root) : (0, value_1.IsIterator)(value) ? ConditionalReadonly((0, index_1.Any)(), root) : (0, value_1.IsArray)(value) ? (0, index_10.Readonly)((0, index_9.Tuple)(FromArray(value))) : (0, value_1.IsUint8Array)(value) ? (0, index_12.Uint8Array)() : (0, value_1.IsDate)(value) ? (0, index_3.Date)() : (0, value_1.IsObject)(value) ? ConditionalReadonly((0, index_7.Object)(FromProperties(value)), root) : (0, value_1.IsFunction)(value) ? ConditionalReadonly((0, index_4.Function)([], (0, index_13.Unknown)()), root) : (0, value_1.IsUndefined)(value) ? (0, index_11.Undefined)() : (0, value_1.IsNull)(value) ? (0, index_6.Null)() : (0, value_1.IsSymbol)(value) ? (0, index_8.Symbol)() : (0, value_1.IsBigInt)(value) ? (0, index_2.BigInt)() : (0, value_1.IsNumber)(value) ? (0, index_5.Literal)(value) : (0, value_1.IsBoolean)(value) ? (0, index_5.Literal)(value) : (0, value_1.IsString)(value) ? (0, index_5.Literal)(value) : (0, index_7.Object)({});
    }
    function Const(T, options) {
      return (0, index_14.CreateType)(FromValue(T, true), options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/const/index.js
var require_const2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/const/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_const(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/constructor-parameters/constructor-parameters.js
var require_constructor_parameters = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/constructor-parameters/constructor-parameters.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConstructorParameters = ConstructorParameters;
    var index_1 = require_tuple2();
    function ConstructorParameters(schema, options) {
      return (0, index_1.Tuple)(schema.parameters, options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/constructor-parameters/index.js
var require_constructor_parameters2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/constructor-parameters/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_constructor_parameters(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/deref/deref.js
var require_deref = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/deref/deref.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Deref = Deref;
    var type_1 = require_type2();
    var index_1 = require_discard2();
    var value_1 = require_value();
    var kind_1 = require_kind();
    function FromRest(schema, references) {
      return schema.map((schema2) => Deref(schema2, references));
    }
    function FromProperties(properties, references) {
      const Acc = {};
      for (const K of globalThis.Object.getOwnPropertyNames(properties)) {
        Acc[K] = Deref(properties[K], references);
      }
      return Acc;
    }
    function FromConstructor(schema, references) {
      schema.parameters = FromRest(schema.parameters, references);
      schema.returns = Deref(schema.returns, references);
      return schema;
    }
    function FromFunction(schema, references) {
      schema.parameters = FromRest(schema.parameters, references);
      schema.returns = Deref(schema.returns, references);
      return schema;
    }
    function FromIntersect(schema, references) {
      schema.allOf = FromRest(schema.allOf, references);
      return schema;
    }
    function FromUnion(schema, references) {
      schema.anyOf = FromRest(schema.anyOf, references);
      return schema;
    }
    function FromTuple(schema, references) {
      if ((0, value_1.IsUndefined)(schema.items))
        return schema;
      schema.items = FromRest(schema.items, references);
      return schema;
    }
    function FromArray(schema, references) {
      schema.items = Deref(schema.items, references);
      return schema;
    }
    function FromObject(schema, references) {
      schema.properties = FromProperties(schema.properties, references);
      return schema;
    }
    function FromPromise(schema, references) {
      schema.item = Deref(schema.item, references);
      return schema;
    }
    function FromAsyncIterator(schema, references) {
      schema.items = Deref(schema.items, references);
      return schema;
    }
    function FromIterator(schema, references) {
      schema.items = Deref(schema.items, references);
      return schema;
    }
    function FromRef(schema, references) {
      const target = references.find((remote) => remote.$id === schema.$ref);
      if (target === void 0)
        throw Error(`Unable to dereference schema with $id ${schema.$ref}`);
      const discard = (0, index_1.Discard)(target, ["$id"]);
      return Deref(discard, references);
    }
    function DerefResolve(schema, references) {
      return (0, kind_1.IsConstructor)(schema) ? FromConstructor(schema, references) : (0, kind_1.IsFunction)(schema) ? FromFunction(schema, references) : (0, kind_1.IsIntersect)(schema) ? FromIntersect(schema, references) : (0, kind_1.IsUnion)(schema) ? FromUnion(schema, references) : (0, kind_1.IsTuple)(schema) ? FromTuple(schema, references) : (0, kind_1.IsArray)(schema) ? FromArray(schema, references) : (0, kind_1.IsObject)(schema) ? FromObject(schema, references) : (0, kind_1.IsPromise)(schema) ? FromPromise(schema, references) : (0, kind_1.IsAsyncIterator)(schema) ? FromAsyncIterator(schema, references) : (0, kind_1.IsIterator)(schema) ? FromIterator(schema, references) : (0, kind_1.IsRef)(schema) ? FromRef(schema, references) : schema;
    }
    function Deref(schema, references) {
      return DerefResolve((0, type_1.CloneType)(schema), (0, type_1.CloneRest)(references));
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/deref/index.js
var require_deref2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/deref/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_deref(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/enum/enum.js
var require_enum = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/enum/enum.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Enum = Enum;
    var index_1 = require_literal2();
    var index_2 = require_symbols2();
    var index_3 = require_union3();
    var value_1 = require_value();
    function Enum(item, options) {
      if ((0, value_1.IsUndefined)(item))
        throw new Error("Enum undefined or empty");
      const values1 = globalThis.Object.getOwnPropertyNames(item).filter((key) => isNaN(key)).map((key) => item[key]);
      const values2 = [...new Set(values1)];
      const anyOf = values2.map((value) => (0, index_1.Literal)(value));
      return (0, index_3.Union)(anyOf, { ...options, [index_2.Hint]: "Enum" });
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/enum/index.js
var require_enum2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/enum/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_enum(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/extends/extends-check.js
var require_extends_check = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/extends/extends-check.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ExtendsResult = exports2.ExtendsResolverError = void 0;
    exports2.ExtendsCheck = ExtendsCheck;
    var index_1 = require_any2();
    var index_2 = require_function2();
    var index_3 = require_number2();
    var index_4 = require_string2();
    var index_5 = require_unknown2();
    var index_6 = require_template_literal2();
    var index_7 = require_patterns2();
    var index_8 = require_symbols2();
    var index_9 = require_error2();
    var index_10 = require_guard3();
    var ExtendsResolverError = class extends index_9.TypeBoxError {
    };
    exports2.ExtendsResolverError = ExtendsResolverError;
    var ExtendsResult;
    (function(ExtendsResult2) {
      ExtendsResult2[ExtendsResult2["Union"] = 0] = "Union";
      ExtendsResult2[ExtendsResult2["True"] = 1] = "True";
      ExtendsResult2[ExtendsResult2["False"] = 2] = "False";
    })(ExtendsResult || (exports2.ExtendsResult = ExtendsResult = {}));
    function IntoBooleanResult(result) {
      return result === ExtendsResult.False ? result : ExtendsResult.True;
    }
    function Throw(message) {
      throw new ExtendsResolverError(message);
    }
    function IsStructuralRight(right) {
      return index_10.TypeGuard.IsNever(right) || index_10.TypeGuard.IsIntersect(right) || index_10.TypeGuard.IsUnion(right) || index_10.TypeGuard.IsUnknown(right) || index_10.TypeGuard.IsAny(right);
    }
    function StructuralRight(left, right) {
      return index_10.TypeGuard.IsNever(right) ? FromNeverRight(left, right) : index_10.TypeGuard.IsIntersect(right) ? FromIntersectRight(left, right) : index_10.TypeGuard.IsUnion(right) ? FromUnionRight(left, right) : index_10.TypeGuard.IsUnknown(right) ? FromUnknownRight(left, right) : index_10.TypeGuard.IsAny(right) ? FromAnyRight(left, right) : Throw("StructuralRight");
    }
    function FromAnyRight(left, right) {
      return ExtendsResult.True;
    }
    function FromAny(left, right) {
      return index_10.TypeGuard.IsIntersect(right) ? FromIntersectRight(left, right) : index_10.TypeGuard.IsUnion(right) && right.anyOf.some((schema) => index_10.TypeGuard.IsAny(schema) || index_10.TypeGuard.IsUnknown(schema)) ? ExtendsResult.True : index_10.TypeGuard.IsUnion(right) ? ExtendsResult.Union : index_10.TypeGuard.IsUnknown(right) ? ExtendsResult.True : index_10.TypeGuard.IsAny(right) ? ExtendsResult.True : ExtendsResult.Union;
    }
    function FromArrayRight(left, right) {
      return index_10.TypeGuard.IsUnknown(left) ? ExtendsResult.False : index_10.TypeGuard.IsAny(left) ? ExtendsResult.Union : index_10.TypeGuard.IsNever(left) ? ExtendsResult.True : ExtendsResult.False;
    }
    function FromArray(left, right) {
      return index_10.TypeGuard.IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : !index_10.TypeGuard.IsArray(right) ? ExtendsResult.False : IntoBooleanResult(Visit(left.items, right.items));
    }
    function FromAsyncIterator(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : !index_10.TypeGuard.IsAsyncIterator(right) ? ExtendsResult.False : IntoBooleanResult(Visit(left.items, right.items));
    }
    function FromBigInt(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : index_10.TypeGuard.IsBigInt(right) ? ExtendsResult.True : ExtendsResult.False;
    }
    function FromBooleanRight(left, right) {
      return index_10.TypeGuard.IsLiteralBoolean(left) ? ExtendsResult.True : index_10.TypeGuard.IsBoolean(left) ? ExtendsResult.True : ExtendsResult.False;
    }
    function FromBoolean(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : index_10.TypeGuard.IsBoolean(right) ? ExtendsResult.True : ExtendsResult.False;
    }
    function FromConstructor(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : !index_10.TypeGuard.IsConstructor(right) ? ExtendsResult.False : left.parameters.length > right.parameters.length ? ExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit(right.parameters[index], schema)) === ExtendsResult.True) ? ExtendsResult.False : IntoBooleanResult(Visit(left.returns, right.returns));
    }
    function FromDate(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : index_10.TypeGuard.IsDate(right) ? ExtendsResult.True : ExtendsResult.False;
    }
    function FromFunction(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : !index_10.TypeGuard.IsFunction(right) ? ExtendsResult.False : left.parameters.length > right.parameters.length ? ExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit(right.parameters[index], schema)) === ExtendsResult.True) ? ExtendsResult.False : IntoBooleanResult(Visit(left.returns, right.returns));
    }
    function FromIntegerRight(left, right) {
      return index_10.TypeGuard.IsLiteral(left) && index_10.ValueGuard.IsNumber(left.const) ? ExtendsResult.True : index_10.TypeGuard.IsNumber(left) || index_10.TypeGuard.IsInteger(left) ? ExtendsResult.True : ExtendsResult.False;
    }
    function FromInteger(left, right) {
      return index_10.TypeGuard.IsInteger(right) || index_10.TypeGuard.IsNumber(right) ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : ExtendsResult.False;
    }
    function FromIntersectRight(left, right) {
      return right.allOf.every((schema) => Visit(left, schema) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
    }
    function FromIntersect(left, right) {
      return left.allOf.some((schema) => Visit(schema, right) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
    }
    function FromIterator(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : !index_10.TypeGuard.IsIterator(right) ? ExtendsResult.False : IntoBooleanResult(Visit(left.items, right.items));
    }
    function FromLiteral(left, right) {
      return index_10.TypeGuard.IsLiteral(right) && right.const === left.const ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : index_10.TypeGuard.IsString(right) ? FromStringRight(left, right) : index_10.TypeGuard.IsNumber(right) ? FromNumberRight(left, right) : index_10.TypeGuard.IsInteger(right) ? FromIntegerRight(left, right) : index_10.TypeGuard.IsBoolean(right) ? FromBooleanRight(left, right) : ExtendsResult.False;
    }
    function FromNeverRight(left, right) {
      return ExtendsResult.False;
    }
    function FromNever(left, right) {
      return ExtendsResult.True;
    }
    function UnwrapTNot(schema) {
      let [current, depth] = [schema, 0];
      while (true) {
        if (!index_10.TypeGuard.IsNot(current))
          break;
        current = current.not;
        depth += 1;
      }
      return depth % 2 === 0 ? current : (0, index_5.Unknown)();
    }
    function FromNot(left, right) {
      return index_10.TypeGuard.IsNot(left) ? Visit(UnwrapTNot(left), right) : index_10.TypeGuard.IsNot(right) ? Visit(left, UnwrapTNot(right)) : Throw("Invalid fallthrough for Not");
    }
    function FromNull(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : index_10.TypeGuard.IsNull(right) ? ExtendsResult.True : ExtendsResult.False;
    }
    function FromNumberRight(left, right) {
      return index_10.TypeGuard.IsLiteralNumber(left) ? ExtendsResult.True : index_10.TypeGuard.IsNumber(left) || index_10.TypeGuard.IsInteger(left) ? ExtendsResult.True : ExtendsResult.False;
    }
    function FromNumber(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : index_10.TypeGuard.IsInteger(right) || index_10.TypeGuard.IsNumber(right) ? ExtendsResult.True : ExtendsResult.False;
    }
    function IsObjectPropertyCount(schema, count) {
      return Object.getOwnPropertyNames(schema.properties).length === count;
    }
    function IsObjectStringLike(schema) {
      return IsObjectArrayLike(schema);
    }
    function IsObjectSymbolLike(schema) {
      return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "description" in schema.properties && index_10.TypeGuard.IsUnion(schema.properties.description) && schema.properties.description.anyOf.length === 2 && (index_10.TypeGuard.IsString(schema.properties.description.anyOf[0]) && index_10.TypeGuard.IsUndefined(schema.properties.description.anyOf[1]) || index_10.TypeGuard.IsString(schema.properties.description.anyOf[1]) && index_10.TypeGuard.IsUndefined(schema.properties.description.anyOf[0]));
    }
    function IsObjectNumberLike(schema) {
      return IsObjectPropertyCount(schema, 0);
    }
    function IsObjectBooleanLike(schema) {
      return IsObjectPropertyCount(schema, 0);
    }
    function IsObjectBigIntLike(schema) {
      return IsObjectPropertyCount(schema, 0);
    }
    function IsObjectDateLike(schema) {
      return IsObjectPropertyCount(schema, 0);
    }
    function IsObjectUint8ArrayLike(schema) {
      return IsObjectArrayLike(schema);
    }
    function IsObjectFunctionLike(schema) {
      const length = (0, index_3.Number)();
      return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit(schema.properties["length"], length)) === ExtendsResult.True;
    }
    function IsObjectConstructorLike(schema) {
      return IsObjectPropertyCount(schema, 0);
    }
    function IsObjectArrayLike(schema) {
      const length = (0, index_3.Number)();
      return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit(schema.properties["length"], length)) === ExtendsResult.True;
    }
    function IsObjectPromiseLike(schema) {
      const then = (0, index_2.Function)([(0, index_1.Any)()], (0, index_1.Any)());
      return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "then" in schema.properties && IntoBooleanResult(Visit(schema.properties["then"], then)) === ExtendsResult.True;
    }
    function Property(left, right) {
      return Visit(left, right) === ExtendsResult.False ? ExtendsResult.False : index_10.TypeGuard.IsOptional(left) && !index_10.TypeGuard.IsOptional(right) ? ExtendsResult.False : ExtendsResult.True;
    }
    function FromObjectRight(left, right) {
      return index_10.TypeGuard.IsUnknown(left) ? ExtendsResult.False : index_10.TypeGuard.IsAny(left) ? ExtendsResult.Union : index_10.TypeGuard.IsNever(left) || index_10.TypeGuard.IsLiteralString(left) && IsObjectStringLike(right) || index_10.TypeGuard.IsLiteralNumber(left) && IsObjectNumberLike(right) || index_10.TypeGuard.IsLiteralBoolean(left) && IsObjectBooleanLike(right) || index_10.TypeGuard.IsSymbol(left) && IsObjectSymbolLike(right) || index_10.TypeGuard.IsBigInt(left) && IsObjectBigIntLike(right) || index_10.TypeGuard.IsString(left) && IsObjectStringLike(right) || index_10.TypeGuard.IsSymbol(left) && IsObjectSymbolLike(right) || index_10.TypeGuard.IsNumber(left) && IsObjectNumberLike(right) || index_10.TypeGuard.IsInteger(left) && IsObjectNumberLike(right) || index_10.TypeGuard.IsBoolean(left) && IsObjectBooleanLike(right) || index_10.TypeGuard.IsUint8Array(left) && IsObjectUint8ArrayLike(right) || index_10.TypeGuard.IsDate(left) && IsObjectDateLike(right) || index_10.TypeGuard.IsConstructor(left) && IsObjectConstructorLike(right) || index_10.TypeGuard.IsFunction(left) && IsObjectFunctionLike(right) ? ExtendsResult.True : index_10.TypeGuard.IsRecord(left) && index_10.TypeGuard.IsString(RecordKey(left)) ? (() => {
        return right[index_8.Hint] === "Record" ? ExtendsResult.True : ExtendsResult.False;
      })() : index_10.TypeGuard.IsRecord(left) && index_10.TypeGuard.IsNumber(RecordKey(left)) ? (() => {
        return IsObjectPropertyCount(right, 0) ? ExtendsResult.True : ExtendsResult.False;
      })() : ExtendsResult.False;
    }
    function FromObject(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : !index_10.TypeGuard.IsObject(right) ? ExtendsResult.False : (() => {
        for (const key of Object.getOwnPropertyNames(right.properties)) {
          if (!(key in left.properties) && !index_10.TypeGuard.IsOptional(right.properties[key])) {
            return ExtendsResult.False;
          }
          if (index_10.TypeGuard.IsOptional(right.properties[key])) {
            return ExtendsResult.True;
          }
          if (Property(left.properties[key], right.properties[key]) === ExtendsResult.False) {
            return ExtendsResult.False;
          }
        }
        return ExtendsResult.True;
      })();
    }
    function FromPromise(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) && IsObjectPromiseLike(right) ? ExtendsResult.True : !index_10.TypeGuard.IsPromise(right) ? ExtendsResult.False : IntoBooleanResult(Visit(left.item, right.item));
    }
    function RecordKey(schema) {
      return index_7.PatternNumberExact in schema.patternProperties ? (0, index_3.Number)() : index_7.PatternStringExact in schema.patternProperties ? (0, index_4.String)() : Throw("Unknown record key pattern");
    }
    function RecordValue(schema) {
      return index_7.PatternNumberExact in schema.patternProperties ? schema.patternProperties[index_7.PatternNumberExact] : index_7.PatternStringExact in schema.patternProperties ? schema.patternProperties[index_7.PatternStringExact] : Throw("Unable to get record value schema");
    }
    function FromRecordRight(left, right) {
      const [Key2, Value] = [RecordKey(right), RecordValue(right)];
      return index_10.TypeGuard.IsLiteralString(left) && index_10.TypeGuard.IsNumber(Key2) && IntoBooleanResult(Visit(left, Value)) === ExtendsResult.True ? ExtendsResult.True : index_10.TypeGuard.IsUint8Array(left) && index_10.TypeGuard.IsNumber(Key2) ? Visit(left, Value) : index_10.TypeGuard.IsString(left) && index_10.TypeGuard.IsNumber(Key2) ? Visit(left, Value) : index_10.TypeGuard.IsArray(left) && index_10.TypeGuard.IsNumber(Key2) ? Visit(left, Value) : index_10.TypeGuard.IsObject(left) ? (() => {
        for (const key of Object.getOwnPropertyNames(left.properties)) {
          if (Property(Value, left.properties[key]) === ExtendsResult.False) {
            return ExtendsResult.False;
          }
        }
        return ExtendsResult.True;
      })() : ExtendsResult.False;
    }
    function FromRecord(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : !index_10.TypeGuard.IsRecord(right) ? ExtendsResult.False : Visit(RecordValue(left), RecordValue(right));
    }
    function FromRegExp(left, right) {
      const L = index_10.TypeGuard.IsRegExp(left) ? (0, index_4.String)() : left;
      const R = index_10.TypeGuard.IsRegExp(right) ? (0, index_4.String)() : right;
      return Visit(L, R);
    }
    function FromStringRight(left, right) {
      return index_10.TypeGuard.IsLiteral(left) && index_10.ValueGuard.IsString(left.const) ? ExtendsResult.True : index_10.TypeGuard.IsString(left) ? ExtendsResult.True : ExtendsResult.False;
    }
    function FromString(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : index_10.TypeGuard.IsString(right) ? ExtendsResult.True : ExtendsResult.False;
    }
    function FromSymbol(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : index_10.TypeGuard.IsSymbol(right) ? ExtendsResult.True : ExtendsResult.False;
    }
    function FromTemplateLiteral(left, right) {
      return index_10.TypeGuard.IsTemplateLiteral(left) ? Visit((0, index_6.TemplateLiteralToUnion)(left), right) : index_10.TypeGuard.IsTemplateLiteral(right) ? Visit(left, (0, index_6.TemplateLiteralToUnion)(right)) : Throw("Invalid fallthrough for TemplateLiteral");
    }
    function IsArrayOfTuple(left, right) {
      return index_10.TypeGuard.IsArray(right) && left.items !== void 0 && left.items.every((schema) => Visit(schema, right.items) === ExtendsResult.True);
    }
    function FromTupleRight(left, right) {
      return index_10.TypeGuard.IsNever(left) ? ExtendsResult.True : index_10.TypeGuard.IsUnknown(left) ? ExtendsResult.False : index_10.TypeGuard.IsAny(left) ? ExtendsResult.Union : ExtendsResult.False;
    }
    function FromTuple(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True : index_10.TypeGuard.IsArray(right) && IsArrayOfTuple(left, right) ? ExtendsResult.True : !index_10.TypeGuard.IsTuple(right) ? ExtendsResult.False : index_10.ValueGuard.IsUndefined(left.items) && !index_10.ValueGuard.IsUndefined(right.items) || !index_10.ValueGuard.IsUndefined(left.items) && index_10.ValueGuard.IsUndefined(right.items) ? ExtendsResult.False : index_10.ValueGuard.IsUndefined(left.items) && !index_10.ValueGuard.IsUndefined(right.items) ? ExtendsResult.True : left.items.every((schema, index) => Visit(schema, right.items[index]) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
    }
    function FromUint8Array(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : index_10.TypeGuard.IsUint8Array(right) ? ExtendsResult.True : ExtendsResult.False;
    }
    function FromUndefined(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : index_10.TypeGuard.IsVoid(right) ? FromVoidRight(left, right) : index_10.TypeGuard.IsUndefined(right) ? ExtendsResult.True : ExtendsResult.False;
    }
    function FromUnionRight(left, right) {
      return right.anyOf.some((schema) => Visit(left, schema) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
    }
    function FromUnion(left, right) {
      return left.anyOf.every((schema) => Visit(schema, right) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
    }
    function FromUnknownRight(left, right) {
      return ExtendsResult.True;
    }
    function FromUnknown(left, right) {
      return index_10.TypeGuard.IsNever(right) ? FromNeverRight(left, right) : index_10.TypeGuard.IsIntersect(right) ? FromIntersectRight(left, right) : index_10.TypeGuard.IsUnion(right) ? FromUnionRight(left, right) : index_10.TypeGuard.IsAny(right) ? FromAnyRight(left, right) : index_10.TypeGuard.IsString(right) ? FromStringRight(left, right) : index_10.TypeGuard.IsNumber(right) ? FromNumberRight(left, right) : index_10.TypeGuard.IsInteger(right) ? FromIntegerRight(left, right) : index_10.TypeGuard.IsBoolean(right) ? FromBooleanRight(left, right) : index_10.TypeGuard.IsArray(right) ? FromArrayRight(left, right) : index_10.TypeGuard.IsTuple(right) ? FromTupleRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : index_10.TypeGuard.IsUnknown(right) ? ExtendsResult.True : ExtendsResult.False;
    }
    function FromVoidRight(left, right) {
      return index_10.TypeGuard.IsUndefined(left) ? ExtendsResult.True : index_10.TypeGuard.IsUndefined(left) ? ExtendsResult.True : ExtendsResult.False;
    }
    function FromVoid(left, right) {
      return index_10.TypeGuard.IsIntersect(right) ? FromIntersectRight(left, right) : index_10.TypeGuard.IsUnion(right) ? FromUnionRight(left, right) : index_10.TypeGuard.IsUnknown(right) ? FromUnknownRight(left, right) : index_10.TypeGuard.IsAny(right) ? FromAnyRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : index_10.TypeGuard.IsVoid(right) ? ExtendsResult.True : ExtendsResult.False;
    }
    function Visit(left, right) {
      return (
        // resolvable
        index_10.TypeGuard.IsTemplateLiteral(left) || index_10.TypeGuard.IsTemplateLiteral(right) ? FromTemplateLiteral(left, right) : index_10.TypeGuard.IsRegExp(left) || index_10.TypeGuard.IsRegExp(right) ? FromRegExp(left, right) : index_10.TypeGuard.IsNot(left) || index_10.TypeGuard.IsNot(right) ? FromNot(left, right) : (
          // standard
          index_10.TypeGuard.IsAny(left) ? FromAny(left, right) : index_10.TypeGuard.IsArray(left) ? FromArray(left, right) : index_10.TypeGuard.IsBigInt(left) ? FromBigInt(left, right) : index_10.TypeGuard.IsBoolean(left) ? FromBoolean(left, right) : index_10.TypeGuard.IsAsyncIterator(left) ? FromAsyncIterator(left, right) : index_10.TypeGuard.IsConstructor(left) ? FromConstructor(left, right) : index_10.TypeGuard.IsDate(left) ? FromDate(left, right) : index_10.TypeGuard.IsFunction(left) ? FromFunction(left, right) : index_10.TypeGuard.IsInteger(left) ? FromInteger(left, right) : index_10.TypeGuard.IsIntersect(left) ? FromIntersect(left, right) : index_10.TypeGuard.IsIterator(left) ? FromIterator(left, right) : index_10.TypeGuard.IsLiteral(left) ? FromLiteral(left, right) : index_10.TypeGuard.IsNever(left) ? FromNever(left, right) : index_10.TypeGuard.IsNull(left) ? FromNull(left, right) : index_10.TypeGuard.IsNumber(left) ? FromNumber(left, right) : index_10.TypeGuard.IsObject(left) ? FromObject(left, right) : index_10.TypeGuard.IsRecord(left) ? FromRecord(left, right) : index_10.TypeGuard.IsString(left) ? FromString(left, right) : index_10.TypeGuard.IsSymbol(left) ? FromSymbol(left, right) : index_10.TypeGuard.IsTuple(left) ? FromTuple(left, right) : index_10.TypeGuard.IsPromise(left) ? FromPromise(left, right) : index_10.TypeGuard.IsUint8Array(left) ? FromUint8Array(left, right) : index_10.TypeGuard.IsUndefined(left) ? FromUndefined(left, right) : index_10.TypeGuard.IsUnion(left) ? FromUnion(left, right) : index_10.TypeGuard.IsUnknown(left) ? FromUnknown(left, right) : index_10.TypeGuard.IsVoid(left) ? FromVoid(left, right) : Throw(`Unknown left type operand '${left[index_8.Kind]}'`)
        )
      );
    }
    function ExtendsCheck(left, right) {
      return Visit(left, right);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/extends/extends-from-mapped-result.js
var require_extends_from_mapped_result = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/extends/extends-from-mapped-result.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ExtendsFromMappedResult = ExtendsFromMappedResult;
    var index_1 = require_mapped2();
    var extends_1 = require_extends();
    var value_1 = require_value2();
    function FromProperties(P, Right, True, False, options) {
      const Acc = {};
      for (const K2 of globalThis.Object.getOwnPropertyNames(P))
        Acc[K2] = (0, extends_1.Extends)(P[K2], Right, True, False, (0, value_1.Clone)(options));
      return Acc;
    }
    function FromMappedResult(Left, Right, True, False, options) {
      return FromProperties(Left.properties, Right, True, False, options);
    }
    function ExtendsFromMappedResult(Left, Right, True, False, options) {
      const P = FromMappedResult(Left, Right, True, False, options);
      return (0, index_1.MappedResult)(P);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/extends/extends.js
var require_extends = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/extends/extends.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Extends = Extends;
    var type_1 = require_type3();
    var index_1 = require_union3();
    var extends_check_1 = require_extends_check();
    var extends_from_mapped_key_1 = require_extends_from_mapped_key();
    var extends_from_mapped_result_1 = require_extends_from_mapped_result();
    var kind_1 = require_kind();
    function ExtendsResolve(left, right, trueType, falseType) {
      const R = (0, extends_check_1.ExtendsCheck)(left, right);
      return R === extends_check_1.ExtendsResult.Union ? (0, index_1.Union)([trueType, falseType]) : R === extends_check_1.ExtendsResult.True ? trueType : falseType;
    }
    function Extends(L, R, T, F, options) {
      return (0, kind_1.IsMappedResult)(L) ? (0, extends_from_mapped_result_1.ExtendsFromMappedResult)(L, R, T, F, options) : (0, kind_1.IsMappedKey)(L) ? (0, type_1.CreateType)((0, extends_from_mapped_key_1.ExtendsFromMappedKey)(L, R, T, F, options)) : (0, type_1.CreateType)(ExtendsResolve(L, R, T, F), options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/extends/extends-from-mapped-key.js
var require_extends_from_mapped_key = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/extends/extends-from-mapped-key.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ExtendsFromMappedKey = ExtendsFromMappedKey;
    var index_1 = require_mapped2();
    var index_2 = require_literal2();
    var extends_1 = require_extends();
    var value_1 = require_value2();
    function FromPropertyKey(K, U, L, R, options) {
      return {
        [K]: (0, extends_1.Extends)((0, index_2.Literal)(K), U, L, R, (0, value_1.Clone)(options))
      };
    }
    function FromPropertyKeys(K, U, L, R, options) {
      return K.reduce((Acc, LK) => {
        return { ...Acc, ...FromPropertyKey(LK, U, L, R, options) };
      }, {});
    }
    function FromMappedKey(K, U, L, R, options) {
      return FromPropertyKeys(K.keys, U, L, R, options);
    }
    function ExtendsFromMappedKey(T, U, L, R, options) {
      const P = FromMappedKey(T, U, L, R, options);
      return (0, index_1.MappedResult)(P);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/extends/extends-undefined.js
var require_extends_undefined = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/extends/extends-undefined.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ExtendsUndefinedCheck = ExtendsUndefinedCheck;
    var index_1 = require_symbols2();
    function Intersect(schema) {
      return schema.allOf.every((schema2) => ExtendsUndefinedCheck(schema2));
    }
    function Union(schema) {
      return schema.anyOf.some((schema2) => ExtendsUndefinedCheck(schema2));
    }
    function Not(schema) {
      return !ExtendsUndefinedCheck(schema.not);
    }
    function ExtendsUndefinedCheck(schema) {
      return schema[index_1.Kind] === "Intersect" ? Intersect(schema) : schema[index_1.Kind] === "Union" ? Union(schema) : schema[index_1.Kind] === "Not" ? Not(schema) : schema[index_1.Kind] === "Undefined" ? true : false;
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/extends/index.js
var require_extends2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/extends/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_extends_check(), exports2);
    __exportStar2(require_extends_from_mapped_key(), exports2);
    __exportStar2(require_extends_from_mapped_result(), exports2);
    __exportStar2(require_extends_undefined(), exports2);
    __exportStar2(require_extends(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/exclude/exclude-from-template-literal.js
var require_exclude_from_template_literal = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/exclude/exclude-from-template-literal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ExcludeFromTemplateLiteral = ExcludeFromTemplateLiteral;
    var exclude_1 = require_exclude();
    var index_1 = require_template_literal2();
    function ExcludeFromTemplateLiteral(L, R) {
      return (0, exclude_1.Exclude)((0, index_1.TemplateLiteralToUnion)(L), R);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/exclude/exclude.js
var require_exclude = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/exclude/exclude.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Exclude = Exclude;
    var type_1 = require_type3();
    var index_1 = require_union3();
    var index_2 = require_never2();
    var index_3 = require_extends2();
    var exclude_from_mapped_result_1 = require_exclude_from_mapped_result();
    var exclude_from_template_literal_1 = require_exclude_from_template_literal();
    var kind_1 = require_kind();
    function ExcludeRest(L, R) {
      const excluded = L.filter((inner) => (0, index_3.ExtendsCheck)(inner, R) === index_3.ExtendsResult.False);
      return excluded.length === 1 ? excluded[0] : (0, index_1.Union)(excluded);
    }
    function Exclude(L, R, options = {}) {
      if ((0, kind_1.IsTemplateLiteral)(L))
        return (0, type_1.CreateType)((0, exclude_from_template_literal_1.ExcludeFromTemplateLiteral)(L, R), options);
      if ((0, kind_1.IsMappedResult)(L))
        return (0, type_1.CreateType)((0, exclude_from_mapped_result_1.ExcludeFromMappedResult)(L, R), options);
      return (0, type_1.CreateType)((0, kind_1.IsUnion)(L) ? ExcludeRest(L.anyOf, R) : (0, index_3.ExtendsCheck)(L, R) !== index_3.ExtendsResult.False ? (0, index_2.Never)() : L, options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/exclude/exclude-from-mapped-result.js
var require_exclude_from_mapped_result = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/exclude/exclude-from-mapped-result.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ExcludeFromMappedResult = ExcludeFromMappedResult;
    var index_1 = require_mapped2();
    var exclude_1 = require_exclude();
    function FromProperties(P, U) {
      const Acc = {};
      for (const K2 of globalThis.Object.getOwnPropertyNames(P))
        Acc[K2] = (0, exclude_1.Exclude)(P[K2], U);
      return Acc;
    }
    function FromMappedResult(R, T) {
      return FromProperties(R.properties, T);
    }
    function ExcludeFromMappedResult(R, T) {
      const P = FromMappedResult(R, T);
      return (0, index_1.MappedResult)(P);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/exclude/index.js
var require_exclude2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/exclude/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_exclude_from_mapped_result(), exports2);
    __exportStar2(require_exclude_from_template_literal(), exports2);
    __exportStar2(require_exclude(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/extract/extract-from-template-literal.js
var require_extract_from_template_literal = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/extract/extract-from-template-literal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ExtractFromTemplateLiteral = ExtractFromTemplateLiteral;
    var extract_1 = require_extract();
    var index_1 = require_template_literal2();
    function ExtractFromTemplateLiteral(L, R) {
      return (0, extract_1.Extract)((0, index_1.TemplateLiteralToUnion)(L), R);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/extract/extract.js
var require_extract = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/extract/extract.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Extract = Extract;
    var type_1 = require_type3();
    var index_1 = require_union3();
    var index_2 = require_never2();
    var index_3 = require_extends2();
    var extract_from_mapped_result_1 = require_extract_from_mapped_result();
    var extract_from_template_literal_1 = require_extract_from_template_literal();
    var kind_1 = require_kind();
    function ExtractRest(L, R) {
      const extracted = L.filter((inner) => (0, index_3.ExtendsCheck)(inner, R) !== index_3.ExtendsResult.False);
      return extracted.length === 1 ? extracted[0] : (0, index_1.Union)(extracted);
    }
    function Extract(L, R, options) {
      if ((0, kind_1.IsTemplateLiteral)(L))
        return (0, type_1.CreateType)((0, extract_from_template_literal_1.ExtractFromTemplateLiteral)(L, R), options);
      if ((0, kind_1.IsMappedResult)(L))
        return (0, type_1.CreateType)((0, extract_from_mapped_result_1.ExtractFromMappedResult)(L, R), options);
      return (0, type_1.CreateType)((0, kind_1.IsUnion)(L) ? ExtractRest(L.anyOf, R) : (0, index_3.ExtendsCheck)(L, R) !== index_3.ExtendsResult.False ? L : (0, index_2.Never)(), options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/extract/extract-from-mapped-result.js
var require_extract_from_mapped_result = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/extract/extract-from-mapped-result.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ExtractFromMappedResult = ExtractFromMappedResult;
    var index_1 = require_mapped2();
    var extract_1 = require_extract();
    function FromProperties(P, T) {
      const Acc = {};
      for (const K2 of globalThis.Object.getOwnPropertyNames(P))
        Acc[K2] = (0, extract_1.Extract)(P[K2], T);
      return Acc;
    }
    function FromMappedResult(R, T) {
      return FromProperties(R.properties, T);
    }
    function ExtractFromMappedResult(R, T) {
      const P = FromMappedResult(R, T);
      return (0, index_1.MappedResult)(P);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/extract/index.js
var require_extract2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/extract/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_extract_from_mapped_result(), exports2);
    __exportStar2(require_extract_from_template_literal(), exports2);
    __exportStar2(require_extract(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/instance-type/instance-type.js
var require_instance_type = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/instance-type/instance-type.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InstanceType = InstanceType;
    var type_1 = require_type3();
    function InstanceType(schema, options) {
      return (0, type_1.CreateType)(schema.returns, options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/instance-type/index.js
var require_instance_type2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/instance-type/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_instance_type(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/integer/integer.js
var require_integer = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/integer/integer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Integer = Integer;
    var type_1 = require_type3();
    var index_1 = require_symbols2();
    function Integer(options) {
      return (0, type_1.CreateType)({ [index_1.Kind]: "Integer", type: "integer" }, options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/integer/index.js
var require_integer2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/integer/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_integer(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/intrinsic/intrinsic-from-mapped-key.js
var require_intrinsic_from_mapped_key = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/intrinsic/intrinsic-from-mapped-key.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IntrinsicFromMappedKey = IntrinsicFromMappedKey;
    var index_1 = require_mapped2();
    var intrinsic_1 = require_intrinsic();
    var index_2 = require_literal2();
    var value_1 = require_value2();
    function MappedIntrinsicPropertyKey(K, M, options) {
      return {
        [K]: (0, intrinsic_1.Intrinsic)((0, index_2.Literal)(K), M, (0, value_1.Clone)(options))
      };
    }
    function MappedIntrinsicPropertyKeys(K, M, options) {
      const result = K.reduce((Acc, L) => {
        return { ...Acc, ...MappedIntrinsicPropertyKey(L, M, options) };
      }, {});
      return result;
    }
    function MappedIntrinsicProperties(T, M, options) {
      return MappedIntrinsicPropertyKeys(T["keys"], M, options);
    }
    function IntrinsicFromMappedKey(T, M, options) {
      const P = MappedIntrinsicProperties(T, M, options);
      return (0, index_1.MappedResult)(P);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/intrinsic/intrinsic.js
var require_intrinsic = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/intrinsic/intrinsic.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Intrinsic = Intrinsic;
    var type_1 = require_type3();
    var index_1 = require_template_literal2();
    var intrinsic_from_mapped_key_1 = require_intrinsic_from_mapped_key();
    var index_2 = require_literal2();
    var index_3 = require_union3();
    var kind_1 = require_kind();
    function ApplyUncapitalize(value) {
      const [first, rest] = [value.slice(0, 1), value.slice(1)];
      return [first.toLowerCase(), rest].join("");
    }
    function ApplyCapitalize(value) {
      const [first, rest] = [value.slice(0, 1), value.slice(1)];
      return [first.toUpperCase(), rest].join("");
    }
    function ApplyUppercase(value) {
      return value.toUpperCase();
    }
    function ApplyLowercase(value) {
      return value.toLowerCase();
    }
    function FromTemplateLiteral(schema, mode, options) {
      const expression = (0, index_1.TemplateLiteralParseExact)(schema.pattern);
      const finite = (0, index_1.IsTemplateLiteralExpressionFinite)(expression);
      if (!finite)
        return { ...schema, pattern: FromLiteralValue(schema.pattern, mode) };
      const strings = [...(0, index_1.TemplateLiteralExpressionGenerate)(expression)];
      const literals = strings.map((value) => (0, index_2.Literal)(value));
      const mapped = FromRest(literals, mode);
      const union = (0, index_3.Union)(mapped);
      return (0, index_1.TemplateLiteral)([union], options);
    }
    function FromLiteralValue(value, mode) {
      return typeof value === "string" ? mode === "Uncapitalize" ? ApplyUncapitalize(value) : mode === "Capitalize" ? ApplyCapitalize(value) : mode === "Uppercase" ? ApplyUppercase(value) : mode === "Lowercase" ? ApplyLowercase(value) : value : value.toString();
    }
    function FromRest(T, M) {
      return T.map((L) => Intrinsic(L, M));
    }
    function Intrinsic(schema, mode, options = {}) {
      return (
        // Intrinsic-Mapped-Inference
        (0, kind_1.IsMappedKey)(schema) ? (0, intrinsic_from_mapped_key_1.IntrinsicFromMappedKey)(schema, mode, options) : (
          // Standard-Inference
          (0, kind_1.IsTemplateLiteral)(schema) ? FromTemplateLiteral(schema, mode, options) : (0, kind_1.IsUnion)(schema) ? (0, index_3.Union)(FromRest(schema.anyOf, mode), options) : (0, kind_1.IsLiteral)(schema) ? (0, index_2.Literal)(FromLiteralValue(schema.const, mode), options) : (
            // Default Type
            (0, type_1.CreateType)(schema, options)
          )
        )
      );
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/intrinsic/capitalize.js
var require_capitalize = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/intrinsic/capitalize.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Capitalize = Capitalize;
    var intrinsic_1 = require_intrinsic();
    function Capitalize(T, options = {}) {
      return (0, intrinsic_1.Intrinsic)(T, "Capitalize", options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/intrinsic/lowercase.js
var require_lowercase = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/intrinsic/lowercase.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Lowercase = Lowercase;
    var intrinsic_1 = require_intrinsic();
    function Lowercase(T, options = {}) {
      return (0, intrinsic_1.Intrinsic)(T, "Lowercase", options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/intrinsic/uncapitalize.js
var require_uncapitalize = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/intrinsic/uncapitalize.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Uncapitalize = Uncapitalize;
    var intrinsic_1 = require_intrinsic();
    function Uncapitalize(T, options = {}) {
      return (0, intrinsic_1.Intrinsic)(T, "Uncapitalize", options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/intrinsic/uppercase.js
var require_uppercase = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/intrinsic/uppercase.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Uppercase = Uppercase;
    var intrinsic_1 = require_intrinsic();
    function Uppercase(T, options = {}) {
      return (0, intrinsic_1.Intrinsic)(T, "Uppercase", options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/intrinsic/index.js
var require_intrinsic2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/intrinsic/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_capitalize(), exports2);
    __exportStar2(require_intrinsic_from_mapped_key(), exports2);
    __exportStar2(require_intrinsic(), exports2);
    __exportStar2(require_lowercase(), exports2);
    __exportStar2(require_uncapitalize(), exports2);
    __exportStar2(require_uppercase(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/not/not.js
var require_not = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/not/not.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Not = Not;
    var type_1 = require_type3();
    var index_1 = require_symbols2();
    function Not(not, options) {
      return (0, type_1.CreateType)({ [index_1.Kind]: "Not", not }, options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/not/index.js
var require_not2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/not/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_not(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/omit/omit-from-mapped-result.js
var require_omit_from_mapped_result = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/omit/omit-from-mapped-result.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OmitFromMappedResult = OmitFromMappedResult;
    var index_1 = require_mapped2();
    var omit_1 = require_omit();
    var value_1 = require_value2();
    function FromProperties(P, K, options) {
      const Acc = {};
      for (const K2 of globalThis.Object.getOwnPropertyNames(P))
        Acc[K2] = (0, omit_1.Omit)(P[K2], K, (0, value_1.Clone)(options));
      return Acc;
    }
    function FromMappedResult(R, K, options) {
      return FromProperties(R.properties, K, options);
    }
    function OmitFromMappedResult(R, K, options) {
      const P = FromMappedResult(R, K, options);
      return (0, index_1.MappedResult)(P);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/omit/omit.js
var require_omit = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/omit/omit.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Omit = Omit;
    var type_1 = require_type3();
    var discard_1 = require_discard();
    var index_1 = require_intersect2();
    var index_2 = require_union3();
    var index_3 = require_object2();
    var index_4 = require_indexed2();
    var omit_from_mapped_key_1 = require_omit_from_mapped_key();
    var omit_from_mapped_result_1 = require_omit_from_mapped_result();
    var symbols_1 = require_symbols();
    var kind_1 = require_kind();
    function FromIntersect(T, K) {
      return T.map((T2) => OmitResolve(T2, K));
    }
    function FromUnion(T, K) {
      return T.map((T2) => OmitResolve(T2, K));
    }
    function FromProperty(T, K) {
      const { [K]: _, ...R } = T;
      return R;
    }
    function FromProperties(T, K) {
      return K.reduce((T2, K2) => FromProperty(T2, K2), T);
    }
    function FromObject(T, K) {
      const options = (0, discard_1.Discard)(T, [symbols_1.TransformKind, "$id", "required", "properties"]);
      const properties = FromProperties(T["properties"], K);
      return (0, index_3.Object)(properties, options);
    }
    function OmitResolve(T, K) {
      return (0, kind_1.IsIntersect)(T) ? (0, index_1.Intersect)(FromIntersect(T.allOf, K)) : (0, kind_1.IsUnion)(T) ? (0, index_2.Union)(FromUnion(T.anyOf, K)) : (0, kind_1.IsObject)(T) ? FromObject(T, K) : (0, index_3.Object)({});
    }
    function Omit(T, K, options) {
      if ((0, kind_1.IsMappedKey)(K))
        return (0, omit_from_mapped_key_1.OmitFromMappedKey)(T, K, options);
      if ((0, kind_1.IsMappedResult)(T))
        return (0, omit_from_mapped_result_1.OmitFromMappedResult)(T, K, options);
      const I = (0, kind_1.IsSchema)(K) ? (0, index_4.IndexPropertyKeys)(K) : K;
      return (0, type_1.CreateType)({ ...OmitResolve(T, I), ...options });
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/omit/omit-from-mapped-key.js
var require_omit_from_mapped_key = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/omit/omit-from-mapped-key.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OmitFromMappedKey = OmitFromMappedKey;
    var index_1 = require_mapped2();
    var omit_1 = require_omit();
    var value_1 = require_value2();
    function FromPropertyKey(T, K, options) {
      return {
        [K]: (0, omit_1.Omit)(T, [K], (0, value_1.Clone)(options))
      };
    }
    function FromPropertyKeys(T, K, options) {
      return K.reduce((Acc, LK) => {
        return { ...Acc, ...FromPropertyKey(T, LK, options) };
      }, {});
    }
    function FromMappedKey(T, K, options) {
      return FromPropertyKeys(T, K.keys, options);
    }
    function OmitFromMappedKey(T, K, options) {
      const P = FromMappedKey(T, K, options);
      return (0, index_1.MappedResult)(P);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/omit/index.js
var require_omit2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/omit/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_omit_from_mapped_key(), exports2);
    __exportStar2(require_omit_from_mapped_result(), exports2);
    __exportStar2(require_omit(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/parameters/parameters.js
var require_parameters = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/parameters/parameters.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Parameters = Parameters;
    var index_1 = require_tuple2();
    function Parameters(schema, options) {
      return (0, index_1.Tuple)(schema.parameters, options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/parameters/index.js
var require_parameters2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/parameters/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_parameters(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/partial/partial.js
var require_partial = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/partial/partial.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Partial = Partial;
    var type_1 = require_type3();
    var index_1 = require_optional2();
    var index_2 = require_object2();
    var index_3 = require_intersect2();
    var index_4 = require_union3();
    var index_5 = require_discard2();
    var index_6 = require_symbols2();
    var partial_from_mapped_result_1 = require_partial_from_mapped_result();
    var kind_1 = require_kind();
    function FromRest(T) {
      return T.map((L) => PartialResolve(L));
    }
    function FromProperties(T) {
      const Acc = {};
      for (const K of globalThis.Object.getOwnPropertyNames(T))
        Acc[K] = (0, index_1.Optional)(T[K]);
      return Acc;
    }
    function FromObject(T) {
      const options = (0, index_5.Discard)(T, [index_6.TransformKind, "$id", "required", "properties"]);
      const properties = FromProperties(T["properties"]);
      return (0, index_2.Object)(properties, options);
    }
    function PartialResolve(T) {
      return (0, kind_1.IsIntersect)(T) ? (0, index_3.Intersect)(FromRest(T.allOf)) : (0, kind_1.IsUnion)(T) ? (0, index_4.Union)(FromRest(T.anyOf)) : (0, kind_1.IsObject)(T) ? FromObject(T) : (0, index_2.Object)({});
    }
    function Partial(T, options) {
      if ((0, kind_1.IsMappedResult)(T)) {
        return (0, partial_from_mapped_result_1.PartialFromMappedResult)(T, options);
      } else {
        return (0, type_1.CreateType)({ ...PartialResolve(T), ...options });
      }
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/partial/partial-from-mapped-result.js
var require_partial_from_mapped_result = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/partial/partial-from-mapped-result.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PartialFromMappedResult = PartialFromMappedResult;
    var index_1 = require_mapped2();
    var partial_1 = require_partial();
    var value_1 = require_value2();
    function FromProperties(K, options) {
      const Acc = {};
      for (const K2 of globalThis.Object.getOwnPropertyNames(K))
        Acc[K2] = (0, partial_1.Partial)(K[K2], (0, value_1.Clone)(options));
      return Acc;
    }
    function FromMappedResult(R, options) {
      return FromProperties(R.properties, options);
    }
    function PartialFromMappedResult(R, options) {
      const P = FromMappedResult(R, options);
      return (0, index_1.MappedResult)(P);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/partial/index.js
var require_partial2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/partial/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_partial_from_mapped_result(), exports2);
    __exportStar2(require_partial(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/pick/pick-from-mapped-result.js
var require_pick_from_mapped_result = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/pick/pick-from-mapped-result.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PickFromMappedResult = PickFromMappedResult;
    var index_1 = require_mapped2();
    var pick_1 = require_pick();
    var value_1 = require_value2();
    function FromProperties(P, K, options) {
      const Acc = {};
      for (const K2 of globalThis.Object.getOwnPropertyNames(P))
        Acc[K2] = (0, pick_1.Pick)(P[K2], K, (0, value_1.Clone)(options));
      return Acc;
    }
    function FromMappedResult(R, K, options) {
      return FromProperties(R.properties, K, options);
    }
    function PickFromMappedResult(R, K, options) {
      const P = FromMappedResult(R, K, options);
      return (0, index_1.MappedResult)(P);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/pick/pick.js
var require_pick = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/pick/pick.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Pick = Pick;
    var type_1 = require_type3();
    var discard_1 = require_discard();
    var index_1 = require_intersect2();
    var index_2 = require_union3();
    var index_3 = require_object2();
    var index_4 = require_indexed2();
    var pick_from_mapped_key_1 = require_pick_from_mapped_key();
    var pick_from_mapped_result_1 = require_pick_from_mapped_result();
    var symbols_1 = require_symbols();
    var kind_1 = require_kind();
    function FromIntersect(T, K) {
      return T.map((T2) => PickResolve(T2, K));
    }
    function FromUnion(T, K) {
      return T.map((T2) => PickResolve(T2, K));
    }
    function FromProperties(T, K) {
      const Acc = {};
      for (const K2 of K)
        if (K2 in T)
          Acc[K2] = T[K2];
      return Acc;
    }
    function FromObject(T, K) {
      const options = (0, discard_1.Discard)(T, [symbols_1.TransformKind, "$id", "required", "properties"]);
      const properties = FromProperties(T["properties"], K);
      return (0, index_3.Object)(properties, options);
    }
    function PickResolve(T, K) {
      return (0, kind_1.IsIntersect)(T) ? (0, index_1.Intersect)(FromIntersect(T.allOf, K)) : (0, kind_1.IsUnion)(T) ? (0, index_2.Union)(FromUnion(T.anyOf, K)) : (0, kind_1.IsObject)(T) ? FromObject(T, K) : (0, index_3.Object)({});
    }
    function Pick(T, K, options) {
      if ((0, kind_1.IsMappedKey)(K))
        return (0, pick_from_mapped_key_1.PickFromMappedKey)(T, K, options);
      if ((0, kind_1.IsMappedResult)(T))
        return (0, pick_from_mapped_result_1.PickFromMappedResult)(T, K, options);
      const I = (0, kind_1.IsSchema)(K) ? (0, index_4.IndexPropertyKeys)(K) : K;
      return (0, type_1.CreateType)({ ...PickResolve(T, I), ...options });
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/pick/pick-from-mapped-key.js
var require_pick_from_mapped_key = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/pick/pick-from-mapped-key.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PickFromMappedKey = PickFromMappedKey;
    var index_1 = require_mapped2();
    var pick_1 = require_pick();
    var value_1 = require_value2();
    function FromPropertyKey(T, K, options) {
      return {
        [K]: (0, pick_1.Pick)(T, [K], (0, value_1.Clone)(options))
      };
    }
    function FromPropertyKeys(T, K, options) {
      return K.reduce((Acc, LK) => {
        return { ...Acc, ...FromPropertyKey(T, LK, options) };
      }, {});
    }
    function FromMappedKey(T, K, options) {
      return FromPropertyKeys(T, K.keys, options);
    }
    function PickFromMappedKey(T, K, options) {
      const P = FromMappedKey(T, K, options);
      return (0, index_1.MappedResult)(P);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/pick/index.js
var require_pick2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/pick/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_pick_from_mapped_key(), exports2);
    __exportStar2(require_pick_from_mapped_result(), exports2);
    __exportStar2(require_pick(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/readonly-optional/readonly-optional.js
var require_readonly_optional = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/readonly-optional/readonly-optional.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ReadonlyOptional = ReadonlyOptional;
    var index_1 = require_readonly2();
    var index_2 = require_optional2();
    function ReadonlyOptional(schema) {
      return (0, index_1.Readonly)((0, index_2.Optional)(schema));
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/readonly-optional/index.js
var require_readonly_optional2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/readonly-optional/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_readonly_optional(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/record/record.js
var require_record = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/record/record.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Record = Record;
    var type_1 = require_type3();
    var index_1 = require_object2();
    var index_2 = require_never2();
    var index_3 = require_union3();
    var index_4 = require_template_literal2();
    var index_5 = require_patterns2();
    var index_6 = require_indexed2();
    var index_7 = require_symbols2();
    var value_1 = require_value();
    var kind_1 = require_kind();
    function RecordCreateFromPattern(pattern, T, options) {
      return (0, type_1.CreateType)({
        [index_7.Kind]: "Record",
        type: "object",
        patternProperties: { [pattern]: T }
      }, options);
    }
    function RecordCreateFromKeys(K, T, options) {
      const Acc = {};
      for (const K2 of K)
        Acc[K2] = T;
      return (0, index_1.Object)(Acc, { ...options, [index_7.Hint]: "Record" });
    }
    function FromTemplateLiteralKey(K, T, options) {
      return (0, index_4.IsTemplateLiteralFinite)(K) ? RecordCreateFromKeys((0, index_6.IndexPropertyKeys)(K), T, options) : RecordCreateFromPattern(K.pattern, T, options);
    }
    function FromUnionKey(K, T, options) {
      return RecordCreateFromKeys((0, index_6.IndexPropertyKeys)((0, index_3.Union)(K)), T, options);
    }
    function FromLiteralKey(K, T, options) {
      return RecordCreateFromKeys([K.toString()], T, options);
    }
    function FromRegExpKey(K, T, options) {
      return RecordCreateFromPattern(K.source, T, options);
    }
    function FromStringKey(K, T, options) {
      const pattern = (0, value_1.IsUndefined)(K.pattern) ? index_5.PatternStringExact : K.pattern;
      return RecordCreateFromPattern(pattern, T, options);
    }
    function FromAnyKey(K, T, options) {
      return RecordCreateFromPattern(index_5.PatternStringExact, T, options);
    }
    function FromNeverKey(K, T, options) {
      return RecordCreateFromPattern(index_5.PatternNeverExact, T, options);
    }
    function FromIntegerKey(_, T, options) {
      return RecordCreateFromPattern(index_5.PatternNumberExact, T, options);
    }
    function FromNumberKey(_, T, options) {
      return RecordCreateFromPattern(index_5.PatternNumberExact, T, options);
    }
    function Record(K, T, options = {}) {
      return (0, kind_1.IsUnion)(K) ? FromUnionKey(K.anyOf, T, options) : (0, kind_1.IsTemplateLiteral)(K) ? FromTemplateLiteralKey(K, T, options) : (0, kind_1.IsLiteral)(K) ? FromLiteralKey(K.const, T, options) : (0, kind_1.IsInteger)(K) ? FromIntegerKey(K, T, options) : (0, kind_1.IsNumber)(K) ? FromNumberKey(K, T, options) : (0, kind_1.IsRegExp)(K) ? FromRegExpKey(K, T, options) : (0, kind_1.IsString)(K) ? FromStringKey(K, T, options) : (0, kind_1.IsAny)(K) ? FromAnyKey(K, T, options) : (0, kind_1.IsNever)(K) ? FromNeverKey(K, T, options) : (0, index_2.Never)(options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/record/index.js
var require_record2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/record/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_record(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/recursive/recursive.js
var require_recursive = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/recursive/recursive.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Recursive = Recursive;
    var type_1 = require_type2();
    var type_2 = require_type3();
    var value_1 = require_value();
    var index_1 = require_symbols2();
    var Ordinal = 0;
    function Recursive(callback, options = {}) {
      if ((0, value_1.IsUndefined)(options.$id))
        options.$id = `T${Ordinal++}`;
      const thisType = (0, type_1.CloneType)(callback({ [index_1.Kind]: "This", $ref: `${options.$id}` }));
      thisType.$id = options.$id;
      return (0, type_2.CreateType)({ [index_1.Hint]: "Recursive", ...thisType }, options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/recursive/index.js
var require_recursive2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/recursive/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_recursive(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/ref/ref.js
var require_ref2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/ref/ref.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Ref = Ref;
    var type_1 = require_type3();
    var index_1 = require_symbols2();
    var value_1 = require_value();
    function Ref(unresolved, options) {
      if ((0, value_1.IsString)(unresolved))
        return (0, type_1.CreateType)({ [index_1.Kind]: "Ref", $ref: unresolved }, options);
      if ((0, value_1.IsUndefined)(unresolved.$id))
        throw new Error("Reference target type must specify an $id");
      return (0, type_1.CreateType)({ [index_1.Kind]: "Ref", $ref: unresolved.$id }, options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/ref/index.js
var require_ref3 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/ref/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_ref2(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/regexp/regexp.js
var require_regexp = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/regexp/regexp.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RegExp = RegExp2;
    var type_1 = require_type3();
    var value_1 = require_value();
    var index_1 = require_symbols2();
    function RegExp2(unresolved, options) {
      const expr = (0, value_1.IsString)(unresolved) ? new globalThis.RegExp(unresolved) : unresolved;
      return (0, type_1.CreateType)({ [index_1.Kind]: "RegExp", type: "RegExp", source: expr.source, flags: expr.flags }, options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/regexp/index.js
var require_regexp2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/regexp/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_regexp(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/required/required.js
var require_required = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/required/required.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Required = Required;
    var type_1 = require_type3();
    var index_1 = require_intersect2();
    var index_2 = require_union3();
    var index_3 = require_object2();
    var index_4 = require_symbols2();
    var index_5 = require_discard2();
    var required_from_mapped_result_1 = require_required_from_mapped_result();
    var kind_1 = require_kind();
    function FromRest(T) {
      return T.map((L) => RequiredResolve(L));
    }
    function FromProperties(T) {
      const Acc = {};
      for (const K of globalThis.Object.getOwnPropertyNames(T))
        Acc[K] = (0, index_5.Discard)(T[K], [index_4.OptionalKind]);
      return Acc;
    }
    function FromObject(T) {
      const options = (0, index_5.Discard)(T, [index_4.TransformKind, "$id", "required", "properties"]);
      const properties = FromProperties(T["properties"]);
      return (0, index_3.Object)(properties, options);
    }
    function RequiredResolve(T) {
      return (0, kind_1.IsIntersect)(T) ? (0, index_1.Intersect)(FromRest(T.allOf)) : (0, kind_1.IsUnion)(T) ? (0, index_2.Union)(FromRest(T.anyOf)) : (0, kind_1.IsObject)(T) ? FromObject(T) : (0, index_3.Object)({});
    }
    function Required(T, options) {
      if ((0, kind_1.IsMappedResult)(T)) {
        return (0, required_from_mapped_result_1.RequiredFromMappedResult)(T, options);
      } else {
        return (0, type_1.CreateType)({ ...RequiredResolve(T), ...options });
      }
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/required/required-from-mapped-result.js
var require_required_from_mapped_result = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/required/required-from-mapped-result.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RequiredFromMappedResult = RequiredFromMappedResult;
    var index_1 = require_mapped2();
    var required_1 = require_required();
    function FromProperties(P, options) {
      const Acc = {};
      for (const K2 of globalThis.Object.getOwnPropertyNames(P))
        Acc[K2] = (0, required_1.Required)(P[K2], options);
      return Acc;
    }
    function FromMappedResult(R, options) {
      return FromProperties(R.properties, options);
    }
    function RequiredFromMappedResult(R, options) {
      const P = FromMappedResult(R, options);
      return (0, index_1.MappedResult)(P);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/required/index.js
var require_required2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/required/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_required_from_mapped_result(), exports2);
    __exportStar2(require_required(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/rest/rest.js
var require_rest = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/rest/rest.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Rest = Rest;
    var kind_1 = require_kind();
    function RestResolve(T) {
      return (0, kind_1.IsIntersect)(T) ? T.allOf : (0, kind_1.IsUnion)(T) ? T.anyOf : (0, kind_1.IsTuple)(T) ? T.items ?? [] : [];
    }
    function Rest(T) {
      return RestResolve(T);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/rest/index.js
var require_rest2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/rest/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_rest(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/return-type/return-type.js
var require_return_type = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/return-type/return-type.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ReturnType = ReturnType;
    var type_1 = require_type3();
    function ReturnType(schema, options) {
      return (0, type_1.CreateType)(schema.returns, options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/return-type/index.js
var require_return_type2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/return-type/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_return_type(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/schema/anyschema.js
var require_anyschema = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/schema/anyschema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/schema/schema.js
var require_schema = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/schema/schema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var index_1 = require_symbols2();
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/schema/index.js
var require_schema2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/schema/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_anyschema(), exports2);
    __exportStar2(require_schema(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/static/static.js
var require_static = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/static/static.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/static/index.js
var require_static2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/static/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_static(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/strict/strict.js
var require_strict = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/strict/strict.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Strict = Strict;
    function Strict(schema) {
      return JSON.parse(JSON.stringify(schema));
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/strict/index.js
var require_strict2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/strict/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_strict(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/transform/transform.js
var require_transform = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/transform/transform.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TransformEncodeBuilder = exports2.TransformDecodeBuilder = void 0;
    exports2.Transform = Transform;
    var index_1 = require_symbols2();
    var kind_1 = require_kind();
    var TransformDecodeBuilder = class {
      constructor(schema) {
        this.schema = schema;
      }
      Decode(decode) {
        return new TransformEncodeBuilder(this.schema, decode);
      }
    };
    exports2.TransformDecodeBuilder = TransformDecodeBuilder;
    var TransformEncodeBuilder = class {
      constructor(schema, decode) {
        this.schema = schema;
        this.decode = decode;
      }
      EncodeTransform(encode, schema) {
        const Encode = (value) => schema[index_1.TransformKind].Encode(encode(value));
        const Decode = (value) => this.decode(schema[index_1.TransformKind].Decode(value));
        const Codec = { Encode, Decode };
        return { ...schema, [index_1.TransformKind]: Codec };
      }
      EncodeSchema(encode, schema) {
        const Codec = { Decode: this.decode, Encode: encode };
        return { ...schema, [index_1.TransformKind]: Codec };
      }
      Encode(encode) {
        return (0, kind_1.IsTransform)(this.schema) ? this.EncodeTransform(encode, this.schema) : this.EncodeSchema(encode, this.schema);
      }
    };
    exports2.TransformEncodeBuilder = TransformEncodeBuilder;
    function Transform(schema) {
      return new TransformDecodeBuilder(schema);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/transform/index.js
var require_transform2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/transform/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_transform(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/unsafe/unsafe.js
var require_unsafe = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/unsafe/unsafe.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Unsafe = Unsafe;
    var type_1 = require_type3();
    var index_1 = require_symbols2();
    function Unsafe(options = {}) {
      return (0, type_1.CreateType)({ [index_1.Kind]: options[index_1.Kind] ?? "Unsafe" }, options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/unsafe/index.js
var require_unsafe2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/unsafe/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_unsafe(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/void/void.js
var require_void = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/void/void.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Void = Void;
    var type_1 = require_type3();
    var index_1 = require_symbols2();
    function Void(options) {
      return (0, type_1.CreateType)({ [index_1.Kind]: "Void", type: "void" }, options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/void/index.js
var require_void2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/void/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_void(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/type/json.js
var require_json = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/type/json.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.JsonTypeBuilder = void 0;
    var index_1 = require_any2();
    var index_2 = require_array2();
    var index_3 = require_boolean2();
    var index_4 = require_composite2();
    var index_5 = require_const2();
    var index_6 = require_deref2();
    var index_7 = require_enum2();
    var index_8 = require_exclude2();
    var index_9 = require_extends2();
    var index_10 = require_extract2();
    var index_11 = require_indexed2();
    var index_12 = require_integer2();
    var index_13 = require_intersect2();
    var index_14 = require_intrinsic2();
    var index_15 = require_keyof2();
    var index_16 = require_literal2();
    var index_17 = require_mapped2();
    var index_18 = require_never2();
    var index_19 = require_not2();
    var index_20 = require_null2();
    var index_21 = require_number2();
    var index_22 = require_object2();
    var index_23 = require_omit2();
    var index_24 = require_optional2();
    var index_25 = require_partial2();
    var index_26 = require_pick2();
    var index_27 = require_readonly2();
    var index_28 = require_readonly_optional2();
    var index_29 = require_record2();
    var index_30 = require_recursive2();
    var index_31 = require_ref3();
    var index_32 = require_required2();
    var index_33 = require_rest2();
    var index_34 = require_strict2();
    var index_35 = require_string2();
    var index_36 = require_template_literal2();
    var index_37 = require_transform2();
    var index_38 = require_tuple2();
    var index_39 = require_union3();
    var index_40 = require_unknown2();
    var index_41 = require_unsafe2();
    var JsonTypeBuilder = class {
      // ------------------------------------------------------------------------
      // Strict
      // ------------------------------------------------------------------------
      /**
       * @deprecated `[Json]` Omits compositing symbols from this schema. It is recommended
       * to use the JSON parse/stringify to remove compositing symbols if needed. This
       * is how Strict works internally.
       *
       * ```typescript
       * JSON.parse(JSON.stringify(Type.String()))
       * ```
       */
      Strict(schema) {
        return (0, index_34.Strict)(schema);
      }
      // ------------------------------------------------------------------------
      // Modifiers
      // ------------------------------------------------------------------------
      /** `[Json]` Creates a Readonly and Optional property */
      ReadonlyOptional(schema) {
        return (0, index_28.ReadonlyOptional)(schema);
      }
      /** `[Json]` Creates a Readonly property */
      Readonly(schema, enable) {
        return (0, index_27.Readonly)(schema, enable ?? true);
      }
      /** `[Json]` Creates a Optional property */
      Optional(schema, enable) {
        return (0, index_24.Optional)(schema, enable ?? true);
      }
      // ------------------------------------------------------------------------
      // Types
      // ------------------------------------------------------------------------
      /** `[Json]` Creates an Any type */
      Any(options) {
        return (0, index_1.Any)(options);
      }
      /** `[Json]` Creates an Array type */
      Array(schema, options) {
        return (0, index_2.Array)(schema, options);
      }
      /** `[Json]` Creates a Boolean type */
      Boolean(options) {
        return (0, index_3.Boolean)(options);
      }
      /** `[Json]` Intrinsic function to Capitalize LiteralString types */
      Capitalize(schema, options) {
        return (0, index_14.Capitalize)(schema, options);
      }
      /** `[Json]` Creates a Composite object type */
      Composite(schemas, options) {
        return (0, index_4.Composite)(schemas, options);
      }
      /** `[JavaScript]` Creates a readonly const type from the given value. */
      Const(value, options) {
        return (0, index_5.Const)(value, options);
      }
      /** `[Json]` Creates a dereferenced type */
      Deref(schema, references) {
        return (0, index_6.Deref)(schema, references);
      }
      /** `[Json]` Creates a Enum type */
      Enum(item, options) {
        return (0, index_7.Enum)(item, options);
      }
      /** `[Json]` Constructs a type by excluding from unionType all union members that are assignable to excludedMembers */
      Exclude(unionType, excludedMembers, options) {
        return (0, index_8.Exclude)(unionType, excludedMembers, options);
      }
      /** `[Json]` Creates a Conditional type */
      Extends(L, R, T, F, options) {
        return (0, index_9.Extends)(L, R, T, F, options);
      }
      /** `[Json]` Constructs a type by extracting from type all union members that are assignable to union */
      Extract(type, union, options) {
        return (0, index_10.Extract)(type, union, options);
      }
      /** `[Json]` Returns an Indexed property type for the given keys */
      Index(schema, unresolved, options) {
        return (0, index_11.Index)(schema, unresolved, options);
      }
      /** `[Json]` Creates an Integer type */
      Integer(options) {
        return (0, index_12.Integer)(options);
      }
      /** `[Json]` Creates an Intersect type */
      Intersect(T, options) {
        return (0, index_13.Intersect)(T, options);
      }
      /** `[Json]` Creates a KeyOf type */
      KeyOf(schema, options) {
        return (0, index_15.KeyOf)(schema, options);
      }
      /** `[Json]` Creates a Literal type */
      Literal(value, options) {
        return (0, index_16.Literal)(value, options);
      }
      /** `[Json]` Intrinsic function to Lowercase LiteralString types */
      Lowercase(schema, options) {
        return (0, index_14.Lowercase)(schema, options);
      }
      /** `[Json]` Creates a Mapped object type */
      Mapped(key, map, options) {
        return (0, index_17.Mapped)(key, map, options);
      }
      /** `[Json]` Creates a Never type */
      Never(options) {
        return (0, index_18.Never)(options);
      }
      /** `[Json]` Creates a Not type */
      Not(schema, options) {
        return (0, index_19.Not)(schema, options);
      }
      /** `[Json]` Creates a Null type */
      Null(options) {
        return (0, index_20.Null)(options);
      }
      /** `[Json]` Creates a Number type */
      Number(options) {
        return (0, index_21.Number)(options);
      }
      /** `[Json]` Creates an Object type */
      Object(properties, options) {
        return (0, index_22.Object)(properties, options);
      }
      /** `[Json]` Constructs a type whose keys are omitted from the given type */
      Omit(schema, unresolved, options) {
        return (0, index_23.Omit)(schema, unresolved, options);
      }
      /** `[Json]` Constructs a type where all properties are optional */
      Partial(schema, options) {
        return (0, index_25.Partial)(schema, options);
      }
      /** `[Json]` Constructs a type whose keys are picked from the given type */
      Pick(schema, unresolved, options) {
        return (0, index_26.Pick)(schema, unresolved, options);
      }
      /** `[Json]` Creates a Record type */
      Record(key, schema, options) {
        return (0, index_29.Record)(key, schema, options);
      }
      /** `[Json]` Creates a Recursive type */
      Recursive(callback, options) {
        return (0, index_30.Recursive)(callback, options);
      }
      /** `[Json]` Creates a Ref type. */
      Ref(unresolved, options) {
        return (0, index_31.Ref)(unresolved, options);
      }
      /** `[Json]` Constructs a type where all properties are required */
      Required(schema, options) {
        return (0, index_32.Required)(schema, options);
      }
      /** `[Json]` Extracts interior Rest elements from Tuple, Intersect and Union types */
      Rest(schema) {
        return (0, index_33.Rest)(schema);
      }
      /** `[Json]` Creates a String type */
      String(options) {
        return (0, index_35.String)(options);
      }
      /** `[Json]` Creates a TemplateLiteral type */
      TemplateLiteral(unresolved, options) {
        return (0, index_36.TemplateLiteral)(unresolved, options);
      }
      /** `[Json]` Creates a Transform type */
      Transform(schema) {
        return (0, index_37.Transform)(schema);
      }
      /** `[Json]` Creates a Tuple type */
      Tuple(items, options) {
        return (0, index_38.Tuple)(items, options);
      }
      /** `[Json]` Intrinsic function to Uncapitalize LiteralString types */
      Uncapitalize(schema, options) {
        return (0, index_14.Uncapitalize)(schema, options);
      }
      /** `[Json]` Creates a Union type */
      Union(schemas, options) {
        return (0, index_39.Union)(schemas, options);
      }
      /** `[Json]` Creates an Unknown type */
      Unknown(options) {
        return (0, index_40.Unknown)(options);
      }
      /** `[Json]` Creates a Unsafe type that will infers as the generic argument T */
      Unsafe(options) {
        return (0, index_41.Unsafe)(options);
      }
      /** `[Json]` Intrinsic function to Uppercase LiteralString types */
      Uppercase(schema, options) {
        return (0, index_14.Uppercase)(schema, options);
      }
    };
    exports2.JsonTypeBuilder = JsonTypeBuilder;
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/type/type.js
var require_type6 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/type/type.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.String = exports2.ReturnType = exports2.Rest = exports2.Required = exports2.RegExp = exports2.Ref = exports2.Recursive = exports2.Record = exports2.ReadonlyOptional = exports2.Readonly = exports2.Promise = exports2.Pick = exports2.Partial = exports2.Parameters = exports2.Optional = exports2.Omit = exports2.Object = exports2.Number = exports2.Null = exports2.Not = exports2.Never = exports2.Mapped = exports2.Literal = exports2.KeyOf = exports2.Iterator = exports2.Uppercase = exports2.Lowercase = exports2.Uncapitalize = exports2.Capitalize = exports2.Intersect = exports2.Integer = exports2.InstanceType = exports2.Index = exports2.Function = exports2.Extract = exports2.Extends = exports2.Exclude = exports2.Enum = exports2.Deref = exports2.Date = exports2.ConstructorParameters = exports2.Constructor = exports2.Const = exports2.Composite = exports2.Boolean = exports2.BigInt = exports2.Awaited = exports2.AsyncIterator = exports2.Array = exports2.Any = void 0;
    exports2.Void = exports2.Unsafe = exports2.Unknown = exports2.Union = exports2.Undefined = exports2.Uint8Array = exports2.Tuple = exports2.Transform = exports2.TemplateLiteral = exports2.Symbol = exports2.Strict = void 0;
    var index_1 = require_any2();
    Object.defineProperty(exports2, "Any", { enumerable: true, get: function() {
      return index_1.Any;
    } });
    var index_2 = require_array2();
    Object.defineProperty(exports2, "Array", { enumerable: true, get: function() {
      return index_2.Array;
    } });
    var index_3 = require_async_iterator3();
    Object.defineProperty(exports2, "AsyncIterator", { enumerable: true, get: function() {
      return index_3.AsyncIterator;
    } });
    var index_4 = require_awaited2();
    Object.defineProperty(exports2, "Awaited", { enumerable: true, get: function() {
      return index_4.Awaited;
    } });
    var index_5 = require_bigint2();
    Object.defineProperty(exports2, "BigInt", { enumerable: true, get: function() {
      return index_5.BigInt;
    } });
    var index_6 = require_boolean2();
    Object.defineProperty(exports2, "Boolean", { enumerable: true, get: function() {
      return index_6.Boolean;
    } });
    var index_7 = require_composite2();
    Object.defineProperty(exports2, "Composite", { enumerable: true, get: function() {
      return index_7.Composite;
    } });
    var index_8 = require_const2();
    Object.defineProperty(exports2, "Const", { enumerable: true, get: function() {
      return index_8.Const;
    } });
    var index_9 = require_constructor2();
    Object.defineProperty(exports2, "Constructor", { enumerable: true, get: function() {
      return index_9.Constructor;
    } });
    var index_10 = require_constructor_parameters2();
    Object.defineProperty(exports2, "ConstructorParameters", { enumerable: true, get: function() {
      return index_10.ConstructorParameters;
    } });
    var index_11 = require_date2();
    Object.defineProperty(exports2, "Date", { enumerable: true, get: function() {
      return index_11.Date;
    } });
    var index_12 = require_deref2();
    Object.defineProperty(exports2, "Deref", { enumerable: true, get: function() {
      return index_12.Deref;
    } });
    var index_13 = require_enum2();
    Object.defineProperty(exports2, "Enum", { enumerable: true, get: function() {
      return index_13.Enum;
    } });
    var index_14 = require_exclude2();
    Object.defineProperty(exports2, "Exclude", { enumerable: true, get: function() {
      return index_14.Exclude;
    } });
    var index_15 = require_extends2();
    Object.defineProperty(exports2, "Extends", { enumerable: true, get: function() {
      return index_15.Extends;
    } });
    var index_16 = require_extract2();
    Object.defineProperty(exports2, "Extract", { enumerable: true, get: function() {
      return index_16.Extract;
    } });
    var index_17 = require_function2();
    Object.defineProperty(exports2, "Function", { enumerable: true, get: function() {
      return index_17.Function;
    } });
    var index_18 = require_indexed2();
    Object.defineProperty(exports2, "Index", { enumerable: true, get: function() {
      return index_18.Index;
    } });
    var index_19 = require_instance_type2();
    Object.defineProperty(exports2, "InstanceType", { enumerable: true, get: function() {
      return index_19.InstanceType;
    } });
    var index_20 = require_integer2();
    Object.defineProperty(exports2, "Integer", { enumerable: true, get: function() {
      return index_20.Integer;
    } });
    var index_21 = require_intersect2();
    Object.defineProperty(exports2, "Intersect", { enumerable: true, get: function() {
      return index_21.Intersect;
    } });
    var index_22 = require_intrinsic2();
    Object.defineProperty(exports2, "Capitalize", { enumerable: true, get: function() {
      return index_22.Capitalize;
    } });
    Object.defineProperty(exports2, "Uncapitalize", { enumerable: true, get: function() {
      return index_22.Uncapitalize;
    } });
    Object.defineProperty(exports2, "Lowercase", { enumerable: true, get: function() {
      return index_22.Lowercase;
    } });
    Object.defineProperty(exports2, "Uppercase", { enumerable: true, get: function() {
      return index_22.Uppercase;
    } });
    var index_23 = require_iterator2();
    Object.defineProperty(exports2, "Iterator", { enumerable: true, get: function() {
      return index_23.Iterator;
    } });
    var index_24 = require_keyof2();
    Object.defineProperty(exports2, "KeyOf", { enumerable: true, get: function() {
      return index_24.KeyOf;
    } });
    var index_25 = require_literal2();
    Object.defineProperty(exports2, "Literal", { enumerable: true, get: function() {
      return index_25.Literal;
    } });
    var index_26 = require_mapped2();
    Object.defineProperty(exports2, "Mapped", { enumerable: true, get: function() {
      return index_26.Mapped;
    } });
    var index_27 = require_never2();
    Object.defineProperty(exports2, "Never", { enumerable: true, get: function() {
      return index_27.Never;
    } });
    var index_28 = require_not2();
    Object.defineProperty(exports2, "Not", { enumerable: true, get: function() {
      return index_28.Not;
    } });
    var index_29 = require_null2();
    Object.defineProperty(exports2, "Null", { enumerable: true, get: function() {
      return index_29.Null;
    } });
    var index_30 = require_number2();
    Object.defineProperty(exports2, "Number", { enumerable: true, get: function() {
      return index_30.Number;
    } });
    var index_31 = require_object2();
    Object.defineProperty(exports2, "Object", { enumerable: true, get: function() {
      return index_31.Object;
    } });
    var index_32 = require_omit2();
    Object.defineProperty(exports2, "Omit", { enumerable: true, get: function() {
      return index_32.Omit;
    } });
    var index_33 = require_optional2();
    Object.defineProperty(exports2, "Optional", { enumerable: true, get: function() {
      return index_33.Optional;
    } });
    var index_34 = require_parameters2();
    Object.defineProperty(exports2, "Parameters", { enumerable: true, get: function() {
      return index_34.Parameters;
    } });
    var index_35 = require_partial2();
    Object.defineProperty(exports2, "Partial", { enumerable: true, get: function() {
      return index_35.Partial;
    } });
    var index_36 = require_pick2();
    Object.defineProperty(exports2, "Pick", { enumerable: true, get: function() {
      return index_36.Pick;
    } });
    var index_37 = require_promise2();
    Object.defineProperty(exports2, "Promise", { enumerable: true, get: function() {
      return index_37.Promise;
    } });
    var index_38 = require_readonly2();
    Object.defineProperty(exports2, "Readonly", { enumerable: true, get: function() {
      return index_38.Readonly;
    } });
    var index_39 = require_readonly_optional2();
    Object.defineProperty(exports2, "ReadonlyOptional", { enumerable: true, get: function() {
      return index_39.ReadonlyOptional;
    } });
    var index_40 = require_record2();
    Object.defineProperty(exports2, "Record", { enumerable: true, get: function() {
      return index_40.Record;
    } });
    var index_41 = require_recursive2();
    Object.defineProperty(exports2, "Recursive", { enumerable: true, get: function() {
      return index_41.Recursive;
    } });
    var index_42 = require_ref3();
    Object.defineProperty(exports2, "Ref", { enumerable: true, get: function() {
      return index_42.Ref;
    } });
    var index_43 = require_regexp2();
    Object.defineProperty(exports2, "RegExp", { enumerable: true, get: function() {
      return index_43.RegExp;
    } });
    var index_44 = require_required2();
    Object.defineProperty(exports2, "Required", { enumerable: true, get: function() {
      return index_44.Required;
    } });
    var index_45 = require_rest2();
    Object.defineProperty(exports2, "Rest", { enumerable: true, get: function() {
      return index_45.Rest;
    } });
    var index_46 = require_return_type2();
    Object.defineProperty(exports2, "ReturnType", { enumerable: true, get: function() {
      return index_46.ReturnType;
    } });
    var index_47 = require_string2();
    Object.defineProperty(exports2, "String", { enumerable: true, get: function() {
      return index_47.String;
    } });
    var index_48 = require_strict2();
    Object.defineProperty(exports2, "Strict", { enumerable: true, get: function() {
      return index_48.Strict;
    } });
    var index_49 = require_symbol2();
    Object.defineProperty(exports2, "Symbol", { enumerable: true, get: function() {
      return index_49.Symbol;
    } });
    var index_50 = require_template_literal2();
    Object.defineProperty(exports2, "TemplateLiteral", { enumerable: true, get: function() {
      return index_50.TemplateLiteral;
    } });
    var index_51 = require_transform2();
    Object.defineProperty(exports2, "Transform", { enumerable: true, get: function() {
      return index_51.Transform;
    } });
    var index_52 = require_tuple2();
    Object.defineProperty(exports2, "Tuple", { enumerable: true, get: function() {
      return index_52.Tuple;
    } });
    var index_53 = require_uint8array2();
    Object.defineProperty(exports2, "Uint8Array", { enumerable: true, get: function() {
      return index_53.Uint8Array;
    } });
    var index_54 = require_undefined2();
    Object.defineProperty(exports2, "Undefined", { enumerable: true, get: function() {
      return index_54.Undefined;
    } });
    var index_55 = require_union3();
    Object.defineProperty(exports2, "Union", { enumerable: true, get: function() {
      return index_55.Union;
    } });
    var index_56 = require_unknown2();
    Object.defineProperty(exports2, "Unknown", { enumerable: true, get: function() {
      return index_56.Unknown;
    } });
    var index_57 = require_unsafe2();
    Object.defineProperty(exports2, "Unsafe", { enumerable: true, get: function() {
      return index_57.Unsafe;
    } });
    var index_58 = require_void2();
    Object.defineProperty(exports2, "Void", { enumerable: true, get: function() {
      return index_58.Void;
    } });
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/type/javascript.js
var require_javascript = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/type/javascript.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.JavaScriptTypeBuilder = void 0;
    var json_1 = require_json();
    var index_1 = require_async_iterator3();
    var index_2 = require_awaited2();
    var index_3 = require_bigint2();
    var index_4 = require_constructor2();
    var index_5 = require_constructor_parameters2();
    var index_6 = require_date2();
    var index_7 = require_function2();
    var index_8 = require_instance_type2();
    var index_9 = require_iterator2();
    var index_10 = require_parameters2();
    var index_11 = require_promise2();
    var index_12 = require_regexp2();
    var index_13 = require_return_type2();
    var index_14 = require_symbol2();
    var index_15 = require_uint8array2();
    var index_16 = require_undefined2();
    var index_17 = require_void2();
    var JavaScriptTypeBuilder = class extends json_1.JsonTypeBuilder {
      /** `[JavaScript]` Creates a AsyncIterator type */
      AsyncIterator(items, options) {
        return (0, index_1.AsyncIterator)(items, options);
      }
      /** `[JavaScript]` Constructs a type by recursively unwrapping Promise types */
      Awaited(schema, options) {
        return (0, index_2.Awaited)(schema, options);
      }
      /** `[JavaScript]` Creates a BigInt type */
      BigInt(options) {
        return (0, index_3.BigInt)(options);
      }
      /** `[JavaScript]` Extracts the ConstructorParameters from the given Constructor type */
      ConstructorParameters(schema, options) {
        return (0, index_5.ConstructorParameters)(schema, options);
      }
      /** `[JavaScript]` Creates a Constructor type */
      Constructor(parameters, returns, options) {
        return (0, index_4.Constructor)(parameters, returns, options);
      }
      /** `[JavaScript]` Creates a Date type */
      Date(options = {}) {
        return (0, index_6.Date)(options);
      }
      /** `[JavaScript]` Creates a Function type */
      Function(parameters, returns, options) {
        return (0, index_7.Function)(parameters, returns, options);
      }
      /** `[JavaScript]` Extracts the InstanceType from the given Constructor type */
      InstanceType(schema, options) {
        return (0, index_8.InstanceType)(schema, options);
      }
      /** `[JavaScript]` Creates an Iterator type */
      Iterator(items, options) {
        return (0, index_9.Iterator)(items, options);
      }
      /** `[JavaScript]` Extracts the Parameters from the given Function type */
      Parameters(schema, options) {
        return (0, index_10.Parameters)(schema, options);
      }
      /** `[JavaScript]` Creates a Promise type */
      Promise(item, options) {
        return (0, index_11.Promise)(item, options);
      }
      /** `[JavaScript]` Creates a RegExp type */
      RegExp(unresolved, options) {
        return (0, index_12.RegExp)(unresolved, options);
      }
      /** `[JavaScript]` Extracts the ReturnType from the given Function type */
      ReturnType(schema, options) {
        return (0, index_13.ReturnType)(schema, options);
      }
      /** `[JavaScript]` Creates a Symbol type */
      Symbol(options) {
        return (0, index_14.Symbol)(options);
      }
      /** `[JavaScript]` Creates a Undefined type */
      Undefined(options) {
        return (0, index_16.Undefined)(options);
      }
      /** `[JavaScript]` Creates a Uint8Array type */
      Uint8Array(options) {
        return (0, index_15.Uint8Array)(options);
      }
      /** `[JavaScript]` Creates a Void type */
      Void(options) {
        return (0, index_17.Void)(options);
      }
    };
    exports2.JavaScriptTypeBuilder = JavaScriptTypeBuilder;
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/type/index.js
var require_type7 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/type/type/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Type = exports2.JavaScriptTypeBuilder = exports2.JsonTypeBuilder = void 0;
    var json_1 = require_json();
    Object.defineProperty(exports2, "JsonTypeBuilder", { enumerable: true, get: function() {
      return json_1.JsonTypeBuilder;
    } });
    var TypeBuilder = require_type6();
    var javascript_1 = require_javascript();
    Object.defineProperty(exports2, "JavaScriptTypeBuilder", { enumerable: true, get: function() {
      return javascript_1.JavaScriptTypeBuilder;
    } });
    var Type = TypeBuilder;
    exports2.Type = Type;
  }
});

// node_modules/@sinclair/typebox/build/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_clone(), exports2);
    __exportStar2(require_create(), exports2);
    __exportStar2(require_error2(), exports2);
    __exportStar2(require_guard3(), exports2);
    __exportStar2(require_helpers2(), exports2);
    __exportStar2(require_patterns2(), exports2);
    __exportStar2(require_registry(), exports2);
    __exportStar2(require_sets(), exports2);
    __exportStar2(require_symbols2(), exports2);
    __exportStar2(require_any2(), exports2);
    __exportStar2(require_array2(), exports2);
    __exportStar2(require_async_iterator3(), exports2);
    __exportStar2(require_awaited2(), exports2);
    __exportStar2(require_bigint2(), exports2);
    __exportStar2(require_boolean2(), exports2);
    __exportStar2(require_composite2(), exports2);
    __exportStar2(require_const2(), exports2);
    __exportStar2(require_constructor2(), exports2);
    __exportStar2(require_constructor_parameters2(), exports2);
    __exportStar2(require_date2(), exports2);
    __exportStar2(require_deref2(), exports2);
    __exportStar2(require_enum2(), exports2);
    __exportStar2(require_exclude2(), exports2);
    __exportStar2(require_extends2(), exports2);
    __exportStar2(require_extract2(), exports2);
    __exportStar2(require_function2(), exports2);
    __exportStar2(require_indexed2(), exports2);
    __exportStar2(require_instance_type2(), exports2);
    __exportStar2(require_integer2(), exports2);
    __exportStar2(require_intersect2(), exports2);
    __exportStar2(require_iterator2(), exports2);
    __exportStar2(require_intrinsic2(), exports2);
    __exportStar2(require_keyof2(), exports2);
    __exportStar2(require_literal2(), exports2);
    __exportStar2(require_mapped2(), exports2);
    __exportStar2(require_never2(), exports2);
    __exportStar2(require_not2(), exports2);
    __exportStar2(require_null2(), exports2);
    __exportStar2(require_number2(), exports2);
    __exportStar2(require_object2(), exports2);
    __exportStar2(require_omit2(), exports2);
    __exportStar2(require_optional2(), exports2);
    __exportStar2(require_parameters2(), exports2);
    __exportStar2(require_partial2(), exports2);
    __exportStar2(require_pick2(), exports2);
    __exportStar2(require_promise2(), exports2);
    __exportStar2(require_readonly2(), exports2);
    __exportStar2(require_readonly_optional2(), exports2);
    __exportStar2(require_record2(), exports2);
    __exportStar2(require_recursive2(), exports2);
    __exportStar2(require_ref3(), exports2);
    __exportStar2(require_regexp2(), exports2);
    __exportStar2(require_required2(), exports2);
    __exportStar2(require_rest2(), exports2);
    __exportStar2(require_return_type2(), exports2);
    __exportStar2(require_schema2(), exports2);
    __exportStar2(require_static2(), exports2);
    __exportStar2(require_strict2(), exports2);
    __exportStar2(require_string2(), exports2);
    __exportStar2(require_symbol2(), exports2);
    __exportStar2(require_template_literal2(), exports2);
    __exportStar2(require_transform2(), exports2);
    __exportStar2(require_tuple2(), exports2);
    __exportStar2(require_uint8array2(), exports2);
    __exportStar2(require_undefined2(), exports2);
    __exportStar2(require_union3(), exports2);
    __exportStar2(require_unknown2(), exports2);
    __exportStar2(require_unsafe2(), exports2);
    __exportStar2(require_void2(), exports2);
    __exportStar2(require_type7(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/system/system.js
var require_system = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/system/system.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeSystem = exports2.TypeSystemDuplicateFormat = exports2.TypeSystemDuplicateTypeKind = void 0;
    var index_1 = require_registry();
    var index_2 = require_unsafe2();
    var index_3 = require_symbols2();
    var index_4 = require_error2();
    var TypeSystemDuplicateTypeKind = class extends index_4.TypeBoxError {
      constructor(kind) {
        super(`Duplicate type kind '${kind}' detected`);
      }
    };
    exports2.TypeSystemDuplicateTypeKind = TypeSystemDuplicateTypeKind;
    var TypeSystemDuplicateFormat = class extends index_4.TypeBoxError {
      constructor(kind) {
        super(`Duplicate string format '${kind}' detected`);
      }
    };
    exports2.TypeSystemDuplicateFormat = TypeSystemDuplicateFormat;
    var TypeSystem;
    (function(TypeSystem2) {
      function Type(kind, check) {
        if (index_1.TypeRegistry.Has(kind))
          throw new TypeSystemDuplicateTypeKind(kind);
        index_1.TypeRegistry.Set(kind, check);
        return (options = {}) => (0, index_2.Unsafe)({ ...options, [index_3.Kind]: kind });
      }
      TypeSystem2.Type = Type;
      function Format(format, check) {
        if (index_1.FormatRegistry.Has(format))
          throw new TypeSystemDuplicateFormat(format);
        index_1.FormatRegistry.Set(format, check);
        return format;
      }
      TypeSystem2.Format = Format;
    })(TypeSystem || (exports2.TypeSystem = TypeSystem = {}));
  }
});

// node_modules/@sinclair/typebox/build/cjs/system/index.js
var require_system2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/system/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_policy(), exports2);
    __exportStar2(require_system(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/errors/function.js
var require_function3 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/errors/function.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DefaultErrorFunction = DefaultErrorFunction;
    exports2.SetErrorFunction = SetErrorFunction;
    exports2.GetErrorFunction = GetErrorFunction;
    var index_1 = require_symbols2();
    var errors_1 = require_errors4();
    function DefaultErrorFunction(error) {
      switch (error.errorType) {
        case errors_1.ValueErrorType.ArrayContains:
          return "Expected array to contain at least one matching value";
        case errors_1.ValueErrorType.ArrayMaxContains:
          return `Expected array to contain no more than ${error.schema.maxContains} matching values`;
        case errors_1.ValueErrorType.ArrayMinContains:
          return `Expected array to contain at least ${error.schema.minContains} matching values`;
        case errors_1.ValueErrorType.ArrayMaxItems:
          return `Expected array length to be less or equal to ${error.schema.maxItems}`;
        case errors_1.ValueErrorType.ArrayMinItems:
          return `Expected array length to be greater or equal to ${error.schema.minItems}`;
        case errors_1.ValueErrorType.ArrayUniqueItems:
          return "Expected array elements to be unique";
        case errors_1.ValueErrorType.Array:
          return "Expected array";
        case errors_1.ValueErrorType.AsyncIterator:
          return "Expected AsyncIterator";
        case errors_1.ValueErrorType.BigIntExclusiveMaximum:
          return `Expected bigint to be less than ${error.schema.exclusiveMaximum}`;
        case errors_1.ValueErrorType.BigIntExclusiveMinimum:
          return `Expected bigint to be greater than ${error.schema.exclusiveMinimum}`;
        case errors_1.ValueErrorType.BigIntMaximum:
          return `Expected bigint to be less or equal to ${error.schema.maximum}`;
        case errors_1.ValueErrorType.BigIntMinimum:
          return `Expected bigint to be greater or equal to ${error.schema.minimum}`;
        case errors_1.ValueErrorType.BigIntMultipleOf:
          return `Expected bigint to be a multiple of ${error.schema.multipleOf}`;
        case errors_1.ValueErrorType.BigInt:
          return "Expected bigint";
        case errors_1.ValueErrorType.Boolean:
          return "Expected boolean";
        case errors_1.ValueErrorType.DateExclusiveMinimumTimestamp:
          return `Expected Date timestamp to be greater than ${error.schema.exclusiveMinimumTimestamp}`;
        case errors_1.ValueErrorType.DateExclusiveMaximumTimestamp:
          return `Expected Date timestamp to be less than ${error.schema.exclusiveMaximumTimestamp}`;
        case errors_1.ValueErrorType.DateMinimumTimestamp:
          return `Expected Date timestamp to be greater or equal to ${error.schema.minimumTimestamp}`;
        case errors_1.ValueErrorType.DateMaximumTimestamp:
          return `Expected Date timestamp to be less or equal to ${error.schema.maximumTimestamp}`;
        case errors_1.ValueErrorType.DateMultipleOfTimestamp:
          return `Expected Date timestamp to be a multiple of ${error.schema.multipleOfTimestamp}`;
        case errors_1.ValueErrorType.Date:
          return "Expected Date";
        case errors_1.ValueErrorType.Function:
          return "Expected function";
        case errors_1.ValueErrorType.IntegerExclusiveMaximum:
          return `Expected integer to be less than ${error.schema.exclusiveMaximum}`;
        case errors_1.ValueErrorType.IntegerExclusiveMinimum:
          return `Expected integer to be greater than ${error.schema.exclusiveMinimum}`;
        case errors_1.ValueErrorType.IntegerMaximum:
          return `Expected integer to be less or equal to ${error.schema.maximum}`;
        case errors_1.ValueErrorType.IntegerMinimum:
          return `Expected integer to be greater or equal to ${error.schema.minimum}`;
        case errors_1.ValueErrorType.IntegerMultipleOf:
          return `Expected integer to be a multiple of ${error.schema.multipleOf}`;
        case errors_1.ValueErrorType.Integer:
          return "Expected integer";
        case errors_1.ValueErrorType.IntersectUnevaluatedProperties:
          return "Unexpected property";
        case errors_1.ValueErrorType.Intersect:
          return "Expected all values to match";
        case errors_1.ValueErrorType.Iterator:
          return "Expected Iterator";
        case errors_1.ValueErrorType.Literal:
          return `Expected ${typeof error.schema.const === "string" ? `'${error.schema.const}'` : error.schema.const}`;
        case errors_1.ValueErrorType.Never:
          return "Never";
        case errors_1.ValueErrorType.Not:
          return "Value should not match";
        case errors_1.ValueErrorType.Null:
          return "Expected null";
        case errors_1.ValueErrorType.NumberExclusiveMaximum:
          return `Expected number to be less than ${error.schema.exclusiveMaximum}`;
        case errors_1.ValueErrorType.NumberExclusiveMinimum:
          return `Expected number to be greater than ${error.schema.exclusiveMinimum}`;
        case errors_1.ValueErrorType.NumberMaximum:
          return `Expected number to be less or equal to ${error.schema.maximum}`;
        case errors_1.ValueErrorType.NumberMinimum:
          return `Expected number to be greater or equal to ${error.schema.minimum}`;
        case errors_1.ValueErrorType.NumberMultipleOf:
          return `Expected number to be a multiple of ${error.schema.multipleOf}`;
        case errors_1.ValueErrorType.Number:
          return "Expected number";
        case errors_1.ValueErrorType.Object:
          return "Expected object";
        case errors_1.ValueErrorType.ObjectAdditionalProperties:
          return "Unexpected property";
        case errors_1.ValueErrorType.ObjectMaxProperties:
          return `Expected object to have no more than ${error.schema.maxProperties} properties`;
        case errors_1.ValueErrorType.ObjectMinProperties:
          return `Expected object to have at least ${error.schema.minProperties} properties`;
        case errors_1.ValueErrorType.ObjectRequiredProperty:
          return "Expected required property";
        case errors_1.ValueErrorType.Promise:
          return "Expected Promise";
        case errors_1.ValueErrorType.RegExp:
          return "Expected string to match regular expression";
        case errors_1.ValueErrorType.StringFormatUnknown:
          return `Unknown format '${error.schema.format}'`;
        case errors_1.ValueErrorType.StringFormat:
          return `Expected string to match '${error.schema.format}' format`;
        case errors_1.ValueErrorType.StringMaxLength:
          return `Expected string length less or equal to ${error.schema.maxLength}`;
        case errors_1.ValueErrorType.StringMinLength:
          return `Expected string length greater or equal to ${error.schema.minLength}`;
        case errors_1.ValueErrorType.StringPattern:
          return `Expected string to match '${error.schema.pattern}'`;
        case errors_1.ValueErrorType.String:
          return "Expected string";
        case errors_1.ValueErrorType.Symbol:
          return "Expected symbol";
        case errors_1.ValueErrorType.TupleLength:
          return `Expected tuple to have ${error.schema.maxItems || 0} elements`;
        case errors_1.ValueErrorType.Tuple:
          return "Expected tuple";
        case errors_1.ValueErrorType.Uint8ArrayMaxByteLength:
          return `Expected byte length less or equal to ${error.schema.maxByteLength}`;
        case errors_1.ValueErrorType.Uint8ArrayMinByteLength:
          return `Expected byte length greater or equal to ${error.schema.minByteLength}`;
        case errors_1.ValueErrorType.Uint8Array:
          return "Expected Uint8Array";
        case errors_1.ValueErrorType.Undefined:
          return "Expected undefined";
        case errors_1.ValueErrorType.Union:
          return "Expected union value";
        case errors_1.ValueErrorType.Void:
          return "Expected void";
        case errors_1.ValueErrorType.Kind:
          return `Expected kind '${error.schema[index_1.Kind]}'`;
        default:
          return "Unknown error type";
      }
    }
    var errorFunction = DefaultErrorFunction;
    function SetErrorFunction(callback) {
      errorFunction = callback;
    }
    function GetErrorFunction() {
      return errorFunction;
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/deref/deref.js
var require_deref3 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/value/deref/deref.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeDereferenceError = void 0;
    exports2.Pushref = Pushref;
    exports2.Deref = Deref;
    var index_1 = require_error2();
    var index_2 = require_symbols2();
    var guard_1 = require_guard();
    var TypeDereferenceError = class extends index_1.TypeBoxError {
      constructor(schema) {
        super(`Unable to dereference schema with $id '${schema.$ref}'`);
        this.schema = schema;
      }
    };
    exports2.TypeDereferenceError = TypeDereferenceError;
    function Resolve(schema, references) {
      const target = references.find((target2) => target2.$id === schema.$ref);
      if (target === void 0)
        throw new TypeDereferenceError(schema);
      return Deref(target, references);
    }
    function Pushref(schema, references) {
      if (!(0, guard_1.IsString)(schema.$id) || references.some((target) => target.$id === schema.$id))
        return references;
      references.push(schema);
      return references;
    }
    function Deref(schema, references) {
      return schema[index_2.Kind] === "This" || schema[index_2.Kind] === "Ref" ? Resolve(schema, references) : schema;
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/deref/index.js
var require_deref4 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/value/deref/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_deref3(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/hash/hash.js
var require_hash3 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/value/hash/hash.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ValueHashError = void 0;
    exports2.Hash = Hash2;
    var index_1 = require_guard2();
    var index_2 = require_error2();
    var ValueHashError = class extends index_2.TypeBoxError {
      constructor(value) {
        super(`Unable to hash value`);
        this.value = value;
      }
    };
    exports2.ValueHashError = ValueHashError;
    var ByteMarker;
    (function(ByteMarker2) {
      ByteMarker2[ByteMarker2["Undefined"] = 0] = "Undefined";
      ByteMarker2[ByteMarker2["Null"] = 1] = "Null";
      ByteMarker2[ByteMarker2["Boolean"] = 2] = "Boolean";
      ByteMarker2[ByteMarker2["Number"] = 3] = "Number";
      ByteMarker2[ByteMarker2["String"] = 4] = "String";
      ByteMarker2[ByteMarker2["Object"] = 5] = "Object";
      ByteMarker2[ByteMarker2["Array"] = 6] = "Array";
      ByteMarker2[ByteMarker2["Date"] = 7] = "Date";
      ByteMarker2[ByteMarker2["Uint8Array"] = 8] = "Uint8Array";
      ByteMarker2[ByteMarker2["Symbol"] = 9] = "Symbol";
      ByteMarker2[ByteMarker2["BigInt"] = 10] = "BigInt";
    })(ByteMarker || (ByteMarker = {}));
    var Accumulator = BigInt("14695981039346656037");
    var [Prime, Size] = [BigInt("1099511628211"), BigInt(
      "18446744073709551616"
      /* 2 ^ 64 */
    )];
    var Bytes = Array.from({ length: 256 }).map((_, i) => BigInt(i));
    var F64 = new Float64Array(1);
    var F64In = new DataView(F64.buffer);
    var F64Out = new Uint8Array(F64.buffer);
    function* NumberToBytes(value) {
      const byteCount = value === 0 ? 1 : Math.ceil(Math.floor(Math.log2(value) + 1) / 8);
      for (let i = 0; i < byteCount; i++) {
        yield value >> 8 * (byteCount - 1 - i) & 255;
      }
    }
    function ArrayType(value) {
      FNV1A64(ByteMarker.Array);
      for (const item of value) {
        Visit(item);
      }
    }
    function BooleanType(value) {
      FNV1A64(ByteMarker.Boolean);
      FNV1A64(value ? 1 : 0);
    }
    function BigIntType(value) {
      FNV1A64(ByteMarker.BigInt);
      F64In.setBigInt64(0, value);
      for (const byte of F64Out) {
        FNV1A64(byte);
      }
    }
    function DateType(value) {
      FNV1A64(ByteMarker.Date);
      Visit(value.getTime());
    }
    function NullType(value) {
      FNV1A64(ByteMarker.Null);
    }
    function NumberType(value) {
      FNV1A64(ByteMarker.Number);
      F64In.setFloat64(0, value);
      for (const byte of F64Out) {
        FNV1A64(byte);
      }
    }
    function ObjectType(value) {
      FNV1A64(ByteMarker.Object);
      for (const key of globalThis.Object.getOwnPropertyNames(value).sort()) {
        Visit(key);
        Visit(value[key]);
      }
    }
    function StringType(value) {
      FNV1A64(ByteMarker.String);
      for (let i = 0; i < value.length; i++) {
        for (const byte of NumberToBytes(value.charCodeAt(i))) {
          FNV1A64(byte);
        }
      }
    }
    function SymbolType(value) {
      FNV1A64(ByteMarker.Symbol);
      Visit(value.description);
    }
    function Uint8ArrayType(value) {
      FNV1A64(ByteMarker.Uint8Array);
      for (let i = 0; i < value.length; i++) {
        FNV1A64(value[i]);
      }
    }
    function UndefinedType(value) {
      return FNV1A64(ByteMarker.Undefined);
    }
    function Visit(value) {
      if ((0, index_1.IsArray)(value))
        return ArrayType(value);
      if ((0, index_1.IsBoolean)(value))
        return BooleanType(value);
      if ((0, index_1.IsBigInt)(value))
        return BigIntType(value);
      if ((0, index_1.IsDate)(value))
        return DateType(value);
      if ((0, index_1.IsNull)(value))
        return NullType(value);
      if ((0, index_1.IsNumber)(value))
        return NumberType(value);
      if ((0, index_1.IsObject)(value))
        return ObjectType(value);
      if ((0, index_1.IsString)(value))
        return StringType(value);
      if ((0, index_1.IsSymbol)(value))
        return SymbolType(value);
      if ((0, index_1.IsUint8Array)(value))
        return Uint8ArrayType(value);
      if ((0, index_1.IsUndefined)(value))
        return UndefinedType(value);
      throw new ValueHashError(value);
    }
    function FNV1A64(byte) {
      Accumulator = Accumulator ^ Bytes[byte];
      Accumulator = Accumulator * Prime % Size;
    }
    function Hash2(value) {
      Accumulator = BigInt("14695981039346656037");
      Visit(value);
      return Accumulator;
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/hash/index.js
var require_hash4 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/value/hash/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_hash3(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/check/check.js
var require_check = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/value/check/check.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ValueCheckUnknownTypeError = void 0;
    exports2.Check = Check;
    var index_1 = require_system2();
    var index_2 = require_deref4();
    var index_3 = require_hash4();
    var index_4 = require_symbols2();
    var index_5 = require_keyof2();
    var index_6 = require_extends2();
    var index_7 = require_registry();
    var index_8 = require_error2();
    var index_9 = require_never2();
    var index_10 = require_guard2();
    var type_1 = require_type4();
    var ValueCheckUnknownTypeError = class extends index_8.TypeBoxError {
      constructor(schema) {
        super(`Unknown type`);
        this.schema = schema;
      }
    };
    exports2.ValueCheckUnknownTypeError = ValueCheckUnknownTypeError;
    function IsAnyOrUnknown(schema) {
      return schema[index_4.Kind] === "Any" || schema[index_4.Kind] === "Unknown";
    }
    function IsDefined(value) {
      return value !== void 0;
    }
    function FromAny(schema, references, value) {
      return true;
    }
    function FromArray(schema, references, value) {
      if (!(0, index_10.IsArray)(value))
        return false;
      if (IsDefined(schema.minItems) && !(value.length >= schema.minItems)) {
        return false;
      }
      if (IsDefined(schema.maxItems) && !(value.length <= schema.maxItems)) {
        return false;
      }
      if (!value.every((value2) => Visit(schema.items, references, value2))) {
        return false;
      }
      if (schema.uniqueItems === true && !function() {
        const set2 = /* @__PURE__ */ new Set();
        for (const element of value) {
          const hashed = (0, index_3.Hash)(element);
          if (set2.has(hashed)) {
            return false;
          } else {
            set2.add(hashed);
          }
        }
        return true;
      }()) {
        return false;
      }
      if (!(IsDefined(schema.contains) || (0, index_10.IsNumber)(schema.minContains) || (0, index_10.IsNumber)(schema.maxContains))) {
        return true;
      }
      const containsSchema = IsDefined(schema.contains) ? schema.contains : (0, index_9.Never)();
      const containsCount = value.reduce((acc, value2) => Visit(containsSchema, references, value2) ? acc + 1 : acc, 0);
      if (containsCount === 0) {
        return false;
      }
      if ((0, index_10.IsNumber)(schema.minContains) && containsCount < schema.minContains) {
        return false;
      }
      if ((0, index_10.IsNumber)(schema.maxContains) && containsCount > schema.maxContains) {
        return false;
      }
      return true;
    }
    function FromAsyncIterator(schema, references, value) {
      return (0, index_10.IsAsyncIterator)(value);
    }
    function FromBigInt(schema, references, value) {
      if (!(0, index_10.IsBigInt)(value))
        return false;
      if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
        return false;
      }
      if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
        return false;
      }
      if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
        return false;
      }
      if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
        return false;
      }
      if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {
        return false;
      }
      return true;
    }
    function FromBoolean(schema, references, value) {
      return (0, index_10.IsBoolean)(value);
    }
    function FromConstructor(schema, references, value) {
      return Visit(schema.returns, references, value.prototype);
    }
    function FromDate(schema, references, value) {
      if (!(0, index_10.IsDate)(value))
        return false;
      if (IsDefined(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {
        return false;
      }
      if (IsDefined(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {
        return false;
      }
      if (IsDefined(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {
        return false;
      }
      if (IsDefined(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {
        return false;
      }
      if (IsDefined(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {
        return false;
      }
      return true;
    }
    function FromFunction(schema, references, value) {
      return (0, index_10.IsFunction)(value);
    }
    function FromInteger(schema, references, value) {
      if (!(0, index_10.IsInteger)(value)) {
        return false;
      }
      if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
        return false;
      }
      if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
        return false;
      }
      if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
        return false;
      }
      if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
        return false;
      }
      if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
        return false;
      }
      return true;
    }
    function FromIntersect(schema, references, value) {
      const check1 = schema.allOf.every((schema2) => Visit(schema2, references, value));
      if (schema.unevaluatedProperties === false) {
        const keyPattern = new RegExp((0, index_5.KeyOfPattern)(schema));
        const check2 = Object.getOwnPropertyNames(value).every((key) => keyPattern.test(key));
        return check1 && check2;
      } else if ((0, type_1.IsSchema)(schema.unevaluatedProperties)) {
        const keyCheck = new RegExp((0, index_5.KeyOfPattern)(schema));
        const check2 = Object.getOwnPropertyNames(value).every((key) => keyCheck.test(key) || Visit(schema.unevaluatedProperties, references, value[key]));
        return check1 && check2;
      } else {
        return check1;
      }
    }
    function FromIterator(schema, references, value) {
      return (0, index_10.IsIterator)(value);
    }
    function FromLiteral(schema, references, value) {
      return value === schema.const;
    }
    function FromNever(schema, references, value) {
      return false;
    }
    function FromNot(schema, references, value) {
      return !Visit(schema.not, references, value);
    }
    function FromNull(schema, references, value) {
      return (0, index_10.IsNull)(value);
    }
    function FromNumber(schema, references, value) {
      if (!index_1.TypeSystemPolicy.IsNumberLike(value))
        return false;
      if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
        return false;
      }
      if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
        return false;
      }
      if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
        return false;
      }
      if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
        return false;
      }
      if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
        return false;
      }
      return true;
    }
    function FromObject(schema, references, value) {
      if (!index_1.TypeSystemPolicy.IsObjectLike(value))
        return false;
      if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
        return false;
      }
      if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
        return false;
      }
      const knownKeys = Object.getOwnPropertyNames(schema.properties);
      for (const knownKey of knownKeys) {
        const property = schema.properties[knownKey];
        if (schema.required && schema.required.includes(knownKey)) {
          if (!Visit(property, references, value[knownKey])) {
            return false;
          }
          if (((0, index_6.ExtendsUndefinedCheck)(property) || IsAnyOrUnknown(property)) && !(knownKey in value)) {
            return false;
          }
        } else {
          if (index_1.TypeSystemPolicy.IsExactOptionalProperty(value, knownKey) && !Visit(property, references, value[knownKey])) {
            return false;
          }
        }
      }
      if (schema.additionalProperties === false) {
        const valueKeys = Object.getOwnPropertyNames(value);
        if (schema.required && schema.required.length === knownKeys.length && valueKeys.length === knownKeys.length) {
          return true;
        } else {
          return valueKeys.every((valueKey) => knownKeys.includes(valueKey));
        }
      } else if (typeof schema.additionalProperties === "object") {
        const valueKeys = Object.getOwnPropertyNames(value);
        return valueKeys.every((key) => knownKeys.includes(key) || Visit(schema.additionalProperties, references, value[key]));
      } else {
        return true;
      }
    }
    function FromPromise(schema, references, value) {
      return (0, index_10.IsPromise)(value);
    }
    function FromRecord(schema, references, value) {
      if (!index_1.TypeSystemPolicy.IsRecordLike(value)) {
        return false;
      }
      if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
        return false;
      }
      if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
        return false;
      }
      const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
      const regex = new RegExp(patternKey);
      const check1 = Object.entries(value).every(([key, value2]) => {
        return regex.test(key) ? Visit(patternSchema, references, value2) : true;
      });
      const check2 = typeof schema.additionalProperties === "object" ? Object.entries(value).every(([key, value2]) => {
        return !regex.test(key) ? Visit(schema.additionalProperties, references, value2) : true;
      }) : true;
      const check3 = schema.additionalProperties === false ? Object.getOwnPropertyNames(value).every((key) => {
        return regex.test(key);
      }) : true;
      return check1 && check2 && check3;
    }
    function FromRef(schema, references, value) {
      return Visit((0, index_2.Deref)(schema, references), references, value);
    }
    function FromRegExp(schema, references, value) {
      const regex = new RegExp(schema.source, schema.flags);
      if (IsDefined(schema.minLength)) {
        if (!(value.length >= schema.minLength))
          return false;
      }
      if (IsDefined(schema.maxLength)) {
        if (!(value.length <= schema.maxLength))
          return false;
      }
      return regex.test(value);
    }
    function FromString(schema, references, value) {
      if (!(0, index_10.IsString)(value)) {
        return false;
      }
      if (IsDefined(schema.minLength)) {
        if (!(value.length >= schema.minLength))
          return false;
      }
      if (IsDefined(schema.maxLength)) {
        if (!(value.length <= schema.maxLength))
          return false;
      }
      if (IsDefined(schema.pattern)) {
        const regex = new RegExp(schema.pattern);
        if (!regex.test(value))
          return false;
      }
      if (IsDefined(schema.format)) {
        if (!index_7.FormatRegistry.Has(schema.format))
          return false;
        const func = index_7.FormatRegistry.Get(schema.format);
        return func(value);
      }
      return true;
    }
    function FromSymbol(schema, references, value) {
      return (0, index_10.IsSymbol)(value);
    }
    function FromTemplateLiteral(schema, references, value) {
      return (0, index_10.IsString)(value) && new RegExp(schema.pattern).test(value);
    }
    function FromThis(schema, references, value) {
      return Visit((0, index_2.Deref)(schema, references), references, value);
    }
    function FromTuple(schema, references, value) {
      if (!(0, index_10.IsArray)(value)) {
        return false;
      }
      if (schema.items === void 0 && !(value.length === 0)) {
        return false;
      }
      if (!(value.length === schema.maxItems)) {
        return false;
      }
      if (!schema.items) {
        return true;
      }
      for (let i = 0; i < schema.items.length; i++) {
        if (!Visit(schema.items[i], references, value[i]))
          return false;
      }
      return true;
    }
    function FromUndefined(schema, references, value) {
      return (0, index_10.IsUndefined)(value);
    }
    function FromUnion(schema, references, value) {
      return schema.anyOf.some((inner) => Visit(inner, references, value));
    }
    function FromUint8Array(schema, references, value) {
      if (!(0, index_10.IsUint8Array)(value)) {
        return false;
      }
      if (IsDefined(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {
        return false;
      }
      if (IsDefined(schema.minByteLength) && !(value.length >= schema.minByteLength)) {
        return false;
      }
      return true;
    }
    function FromUnknown(schema, references, value) {
      return true;
    }
    function FromVoid(schema, references, value) {
      return index_1.TypeSystemPolicy.IsVoidLike(value);
    }
    function FromKind(schema, references, value) {
      if (!index_7.TypeRegistry.Has(schema[index_4.Kind]))
        return false;
      const func = index_7.TypeRegistry.Get(schema[index_4.Kind]);
      return func(schema, value);
    }
    function Visit(schema, references, value) {
      const references_ = IsDefined(schema.$id) ? [...references, schema] : references;
      const schema_ = schema;
      switch (schema_[index_4.Kind]) {
        case "Any":
          return FromAny(schema_, references_, value);
        case "Array":
          return FromArray(schema_, references_, value);
        case "AsyncIterator":
          return FromAsyncIterator(schema_, references_, value);
        case "BigInt":
          return FromBigInt(schema_, references_, value);
        case "Boolean":
          return FromBoolean(schema_, references_, value);
        case "Constructor":
          return FromConstructor(schema_, references_, value);
        case "Date":
          return FromDate(schema_, references_, value);
        case "Function":
          return FromFunction(schema_, references_, value);
        case "Integer":
          return FromInteger(schema_, references_, value);
        case "Intersect":
          return FromIntersect(schema_, references_, value);
        case "Iterator":
          return FromIterator(schema_, references_, value);
        case "Literal":
          return FromLiteral(schema_, references_, value);
        case "Never":
          return FromNever(schema_, references_, value);
        case "Not":
          return FromNot(schema_, references_, value);
        case "Null":
          return FromNull(schema_, references_, value);
        case "Number":
          return FromNumber(schema_, references_, value);
        case "Object":
          return FromObject(schema_, references_, value);
        case "Promise":
          return FromPromise(schema_, references_, value);
        case "Record":
          return FromRecord(schema_, references_, value);
        case "Ref":
          return FromRef(schema_, references_, value);
        case "RegExp":
          return FromRegExp(schema_, references_, value);
        case "String":
          return FromString(schema_, references_, value);
        case "Symbol":
          return FromSymbol(schema_, references_, value);
        case "TemplateLiteral":
          return FromTemplateLiteral(schema_, references_, value);
        case "This":
          return FromThis(schema_, references_, value);
        case "Tuple":
          return FromTuple(schema_, references_, value);
        case "Undefined":
          return FromUndefined(schema_, references_, value);
        case "Union":
          return FromUnion(schema_, references_, value);
        case "Uint8Array":
          return FromUint8Array(schema_, references_, value);
        case "Unknown":
          return FromUnknown(schema_, references_, value);
        case "Void":
          return FromVoid(schema_, references_, value);
        default:
          if (!index_7.TypeRegistry.Has(schema_[index_4.Kind]))
            throw new ValueCheckUnknownTypeError(schema_);
          return FromKind(schema_, references_, value);
      }
    }
    function Check(...args) {
      return args.length === 3 ? Visit(args[0], args[1], args[2]) : Visit(args[0], [], args[1]);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/check/index.js
var require_check2 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/value/check/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_check(), exports2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/errors/errors.js
var require_errors4 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/errors/errors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ValueErrorIterator = exports2.ValueErrorsUnknownTypeError = exports2.ValueErrorType = void 0;
    exports2.Errors = Errors;
    var index_1 = require_system2();
    var index_2 = require_keyof2();
    var index_3 = require_registry();
    var extends_undefined_1 = require_extends_undefined();
    var function_1 = require_function3();
    var index_4 = require_error2();
    var index_5 = require_deref4();
    var index_6 = require_hash4();
    var index_7 = require_check2();
    var index_8 = require_symbols2();
    var index_9 = require_never2();
    var index_10 = require_guard2();
    var ValueErrorType;
    (function(ValueErrorType2) {
      ValueErrorType2[ValueErrorType2["ArrayContains"] = 0] = "ArrayContains";
      ValueErrorType2[ValueErrorType2["ArrayMaxContains"] = 1] = "ArrayMaxContains";
      ValueErrorType2[ValueErrorType2["ArrayMaxItems"] = 2] = "ArrayMaxItems";
      ValueErrorType2[ValueErrorType2["ArrayMinContains"] = 3] = "ArrayMinContains";
      ValueErrorType2[ValueErrorType2["ArrayMinItems"] = 4] = "ArrayMinItems";
      ValueErrorType2[ValueErrorType2["ArrayUniqueItems"] = 5] = "ArrayUniqueItems";
      ValueErrorType2[ValueErrorType2["Array"] = 6] = "Array";
      ValueErrorType2[ValueErrorType2["AsyncIterator"] = 7] = "AsyncIterator";
      ValueErrorType2[ValueErrorType2["BigIntExclusiveMaximum"] = 8] = "BigIntExclusiveMaximum";
      ValueErrorType2[ValueErrorType2["BigIntExclusiveMinimum"] = 9] = "BigIntExclusiveMinimum";
      ValueErrorType2[ValueErrorType2["BigIntMaximum"] = 10] = "BigIntMaximum";
      ValueErrorType2[ValueErrorType2["BigIntMinimum"] = 11] = "BigIntMinimum";
      ValueErrorType2[ValueErrorType2["BigIntMultipleOf"] = 12] = "BigIntMultipleOf";
      ValueErrorType2[ValueErrorType2["BigInt"] = 13] = "BigInt";
      ValueErrorType2[ValueErrorType2["Boolean"] = 14] = "Boolean";
      ValueErrorType2[ValueErrorType2["DateExclusiveMaximumTimestamp"] = 15] = "DateExclusiveMaximumTimestamp";
      ValueErrorType2[ValueErrorType2["DateExclusiveMinimumTimestamp"] = 16] = "DateExclusiveMinimumTimestamp";
      ValueErrorType2[ValueErrorType2["DateMaximumTimestamp"] = 17] = "DateMaximumTimestamp";
      ValueErrorType2[ValueErrorType2["DateMinimumTimestamp"] = 18] = "DateMinimumTimestamp";
      ValueErrorType2[ValueErrorType2["DateMultipleOfTimestamp"] = 19] = "DateMultipleOfTimestamp";
      ValueErrorType2[ValueErrorType2["Date"] = 20] = "Date";
      ValueErrorType2[ValueErrorType2["Function"] = 21] = "Function";
      ValueErrorType2[ValueErrorType2["IntegerExclusiveMaximum"] = 22] = "IntegerExclusiveMaximum";
      ValueErrorType2[ValueErrorType2["IntegerExclusiveMinimum"] = 23] = "IntegerExclusiveMinimum";
      ValueErrorType2[ValueErrorType2["IntegerMaximum"] = 24] = "IntegerMaximum";
      ValueErrorType2[ValueErrorType2["IntegerMinimum"] = 25] = "IntegerMinimum";
      ValueErrorType2[ValueErrorType2["IntegerMultipleOf"] = 26] = "IntegerMultipleOf";
      ValueErrorType2[ValueErrorType2["Integer"] = 27] = "Integer";
      ValueErrorType2[ValueErrorType2["IntersectUnevaluatedProperties"] = 28] = "IntersectUnevaluatedProperties";
      ValueErrorType2[ValueErrorType2["Intersect"] = 29] = "Intersect";
      ValueErrorType2[ValueErrorType2["Iterator"] = 30] = "Iterator";
      ValueErrorType2[ValueErrorType2["Kind"] = 31] = "Kind";
      ValueErrorType2[ValueErrorType2["Literal"] = 32] = "Literal";
      ValueErrorType2[ValueErrorType2["Never"] = 33] = "Never";
      ValueErrorType2[ValueErrorType2["Not"] = 34] = "Not";
      ValueErrorType2[ValueErrorType2["Null"] = 35] = "Null";
      ValueErrorType2[ValueErrorType2["NumberExclusiveMaximum"] = 36] = "NumberExclusiveMaximum";
      ValueErrorType2[ValueErrorType2["NumberExclusiveMinimum"] = 37] = "NumberExclusiveMinimum";
      ValueErrorType2[ValueErrorType2["NumberMaximum"] = 38] = "NumberMaximum";
      ValueErrorType2[ValueErrorType2["NumberMinimum"] = 39] = "NumberMinimum";
      ValueErrorType2[ValueErrorType2["NumberMultipleOf"] = 40] = "NumberMultipleOf";
      ValueErrorType2[ValueErrorType2["Number"] = 41] = "Number";
      ValueErrorType2[ValueErrorType2["ObjectAdditionalProperties"] = 42] = "ObjectAdditionalProperties";
      ValueErrorType2[ValueErrorType2["ObjectMaxProperties"] = 43] = "ObjectMaxProperties";
      ValueErrorType2[ValueErrorType2["ObjectMinProperties"] = 44] = "ObjectMinProperties";
      ValueErrorType2[ValueErrorType2["ObjectRequiredProperty"] = 45] = "ObjectRequiredProperty";
      ValueErrorType2[ValueErrorType2["Object"] = 46] = "Object";
      ValueErrorType2[ValueErrorType2["Promise"] = 47] = "Promise";
      ValueErrorType2[ValueErrorType2["RegExp"] = 48] = "RegExp";
      ValueErrorType2[ValueErrorType2["StringFormatUnknown"] = 49] = "StringFormatUnknown";
      ValueErrorType2[ValueErrorType2["StringFormat"] = 50] = "StringFormat";
      ValueErrorType2[ValueErrorType2["StringMaxLength"] = 51] = "StringMaxLength";
      ValueErrorType2[ValueErrorType2["StringMinLength"] = 52] = "StringMinLength";
      ValueErrorType2[ValueErrorType2["StringPattern"] = 53] = "StringPattern";
      ValueErrorType2[ValueErrorType2["String"] = 54] = "String";
      ValueErrorType2[ValueErrorType2["Symbol"] = 55] = "Symbol";
      ValueErrorType2[ValueErrorType2["TupleLength"] = 56] = "TupleLength";
      ValueErrorType2[ValueErrorType2["Tuple"] = 57] = "Tuple";
      ValueErrorType2[ValueErrorType2["Uint8ArrayMaxByteLength"] = 58] = "Uint8ArrayMaxByteLength";
      ValueErrorType2[ValueErrorType2["Uint8ArrayMinByteLength"] = 59] = "Uint8ArrayMinByteLength";
      ValueErrorType2[ValueErrorType2["Uint8Array"] = 60] = "Uint8Array";
      ValueErrorType2[ValueErrorType2["Undefined"] = 61] = "Undefined";
      ValueErrorType2[ValueErrorType2["Union"] = 62] = "Union";
      ValueErrorType2[ValueErrorType2["Void"] = 63] = "Void";
    })(ValueErrorType || (exports2.ValueErrorType = ValueErrorType = {}));
    var ValueErrorsUnknownTypeError = class extends index_4.TypeBoxError {
      constructor(schema) {
        super("Unknown type");
        this.schema = schema;
      }
    };
    exports2.ValueErrorsUnknownTypeError = ValueErrorsUnknownTypeError;
    function EscapeKey(key) {
      return key.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    function IsDefined(value) {
      return value !== void 0;
    }
    var ValueErrorIterator = class {
      constructor(iterator) {
        this.iterator = iterator;
      }
      [Symbol.iterator]() {
        return this.iterator;
      }
      /** Returns the first value error or undefined if no errors */
      First() {
        const next = this.iterator.next();
        return next.done ? void 0 : next.value;
      }
    };
    exports2.ValueErrorIterator = ValueErrorIterator;
    function Create(errorType, schema, path, value, errors = []) {
      return {
        type: errorType,
        schema,
        path,
        value,
        message: (0, function_1.GetErrorFunction)()({ errorType, path, schema, value, errors }),
        errors
      };
    }
    function* FromAny(schema, references, path, value) {
    }
    function* FromArray(schema, references, path, value) {
      if (!(0, index_10.IsArray)(value)) {
        return yield Create(ValueErrorType.Array, schema, path, value);
      }
      if (IsDefined(schema.minItems) && !(value.length >= schema.minItems)) {
        yield Create(ValueErrorType.ArrayMinItems, schema, path, value);
      }
      if (IsDefined(schema.maxItems) && !(value.length <= schema.maxItems)) {
        yield Create(ValueErrorType.ArrayMaxItems, schema, path, value);
      }
      for (let i = 0; i < value.length; i++) {
        yield* Visit(schema.items, references, `${path}/${i}`, value[i]);
      }
      if (schema.uniqueItems === true && !function() {
        const set2 = /* @__PURE__ */ new Set();
        for (const element of value) {
          const hashed = (0, index_6.Hash)(element);
          if (set2.has(hashed)) {
            return false;
          } else {
            set2.add(hashed);
          }
        }
        return true;
      }()) {
        yield Create(ValueErrorType.ArrayUniqueItems, schema, path, value);
      }
      if (!(IsDefined(schema.contains) || IsDefined(schema.minContains) || IsDefined(schema.maxContains))) {
        return;
      }
      const containsSchema = IsDefined(schema.contains) ? schema.contains : (0, index_9.Never)();
      const containsCount = value.reduce((acc, value2, index) => Visit(containsSchema, references, `${path}${index}`, value2).next().done === true ? acc + 1 : acc, 0);
      if (containsCount === 0) {
        yield Create(ValueErrorType.ArrayContains, schema, path, value);
      }
      if ((0, index_10.IsNumber)(schema.minContains) && containsCount < schema.minContains) {
        yield Create(ValueErrorType.ArrayMinContains, schema, path, value);
      }
      if ((0, index_10.IsNumber)(schema.maxContains) && containsCount > schema.maxContains) {
        yield Create(ValueErrorType.ArrayMaxContains, schema, path, value);
      }
    }
    function* FromAsyncIterator(schema, references, path, value) {
      if (!(0, index_10.IsAsyncIterator)(value))
        yield Create(ValueErrorType.AsyncIterator, schema, path, value);
    }
    function* FromBigInt(schema, references, path, value) {
      if (!(0, index_10.IsBigInt)(value))
        return yield Create(ValueErrorType.BigInt, schema, path, value);
      if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
        yield Create(ValueErrorType.BigIntExclusiveMaximum, schema, path, value);
      }
      if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
        yield Create(ValueErrorType.BigIntExclusiveMinimum, schema, path, value);
      }
      if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
        yield Create(ValueErrorType.BigIntMaximum, schema, path, value);
      }
      if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
        yield Create(ValueErrorType.BigIntMinimum, schema, path, value);
      }
      if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {
        yield Create(ValueErrorType.BigIntMultipleOf, schema, path, value);
      }
    }
    function* FromBoolean(schema, references, path, value) {
      if (!(0, index_10.IsBoolean)(value))
        yield Create(ValueErrorType.Boolean, schema, path, value);
    }
    function* FromConstructor(schema, references, path, value) {
      yield* Visit(schema.returns, references, path, value.prototype);
    }
    function* FromDate(schema, references, path, value) {
      if (!(0, index_10.IsDate)(value))
        return yield Create(ValueErrorType.Date, schema, path, value);
      if (IsDefined(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {
        yield Create(ValueErrorType.DateExclusiveMaximumTimestamp, schema, path, value);
      }
      if (IsDefined(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {
        yield Create(ValueErrorType.DateExclusiveMinimumTimestamp, schema, path, value);
      }
      if (IsDefined(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {
        yield Create(ValueErrorType.DateMaximumTimestamp, schema, path, value);
      }
      if (IsDefined(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {
        yield Create(ValueErrorType.DateMinimumTimestamp, schema, path, value);
      }
      if (IsDefined(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {
        yield Create(ValueErrorType.DateMultipleOfTimestamp, schema, path, value);
      }
    }
    function* FromFunction(schema, references, path, value) {
      if (!(0, index_10.IsFunction)(value))
        yield Create(ValueErrorType.Function, schema, path, value);
    }
    function* FromInteger(schema, references, path, value) {
      if (!(0, index_10.IsInteger)(value))
        return yield Create(ValueErrorType.Integer, schema, path, value);
      if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
        yield Create(ValueErrorType.IntegerExclusiveMaximum, schema, path, value);
      }
      if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
        yield Create(ValueErrorType.IntegerExclusiveMinimum, schema, path, value);
      }
      if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
        yield Create(ValueErrorType.IntegerMaximum, schema, path, value);
      }
      if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
        yield Create(ValueErrorType.IntegerMinimum, schema, path, value);
      }
      if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
        yield Create(ValueErrorType.IntegerMultipleOf, schema, path, value);
      }
    }
    function* FromIntersect(schema, references, path, value) {
      let hasError = false;
      for (const inner of schema.allOf) {
        for (const error of Visit(inner, references, path, value)) {
          hasError = true;
          yield error;
        }
      }
      if (hasError) {
        return yield Create(ValueErrorType.Intersect, schema, path, value);
      }
      if (schema.unevaluatedProperties === false) {
        const keyCheck = new RegExp((0, index_2.KeyOfPattern)(schema));
        for (const valueKey of Object.getOwnPropertyNames(value)) {
          if (!keyCheck.test(valueKey)) {
            yield Create(ValueErrorType.IntersectUnevaluatedProperties, schema, `${path}/${valueKey}`, value);
          }
        }
      }
      if (typeof schema.unevaluatedProperties === "object") {
        const keyCheck = new RegExp((0, index_2.KeyOfPattern)(schema));
        for (const valueKey of Object.getOwnPropertyNames(value)) {
          if (!keyCheck.test(valueKey)) {
            const next = Visit(schema.unevaluatedProperties, references, `${path}/${valueKey}`, value[valueKey]).next();
            if (!next.done)
              yield next.value;
          }
        }
      }
    }
    function* FromIterator(schema, references, path, value) {
      if (!(0, index_10.IsIterator)(value))
        yield Create(ValueErrorType.Iterator, schema, path, value);
    }
    function* FromLiteral(schema, references, path, value) {
      if (!(value === schema.const))
        yield Create(ValueErrorType.Literal, schema, path, value);
    }
    function* FromNever(schema, references, path, value) {
      yield Create(ValueErrorType.Never, schema, path, value);
    }
    function* FromNot(schema, references, path, value) {
      if (Visit(schema.not, references, path, value).next().done === true)
        yield Create(ValueErrorType.Not, schema, path, value);
    }
    function* FromNull(schema, references, path, value) {
      if (!(0, index_10.IsNull)(value))
        yield Create(ValueErrorType.Null, schema, path, value);
    }
    function* FromNumber(schema, references, path, value) {
      if (!index_1.TypeSystemPolicy.IsNumberLike(value))
        return yield Create(ValueErrorType.Number, schema, path, value);
      if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
        yield Create(ValueErrorType.NumberExclusiveMaximum, schema, path, value);
      }
      if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
        yield Create(ValueErrorType.NumberExclusiveMinimum, schema, path, value);
      }
      if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
        yield Create(ValueErrorType.NumberMaximum, schema, path, value);
      }
      if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
        yield Create(ValueErrorType.NumberMinimum, schema, path, value);
      }
      if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
        yield Create(ValueErrorType.NumberMultipleOf, schema, path, value);
      }
    }
    function* FromObject(schema, references, path, value) {
      if (!index_1.TypeSystemPolicy.IsObjectLike(value))
        return yield Create(ValueErrorType.Object, schema, path, value);
      if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
        yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);
      }
      if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
        yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);
      }
      const requiredKeys = Array.isArray(schema.required) ? schema.required : [];
      const knownKeys = Object.getOwnPropertyNames(schema.properties);
      const unknownKeys = Object.getOwnPropertyNames(value);
      for (const requiredKey of requiredKeys) {
        if (unknownKeys.includes(requiredKey))
          continue;
        yield Create(ValueErrorType.ObjectRequiredProperty, schema.properties[requiredKey], `${path}/${EscapeKey(requiredKey)}`, void 0);
      }
      if (schema.additionalProperties === false) {
        for (const valueKey of unknownKeys) {
          if (!knownKeys.includes(valueKey)) {
            yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(valueKey)}`, value[valueKey]);
          }
        }
      }
      if (typeof schema.additionalProperties === "object") {
        for (const valueKey of unknownKeys) {
          if (knownKeys.includes(valueKey))
            continue;
          yield* Visit(schema.additionalProperties, references, `${path}/${EscapeKey(valueKey)}`, value[valueKey]);
        }
      }
      for (const knownKey of knownKeys) {
        const property = schema.properties[knownKey];
        if (schema.required && schema.required.includes(knownKey)) {
          yield* Visit(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);
          if ((0, extends_undefined_1.ExtendsUndefinedCheck)(schema) && !(knownKey in value)) {
            yield Create(ValueErrorType.ObjectRequiredProperty, property, `${path}/${EscapeKey(knownKey)}`, void 0);
          }
        } else {
          if (index_1.TypeSystemPolicy.IsExactOptionalProperty(value, knownKey)) {
            yield* Visit(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);
          }
        }
      }
    }
    function* FromPromise(schema, references, path, value) {
      if (!(0, index_10.IsPromise)(value))
        yield Create(ValueErrorType.Promise, schema, path, value);
    }
    function* FromRecord(schema, references, path, value) {
      if (!index_1.TypeSystemPolicy.IsRecordLike(value))
        return yield Create(ValueErrorType.Object, schema, path, value);
      if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
        yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);
      }
      if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
        yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);
      }
      const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
      const regex = new RegExp(patternKey);
      for (const [propertyKey, propertyValue] of Object.entries(value)) {
        if (regex.test(propertyKey))
          yield* Visit(patternSchema, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
      }
      if (typeof schema.additionalProperties === "object") {
        for (const [propertyKey, propertyValue] of Object.entries(value)) {
          if (!regex.test(propertyKey))
            yield* Visit(schema.additionalProperties, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
        }
      }
      if (schema.additionalProperties === false) {
        for (const [propertyKey, propertyValue] of Object.entries(value)) {
          if (regex.test(propertyKey))
            continue;
          return yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
        }
      }
    }
    function* FromRef(schema, references, path, value) {
      yield* Visit((0, index_5.Deref)(schema, references), references, path, value);
    }
    function* FromRegExp(schema, references, path, value) {
      if (!(0, index_10.IsString)(value))
        return yield Create(ValueErrorType.String, schema, path, value);
      if (IsDefined(schema.minLength) && !(value.length >= schema.minLength)) {
        yield Create(ValueErrorType.StringMinLength, schema, path, value);
      }
      if (IsDefined(schema.maxLength) && !(value.length <= schema.maxLength)) {
        yield Create(ValueErrorType.StringMaxLength, schema, path, value);
      }
      const regex = new RegExp(schema.source, schema.flags);
      if (!regex.test(value)) {
        return yield Create(ValueErrorType.RegExp, schema, path, value);
      }
    }
    function* FromString(schema, references, path, value) {
      if (!(0, index_10.IsString)(value))
        return yield Create(ValueErrorType.String, schema, path, value);
      if (IsDefined(schema.minLength) && !(value.length >= schema.minLength)) {
        yield Create(ValueErrorType.StringMinLength, schema, path, value);
      }
      if (IsDefined(schema.maxLength) && !(value.length <= schema.maxLength)) {
        yield Create(ValueErrorType.StringMaxLength, schema, path, value);
      }
      if ((0, index_10.IsString)(schema.pattern)) {
        const regex = new RegExp(schema.pattern);
        if (!regex.test(value)) {
          yield Create(ValueErrorType.StringPattern, schema, path, value);
        }
      }
      if ((0, index_10.IsString)(schema.format)) {
        if (!index_3.FormatRegistry.Has(schema.format)) {
          yield Create(ValueErrorType.StringFormatUnknown, schema, path, value);
        } else {
          const format = index_3.FormatRegistry.Get(schema.format);
          if (!format(value)) {
            yield Create(ValueErrorType.StringFormat, schema, path, value);
          }
        }
      }
    }
    function* FromSymbol(schema, references, path, value) {
      if (!(0, index_10.IsSymbol)(value))
        yield Create(ValueErrorType.Symbol, schema, path, value);
    }
    function* FromTemplateLiteral(schema, references, path, value) {
      if (!(0, index_10.IsString)(value))
        return yield Create(ValueErrorType.String, schema, path, value);
      const regex = new RegExp(schema.pattern);
      if (!regex.test(value)) {
        yield Create(ValueErrorType.StringPattern, schema, path, value);
      }
    }
    function* FromThis(schema, references, path, value) {
      yield* Visit((0, index_5.Deref)(schema, references), references, path, value);
    }
    function* FromTuple(schema, references, path, value) {
      if (!(0, index_10.IsArray)(value))
        return yield Create(ValueErrorType.Tuple, schema, path, value);
      if (schema.items === void 0 && !(value.length === 0)) {
        return yield Create(ValueErrorType.TupleLength, schema, path, value);
      }
      if (!(value.length === schema.maxItems)) {
        return yield Create(ValueErrorType.TupleLength, schema, path, value);
      }
      if (!schema.items) {
        return;
      }
      for (let i = 0; i < schema.items.length; i++) {
        yield* Visit(schema.items[i], references, `${path}/${i}`, value[i]);
      }
    }
    function* FromUndefined(schema, references, path, value) {
      if (!(0, index_10.IsUndefined)(value))
        yield Create(ValueErrorType.Undefined, schema, path, value);
    }
    function* FromUnion(schema, references, path, value) {
      if ((0, index_7.Check)(schema, references, value))
        return;
      const errors = schema.anyOf.map((variant) => new ValueErrorIterator(Visit(variant, references, path, value)));
      yield Create(ValueErrorType.Union, schema, path, value, errors);
    }
    function* FromUint8Array(schema, references, path, value) {
      if (!(0, index_10.IsUint8Array)(value))
        return yield Create(ValueErrorType.Uint8Array, schema, path, value);
      if (IsDefined(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {
        yield Create(ValueErrorType.Uint8ArrayMaxByteLength, schema, path, value);
      }
      if (IsDefined(schema.minByteLength) && !(value.length >= schema.minByteLength)) {
        yield Create(ValueErrorType.Uint8ArrayMinByteLength, schema, path, value);
      }
    }
    function* FromUnknown(schema, references, path, value) {
    }
    function* FromVoid(schema, references, path, value) {
      if (!index_1.TypeSystemPolicy.IsVoidLike(value))
        yield Create(ValueErrorType.Void, schema, path, value);
    }
    function* FromKind(schema, references, path, value) {
      const check = index_3.TypeRegistry.Get(schema[index_8.Kind]);
      if (!check(schema, value))
        yield Create(ValueErrorType.Kind, schema, path, value);
    }
    function* Visit(schema, references, path, value) {
      const references_ = IsDefined(schema.$id) ? [...references, schema] : references;
      const schema_ = schema;
      switch (schema_[index_8.Kind]) {
        case "Any":
          return yield* FromAny(schema_, references_, path, value);
        case "Array":
          return yield* FromArray(schema_, references_, path, value);
        case "AsyncIterator":
          return yield* FromAsyncIterator(schema_, references_, path, value);
        case "BigInt":
          return yield* FromBigInt(schema_, references_, path, value);
        case "Boolean":
          return yield* FromBoolean(schema_, references_, path, value);
        case "Constructor":
          return yield* FromConstructor(schema_, references_, path, value);
        case "Date":
          return yield* FromDate(schema_, references_, path, value);
        case "Function":
          return yield* FromFunction(schema_, references_, path, value);
        case "Integer":
          return yield* FromInteger(schema_, references_, path, value);
        case "Intersect":
          return yield* FromIntersect(schema_, references_, path, value);
        case "Iterator":
          return yield* FromIterator(schema_, references_, path, value);
        case "Literal":
          return yield* FromLiteral(schema_, references_, path, value);
        case "Never":
          return yield* FromNever(schema_, references_, path, value);
        case "Not":
          return yield* FromNot(schema_, references_, path, value);
        case "Null":
          return yield* FromNull(schema_, references_, path, value);
        case "Number":
          return yield* FromNumber(schema_, references_, path, value);
        case "Object":
          return yield* FromObject(schema_, references_, path, value);
        case "Promise":
          return yield* FromPromise(schema_, references_, path, value);
        case "Record":
          return yield* FromRecord(schema_, references_, path, value);
        case "Ref":
          return yield* FromRef(schema_, references_, path, value);
        case "RegExp":
          return yield* FromRegExp(schema_, references_, path, value);
        case "String":
          return yield* FromString(schema_, references_, path, value);
        case "Symbol":
          return yield* FromSymbol(schema_, references_, path, value);
        case "TemplateLiteral":
          return yield* FromTemplateLiteral(schema_, references_, path, value);
        case "This":
          return yield* FromThis(schema_, references_, path, value);
        case "Tuple":
          return yield* FromTuple(schema_, references_, path, value);
        case "Undefined":
          return yield* FromUndefined(schema_, references_, path, value);
        case "Union":
          return yield* FromUnion(schema_, references_, path, value);
        case "Uint8Array":
          return yield* FromUint8Array(schema_, references_, path, value);
        case "Unknown":
          return yield* FromUnknown(schema_, references_, path, value);
        case "Void":
          return yield* FromVoid(schema_, references_, path, value);
        default:
          if (!index_3.TypeRegistry.Has(schema_[index_8.Kind]))
            throw new ValueErrorsUnknownTypeError(schema);
          return yield* FromKind(schema_, references_, path, value);
      }
    }
    function Errors(...args) {
      const iterator = args.length === 3 ? Visit(args[0], args[1], "", args[2]) : Visit(args[0], [], "", args[1]);
      return new ValueErrorIterator(iterator);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/errors/index.js
var require_errors5 = __commonJS({
  "node_modules/@sinclair/typebox/build/cjs/errors/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_errors4(), exports2);
    __exportStar2(require_function3(), exports2);
  }
});

// node_modules/ts-mixer/dist/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  Mixin: () => Mixin,
  decorate: () => decorate,
  hasMixin: () => hasMixin,
  mix: () => mix,
  settings: () => settings
});
function Mixin(...constructors) {
  var _a, _b, _c;
  const prototypes = constructors.map((constructor) => constructor.prototype);
  const initFunctionName = settings.initFunction;
  if (initFunctionName !== null) {
    const initFunctions = prototypes.map((proto) => proto[initFunctionName]).filter((func) => typeof func === "function");
    const combinedInitFunction = function(...args) {
      for (let initFunction of initFunctions)
        initFunction.apply(this, args);
    };
    const extraProto = { [initFunctionName]: combinedInitFunction };
    prototypes.push(extraProto);
  }
  function MixedClass(...args) {
    for (const constructor of constructors)
      copyProps(this, new constructor(...args));
    if (initFunctionName !== null && typeof this[initFunctionName] === "function")
      this[initFunctionName].apply(this, args);
  }
  MixedClass.prototype = settings.prototypeStrategy === "copy" ? hardMixProtos(prototypes, MixedClass) : softMixProtos(prototypes, MixedClass);
  Object.setPrototypeOf(MixedClass, settings.staticsStrategy === "copy" ? hardMixProtos(constructors, null, ["prototype"]) : proxyMix(constructors, Function.prototype));
  let DecoratedMixedClass = MixedClass;
  if (settings.decoratorInheritance !== "none") {
    const classDecorators = settings.decoratorInheritance === "deep" ? deepDecoratorSearch(...constructors) : directDecoratorSearch(...constructors);
    for (let decorator of (_a = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.class) !== null && _a !== void 0 ? _a : []) {
      const result = decorator(DecoratedMixedClass);
      if (result) {
        DecoratedMixedClass = result;
      }
    }
    applyPropAndMethodDecorators((_b = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.static) !== null && _b !== void 0 ? _b : {}, DecoratedMixedClass);
    applyPropAndMethodDecorators((_c = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.instance) !== null && _c !== void 0 ? _c : {}, DecoratedMixedClass.prototype);
  }
  registerMixins(DecoratedMixedClass, constructors);
  return DecoratedMixedClass;
}
var copyProps, protoChain, nearestCommonProto, hardMixProtos, unique, getIngredientWithProp, proxyMix, softMixProtos, settings, mixins, getMixinsForClass, registerMixins, hasMixin, mergeObjectsOfDecorators, mergePropertyAndMethodDecorators, mergeDecorators, decorators, findAllConstituentClasses, deepDecoratorSearch, directDecoratorSearch, getDecoratorsForClass, decorateClass, decorateMember, decorate, applyPropAndMethodDecorators, mix;
var init_esm = __esm({
  "node_modules/ts-mixer/dist/esm/index.js"() {
    copyProps = (dest, src, exclude = []) => {
      const props = Object.getOwnPropertyDescriptors(src);
      for (let prop of exclude)
        delete props[prop];
      Object.defineProperties(dest, props);
    };
    protoChain = (obj, currentChain = [obj]) => {
      const proto = Object.getPrototypeOf(obj);
      if (proto === null)
        return currentChain;
      return protoChain(proto, [...currentChain, proto]);
    };
    nearestCommonProto = (...objs) => {
      if (objs.length === 0)
        return void 0;
      let commonProto = void 0;
      const protoChains = objs.map((obj) => protoChain(obj));
      while (protoChains.every((protoChain2) => protoChain2.length > 0)) {
        const protos = protoChains.map((protoChain2) => protoChain2.pop());
        const potentialCommonProto = protos[0];
        if (protos.every((proto) => proto === potentialCommonProto))
          commonProto = potentialCommonProto;
        else
          break;
      }
      return commonProto;
    };
    hardMixProtos = (ingredients, constructor, exclude = []) => {
      var _a;
      const base = (_a = nearestCommonProto(...ingredients)) !== null && _a !== void 0 ? _a : Object.prototype;
      const mixedProto = Object.create(base);
      const visitedProtos = protoChain(base);
      for (let prototype of ingredients) {
        let protos = protoChain(prototype);
        for (let i = protos.length - 1; i >= 0; i--) {
          let newProto = protos[i];
          if (visitedProtos.indexOf(newProto) === -1) {
            copyProps(mixedProto, newProto, ["constructor", ...exclude]);
            visitedProtos.push(newProto);
          }
        }
      }
      mixedProto.constructor = constructor;
      return mixedProto;
    };
    unique = (arr) => arr.filter((e, i) => arr.indexOf(e) == i);
    getIngredientWithProp = (prop, ingredients) => {
      const protoChains = ingredients.map((ingredient) => protoChain(ingredient));
      let protoDepth = 0;
      let protosAreLeftToSearch = true;
      while (protosAreLeftToSearch) {
        protosAreLeftToSearch = false;
        for (let i = ingredients.length - 1; i >= 0; i--) {
          const searchTarget = protoChains[i][protoDepth];
          if (searchTarget !== void 0 && searchTarget !== null) {
            protosAreLeftToSearch = true;
            if (Object.getOwnPropertyDescriptor(searchTarget, prop) != void 0) {
              return protoChains[i][0];
            }
          }
        }
        protoDepth++;
      }
      return void 0;
    };
    proxyMix = (ingredients, prototype = Object.prototype) => new Proxy({}, {
      getPrototypeOf() {
        return prototype;
      },
      setPrototypeOf() {
        throw Error("Cannot set prototype of Proxies created by ts-mixer");
      },
      getOwnPropertyDescriptor(_, prop) {
        return Object.getOwnPropertyDescriptor(getIngredientWithProp(prop, ingredients) || {}, prop);
      },
      defineProperty() {
        throw new Error("Cannot define new properties on Proxies created by ts-mixer");
      },
      has(_, prop) {
        return getIngredientWithProp(prop, ingredients) !== void 0 || prototype[prop] !== void 0;
      },
      get(_, prop) {
        return (getIngredientWithProp(prop, ingredients) || prototype)[prop];
      },
      set(_, prop, val) {
        const ingredientWithProp = getIngredientWithProp(prop, ingredients);
        if (ingredientWithProp === void 0)
          throw new Error("Cannot set new properties on Proxies created by ts-mixer");
        ingredientWithProp[prop] = val;
        return true;
      },
      deleteProperty() {
        throw new Error("Cannot delete properties on Proxies created by ts-mixer");
      },
      ownKeys() {
        return ingredients.map(Object.getOwnPropertyNames).reduce((prev, curr) => curr.concat(prev.filter((key) => curr.indexOf(key) < 0)));
      }
    });
    softMixProtos = (ingredients, constructor) => proxyMix([...ingredients, { constructor }]);
    settings = {
      initFunction: null,
      staticsStrategy: "copy",
      prototypeStrategy: "copy",
      decoratorInheritance: "deep"
    };
    mixins = /* @__PURE__ */ new WeakMap();
    getMixinsForClass = (clazz) => mixins.get(clazz);
    registerMixins = (mixedClass, constituents) => mixins.set(mixedClass, constituents);
    hasMixin = (instance, mixin) => {
      if (instance instanceof mixin)
        return true;
      const constructor = instance.constructor;
      const visited = /* @__PURE__ */ new Set();
      let frontier = /* @__PURE__ */ new Set();
      frontier.add(constructor);
      while (frontier.size > 0) {
        if (frontier.has(mixin))
          return true;
        frontier.forEach((item) => visited.add(item));
        const newFrontier = /* @__PURE__ */ new Set();
        frontier.forEach((item) => {
          var _a;
          const itemConstituents = (_a = mixins.get(item)) !== null && _a !== void 0 ? _a : protoChain(item.prototype).map((proto) => proto.constructor).filter((item2) => item2 !== null);
          if (itemConstituents)
            itemConstituents.forEach((constituent) => {
              if (!visited.has(constituent) && !frontier.has(constituent))
                newFrontier.add(constituent);
            });
        });
        frontier = newFrontier;
      }
      return false;
    };
    mergeObjectsOfDecorators = (o1, o2) => {
      var _a, _b;
      const allKeys = unique([...Object.getOwnPropertyNames(o1), ...Object.getOwnPropertyNames(o2)]);
      const mergedObject = {};
      for (let key of allKeys)
        mergedObject[key] = unique([...(_a = o1 === null || o1 === void 0 ? void 0 : o1[key]) !== null && _a !== void 0 ? _a : [], ...(_b = o2 === null || o2 === void 0 ? void 0 : o2[key]) !== null && _b !== void 0 ? _b : []]);
      return mergedObject;
    };
    mergePropertyAndMethodDecorators = (d1, d2) => {
      var _a, _b, _c, _d;
      return {
        property: mergeObjectsOfDecorators((_a = d1 === null || d1 === void 0 ? void 0 : d1.property) !== null && _a !== void 0 ? _a : {}, (_b = d2 === null || d2 === void 0 ? void 0 : d2.property) !== null && _b !== void 0 ? _b : {}),
        method: mergeObjectsOfDecorators((_c = d1 === null || d1 === void 0 ? void 0 : d1.method) !== null && _c !== void 0 ? _c : {}, (_d = d2 === null || d2 === void 0 ? void 0 : d2.method) !== null && _d !== void 0 ? _d : {})
      };
    };
    mergeDecorators = (d1, d2) => {
      var _a, _b, _c, _d, _e, _f;
      return {
        class: unique([...(_a = d1 === null || d1 === void 0 ? void 0 : d1.class) !== null && _a !== void 0 ? _a : [], ...(_b = d2 === null || d2 === void 0 ? void 0 : d2.class) !== null && _b !== void 0 ? _b : []]),
        static: mergePropertyAndMethodDecorators((_c = d1 === null || d1 === void 0 ? void 0 : d1.static) !== null && _c !== void 0 ? _c : {}, (_d = d2 === null || d2 === void 0 ? void 0 : d2.static) !== null && _d !== void 0 ? _d : {}),
        instance: mergePropertyAndMethodDecorators((_e = d1 === null || d1 === void 0 ? void 0 : d1.instance) !== null && _e !== void 0 ? _e : {}, (_f = d2 === null || d2 === void 0 ? void 0 : d2.instance) !== null && _f !== void 0 ? _f : {})
      };
    };
    decorators = /* @__PURE__ */ new Map();
    findAllConstituentClasses = (...classes) => {
      var _a;
      const allClasses = /* @__PURE__ */ new Set();
      const frontier = /* @__PURE__ */ new Set([...classes]);
      while (frontier.size > 0) {
        for (let clazz of frontier) {
          const protoChainClasses = protoChain(clazz.prototype).map((proto) => proto.constructor);
          const mixinClasses = (_a = getMixinsForClass(clazz)) !== null && _a !== void 0 ? _a : [];
          const potentiallyNewClasses = [...protoChainClasses, ...mixinClasses];
          const newClasses = potentiallyNewClasses.filter((c) => !allClasses.has(c));
          for (let newClass of newClasses)
            frontier.add(newClass);
          allClasses.add(clazz);
          frontier.delete(clazz);
        }
      }
      return [...allClasses];
    };
    deepDecoratorSearch = (...classes) => {
      const decoratorsForClassChain = findAllConstituentClasses(...classes).map((clazz) => decorators.get(clazz)).filter((decorators2) => !!decorators2);
      if (decoratorsForClassChain.length == 0)
        return {};
      if (decoratorsForClassChain.length == 1)
        return decoratorsForClassChain[0];
      return decoratorsForClassChain.reduce((d1, d2) => mergeDecorators(d1, d2));
    };
    directDecoratorSearch = (...classes) => {
      const classDecorators = classes.map((clazz) => getDecoratorsForClass(clazz));
      if (classDecorators.length === 0)
        return {};
      if (classDecorators.length === 1)
        return classDecorators[0];
      return classDecorators.reduce((d1, d2) => mergeDecorators(d1, d2));
    };
    getDecoratorsForClass = (clazz) => {
      let decoratorsForClass = decorators.get(clazz);
      if (!decoratorsForClass) {
        decoratorsForClass = {};
        decorators.set(clazz, decoratorsForClass);
      }
      return decoratorsForClass;
    };
    decorateClass = (decorator) => (clazz) => {
      const decoratorsForClass = getDecoratorsForClass(clazz);
      let classDecorators = decoratorsForClass.class;
      if (!classDecorators) {
        classDecorators = [];
        decoratorsForClass.class = classDecorators;
      }
      classDecorators.push(decorator);
      return decorator(clazz);
    };
    decorateMember = (decorator) => (object, key, ...otherArgs) => {
      var _a, _b, _c;
      const decoratorTargetType = typeof object === "function" ? "static" : "instance";
      const decoratorType = typeof object[key] === "function" ? "method" : "property";
      const clazz = decoratorTargetType === "static" ? object : object.constructor;
      const decoratorsForClass = getDecoratorsForClass(clazz);
      const decoratorsForTargetType = (_a = decoratorsForClass === null || decoratorsForClass === void 0 ? void 0 : decoratorsForClass[decoratorTargetType]) !== null && _a !== void 0 ? _a : {};
      decoratorsForClass[decoratorTargetType] = decoratorsForTargetType;
      let decoratorsForType = (_b = decoratorsForTargetType === null || decoratorsForTargetType === void 0 ? void 0 : decoratorsForTargetType[decoratorType]) !== null && _b !== void 0 ? _b : {};
      decoratorsForTargetType[decoratorType] = decoratorsForType;
      let decoratorsForKey = (_c = decoratorsForType === null || decoratorsForType === void 0 ? void 0 : decoratorsForType[key]) !== null && _c !== void 0 ? _c : [];
      decoratorsForType[key] = decoratorsForKey;
      decoratorsForKey.push(decorator);
      return decorator(object, key, ...otherArgs);
    };
    decorate = (decorator) => (...args) => {
      if (args.length === 1)
        return decorateClass(decorator)(args[0]);
      return decorateMember(decorator)(...args);
    };
    applyPropAndMethodDecorators = (propAndMethodDecorators, target) => {
      const propDecorators = propAndMethodDecorators.property;
      const methodDecorators = propAndMethodDecorators.method;
      if (propDecorators)
        for (let key in propDecorators)
          for (let decorator of propDecorators[key])
            decorator(target, key);
      if (methodDecorators)
        for (let key in methodDecorators)
          for (let decorator of methodDecorators[key])
            decorator(target, key, Object.getOwnPropertyDescriptor(target, key));
    };
    mix = (...ingredients) => (decoratedClass) => {
      const mixedClass = Mixin(...ingredients.concat([decoratedClass]));
      Object.defineProperty(mixedClass, "name", {
        value: decoratedClass.name,
        writable: false
      });
      return mixedClass;
    };
  }
});

// node_modules/@trezor/schema-utils/lib/custom-types/array-buffer.js
var require_array_buffer = __commonJS({
  "node_modules/@trezor/schema-utils/lib/custom-types/array-buffer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ArrayBufferBuilder = void 0;
    var typebox_1 = require_cjs();
    typebox_1.TypeRegistry.Set("ArrayBuffer", (_, value) => value instanceof ArrayBuffer);
    var ArrayBufferBuilder = class extends typebox_1.JavaScriptTypeBuilder {
      ArrayBuffer(options) {
        return (0, typebox_1.CreateType)({ [typebox_1.Kind]: "ArrayBuffer", type: "ArrayBuffer" }, options);
      }
    };
    exports2.ArrayBufferBuilder = ArrayBufferBuilder;
  }
});

// node_modules/@trezor/schema-utils/lib/custom-types/buffer.js
var require_buffer2 = __commonJS({
  "node_modules/@trezor/schema-utils/lib/custom-types/buffer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BufferBuilder = void 0;
    var typebox_1 = require_cjs();
    typebox_1.TypeRegistry.Set("Buffer", (_, value) => value instanceof Buffer);
    var BufferBuilder = class extends typebox_1.JavaScriptTypeBuilder {
      Buffer(options) {
        return (0, typebox_1.CreateType)({ [typebox_1.Kind]: "Buffer", type: "Buffer" }, options);
      }
    };
    exports2.BufferBuilder = BufferBuilder;
  }
});

// node_modules/@trezor/schema-utils/lib/custom-types/keyof-enum.js
var require_keyof_enum = __commonJS({
  "node_modules/@trezor/schema-utils/lib/custom-types/keyof-enum.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KeyofEnumBuilder = void 0;
    var typebox_1 = require_cjs();
    var KeyofEnumBuilder = class extends typebox_1.JavaScriptTypeBuilder {
      KeyOfEnum(schema, options) {
        const keys = Object.keys(schema).map((key) => this.Literal(key));
        return this.Union(keys, { ...options, [typebox_1.Hint]: "KeyOfEnum" });
      }
      Enum(schema, options) {
        const anyOf = Object.entries(schema).filter(([key, _value]) => typeof key === "string" || !isNaN(key)).map(([key, value]) => this.Literal(value, { $id: key }));
        return this.Union(anyOf, { ...options, [typebox_1.Hint]: "Enum" });
      }
    };
    exports2.KeyofEnumBuilder = KeyofEnumBuilder;
  }
});

// node_modules/@trezor/schema-utils/lib/custom-types/uint.js
var require_uint = __commonJS({
  "node_modules/@trezor/schema-utils/lib/custom-types/uint.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UintBuilder = void 0;
    var typebox_1 = require_cjs();
    typebox_1.TypeRegistry.Set("Uint", (schema, value) => {
      if (typeof value !== "string" && typeof value !== "number") {
        return false;
      }
      if (typeof value === "number" && !Number.isSafeInteger(value) || !/^(?:[1-9]\d*|\d)$/.test(value.toString().replace(/^-/, schema.allowNegative ? "" : "-"))) {
        return false;
      }
      return true;
    });
    var UintBuilder = class extends typebox_1.JavaScriptTypeBuilder {
      Uint(options) {
        return (0, typebox_1.CreateType)({ [typebox_1.Kind]: "Uint", type: "Uint" }, options);
      }
    };
    exports2.UintBuilder = UintBuilder;
  }
});

// node_modules/@trezor/schema-utils/lib/custom-types/index.js
var require_custom_types = __commonJS({
  "node_modules/@trezor/schema-utils/lib/custom-types/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UintBuilder = exports2.KeyofEnumBuilder = exports2.BufferBuilder = exports2.ArrayBufferBuilder = void 0;
    var array_buffer_1 = require_array_buffer();
    Object.defineProperty(exports2, "ArrayBufferBuilder", { enumerable: true, get: function() {
      return array_buffer_1.ArrayBufferBuilder;
    } });
    var buffer_1 = require_buffer2();
    Object.defineProperty(exports2, "BufferBuilder", { enumerable: true, get: function() {
      return buffer_1.BufferBuilder;
    } });
    var keyof_enum_1 = require_keyof_enum();
    Object.defineProperty(exports2, "KeyofEnumBuilder", { enumerable: true, get: function() {
      return keyof_enum_1.KeyofEnumBuilder;
    } });
    var uint_1 = require_uint();
    Object.defineProperty(exports2, "UintBuilder", { enumerable: true, get: function() {
      return uint_1.UintBuilder;
    } });
  }
});

// node_modules/@trezor/schema-utils/lib/errors.js
var require_errors6 = __commonJS({
  "node_modules/@trezor/schema-utils/lib/errors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InvalidParameter = void 0;
    var InvalidParameter = class extends Error {
      field;
      type;
      constructor(reason, field, type, value) {
        let message = `Invalid parameter`;
        message += ` "${field.substring(1)}"`;
        message += ` (= ${JSON.stringify(value)})`;
        message += `: ${reason.replace(/'/g, '"')}`;
        super(message);
        this.name = "InvalidParameter";
        this.field = field;
        this.type = type;
      }
    };
    exports2.InvalidParameter = InvalidParameter;
  }
});

// node_modules/@trezor/schema-utils/lib/utils.js
var require_utils5 = __commonJS({
  "node_modules/@trezor/schema-utils/lib/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setDeepValue = setDeepValue;
    exports2.getDeepValue = getDeepValue;
    function setDeepValue(obj, [prop, ...path], value) {
      if (!path.length) {
        obj[prop] = value;
      } else {
        if (!(prop in obj))
          obj[prop] = {};
        setDeepValue(obj[prop], path, value);
      }
    }
    function getDeepValue(obj, [prop, ...path]) {
      if (!path.length) {
        return obj[prop];
      } else {
        if (!(prop in obj))
          return void 0;
        return getDeepValue(obj[prop], path);
      }
    }
  }
});

// node_modules/@trezor/schema-utils/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/@trezor/schema-utils/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CloneType = exports2.Optional = exports2.Type = void 0;
    exports2.Validate = Validate;
    exports2.Assert = Assert;
    exports2.AssertWeak = AssertWeak;
    var typebox_1 = require_cjs();
    Object.defineProperty(exports2, "CloneType", { enumerable: true, get: function() {
      return typebox_1.CloneType;
    } });
    Object.defineProperty(exports2, "Optional", { enumerable: true, get: function() {
      return typebox_1.Optional;
    } });
    var errors_1 = require_errors5();
    var ts_mixer_1 = (init_esm(), __toCommonJS(esm_exports));
    var custom_types_1 = require_custom_types();
    var errors_2 = require_errors6();
    var utils_1 = require_utils5();
    var CustomTypeBuilder = class extends (0, ts_mixer_1.Mixin)(typebox_1.JavaScriptTypeBuilder, custom_types_1.ArrayBufferBuilder, custom_types_1.BufferBuilder, custom_types_1.KeyofEnumBuilder, custom_types_1.UintBuilder) {
    };
    function Validate(schema, value) {
      try {
        Assert(schema, value);
        return true;
      } catch {
        return false;
      }
    }
    function FindErrorInUnion(error) {
      const currentValue = error.value;
      const unionMembers = error.schema.anyOf;
      const hasValidMember = unionMembers.find((unionSchema) => Validate(unionSchema, currentValue));
      if (!hasValidMember) {
        const possibleMatchesByLiterals = unionMembers.filter((unionSchema) => {
          if (unionSchema[typebox_1.Kind] !== "Object")
            return false;
          return !Object.entries(unionSchema.properties).find(([property, propertySchema]) => propertySchema.const && propertySchema.const !== currentValue[property]);
        });
        if (possibleMatchesByLiterals.length === 1) {
          Assert(possibleMatchesByLiterals[0], currentValue);
        } else if (possibleMatchesByLiterals.length > 1) {
          const errorsOfPossibleMatches = possibleMatchesByLiterals.map((matchSchema) => ({
            schema: matchSchema,
            errors: [...(0, errors_1.Errors)(matchSchema, currentValue)]
          }));
          const sortedErrors = errorsOfPossibleMatches.sort((a, b2) => a.errors.length - b2.errors.length);
          const [bestMatch] = sortedErrors;
          Assert(bestMatch.schema, currentValue);
        }
        throw new errors_2.InvalidParameter(error.message, error.path, error.type, error.value);
      }
    }
    function Assert(schema, value) {
      const errors = [...(0, errors_1.Errors)(schema, value)];
      let [error] = errors;
      while (error) {
        if (error.path === "/" && errors.length > 1) {
        } else if (error.value == null && error.schema[typebox_1.OptionalKind] === "Optional") {
        } else if (error.type === errors_1.ValueErrorType.Union) {
          FindErrorInUnion(error);
        } else if (error.type === errors_1.ValueErrorType.Number && typeof error.value === "string") {
          const currentValue = error.value;
          const parsedNumber = Number(currentValue);
          if (!Number.isNaN(parsedNumber) && currentValue === parsedNumber.toString()) {
            const pathParts = error.path.slice(1).split("/");
            (0, utils_1.setDeepValue)(value, pathParts, parsedNumber);
          } else {
            throw new errors_2.InvalidParameter(error.message, error.path, error.type, error.value);
          }
        } else {
          throw new errors_2.InvalidParameter(error.message, error.path, error.type, error.value);
        }
        errors.shift();
        [error] = errors;
      }
    }
    function AssertWeak(schema, value) {
      try {
        Assert(schema, value);
      } catch (e) {
        if (e instanceof errors_2.InvalidParameter) {
          if (e.type === errors_1.ValueErrorType.ObjectRequiredProperty) {
            throw e;
          }
          console.warn("Method params validation failed", e);
        } else {
          throw e;
        }
      }
    }
    exports2.Type = new CustomTypeBuilder();
  }
});

// node_modules/@trezor/connect/lib/constants/nem.js
var require_nem = __commonJS({
  "node_modules/@trezor/connect/lib/constants/nem.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EnumTxVersion = exports2.TxVersion = exports2.EnumTxType = exports2.TxType = exports2.EnumNetworks = exports2.Networks = void 0;
    var schema_utils_1 = require_lib2();
    var Networks;
    (function(Networks2) {
      Networks2[Networks2["mainnet"] = 104] = "mainnet";
      Networks2[Networks2["testnet"] = 152] = "testnet";
      Networks2[Networks2["mijin"] = 96] = "mijin";
    })(Networks || (exports2.Networks = Networks = {}));
    exports2.EnumNetworks = schema_utils_1.Type.Enum(Networks);
    var TxType;
    (function(TxType2) {
      TxType2[TxType2["TRANSFER"] = 257] = "TRANSFER";
      TxType2[TxType2["COSIGNING"] = 258] = "COSIGNING";
      TxType2[TxType2["IMPORTANCE_TRANSFER"] = 2049] = "IMPORTANCE_TRANSFER";
      TxType2[TxType2["AGGREGATE_MODIFICATION"] = 4097] = "AGGREGATE_MODIFICATION";
      TxType2[TxType2["MULTISIG_SIGNATURE"] = 4098] = "MULTISIG_SIGNATURE";
      TxType2[TxType2["MULTISIG"] = 4100] = "MULTISIG";
      TxType2[TxType2["PROVISION_NAMESPACE"] = 8193] = "PROVISION_NAMESPACE";
      TxType2[TxType2["MOSAIC_CREATION"] = 16385] = "MOSAIC_CREATION";
      TxType2[TxType2["SUPPLY_CHANGE"] = 16386] = "SUPPLY_CHANGE";
    })(TxType || (exports2.TxType = TxType = {}));
    exports2.EnumTxType = schema_utils_1.Type.Enum(TxType);
    var TxVersion;
    (function(TxVersion2) {
      TxVersion2[TxVersion2["mainnet"] = 1744830464] = "mainnet";
      TxVersion2[TxVersion2["testnet"] = -1744830464] = "testnet";
      TxVersion2[TxVersion2["mijin"] = 1610612736] = "mijin";
    })(TxVersion || (exports2.TxVersion = TxVersion = {}));
    exports2.EnumTxVersion = schema_utils_1.Type.Enum(TxVersion);
  }
});

// node_modules/@trezor/connect/lib/constants/firmware.js
var require_firmware = __commonJS({
  "node_modules/@trezor/connect/lib/constants/firmware.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.REVISION_CHECK_RETRIABLE_ERRORS = exports2.HASH_CHECK_RETRIABLE_ERRORS = exports2.HASH_CHECK_MAX_ATTEMPTS = void 0;
    exports2.HASH_CHECK_MAX_ATTEMPTS = 3;
    exports2.HASH_CHECK_RETRIABLE_ERRORS = ["other-error"];
    exports2.REVISION_CHECK_RETRIABLE_ERRORS = [
      "cannot-perform-check-offline",
      "other-error"
    ];
  }
});

// node_modules/@trezor/connect/lib/constants/utxo.js
var require_utxo = __commonJS({
  "node_modules/@trezor/connect/lib/constants/utxo.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DEFAULT_SORTING_STRATEGY = void 0;
    exports2.DEFAULT_SORTING_STRATEGY = "random";
  }
});

// node_modules/long/umd/index.js
var require_umd = __commonJS({
  "node_modules/long/umd/index.js"(exports2, module2) {
    var Long = function(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", {
        value: true
      });
      exports3.default = void 0;
      var wasm = null;
      try {
        wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
      } catch (e) {
      }
      function Long2(low, high, unsigned) {
        this.low = low | 0;
        this.high = high | 0;
        this.unsigned = !!unsigned;
      }
      Long2.prototype.__isLong__;
      Object.defineProperty(Long2.prototype, "__isLong__", {
        value: true
      });
      function isLong(obj) {
        return (obj && obj["__isLong__"]) === true;
      }
      function ctz32(value) {
        var c = Math.clz32(value & -value);
        return value ? 31 - c : c;
      }
      Long2.isLong = isLong;
      var INT_CACHE = {};
      var UINT_CACHE = {};
      function fromInt(value, unsigned) {
        var obj, cachedObj, cache;
        if (unsigned) {
          value >>>= 0;
          if (cache = 0 <= value && value < 256) {
            cachedObj = UINT_CACHE[value];
            if (cachedObj) return cachedObj;
          }
          obj = fromBits(value, 0, true);
          if (cache) UINT_CACHE[value] = obj;
          return obj;
        } else {
          value |= 0;
          if (cache = -128 <= value && value < 128) {
            cachedObj = INT_CACHE[value];
            if (cachedObj) return cachedObj;
          }
          obj = fromBits(value, value < 0 ? -1 : 0, false);
          if (cache) INT_CACHE[value] = obj;
          return obj;
        }
      }
      Long2.fromInt = fromInt;
      function fromNumber(value, unsigned) {
        if (isNaN(value)) return unsigned ? UZERO : ZERO;
        if (unsigned) {
          if (value < 0) return UZERO;
          if (value >= TWO_PWR_64_DBL) return MAX_UNSIGNED_VALUE;
        } else {
          if (value <= -TWO_PWR_63_DBL) return MIN_VALUE;
          if (value + 1 >= TWO_PWR_63_DBL) return MAX_VALUE;
        }
        if (value < 0) return fromNumber(-value, unsigned).neg();
        return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
      }
      Long2.fromNumber = fromNumber;
      function fromBits(lowBits, highBits, unsigned) {
        return new Long2(lowBits, highBits, unsigned);
      }
      Long2.fromBits = fromBits;
      var pow_dbl = Math.pow;
      function fromString(str, unsigned, radix) {
        if (str.length === 0) throw Error("empty string");
        if (typeof unsigned === "number") {
          radix = unsigned;
          unsigned = false;
        } else {
          unsigned = !!unsigned;
        }
        if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity") return unsigned ? UZERO : ZERO;
        radix = radix || 10;
        if (radix < 2 || 36 < radix) throw RangeError("radix");
        var p;
        if ((p = str.indexOf("-")) > 0) throw Error("interior hyphen");
        else if (p === 0) {
          return fromString(str.substring(1), unsigned, radix).neg();
        }
        var radixToPower = fromNumber(pow_dbl(radix, 8));
        var result = ZERO;
        for (var i = 0; i < str.length; i += 8) {
          var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);
          if (size < 8) {
            var power = fromNumber(pow_dbl(radix, size));
            result = result.mul(power).add(fromNumber(value));
          } else {
            result = result.mul(radixToPower);
            result = result.add(fromNumber(value));
          }
        }
        result.unsigned = unsigned;
        return result;
      }
      Long2.fromString = fromString;
      function fromValue(val, unsigned) {
        if (typeof val === "number") return fromNumber(val, unsigned);
        if (typeof val === "string") return fromString(val, unsigned);
        return fromBits(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned);
      }
      Long2.fromValue = fromValue;
      var TWO_PWR_16_DBL = 1 << 16;
      var TWO_PWR_24_DBL = 1 << 24;
      var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
      var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
      var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
      var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
      var ZERO = fromInt(0);
      Long2.ZERO = ZERO;
      var UZERO = fromInt(0, true);
      Long2.UZERO = UZERO;
      var ONE = fromInt(1);
      Long2.ONE = ONE;
      var UONE = fromInt(1, true);
      Long2.UONE = UONE;
      var NEG_ONE = fromInt(-1);
      Long2.NEG_ONE = NEG_ONE;
      var MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);
      Long2.MAX_VALUE = MAX_VALUE;
      var MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);
      Long2.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
      var MIN_VALUE = fromBits(0, 2147483648 | 0, false);
      Long2.MIN_VALUE = MIN_VALUE;
      var LongPrototype = Long2.prototype;
      LongPrototype.toInt = function toInt() {
        return this.unsigned ? this.low >>> 0 : this.low;
      };
      LongPrototype.toNumber = function toNumber() {
        if (this.unsigned) return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
        return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
      };
      LongPrototype.toString = function toString(radix) {
        radix = radix || 10;
        if (radix < 2 || 36 < radix) throw RangeError("radix");
        if (this.isZero()) return "0";
        if (this.isNegative()) {
          if (this.eq(MIN_VALUE)) {
            var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
            return div.toString(radix) + rem1.toInt().toString(radix);
          } else return "-" + this.neg().toString(radix);
        }
        var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
        var result = "";
        while (true) {
          var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
          rem = remDiv;
          if (rem.isZero()) return digits + result;
          else {
            while (digits.length < 6) digits = "0" + digits;
            result = "" + digits + result;
          }
        }
      };
      LongPrototype.getHighBits = function getHighBits() {
        return this.high;
      };
      LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
        return this.high >>> 0;
      };
      LongPrototype.getLowBits = function getLowBits() {
        return this.low;
      };
      LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
        return this.low >>> 0;
      };
      LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
        if (this.isNegative())
          return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
        var val = this.high != 0 ? this.high : this.low;
        for (var bit = 31; bit > 0; bit--) if ((val & 1 << bit) != 0) break;
        return this.high != 0 ? bit + 33 : bit + 1;
      };
      LongPrototype.isZero = function isZero() {
        return this.high === 0 && this.low === 0;
      };
      LongPrototype.eqz = LongPrototype.isZero;
      LongPrototype.isNegative = function isNegative() {
        return !this.unsigned && this.high < 0;
      };
      LongPrototype.isPositive = function isPositive() {
        return this.unsigned || this.high >= 0;
      };
      LongPrototype.isOdd = function isOdd() {
        return (this.low & 1) === 1;
      };
      LongPrototype.isEven = function isEven() {
        return (this.low & 1) === 0;
      };
      LongPrototype.equals = function equals(other) {
        if (!isLong(other)) other = fromValue(other);
        if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1) return false;
        return this.high === other.high && this.low === other.low;
      };
      LongPrototype.eq = LongPrototype.equals;
      LongPrototype.notEquals = function notEquals(other) {
        return !this.eq(
          /* validates */
          other
        );
      };
      LongPrototype.neq = LongPrototype.notEquals;
      LongPrototype.ne = LongPrototype.notEquals;
      LongPrototype.lessThan = function lessThan(other) {
        return this.comp(
          /* validates */
          other
        ) < 0;
      };
      LongPrototype.lt = LongPrototype.lessThan;
      LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
        return this.comp(
          /* validates */
          other
        ) <= 0;
      };
      LongPrototype.lte = LongPrototype.lessThanOrEqual;
      LongPrototype.le = LongPrototype.lessThanOrEqual;
      LongPrototype.greaterThan = function greaterThan(other) {
        return this.comp(
          /* validates */
          other
        ) > 0;
      };
      LongPrototype.gt = LongPrototype.greaterThan;
      LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
        return this.comp(
          /* validates */
          other
        ) >= 0;
      };
      LongPrototype.gte = LongPrototype.greaterThanOrEqual;
      LongPrototype.ge = LongPrototype.greaterThanOrEqual;
      LongPrototype.compare = function compare(other) {
        if (!isLong(other)) other = fromValue(other);
        if (this.eq(other)) return 0;
        var thisNeg = this.isNegative(), otherNeg = other.isNegative();
        if (thisNeg && !otherNeg) return -1;
        if (!thisNeg && otherNeg) return 1;
        if (!this.unsigned) return this.sub(other).isNegative() ? -1 : 1;
        return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
      };
      LongPrototype.comp = LongPrototype.compare;
      LongPrototype.negate = function negate() {
        if (!this.unsigned && this.eq(MIN_VALUE)) return MIN_VALUE;
        return this.not().add(ONE);
      };
      LongPrototype.neg = LongPrototype.negate;
      LongPrototype.add = function add(addend) {
        if (!isLong(addend)) addend = fromValue(addend);
        var a48 = this.high >>> 16;
        var a32 = this.high & 65535;
        var a16 = this.low >>> 16;
        var a00 = this.low & 65535;
        var b48 = addend.high >>> 16;
        var b32 = addend.high & 65535;
        var b16 = addend.low >>> 16;
        var b00 = addend.low & 65535;
        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 + b00;
        c16 += c00 >>> 16;
        c00 &= 65535;
        c16 += a16 + b16;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c32 += a32 + b32;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c48 += a48 + b48;
        c48 &= 65535;
        return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
      };
      LongPrototype.subtract = function subtract(subtrahend) {
        if (!isLong(subtrahend)) subtrahend = fromValue(subtrahend);
        return this.add(subtrahend.neg());
      };
      LongPrototype.sub = LongPrototype.subtract;
      LongPrototype.multiply = function multiply(multiplier) {
        if (this.isZero()) return this;
        if (!isLong(multiplier)) multiplier = fromValue(multiplier);
        if (wasm) {
          var low = wasm["mul"](this.low, this.high, multiplier.low, multiplier.high);
          return fromBits(low, wasm["get_high"](), this.unsigned);
        }
        if (multiplier.isZero()) return this.unsigned ? UZERO : ZERO;
        if (this.eq(MIN_VALUE)) return multiplier.isOdd() ? MIN_VALUE : ZERO;
        if (multiplier.eq(MIN_VALUE)) return this.isOdd() ? MIN_VALUE : ZERO;
        if (this.isNegative()) {
          if (multiplier.isNegative()) return this.neg().mul(multiplier.neg());
          else return this.neg().mul(multiplier).neg();
        } else if (multiplier.isNegative()) return this.mul(multiplier.neg()).neg();
        if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24)) return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
        var a48 = this.high >>> 16;
        var a32 = this.high & 65535;
        var a16 = this.low >>> 16;
        var a00 = this.low & 65535;
        var b48 = multiplier.high >>> 16;
        var b32 = multiplier.high & 65535;
        var b16 = multiplier.low >>> 16;
        var b00 = multiplier.low & 65535;
        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 * b00;
        c16 += c00 >>> 16;
        c00 &= 65535;
        c16 += a16 * b00;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c16 += a00 * b16;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c32 += a32 * b00;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c32 += a16 * b16;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c32 += a00 * b32;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
        c48 &= 65535;
        return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
      };
      LongPrototype.mul = LongPrototype.multiply;
      LongPrototype.divide = function divide(divisor) {
        if (!isLong(divisor)) divisor = fromValue(divisor);
        if (divisor.isZero()) throw Error("division by zero");
        if (wasm) {
          if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
            return this;
          }
          var low = (this.unsigned ? wasm["div_u"] : wasm["div_s"])(this.low, this.high, divisor.low, divisor.high);
          return fromBits(low, wasm["get_high"](), this.unsigned);
        }
        if (this.isZero()) return this.unsigned ? UZERO : ZERO;
        var approx, rem, res;
        if (!this.unsigned) {
          if (this.eq(MIN_VALUE)) {
            if (divisor.eq(ONE) || divisor.eq(NEG_ONE)) return MIN_VALUE;
            else if (divisor.eq(MIN_VALUE)) return ONE;
            else {
              var halfThis = this.shr(1);
              approx = halfThis.div(divisor).shl(1);
              if (approx.eq(ZERO)) {
                return divisor.isNegative() ? ONE : NEG_ONE;
              } else {
                rem = this.sub(divisor.mul(approx));
                res = approx.add(rem.div(divisor));
                return res;
              }
            }
          } else if (divisor.eq(MIN_VALUE)) return this.unsigned ? UZERO : ZERO;
          if (this.isNegative()) {
            if (divisor.isNegative()) return this.neg().div(divisor.neg());
            return this.neg().div(divisor).neg();
          } else if (divisor.isNegative()) return this.div(divisor.neg()).neg();
          res = ZERO;
        } else {
          if (!divisor.unsigned) divisor = divisor.toUnsigned();
          if (divisor.gt(this)) return UZERO;
          if (divisor.gt(this.shru(1)))
            return UONE;
          res = UZERO;
        }
        rem = this;
        while (rem.gte(divisor)) {
          approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
          var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
          while (approxRem.isNegative() || approxRem.gt(rem)) {
            approx -= delta;
            approxRes = fromNumber(approx, this.unsigned);
            approxRem = approxRes.mul(divisor);
          }
          if (approxRes.isZero()) approxRes = ONE;
          res = res.add(approxRes);
          rem = rem.sub(approxRem);
        }
        return res;
      };
      LongPrototype.div = LongPrototype.divide;
      LongPrototype.modulo = function modulo(divisor) {
        if (!isLong(divisor)) divisor = fromValue(divisor);
        if (wasm) {
          var low = (this.unsigned ? wasm["rem_u"] : wasm["rem_s"])(this.low, this.high, divisor.low, divisor.high);
          return fromBits(low, wasm["get_high"](), this.unsigned);
        }
        return this.sub(this.div(divisor).mul(divisor));
      };
      LongPrototype.mod = LongPrototype.modulo;
      LongPrototype.rem = LongPrototype.modulo;
      LongPrototype.not = function not() {
        return fromBits(~this.low, ~this.high, this.unsigned);
      };
      LongPrototype.countLeadingZeros = function countLeadingZeros() {
        return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
      };
      LongPrototype.clz = LongPrototype.countLeadingZeros;
      LongPrototype.countTrailingZeros = function countTrailingZeros() {
        return this.low ? ctz32(this.low) : ctz32(this.high) + 32;
      };
      LongPrototype.ctz = LongPrototype.countTrailingZeros;
      LongPrototype.and = function and(other) {
        if (!isLong(other)) other = fromValue(other);
        return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
      };
      LongPrototype.or = function or(other) {
        if (!isLong(other)) other = fromValue(other);
        return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
      };
      LongPrototype.xor = function xor(other) {
        if (!isLong(other)) other = fromValue(other);
        return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
      };
      LongPrototype.shiftLeft = function shiftLeft(numBits) {
        if (isLong(numBits)) numBits = numBits.toInt();
        if ((numBits &= 63) === 0) return this;
        else if (numBits < 32) return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
        else return fromBits(0, this.low << numBits - 32, this.unsigned);
      };
      LongPrototype.shl = LongPrototype.shiftLeft;
      LongPrototype.shiftRight = function shiftRight(numBits) {
        if (isLong(numBits)) numBits = numBits.toInt();
        if ((numBits &= 63) === 0) return this;
        else if (numBits < 32) return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
        else return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
      };
      LongPrototype.shr = LongPrototype.shiftRight;
      LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
        if (isLong(numBits)) numBits = numBits.toInt();
        if ((numBits &= 63) === 0) return this;
        if (numBits < 32) return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >>> numBits, this.unsigned);
        if (numBits === 32) return fromBits(this.high, 0, this.unsigned);
        return fromBits(this.high >>> numBits - 32, 0, this.unsigned);
      };
      LongPrototype.shru = LongPrototype.shiftRightUnsigned;
      LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
      LongPrototype.rotateLeft = function rotateLeft(numBits) {
        var b2;
        if (isLong(numBits)) numBits = numBits.toInt();
        if ((numBits &= 63) === 0) return this;
        if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
        if (numBits < 32) {
          b2 = 32 - numBits;
          return fromBits(this.low << numBits | this.high >>> b2, this.high << numBits | this.low >>> b2, this.unsigned);
        }
        numBits -= 32;
        b2 = 32 - numBits;
        return fromBits(this.high << numBits | this.low >>> b2, this.low << numBits | this.high >>> b2, this.unsigned);
      };
      LongPrototype.rotl = LongPrototype.rotateLeft;
      LongPrototype.rotateRight = function rotateRight(numBits) {
        var b2;
        if (isLong(numBits)) numBits = numBits.toInt();
        if ((numBits &= 63) === 0) return this;
        if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
        if (numBits < 32) {
          b2 = 32 - numBits;
          return fromBits(this.high << b2 | this.low >>> numBits, this.low << b2 | this.high >>> numBits, this.unsigned);
        }
        numBits -= 32;
        b2 = 32 - numBits;
        return fromBits(this.low << b2 | this.high >>> numBits, this.high << b2 | this.low >>> numBits, this.unsigned);
      };
      LongPrototype.rotr = LongPrototype.rotateRight;
      LongPrototype.toSigned = function toSigned() {
        if (!this.unsigned) return this;
        return fromBits(this.low, this.high, false);
      };
      LongPrototype.toUnsigned = function toUnsigned() {
        if (this.unsigned) return this;
        return fromBits(this.low, this.high, true);
      };
      LongPrototype.toBytes = function toBytes2(le) {
        return le ? this.toBytesLE() : this.toBytesBE();
      };
      LongPrototype.toBytesLE = function toBytesLE() {
        var hi = this.high, lo = this.low;
        return [lo & 255, lo >>> 8 & 255, lo >>> 16 & 255, lo >>> 24, hi & 255, hi >>> 8 & 255, hi >>> 16 & 255, hi >>> 24];
      };
      LongPrototype.toBytesBE = function toBytesBE() {
        var hi = this.high, lo = this.low;
        return [hi >>> 24, hi >>> 16 & 255, hi >>> 8 & 255, hi & 255, lo >>> 24, lo >>> 16 & 255, lo >>> 8 & 255, lo & 255];
      };
      Long2.fromBytes = function fromBytes(bytes, unsigned, le) {
        return le ? Long2.fromBytesLE(bytes, unsigned) : Long2.fromBytesBE(bytes, unsigned);
      };
      Long2.fromBytesLE = function fromBytesLE(bytes, unsigned) {
        return new Long2(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);
      };
      Long2.fromBytesBE = function fromBytesBE(bytes, unsigned) {
        return new Long2(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned);
      };
      var _default = Long2;
      exports3.default = _default;
      return "default" in exports3 ? exports3.default : exports3;
    }({});
    if (typeof define === "function" && define.amd) define([], function() {
      return Long;
    });
    else if (typeof module2 === "object" && typeof exports2 === "object") module2.exports = Long;
  }
});

// node_modules/@protobufjs/aspromise/index.js
var require_aspromise = __commonJS({
  "node_modules/@protobufjs/aspromise/index.js"(exports2, module2) {
    "use strict";
    module2.exports = asPromise;
    function asPromise(fn, ctx) {
      var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;
      while (index < arguments.length)
        params[offset++] = arguments[index++];
      return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err) {
          if (pending) {
            pending = false;
            if (err)
              reject(err);
            else {
              var params2 = new Array(arguments.length - 1), offset2 = 0;
              while (offset2 < params2.length)
                params2[offset2++] = arguments[offset2];
              resolve.apply(null, params2);
            }
          }
        };
        try {
          fn.apply(ctx || null, params);
        } catch (err) {
          if (pending) {
            pending = false;
            reject(err);
          }
        }
      });
    }
  }
});

// node_modules/@protobufjs/base64/index.js
var require_base64 = __commonJS({
  "node_modules/@protobufjs/base64/index.js"(exports2) {
    "use strict";
    var base64 = exports2;
    base64.length = function length(string) {
      var p = string.length;
      if (!p)
        return 0;
      var n = 0;
      while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
      return Math.ceil(string.length * 3) / 4 - n;
    };
    var b64 = new Array(64);
    var s64 = new Array(123);
    for (i = 0; i < 64; )
      s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
    var i;
    base64.encode = function encode(buffer, start, end) {
      var parts = null, chunk = [];
      var i2 = 0, j = 0, t;
      while (start < end) {
        var b2 = buffer[start++];
        switch (j) {
          case 0:
            chunk[i2++] = b64[b2 >> 2];
            t = (b2 & 3) << 4;
            j = 1;
            break;
          case 1:
            chunk[i2++] = b64[t | b2 >> 4];
            t = (b2 & 15) << 2;
            j = 2;
            break;
          case 2:
            chunk[i2++] = b64[t | b2 >> 6];
            chunk[i2++] = b64[b2 & 63];
            j = 0;
            break;
        }
        if (i2 > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i2 = 0;
        }
      }
      if (j) {
        chunk[i2++] = b64[t];
        chunk[i2++] = 61;
        if (j === 1)
          chunk[i2++] = 61;
      }
      if (parts) {
        if (i2)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i2));
    };
    var invalidEncoding = "invalid encoding";
    base64.decode = function decode(string, buffer, offset) {
      var start = offset;
      var j = 0, t;
      for (var i2 = 0; i2 < string.length; ) {
        var c = string.charCodeAt(i2++);
        if (c === 61 && j > 1)
          break;
        if ((c = s64[c]) === void 0)
          throw Error(invalidEncoding);
        switch (j) {
          case 0:
            t = c;
            j = 1;
            break;
          case 1:
            buffer[offset++] = t << 2 | (c & 48) >> 4;
            t = c;
            j = 2;
            break;
          case 2:
            buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
            t = c;
            j = 3;
            break;
          case 3:
            buffer[offset++] = (t & 3) << 6 | c;
            j = 0;
            break;
        }
      }
      if (j === 1)
        throw Error(invalidEncoding);
      return offset - start;
    };
    base64.test = function test(string) {
      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
    };
  }
});

// node_modules/@protobufjs/eventemitter/index.js
var require_eventemitter = __commonJS({
  "node_modules/@protobufjs/eventemitter/index.js"(exports2, module2) {
    "use strict";
    module2.exports = EventEmitter2;
    function EventEmitter2() {
      this._listeners = {};
    }
    EventEmitter2.prototype.on = function on(evt, fn, ctx) {
      (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn,
        ctx: ctx || this
      });
      return this;
    };
    EventEmitter2.prototype.off = function off(evt, fn) {
      if (evt === void 0)
        this._listeners = {};
      else {
        if (fn === void 0)
          this._listeners[evt] = [];
        else {
          var listeners = this._listeners[evt];
          for (var i = 0; i < listeners.length; )
            if (listeners[i].fn === fn)
              listeners.splice(i, 1);
            else
              ++i;
        }
      }
      return this;
    };
    EventEmitter2.prototype.emit = function emit(evt) {
      var listeners = this._listeners[evt];
      if (listeners) {
        var args = [], i = 1;
        for (; i < arguments.length; )
          args.push(arguments[i++]);
        for (i = 0; i < listeners.length; )
          listeners[i].fn.apply(listeners[i++].ctx, args);
      }
      return this;
    };
  }
});

// node_modules/@protobufjs/float/index.js
var require_float = __commonJS({
  "node_modules/@protobufjs/float/index.js"(exports2, module2) {
    "use strict";
    module2.exports = factory(factory);
    function factory(exports3) {
      if (typeof Float32Array !== "undefined") (function() {
        var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
        function writeFloat_f32_cpy(val, buf, pos) {
          f32[0] = val;
          buf[pos] = f8b[0];
          buf[pos + 1] = f8b[1];
          buf[pos + 2] = f8b[2];
          buf[pos + 3] = f8b[3];
        }
        function writeFloat_f32_rev(val, buf, pos) {
          f32[0] = val;
          buf[pos] = f8b[3];
          buf[pos + 1] = f8b[2];
          buf[pos + 2] = f8b[1];
          buf[pos + 3] = f8b[0];
        }
        exports3.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
        exports3.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
        function readFloat_f32_cpy(buf, pos) {
          f8b[0] = buf[pos];
          f8b[1] = buf[pos + 1];
          f8b[2] = buf[pos + 2];
          f8b[3] = buf[pos + 3];
          return f32[0];
        }
        function readFloat_f32_rev(buf, pos) {
          f8b[3] = buf[pos];
          f8b[2] = buf[pos + 1];
          f8b[1] = buf[pos + 2];
          f8b[0] = buf[pos + 3];
          return f32[0];
        }
        exports3.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
        exports3.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
      })();
      else (function() {
        function writeFloat_ieee754(writeUint, val, buf, pos) {
          var sign = val < 0 ? 1 : 0;
          if (sign)
            val = -val;
          if (val === 0)
            writeUint(1 / val > 0 ? (
              /* positive */
              0
            ) : (
              /* negative 0 */
              2147483648
            ), buf, pos);
          else if (isNaN(val))
            writeUint(2143289344, buf, pos);
          else if (val > 34028234663852886e22)
            writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
          else if (val < 11754943508222875e-54)
            writeUint((sign << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf, pos);
          else {
            var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
            writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
          }
        }
        exports3.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
        exports3.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
        function readFloat_ieee754(readUint, buf, pos) {
          var uint = readUint(buf, pos), sign = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
          return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 1401298464324817e-60 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
        }
        exports3.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
        exports3.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
      })();
      if (typeof Float64Array !== "undefined") (function() {
        var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
        function writeDouble_f64_cpy(val, buf, pos) {
          f64[0] = val;
          buf[pos] = f8b[0];
          buf[pos + 1] = f8b[1];
          buf[pos + 2] = f8b[2];
          buf[pos + 3] = f8b[3];
          buf[pos + 4] = f8b[4];
          buf[pos + 5] = f8b[5];
          buf[pos + 6] = f8b[6];
          buf[pos + 7] = f8b[7];
        }
        function writeDouble_f64_rev(val, buf, pos) {
          f64[0] = val;
          buf[pos] = f8b[7];
          buf[pos + 1] = f8b[6];
          buf[pos + 2] = f8b[5];
          buf[pos + 3] = f8b[4];
          buf[pos + 4] = f8b[3];
          buf[pos + 5] = f8b[2];
          buf[pos + 6] = f8b[1];
          buf[pos + 7] = f8b[0];
        }
        exports3.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
        exports3.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
        function readDouble_f64_cpy(buf, pos) {
          f8b[0] = buf[pos];
          f8b[1] = buf[pos + 1];
          f8b[2] = buf[pos + 2];
          f8b[3] = buf[pos + 3];
          f8b[4] = buf[pos + 4];
          f8b[5] = buf[pos + 5];
          f8b[6] = buf[pos + 6];
          f8b[7] = buf[pos + 7];
          return f64[0];
        }
        function readDouble_f64_rev(buf, pos) {
          f8b[7] = buf[pos];
          f8b[6] = buf[pos + 1];
          f8b[5] = buf[pos + 2];
          f8b[4] = buf[pos + 3];
          f8b[3] = buf[pos + 4];
          f8b[2] = buf[pos + 5];
          f8b[1] = buf[pos + 6];
          f8b[0] = buf[pos + 7];
          return f64[0];
        }
        exports3.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
        exports3.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
      })();
      else (function() {
        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
          var sign = val < 0 ? 1 : 0;
          if (sign)
            val = -val;
          if (val === 0) {
            writeUint(0, buf, pos + off0);
            writeUint(1 / val > 0 ? (
              /* positive */
              0
            ) : (
              /* negative 0 */
              2147483648
            ), buf, pos + off1);
          } else if (isNaN(val)) {
            writeUint(0, buf, pos + off0);
            writeUint(2146959360, buf, pos + off1);
          } else if (val > 17976931348623157e292) {
            writeUint(0, buf, pos + off0);
            writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
          } else {
            var mantissa;
            if (val < 22250738585072014e-324) {
              mantissa = val / 5e-324;
              writeUint(mantissa >>> 0, buf, pos + off0);
              writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
            } else {
              var exponent = Math.floor(Math.log(val) / Math.LN2);
              if (exponent === 1024)
                exponent = 1023;
              mantissa = val * Math.pow(2, -exponent);
              writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
              writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
            }
          }
        }
        exports3.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
        exports3.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
        function readDouble_ieee754(readUint, off0, off1, buf, pos) {
          var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1);
          var sign = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
          return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
        }
        exports3.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
        exports3.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
      })();
      return exports3;
    }
    function writeUintLE(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    function writeUintBE(val, buf, pos) {
      buf[pos] = val >>> 24;
      buf[pos + 1] = val >>> 16 & 255;
      buf[pos + 2] = val >>> 8 & 255;
      buf[pos + 3] = val & 255;
    }
    function readUintLE(buf, pos) {
      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;
    }
    function readUintBE(buf, pos) {
      return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;
    }
  }
});

// node_modules/@protobufjs/inquire/index.js
var require_inquire = __commonJS({
  "node_modules/@protobufjs/inquire/index.js"(exports, module) {
    "use strict";
    module.exports = inquire;
    function inquire(moduleName) {
      try {
        var mod = eval("quire".replace(/^/, "re"))(moduleName);
        if (mod && (mod.length || Object.keys(mod).length))
          return mod;
      } catch (e) {
      }
      return null;
    }
  }
});

// node_modules/@protobufjs/utf8/index.js
var require_utf8 = __commonJS({
  "node_modules/@protobufjs/utf8/index.js"(exports2) {
    "use strict";
    var utf8 = exports2;
    utf8.length = function utf8_length(string) {
      var len = 0, c = 0;
      for (var i = 0; i < string.length; ++i) {
        c = string.charCodeAt(i);
        if (c < 128)
          len += 1;
        else if (c < 2048)
          len += 2;
        else if ((c & 64512) === 55296 && (string.charCodeAt(i + 1) & 64512) === 56320) {
          ++i;
          len += 4;
        } else
          len += 3;
      }
      return len;
    };
    utf8.read = function utf8_read(buffer, start, end) {
      var len = end - start;
      if (len < 1)
        return "";
      var parts = null, chunk = [], i = 0, t;
      while (start < end) {
        t = buffer[start++];
        if (t < 128)
          chunk[i++] = t;
        else if (t > 191 && t < 224)
          chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
          t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 65536;
          chunk[i++] = 55296 + (t >> 10);
          chunk[i++] = 56320 + (t & 1023);
        } else
          chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i = 0;
        }
      }
      if (parts) {
        if (i)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i));
    };
    utf8.write = function utf8_write(string, buffer, offset) {
      var start = offset, c1, c2;
      for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
          buffer[offset++] = c1;
        } else if (c1 < 2048) {
          buffer[offset++] = c1 >> 6 | 192;
          buffer[offset++] = c1 & 63 | 128;
        } else if ((c1 & 64512) === 55296 && ((c2 = string.charCodeAt(i + 1)) & 64512) === 56320) {
          c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
          ++i;
          buffer[offset++] = c1 >> 18 | 240;
          buffer[offset++] = c1 >> 12 & 63 | 128;
          buffer[offset++] = c1 >> 6 & 63 | 128;
          buffer[offset++] = c1 & 63 | 128;
        } else {
          buffer[offset++] = c1 >> 12 | 224;
          buffer[offset++] = c1 >> 6 & 63 | 128;
          buffer[offset++] = c1 & 63 | 128;
        }
      }
      return offset - start;
    };
  }
});

// node_modules/@protobufjs/pool/index.js
var require_pool = __commonJS({
  "node_modules/@protobufjs/pool/index.js"(exports2, module2) {
    "use strict";
    module2.exports = pool;
    function pool(alloc, slice, size) {
      var SIZE = size || 8192;
      var MAX = SIZE >>> 1;
      var slab = null;
      var offset = SIZE;
      return function pool_alloc(size2) {
        if (size2 < 1 || size2 > MAX)
          return alloc(size2);
        if (offset + size2 > SIZE) {
          slab = alloc(SIZE);
          offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size2);
        if (offset & 7)
          offset = (offset | 7) + 1;
        return buf;
      };
    }
  }
});

// node_modules/protobufjs/src/util/longbits.js
var require_longbits = __commonJS({
  "node_modules/protobufjs/src/util/longbits.js"(exports2, module2) {
    "use strict";
    module2.exports = LongBits;
    var util = require_minimal();
    function LongBits(lo, hi) {
      this.lo = lo >>> 0;
      this.hi = hi >>> 0;
    }
    var zero = LongBits.zero = new LongBits(0, 0);
    zero.toNumber = function() {
      return 0;
    };
    zero.zzEncode = zero.zzDecode = function() {
      return this;
    };
    zero.length = function() {
      return 1;
    };
    var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
    LongBits.fromNumber = function fromNumber(value) {
      if (value === 0)
        return zero;
      var sign = value < 0;
      if (sign)
        value = -value;
      var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
      if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
          lo = 0;
          if (++hi > 4294967295)
            hi = 0;
        }
      }
      return new LongBits(lo, hi);
    };
    LongBits.from = function from(value) {
      if (typeof value === "number")
        return LongBits.fromNumber(value);
      if (util.isString(value)) {
        if (util.Long)
          value = util.Long.fromString(value);
        else
          return LongBits.fromNumber(parseInt(value, 10));
      }
      return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
    };
    LongBits.prototype.toNumber = function toNumber(unsigned) {
      if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
        if (!lo)
          hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
      }
      return this.lo + this.hi * 4294967296;
    };
    LongBits.prototype.toLong = function toLong(unsigned) {
      return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
    };
    var charCodeAt = String.prototype.charCodeAt;
    LongBits.fromHash = function fromHash(hash) {
      if (hash === zeroHash)
        return zero;
      return new LongBits(
        (charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0,
        (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0
      );
    };
    LongBits.prototype.toHash = function toHash() {
      return String.fromCharCode(
        this.lo & 255,
        this.lo >>> 8 & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24,
        this.hi & 255,
        this.hi >>> 8 & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
      );
    };
    LongBits.prototype.zzEncode = function zzEncode() {
      var mask = this.hi >> 31;
      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
      this.lo = (this.lo << 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.zzDecode = function zzDecode() {
      var mask = -(this.lo & 1);
      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
      this.hi = (this.hi >>> 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.length = function length() {
      var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
    };
  }
});

// node_modules/protobufjs/src/util/minimal.js
var require_minimal = __commonJS({
  "node_modules/protobufjs/src/util/minimal.js"(exports2) {
    "use strict";
    var util = exports2;
    util.asPromise = require_aspromise();
    util.base64 = require_base64();
    util.EventEmitter = require_eventemitter();
    util.float = require_float();
    util.inquire = require_inquire();
    util.utf8 = require_utf8();
    util.pool = require_pool();
    util.LongBits = require_longbits();
    util.isNode = Boolean(typeof globalThis !== "undefined" && globalThis && globalThis.process && globalThis.process.versions && globalThis.process.versions.node);
    util.global = util.isNode && globalThis || typeof window !== "undefined" && window || typeof self !== "undefined" && self || exports2;
    util.emptyArray = Object.freeze ? Object.freeze([]) : (
      /* istanbul ignore next */
      []
    );
    util.emptyObject = Object.freeze ? Object.freeze({}) : (
      /* istanbul ignore next */
      {}
    );
    util.isInteger = Number.isInteger || /* istanbul ignore next */
    function isInteger(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    };
    util.isString = function isString(value) {
      return typeof value === "string" || value instanceof String;
    };
    util.isObject = function isObject2(value) {
      return value && typeof value === "object";
    };
    util.isset = /**
     * Checks if a property on a message is considered to be present.
     * @param {Object} obj Plain object or message instance
     * @param {string} prop Property name
     * @returns {boolean} `true` if considered to be present, otherwise `false`
     */
    util.isSet = function isSet(obj, prop) {
      var value = obj[prop];
      if (value != null && obj.hasOwnProperty(prop))
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
      return false;
    };
    util.Buffer = function() {
      try {
        var Buffer2 = util.inquire("buffer").Buffer;
        return Buffer2.prototype.utf8Write ? Buffer2 : (
          /* istanbul ignore next */
          null
        );
      } catch (e) {
        return null;
      }
    }();
    util._Buffer_from = null;
    util._Buffer_allocUnsafe = null;
    util.newBuffer = function newBuffer(sizeOrArray) {
      return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
    };
    util.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    util.Long = /* istanbul ignore next */
    util.global.dcodeIO && /* istanbul ignore next */
    util.global.dcodeIO.Long || /* istanbul ignore next */
    util.global.Long || util.inquire("long");
    util.key2Re = /^true|false|0|1$/;
    util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util.longToHash = function longToHash(value) {
      return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
    };
    util.longFromHash = function longFromHash(hash, unsigned) {
      var bits = util.LongBits.fromHash(hash);
      if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
      return bits.toNumber(Boolean(unsigned));
    };
    function merge(dst, src, ifNotSet) {
      for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === void 0 || !ifNotSet)
          dst[keys[i]] = src[keys[i]];
      return dst;
    }
    util.merge = merge;
    util.lcFirst = function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    };
    function newError(name) {
      function CustomError(message, properties) {
        if (!(this instanceof CustomError))
          return new CustomError(message, properties);
        Object.defineProperty(this, "message", { get: function() {
          return message;
        } });
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, CustomError);
        else
          Object.defineProperty(this, "stack", { value: new Error().stack || "" });
        if (properties)
          merge(this, properties);
      }
      CustomError.prototype = Object.create(Error.prototype, {
        constructor: {
          value: CustomError,
          writable: true,
          enumerable: false,
          configurable: true
        },
        name: {
          get: function get2() {
            return name;
          },
          set: void 0,
          enumerable: false,
          // configurable: false would accurately preserve the behavior of
          // the original, but I'm guessing that was not intentional.
          // For an actual error subclass, this property would
          // be configurable.
          configurable: true
        },
        toString: {
          value: function value() {
            return this.name + ": " + this.message;
          },
          writable: true,
          enumerable: false,
          configurable: true
        }
      });
      return CustomError;
    }
    util.newError = newError;
    util.ProtocolError = newError("ProtocolError");
    util.oneOfGetter = function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;
      return function() {
        for (var keys = Object.keys(this), i2 = keys.length - 1; i2 > -1; --i2)
          if (fieldMap[keys[i2]] === 1 && this[keys[i2]] !== void 0 && this[keys[i2]] !== null)
            return keys[i2];
      };
    };
    util.oneOfSetter = function setOneOf(fieldNames) {
      return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
          if (fieldNames[i] !== name)
            delete this[fieldNames[i]];
      };
    };
    util.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
    };
    util._configure = function() {
      var Buffer2 = util.Buffer;
      if (!Buffer2) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
      }
      util._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || /* istanbul ignore next */
      function Buffer_from(value, encoding) {
        return new Buffer2(value, encoding);
      };
      util._Buffer_allocUnsafe = Buffer2.allocUnsafe || /* istanbul ignore next */
      function Buffer_allocUnsafe(size) {
        return new Buffer2(size);
      };
    };
  }
});

// node_modules/protobufjs/src/writer.js
var require_writer = __commonJS({
  "node_modules/protobufjs/src/writer.js"(exports2, module2) {
    "use strict";
    module2.exports = Writer;
    var util = require_minimal();
    var BufferWriter2;
    var LongBits = util.LongBits;
    var base64 = util.base64;
    var utf8 = util.utf8;
    function Op(fn, len, val) {
      this.fn = fn;
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    function noop() {
    }
    function State(writer) {
      this.head = writer.head;
      this.tail = writer.tail;
      this.len = writer.len;
      this.next = writer.states;
    }
    function Writer() {
      this.len = 0;
      this.head = new Op(noop, 0, 0);
      this.tail = this.head;
      this.states = null;
    }
    var create = function create2() {
      return util.Buffer ? function create_buffer_setup() {
        return (Writer.create = function create_buffer() {
          return new BufferWriter2();
        })();
      } : function create_array() {
        return new Writer();
      };
    };
    Writer.create = create();
    Writer.alloc = function alloc(size) {
      return new util.Array(size);
    };
    if (util.Array !== Array)
      Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);
    Writer.prototype._push = function push(fn, len, val) {
      this.tail = this.tail.next = new Op(fn, len, val);
      this.len += len;
      return this;
    };
    function writeByte(val, buf, pos) {
      buf[pos] = val & 255;
    }
    function writeVarint32(val, buf, pos) {
      while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
      }
      buf[pos] = val;
    }
    function VarintOp(len, val) {
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    VarintOp.prototype = Object.create(Op.prototype);
    VarintOp.prototype.fn = writeVarint32;
    Writer.prototype.uint32 = function write_uint32(value) {
      this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5,
        value
      )).len;
      return this;
    };
    Writer.prototype.int32 = function write_int32(value) {
      return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
    };
    Writer.prototype.sint32 = function write_sint32(value) {
      return this.uint32((value << 1 ^ value >> 31) >>> 0);
    };
    function writeVarint64(val, buf, pos) {
      while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
      }
      while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
      }
      buf[pos++] = val.lo;
    }
    Writer.prototype.uint64 = function write_uint64(value) {
      var bits = LongBits.from(value);
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.int64 = Writer.prototype.uint64;
    Writer.prototype.sint64 = function write_sint64(value) {
      var bits = LongBits.from(value).zzEncode();
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.bool = function write_bool(value) {
      return this._push(writeByte, 1, value ? 1 : 0);
    };
    function writeFixed32(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    Writer.prototype.fixed32 = function write_fixed32(value) {
      return this._push(writeFixed32, 4, value >>> 0);
    };
    Writer.prototype.sfixed32 = Writer.prototype.fixed32;
    Writer.prototype.fixed64 = function write_fixed64(value) {
      var bits = LongBits.from(value);
      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
    };
    Writer.prototype.sfixed64 = Writer.prototype.fixed64;
    Writer.prototype.float = function write_float(value) {
      return this._push(util.float.writeFloatLE, 4, value);
    };
    Writer.prototype.double = function write_double(value) {
      return this._push(util.float.writeDoubleLE, 8, value);
    };
    var writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {
      buf.set(val, pos);
    } : function writeBytes_for(val, buf, pos) {
      for (var i = 0; i < val.length; ++i)
        buf[pos + i] = val[i];
    };
    Writer.prototype.bytes = function write_bytes(value) {
      var len = value.length >>> 0;
      if (!len)
        return this._push(writeByte, 1, 0);
      if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
      }
      return this.uint32(len)._push(writeBytes, len, value);
    };
    Writer.prototype.string = function write_string(value) {
      var len = utf8.length(value);
      return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
    };
    Writer.prototype.fork = function fork() {
      this.states = new State(this);
      this.head = this.tail = new Op(noop, 0, 0);
      this.len = 0;
      return this;
    };
    Writer.prototype.reset = function reset() {
      if (this.states) {
        this.head = this.states.head;
        this.tail = this.states.tail;
        this.len = this.states.len;
        this.states = this.states.next;
      } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len = 0;
      }
      return this;
    };
    Writer.prototype.ldelim = function ldelim() {
      var head = this.head, tail = this.tail, len = this.len;
      this.reset().uint32(len);
      if (len) {
        this.tail.next = head.next;
        this.tail = tail;
        this.len += len;
      }
      return this;
    };
    Writer.prototype.finish = function finish() {
      var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;
      while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
      }
      return buf;
    };
    Writer._configure = function(BufferWriter_) {
      BufferWriter2 = BufferWriter_;
      Writer.create = create();
      BufferWriter2._configure();
    };
  }
});

// node_modules/protobufjs/src/writer_buffer.js
var require_writer_buffer = __commonJS({
  "node_modules/protobufjs/src/writer_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferWriter2;
    var Writer = require_writer();
    (BufferWriter2.prototype = Object.create(Writer.prototype)).constructor = BufferWriter2;
    var util = require_minimal();
    function BufferWriter2() {
      Writer.call(this);
    }
    BufferWriter2._configure = function() {
      BufferWriter2.alloc = util._Buffer_allocUnsafe;
      BufferWriter2.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf, pos) {
        buf.set(val, pos);
      } : function writeBytesBuffer_copy(val, buf, pos) {
        if (val.copy)
          val.copy(buf, pos, 0, val.length);
        else for (var i = 0; i < val.length; )
          buf[pos++] = val[i++];
      };
    };
    BufferWriter2.prototype.bytes = function write_bytes_buffer(value) {
      if (util.isString(value))
        value = util._Buffer_from(value, "base64");
      var len = value.length >>> 0;
      this.uint32(len);
      if (len)
        this._push(BufferWriter2.writeBytesBuffer, len, value);
      return this;
    };
    function writeStringBuffer(val, buf, pos) {
      if (val.length < 40)
        util.utf8.write(val, buf, pos);
      else if (buf.utf8Write)
        buf.utf8Write(val, pos);
      else
        buf.write(val, pos);
    }
    BufferWriter2.prototype.string = function write_string_buffer(value) {
      var len = util.Buffer.byteLength(value);
      this.uint32(len);
      if (len)
        this._push(writeStringBuffer, len, value);
      return this;
    };
    BufferWriter2._configure();
  }
});

// node_modules/protobufjs/src/reader.js
var require_reader = __commonJS({
  "node_modules/protobufjs/src/reader.js"(exports2, module2) {
    "use strict";
    module2.exports = Reader;
    var util = require_minimal();
    var BufferReader2;
    var LongBits = util.LongBits;
    var utf8 = util.utf8;
    function indexOutOfRange(reader, writeLength) {
      return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
    }
    function Reader(buffer) {
      this.buf = buffer;
      this.pos = 0;
      this.len = buffer.length;
    }
    var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer) {
      if (buffer instanceof Uint8Array || Array.isArray(buffer))
        return new Reader(buffer);
      throw Error("illegal buffer");
    } : function create_array2(buffer) {
      if (Array.isArray(buffer))
        return new Reader(buffer);
      throw Error("illegal buffer");
    };
    var create = function create2() {
      return util.Buffer ? function create_buffer_setup(buffer) {
        return (Reader.create = function create_buffer(buffer2) {
          return util.Buffer.isBuffer(buffer2) ? new BufferReader2(buffer2) : create_array(buffer2);
        })(buffer);
      } : create_array;
    };
    Reader.create = create();
    Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */
    util.Array.prototype.slice;
    Reader.prototype.uint32 = /* @__PURE__ */ function read_uint32_setup() {
      var value = 4294967295;
      return function read_uint32() {
        value = (this.buf[this.pos] & 127) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        if ((this.pos += 5) > this.len) {
          this.pos = this.len;
          throw indexOutOfRange(this, 10);
        }
        return value;
      };
    }();
    Reader.prototype.int32 = function read_int32() {
      return this.uint32() | 0;
    };
    Reader.prototype.sint32 = function read_sint32() {
      var value = this.uint32();
      return value >>> 1 ^ -(value & 1) | 0;
    };
    function readLongVarint() {
      var bits = new LongBits(0, 0);
      var i = 0;
      if (this.len - this.pos > 4) {
        for (; i < 4; ++i) {
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
        i = 0;
      } else {
        for (; i < 3; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
      }
      if (this.len - this.pos > 4) {
        for (; i < 5; ++i) {
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      } else {
        for (; i < 5; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      }
      throw Error("invalid varint encoding");
    }
    Reader.prototype.bool = function read_bool() {
      return this.uint32() !== 0;
    };
    function readFixed32_end(buf, end) {
      return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
    }
    Reader.prototype.fixed32 = function read_fixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4);
    };
    Reader.prototype.sfixed32 = function read_sfixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4) | 0;
    };
    function readFixed64() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);
      return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
    }
    Reader.prototype.float = function read_float() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readFloatLE(this.buf, this.pos);
      this.pos += 4;
      return value;
    };
    Reader.prototype.double = function read_double() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readDoubleLE(this.buf, this.pos);
      this.pos += 8;
      return value;
    };
    Reader.prototype.bytes = function read_bytes() {
      var length = this.uint32(), start = this.pos, end = this.pos + length;
      if (end > this.len)
        throw indexOutOfRange(this, length);
      this.pos += length;
      if (Array.isArray(this.buf))
        return this.buf.slice(start, end);
      if (start === end) {
        var nativeBuffer = util.Buffer;
        return nativeBuffer ? nativeBuffer.alloc(0) : new this.buf.constructor(0);
      }
      return this._slice.call(this.buf, start, end);
    };
    Reader.prototype.string = function read_string() {
      var bytes = this.bytes();
      return utf8.read(bytes, 0, bytes.length);
    };
    Reader.prototype.skip = function skip(length) {
      if (typeof length === "number") {
        if (this.pos + length > this.len)
          throw indexOutOfRange(this, length);
        this.pos += length;
      } else {
        do {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
      }
      return this;
    };
    Reader.prototype.skipType = function(wireType) {
      switch (wireType) {
        case 0:
          this.skip();
          break;
        case 1:
          this.skip(8);
          break;
        case 2:
          this.skip(this.uint32());
          break;
        case 3:
          while ((wireType = this.uint32() & 7) !== 4) {
            this.skipType(wireType);
          }
          break;
        case 5:
          this.skip(4);
          break;
        /* istanbul ignore next */
        default:
          throw Error("invalid wire type " + wireType + " at offset " + this.pos);
      }
      return this;
    };
    Reader._configure = function(BufferReader_) {
      BufferReader2 = BufferReader_;
      Reader.create = create();
      BufferReader2._configure();
      var fn = util.Long ? "toLong" : (
        /* istanbul ignore next */
        "toNumber"
      );
      util.merge(Reader.prototype, {
        int64: function read_int64() {
          return readLongVarint.call(this)[fn](false);
        },
        uint64: function read_uint64() {
          return readLongVarint.call(this)[fn](true);
        },
        sint64: function read_sint64() {
          return readLongVarint.call(this).zzDecode()[fn](false);
        },
        fixed64: function read_fixed64() {
          return readFixed64.call(this)[fn](true);
        },
        sfixed64: function read_sfixed64() {
          return readFixed64.call(this)[fn](false);
        }
      });
    };
  }
});

// node_modules/protobufjs/src/reader_buffer.js
var require_reader_buffer = __commonJS({
  "node_modules/protobufjs/src/reader_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferReader2;
    var Reader = require_reader();
    (BufferReader2.prototype = Object.create(Reader.prototype)).constructor = BufferReader2;
    var util = require_minimal();
    function BufferReader2(buffer) {
      Reader.call(this, buffer);
    }
    BufferReader2._configure = function() {
      if (util.Buffer)
        BufferReader2.prototype._slice = util.Buffer.prototype.slice;
    };
    BufferReader2.prototype.string = function read_string_buffer() {
      var len = this.uint32();
      return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
    };
    BufferReader2._configure();
  }
});

// node_modules/protobufjs/src/rpc/service.js
var require_service = __commonJS({
  "node_modules/protobufjs/src/rpc/service.js"(exports2, module2) {
    "use strict";
    module2.exports = Service;
    var util = require_minimal();
    (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
    function Service(rpcImpl, requestDelimited, responseDelimited) {
      if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");
      util.EventEmitter.call(this);
      this.rpcImpl = rpcImpl;
      this.requestDelimited = Boolean(requestDelimited);
      this.responseDelimited = Boolean(responseDelimited);
    }
    Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
      if (!request)
        throw TypeError("request must be specified");
      var self2 = this;
      if (!callback)
        return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);
      if (!self2.rpcImpl) {
        setTimeout(function() {
          callback(Error("already ended"));
        }, 0);
        return void 0;
      }
      try {
        return self2.rpcImpl(
          method,
          requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
          function rpcCallback(err, response) {
            if (err) {
              self2.emit("error", err, method);
              return callback(err);
            }
            if (response === null) {
              self2.end(
                /* endedByRPC */
                true
              );
              return void 0;
            }
            if (!(response instanceof responseCtor)) {
              try {
                response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
              } catch (err2) {
                self2.emit("error", err2, method);
                return callback(err2);
              }
            }
            self2.emit("data", response, method);
            return callback(null, response);
          }
        );
      } catch (err) {
        self2.emit("error", err, method);
        setTimeout(function() {
          callback(err);
        }, 0);
        return void 0;
      }
    };
    Service.prototype.end = function end(endedByRPC) {
      if (this.rpcImpl) {
        if (!endedByRPC)
          this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
      }
      return this;
    };
  }
});

// node_modules/protobufjs/src/rpc.js
var require_rpc = __commonJS({
  "node_modules/protobufjs/src/rpc.js"(exports2) {
    "use strict";
    var rpc = exports2;
    rpc.Service = require_service();
  }
});

// node_modules/protobufjs/src/roots.js
var require_roots = __commonJS({
  "node_modules/protobufjs/src/roots.js"(exports2, module2) {
    "use strict";
    module2.exports = {};
  }
});

// node_modules/protobufjs/src/index-minimal.js
var require_index_minimal = __commonJS({
  "node_modules/protobufjs/src/index-minimal.js"(exports2) {
    "use strict";
    var protobuf = exports2;
    protobuf.build = "minimal";
    protobuf.Writer = require_writer();
    protobuf.BufferWriter = require_writer_buffer();
    protobuf.Reader = require_reader();
    protobuf.BufferReader = require_reader_buffer();
    protobuf.util = require_minimal();
    protobuf.rpc = require_rpc();
    protobuf.roots = require_roots();
    protobuf.configure = configure;
    function configure() {
      protobuf.util._configure();
      protobuf.Writer._configure(protobuf.BufferWriter);
      protobuf.Reader._configure(protobuf.BufferReader);
    }
    configure();
  }
});

// node_modules/@protobufjs/codegen/index.js
var require_codegen = __commonJS({
  "node_modules/@protobufjs/codegen/index.js"(exports2, module2) {
    "use strict";
    module2.exports = codegen;
    function codegen(functionParams, functionName) {
      if (typeof functionParams === "string") {
        functionName = functionParams;
        functionParams = void 0;
      }
      var body = [];
      function Codegen(formatStringOrScope) {
        if (typeof formatStringOrScope !== "string") {
          var source = toString();
          if (codegen.verbose)
            console.log("codegen: " + source);
          source = "return " + source;
          if (formatStringOrScope) {
            var scopeKeys = Object.keys(formatStringOrScope), scopeParams = new Array(scopeKeys.length + 1), scopeValues = new Array(scopeKeys.length), scopeOffset = 0;
            while (scopeOffset < scopeKeys.length) {
              scopeParams[scopeOffset] = scopeKeys[scopeOffset];
              scopeValues[scopeOffset] = formatStringOrScope[scopeKeys[scopeOffset++]];
            }
            scopeParams[scopeOffset] = source;
            return Function.apply(null, scopeParams).apply(null, scopeValues);
          }
          return Function(source)();
        }
        var formatParams = new Array(arguments.length - 1), formatOffset = 0;
        while (formatOffset < formatParams.length)
          formatParams[formatOffset] = arguments[++formatOffset];
        formatOffset = 0;
        formatStringOrScope = formatStringOrScope.replace(/%([%dfijs])/g, function replace($0, $1) {
          var value = formatParams[formatOffset++];
          switch ($1) {
            case "d":
            case "f":
              return String(Number(value));
            case "i":
              return String(Math.floor(value));
            case "j":
              return JSON.stringify(value);
            case "s":
              return String(value);
          }
          return "%";
        });
        if (formatOffset !== formatParams.length)
          throw Error("parameter count mismatch");
        body.push(formatStringOrScope);
        return Codegen;
      }
      function toString(functionNameOverride) {
        return "function " + (functionNameOverride || functionName || "") + "(" + (functionParams && functionParams.join(",") || "") + "){\n  " + body.join("\n  ") + "\n}";
      }
      Codegen.toString = toString;
      return Codegen;
    }
    codegen.verbose = false;
  }
});

// node_modules/@protobufjs/fetch/index.js
var require_fetch = __commonJS({
  "node_modules/@protobufjs/fetch/index.js"(exports2, module2) {
    "use strict";
    module2.exports = fetch;
    var asPromise = require_aspromise();
    var inquire2 = require_inquire();
    var fs = inquire2("fs");
    function fetch(filename, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      } else if (!options)
        options = {};
      if (!callback)
        return asPromise(fetch, this, filename, options);
      if (!options.xhr && fs && fs.readFile)
        return fs.readFile(filename, function fetchReadFileCallback(err, contents) {
          return err && typeof XMLHttpRequest !== "undefined" ? fetch.xhr(filename, options, callback) : err ? callback(err) : callback(null, options.binary ? contents : contents.toString("utf8"));
        });
      return fetch.xhr(filename, options, callback);
    }
    fetch.xhr = function fetch_xhr(filename, options, callback) {
      var xhr = new XMLHttpRequest();
      xhr.onreadystatechange = function fetchOnReadyStateChange() {
        if (xhr.readyState !== 4)
          return void 0;
        if (xhr.status !== 0 && xhr.status !== 200)
          return callback(Error("status " + xhr.status));
        if (options.binary) {
          var buffer = xhr.response;
          if (!buffer) {
            buffer = [];
            for (var i = 0; i < xhr.responseText.length; ++i)
              buffer.push(xhr.responseText.charCodeAt(i) & 255);
          }
          return callback(null, typeof Uint8Array !== "undefined" ? new Uint8Array(buffer) : buffer);
        }
        return callback(null, xhr.responseText);
      };
      if (options.binary) {
        if ("overrideMimeType" in xhr)
          xhr.overrideMimeType("text/plain; charset=x-user-defined");
        xhr.responseType = "arraybuffer";
      }
      xhr.open("GET", filename);
      xhr.send();
    };
  }
});

// node_modules/@protobufjs/path/index.js
var require_path = __commonJS({
  "node_modules/@protobufjs/path/index.js"(exports2) {
    "use strict";
    var path = exports2;
    var isAbsolute = (
      /**
       * Tests if the specified path is absolute.
       * @param {string} path Path to test
       * @returns {boolean} `true` if path is absolute
       */
      path.isAbsolute = function isAbsolute2(path2) {
        return /^(?:\/|\w+:)/.test(path2);
      }
    );
    var normalize = (
      /**
       * Normalizes the specified path.
       * @param {string} path Path to normalize
       * @returns {string} Normalized path
       */
      path.normalize = function normalize2(path2) {
        path2 = path2.replace(/\\/g, "/").replace(/\/{2,}/g, "/");
        var parts = path2.split("/"), absolute = isAbsolute(path2), prefix = "";
        if (absolute)
          prefix = parts.shift() + "/";
        for (var i = 0; i < parts.length; ) {
          if (parts[i] === "..") {
            if (i > 0 && parts[i - 1] !== "..")
              parts.splice(--i, 2);
            else if (absolute)
              parts.splice(i, 1);
            else
              ++i;
          } else if (parts[i] === ".")
            parts.splice(i, 1);
          else
            ++i;
        }
        return prefix + parts.join("/");
      }
    );
    path.resolve = function resolve(originPath, includePath, alreadyNormalized) {
      if (!alreadyNormalized)
        includePath = normalize(includePath);
      if (isAbsolute(includePath))
        return includePath;
      if (!alreadyNormalized)
        originPath = normalize(originPath);
      return (originPath = originPath.replace(/(?:\/|^)[^/]+$/, "")).length ? normalize(originPath + "/" + includePath) : includePath;
    };
  }
});

// node_modules/protobufjs/src/types.js
var require_types2 = __commonJS({
  "node_modules/protobufjs/src/types.js"(exports2) {
    "use strict";
    var types = exports2;
    var util = require_util3();
    var s = [
      "double",
      // 0
      "float",
      // 1
      "int32",
      // 2
      "uint32",
      // 3
      "sint32",
      // 4
      "fixed32",
      // 5
      "sfixed32",
      // 6
      "int64",
      // 7
      "uint64",
      // 8
      "sint64",
      // 9
      "fixed64",
      // 10
      "sfixed64",
      // 11
      "bool",
      // 12
      "string",
      // 13
      "bytes"
      // 14
    ];
    function bake(values, offset) {
      var i = 0, o = {};
      offset |= 0;
      while (i < values.length) o[s[i + offset]] = values[i++];
      return o;
    }
    types.basic = bake([
      /* double   */
      1,
      /* float    */
      5,
      /* int32    */
      0,
      /* uint32   */
      0,
      /* sint32   */
      0,
      /* fixed32  */
      5,
      /* sfixed32 */
      5,
      /* int64    */
      0,
      /* uint64   */
      0,
      /* sint64   */
      0,
      /* fixed64  */
      1,
      /* sfixed64 */
      1,
      /* bool     */
      0,
      /* string   */
      2,
      /* bytes    */
      2
    ]);
    types.defaults = bake([
      /* double   */
      0,
      /* float    */
      0,
      /* int32    */
      0,
      /* uint32   */
      0,
      /* sint32   */
      0,
      /* fixed32  */
      0,
      /* sfixed32 */
      0,
      /* int64    */
      0,
      /* uint64   */
      0,
      /* sint64   */
      0,
      /* fixed64  */
      0,
      /* sfixed64 */
      0,
      /* bool     */
      false,
      /* string   */
      "",
      /* bytes    */
      util.emptyArray,
      /* message  */
      null
    ]);
    types.long = bake([
      /* int64    */
      0,
      /* uint64   */
      0,
      /* sint64   */
      0,
      /* fixed64  */
      1,
      /* sfixed64 */
      1
    ], 7);
    types.mapKey = bake([
      /* int32    */
      0,
      /* uint32   */
      0,
      /* sint32   */
      0,
      /* fixed32  */
      5,
      /* sfixed32 */
      5,
      /* int64    */
      0,
      /* uint64   */
      0,
      /* sint64   */
      0,
      /* fixed64  */
      1,
      /* sfixed64 */
      1,
      /* bool     */
      0,
      /* string   */
      2
    ], 2);
    types.packed = bake([
      /* double   */
      1,
      /* float    */
      5,
      /* int32    */
      0,
      /* uint32   */
      0,
      /* sint32   */
      0,
      /* fixed32  */
      5,
      /* sfixed32 */
      5,
      /* int64    */
      0,
      /* uint64   */
      0,
      /* sint64   */
      0,
      /* fixed64  */
      1,
      /* sfixed64 */
      1,
      /* bool     */
      0
    ]);
  }
});

// node_modules/protobufjs/src/field.js
var require_field = __commonJS({
  "node_modules/protobufjs/src/field.js"(exports2, module2) {
    "use strict";
    module2.exports = Field2;
    var ReflectionObject = require_object3();
    ((Field2.prototype = Object.create(ReflectionObject.prototype)).constructor = Field2).className = "Field";
    var Enum = require_enum3();
    var types = require_types2();
    var util = require_util3();
    var Type;
    var ruleRe = /^required|optional|repeated$/;
    Field2.fromJSON = function fromJSON(name, json) {
      return new Field2(name, json.id, json.type, json.rule, json.extend, json.options, json.comment);
    };
    function Field2(name, id2, type, rule, extend, options, comment) {
      if (util.isObject(rule)) {
        comment = extend;
        options = rule;
        rule = extend = void 0;
      } else if (util.isObject(extend)) {
        comment = options;
        options = extend;
        extend = void 0;
      }
      ReflectionObject.call(this, name, options);
      if (!util.isInteger(id2) || id2 < 0)
        throw TypeError("id must be a non-negative integer");
      if (!util.isString(type))
        throw TypeError("type must be a string");
      if (rule !== void 0 && !ruleRe.test(rule = rule.toString().toLowerCase()))
        throw TypeError("rule must be a string rule");
      if (extend !== void 0 && !util.isString(extend))
        throw TypeError("extend must be a string");
      if (rule === "proto3_optional") {
        rule = "optional";
      }
      this.rule = rule && rule !== "optional" ? rule : void 0;
      this.type = type;
      this.id = id2;
      this.extend = extend || void 0;
      this.required = rule === "required";
      this.optional = !this.required;
      this.repeated = rule === "repeated";
      this.map = false;
      this.message = null;
      this.partOf = null;
      this.typeDefault = null;
      this.defaultValue = null;
      this.long = util.Long ? types.long[type] !== void 0 : (
        /* istanbul ignore next */
        false
      );
      this.bytes = type === "bytes";
      this.resolvedType = null;
      this.extensionField = null;
      this.declaringField = null;
      this._packed = null;
      this.comment = comment;
    }
    Object.defineProperty(Field2.prototype, "packed", {
      get: function() {
        if (this._packed === null)
          this._packed = this.getOption("packed") !== false;
        return this._packed;
      }
    });
    Field2.prototype.setOption = function setOption(name, value, ifNotSet) {
      if (name === "packed")
        this._packed = null;
      return ReflectionObject.prototype.setOption.call(this, name, value, ifNotSet);
    };
    Field2.prototype.toJSON = function toJSON(toJSONOptions) {
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util.toObject([
        "rule",
        this.rule !== "optional" && this.rule || void 0,
        "type",
        this.type,
        "id",
        this.id,
        "extend",
        this.extend,
        "options",
        this.options,
        "comment",
        keepComments ? this.comment : void 0
      ]);
    };
    Field2.prototype.resolve = function resolve() {
      if (this.resolved)
        return this;
      if ((this.typeDefault = types.defaults[this.type]) === void 0) {
        this.resolvedType = (this.declaringField ? this.declaringField.parent : this.parent).lookupTypeOrEnum(this.type);
        if (this.resolvedType instanceof Type)
          this.typeDefault = null;
        else
          this.typeDefault = this.resolvedType.values[Object.keys(this.resolvedType.values)[0]];
      } else if (this.options && this.options.proto3_optional) {
        this.typeDefault = null;
      }
      if (this.options && this.options["default"] != null) {
        this.typeDefault = this.options["default"];
        if (this.resolvedType instanceof Enum && typeof this.typeDefault === "string")
          this.typeDefault = this.resolvedType.values[this.typeDefault];
      }
      if (this.options) {
        if (this.options.packed === true || this.options.packed !== void 0 && this.resolvedType && !(this.resolvedType instanceof Enum))
          delete this.options.packed;
        if (!Object.keys(this.options).length)
          this.options = void 0;
      }
      if (this.long) {
        this.typeDefault = util.Long.fromNumber(this.typeDefault, this.type.charAt(0) === "u");
        if (Object.freeze)
          Object.freeze(this.typeDefault);
      } else if (this.bytes && typeof this.typeDefault === "string") {
        var buf;
        if (util.base64.test(this.typeDefault))
          util.base64.decode(this.typeDefault, buf = util.newBuffer(util.base64.length(this.typeDefault)), 0);
        else
          util.utf8.write(this.typeDefault, buf = util.newBuffer(util.utf8.length(this.typeDefault)), 0);
        this.typeDefault = buf;
      }
      if (this.map)
        this.defaultValue = util.emptyObject;
      else if (this.repeated)
        this.defaultValue = util.emptyArray;
      else
        this.defaultValue = this.typeDefault;
      if (this.parent instanceof Type)
        this.parent.ctor.prototype[this.name] = this.defaultValue;
      return ReflectionObject.prototype.resolve.call(this);
    };
    Field2.d = function decorateField(fieldId, fieldType, fieldRule, defaultValue) {
      if (typeof fieldType === "function")
        fieldType = util.decorateType(fieldType).name;
      else if (fieldType && typeof fieldType === "object")
        fieldType = util.decorateEnum(fieldType).name;
      return function fieldDecorator(prototype, fieldName) {
        util.decorateType(prototype.constructor).add(new Field2(fieldName, fieldId, fieldType, fieldRule, { "default": defaultValue }));
      };
    };
    Field2._configure = function configure(Type_) {
      Type = Type_;
    };
  }
});

// node_modules/protobufjs/src/oneof.js
var require_oneof = __commonJS({
  "node_modules/protobufjs/src/oneof.js"(exports2, module2) {
    "use strict";
    module2.exports = OneOf;
    var ReflectionObject = require_object3();
    ((OneOf.prototype = Object.create(ReflectionObject.prototype)).constructor = OneOf).className = "OneOf";
    var Field2 = require_field();
    var util = require_util3();
    function OneOf(name, fieldNames, options, comment) {
      if (!Array.isArray(fieldNames)) {
        options = fieldNames;
        fieldNames = void 0;
      }
      ReflectionObject.call(this, name, options);
      if (!(fieldNames === void 0 || Array.isArray(fieldNames)))
        throw TypeError("fieldNames must be an Array");
      this.oneof = fieldNames || [];
      this.fieldsArray = [];
      this.comment = comment;
    }
    OneOf.fromJSON = function fromJSON(name, json) {
      return new OneOf(name, json.oneof, json.options, json.comment);
    };
    OneOf.prototype.toJSON = function toJSON(toJSONOptions) {
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util.toObject([
        "options",
        this.options,
        "oneof",
        this.oneof,
        "comment",
        keepComments ? this.comment : void 0
      ]);
    };
    function addFieldsToParent(oneof) {
      if (oneof.parent) {
        for (var i = 0; i < oneof.fieldsArray.length; ++i)
          if (!oneof.fieldsArray[i].parent)
            oneof.parent.add(oneof.fieldsArray[i]);
      }
    }
    OneOf.prototype.add = function add(field) {
      if (!(field instanceof Field2))
        throw TypeError("field must be a Field");
      if (field.parent && field.parent !== this.parent)
        field.parent.remove(field);
      this.oneof.push(field.name);
      this.fieldsArray.push(field);
      field.partOf = this;
      addFieldsToParent(this);
      return this;
    };
    OneOf.prototype.remove = function remove(field) {
      if (!(field instanceof Field2))
        throw TypeError("field must be a Field");
      var index = this.fieldsArray.indexOf(field);
      if (index < 0)
        throw Error(field + " is not a member of " + this);
      this.fieldsArray.splice(index, 1);
      index = this.oneof.indexOf(field.name);
      if (index > -1)
        this.oneof.splice(index, 1);
      field.partOf = null;
      return this;
    };
    OneOf.prototype.onAdd = function onAdd(parent) {
      ReflectionObject.prototype.onAdd.call(this, parent);
      var self2 = this;
      for (var i = 0; i < this.oneof.length; ++i) {
        var field = parent.get(this.oneof[i]);
        if (field && !field.partOf) {
          field.partOf = self2;
          self2.fieldsArray.push(field);
        }
      }
      addFieldsToParent(this);
    };
    OneOf.prototype.onRemove = function onRemove(parent) {
      for (var i = 0, field; i < this.fieldsArray.length; ++i)
        if ((field = this.fieldsArray[i]).parent)
          field.parent.remove(field);
      ReflectionObject.prototype.onRemove.call(this, parent);
    };
    OneOf.d = function decorateOneOf() {
      var fieldNames = new Array(arguments.length), index = 0;
      while (index < arguments.length)
        fieldNames[index] = arguments[index++];
      return function oneOfDecorator(prototype, oneofName) {
        util.decorateType(prototype.constructor).add(new OneOf(oneofName, fieldNames));
        Object.defineProperty(prototype, oneofName, {
          get: util.oneOfGetter(fieldNames),
          set: util.oneOfSetter(fieldNames)
        });
      };
    };
  }
});

// node_modules/protobufjs/src/namespace.js
var require_namespace = __commonJS({
  "node_modules/protobufjs/src/namespace.js"(exports2, module2) {
    "use strict";
    module2.exports = Namespace;
    var ReflectionObject = require_object3();
    ((Namespace.prototype = Object.create(ReflectionObject.prototype)).constructor = Namespace).className = "Namespace";
    var Field2 = require_field();
    var util = require_util3();
    var OneOf = require_oneof();
    var Type;
    var Service;
    var Enum;
    Namespace.fromJSON = function fromJSON(name, json) {
      return new Namespace(name, json.options).addJSON(json.nested);
    };
    function arrayToJSON(array, toJSONOptions) {
      if (!(array && array.length))
        return void 0;
      var obj = {};
      for (var i = 0; i < array.length; ++i)
        obj[array[i].name] = array[i].toJSON(toJSONOptions);
      return obj;
    }
    Namespace.arrayToJSON = arrayToJSON;
    Namespace.isReservedId = function isReservedId(reserved, id2) {
      if (reserved) {
        for (var i = 0; i < reserved.length; ++i)
          if (typeof reserved[i] !== "string" && reserved[i][0] <= id2 && reserved[i][1] > id2)
            return true;
      }
      return false;
    };
    Namespace.isReservedName = function isReservedName(reserved, name) {
      if (reserved) {
        for (var i = 0; i < reserved.length; ++i)
          if (reserved[i] === name)
            return true;
      }
      return false;
    };
    function Namespace(name, options) {
      ReflectionObject.call(this, name, options);
      this.nested = void 0;
      this._nestedArray = null;
    }
    function clearCache(namespace) {
      namespace._nestedArray = null;
      return namespace;
    }
    Object.defineProperty(Namespace.prototype, "nestedArray", {
      get: function() {
        return this._nestedArray || (this._nestedArray = util.toArray(this.nested));
      }
    });
    Namespace.prototype.toJSON = function toJSON(toJSONOptions) {
      return util.toObject([
        "options",
        this.options,
        "nested",
        arrayToJSON(this.nestedArray, toJSONOptions)
      ]);
    };
    Namespace.prototype.addJSON = function addJSON(nestedJson) {
      var ns = this;
      if (nestedJson) {
        for (var names = Object.keys(nestedJson), i = 0, nested; i < names.length; ++i) {
          nested = nestedJson[names[i]];
          ns.add(
            // most to least likely
            (nested.fields !== void 0 ? Type.fromJSON : nested.values !== void 0 ? Enum.fromJSON : nested.methods !== void 0 ? Service.fromJSON : nested.id !== void 0 ? Field2.fromJSON : Namespace.fromJSON)(names[i], nested)
          );
        }
      }
      return this;
    };
    Namespace.prototype.get = function get2(name) {
      return this.nested && this.nested[name] || null;
    };
    Namespace.prototype.getEnum = function getEnum(name) {
      if (this.nested && this.nested[name] instanceof Enum)
        return this.nested[name].values;
      throw Error("no such enum: " + name);
    };
    Namespace.prototype.add = function add(object) {
      if (!(object instanceof Field2 && object.extend !== void 0 || object instanceof Type || object instanceof OneOf || object instanceof Enum || object instanceof Service || object instanceof Namespace))
        throw TypeError("object must be a valid nested object");
      if (!this.nested)
        this.nested = {};
      else {
        var prev = this.get(object.name);
        if (prev) {
          if (prev instanceof Namespace && object instanceof Namespace && !(prev instanceof Type || prev instanceof Service)) {
            var nested = prev.nestedArray;
            for (var i = 0; i < nested.length; ++i)
              object.add(nested[i]);
            this.remove(prev);
            if (!this.nested)
              this.nested = {};
            object.setOptions(prev.options, true);
          } else
            throw Error("duplicate name '" + object.name + "' in " + this);
        }
      }
      this.nested[object.name] = object;
      object.onAdd(this);
      return clearCache(this);
    };
    Namespace.prototype.remove = function remove(object) {
      if (!(object instanceof ReflectionObject))
        throw TypeError("object must be a ReflectionObject");
      if (object.parent !== this)
        throw Error(object + " is not a member of " + this);
      delete this.nested[object.name];
      if (!Object.keys(this.nested).length)
        this.nested = void 0;
      object.onRemove(this);
      return clearCache(this);
    };
    Namespace.prototype.define = function define2(path, json) {
      if (util.isString(path))
        path = path.split(".");
      else if (!Array.isArray(path))
        throw TypeError("illegal path");
      if (path && path.length && path[0] === "")
        throw Error("path must be relative");
      var ptr = this;
      while (path.length > 0) {
        var part = path.shift();
        if (ptr.nested && ptr.nested[part]) {
          ptr = ptr.nested[part];
          if (!(ptr instanceof Namespace))
            throw Error("path conflicts with non-namespace objects");
        } else
          ptr.add(ptr = new Namespace(part));
      }
      if (json)
        ptr.addJSON(json);
      return ptr;
    };
    Namespace.prototype.resolveAll = function resolveAll() {
      var nested = this.nestedArray, i = 0;
      while (i < nested.length)
        if (nested[i] instanceof Namespace)
          nested[i++].resolveAll();
        else
          nested[i++].resolve();
      return this.resolve();
    };
    Namespace.prototype.lookup = function lookup(path, filterTypes, parentAlreadyChecked) {
      if (typeof filterTypes === "boolean") {
        parentAlreadyChecked = filterTypes;
        filterTypes = void 0;
      } else if (filterTypes && !Array.isArray(filterTypes))
        filterTypes = [filterTypes];
      if (util.isString(path) && path.length) {
        if (path === ".")
          return this.root;
        path = path.split(".");
      } else if (!path.length)
        return this;
      if (path[0] === "")
        return this.root.lookup(path.slice(1), filterTypes);
      var found = this.get(path[0]);
      if (found) {
        if (path.length === 1) {
          if (!filterTypes || filterTypes.indexOf(found.constructor) > -1)
            return found;
        } else if (found instanceof Namespace && (found = found.lookup(path.slice(1), filterTypes, true)))
          return found;
      } else
        for (var i = 0; i < this.nestedArray.length; ++i)
          if (this._nestedArray[i] instanceof Namespace && (found = this._nestedArray[i].lookup(path, filterTypes, true)))
            return found;
      if (this.parent === null || parentAlreadyChecked)
        return null;
      return this.parent.lookup(path, filterTypes);
    };
    Namespace.prototype.lookupType = function lookupType(path) {
      var found = this.lookup(path, [Type]);
      if (!found)
        throw Error("no such type: " + path);
      return found;
    };
    Namespace.prototype.lookupEnum = function lookupEnum(path) {
      var found = this.lookup(path, [Enum]);
      if (!found)
        throw Error("no such Enum '" + path + "' in " + this);
      return found;
    };
    Namespace.prototype.lookupTypeOrEnum = function lookupTypeOrEnum(path) {
      var found = this.lookup(path, [Type, Enum]);
      if (!found)
        throw Error("no such Type or Enum '" + path + "' in " + this);
      return found;
    };
    Namespace.prototype.lookupService = function lookupService(path) {
      var found = this.lookup(path, [Service]);
      if (!found)
        throw Error("no such Service '" + path + "' in " + this);
      return found;
    };
    Namespace._configure = function(Type_, Service_, Enum_) {
      Type = Type_;
      Service = Service_;
      Enum = Enum_;
    };
  }
});

// node_modules/protobufjs/src/mapfield.js
var require_mapfield = __commonJS({
  "node_modules/protobufjs/src/mapfield.js"(exports2, module2) {
    "use strict";
    module2.exports = MapField;
    var Field2 = require_field();
    ((MapField.prototype = Object.create(Field2.prototype)).constructor = MapField).className = "MapField";
    var types = require_types2();
    var util = require_util3();
    function MapField(name, id2, keyType, type, options, comment) {
      Field2.call(this, name, id2, type, void 0, void 0, options, comment);
      if (!util.isString(keyType))
        throw TypeError("keyType must be a string");
      this.keyType = keyType;
      this.resolvedKeyType = null;
      this.map = true;
    }
    MapField.fromJSON = function fromJSON(name, json) {
      return new MapField(name, json.id, json.keyType, json.type, json.options, json.comment);
    };
    MapField.prototype.toJSON = function toJSON(toJSONOptions) {
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util.toObject([
        "keyType",
        this.keyType,
        "type",
        this.type,
        "id",
        this.id,
        "extend",
        this.extend,
        "options",
        this.options,
        "comment",
        keepComments ? this.comment : void 0
      ]);
    };
    MapField.prototype.resolve = function resolve() {
      if (this.resolved)
        return this;
      if (types.mapKey[this.keyType] === void 0)
        throw Error("invalid key type: " + this.keyType);
      return Field2.prototype.resolve.call(this);
    };
    MapField.d = function decorateMapField(fieldId, fieldKeyType, fieldValueType) {
      if (typeof fieldValueType === "function")
        fieldValueType = util.decorateType(fieldValueType).name;
      else if (fieldValueType && typeof fieldValueType === "object")
        fieldValueType = util.decorateEnum(fieldValueType).name;
      return function mapFieldDecorator(prototype, fieldName) {
        util.decorateType(prototype.constructor).add(new MapField(fieldName, fieldId, fieldKeyType, fieldValueType));
      };
    };
  }
});

// node_modules/protobufjs/src/method.js
var require_method = __commonJS({
  "node_modules/protobufjs/src/method.js"(exports2, module2) {
    "use strict";
    module2.exports = Method;
    var ReflectionObject = require_object3();
    ((Method.prototype = Object.create(ReflectionObject.prototype)).constructor = Method).className = "Method";
    var util = require_util3();
    function Method(name, type, requestType, responseType, requestStream, responseStream, options, comment, parsedOptions) {
      if (util.isObject(requestStream)) {
        options = requestStream;
        requestStream = responseStream = void 0;
      } else if (util.isObject(responseStream)) {
        options = responseStream;
        responseStream = void 0;
      }
      if (!(type === void 0 || util.isString(type)))
        throw TypeError("type must be a string");
      if (!util.isString(requestType))
        throw TypeError("requestType must be a string");
      if (!util.isString(responseType))
        throw TypeError("responseType must be a string");
      ReflectionObject.call(this, name, options);
      this.type = type || "rpc";
      this.requestType = requestType;
      this.requestStream = requestStream ? true : void 0;
      this.responseType = responseType;
      this.responseStream = responseStream ? true : void 0;
      this.resolvedRequestType = null;
      this.resolvedResponseType = null;
      this.comment = comment;
      this.parsedOptions = parsedOptions;
    }
    Method.fromJSON = function fromJSON(name, json) {
      return new Method(name, json.type, json.requestType, json.responseType, json.requestStream, json.responseStream, json.options, json.comment, json.parsedOptions);
    };
    Method.prototype.toJSON = function toJSON(toJSONOptions) {
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util.toObject([
        "type",
        this.type !== "rpc" && /* istanbul ignore next */
        this.type || void 0,
        "requestType",
        this.requestType,
        "requestStream",
        this.requestStream,
        "responseType",
        this.responseType,
        "responseStream",
        this.responseStream,
        "options",
        this.options,
        "comment",
        keepComments ? this.comment : void 0,
        "parsedOptions",
        this.parsedOptions
      ]);
    };
    Method.prototype.resolve = function resolve() {
      if (this.resolved)
        return this;
      this.resolvedRequestType = this.parent.lookupType(this.requestType);
      this.resolvedResponseType = this.parent.lookupType(this.responseType);
      return ReflectionObject.prototype.resolve.call(this);
    };
  }
});

// node_modules/protobufjs/src/service.js
var require_service2 = __commonJS({
  "node_modules/protobufjs/src/service.js"(exports2, module2) {
    "use strict";
    module2.exports = Service;
    var Namespace = require_namespace();
    ((Service.prototype = Object.create(Namespace.prototype)).constructor = Service).className = "Service";
    var Method = require_method();
    var util = require_util3();
    var rpc = require_rpc();
    function Service(name, options) {
      Namespace.call(this, name, options);
      this.methods = {};
      this._methodsArray = null;
    }
    Service.fromJSON = function fromJSON(name, json) {
      var service = new Service(name, json.options);
      if (json.methods)
        for (var names = Object.keys(json.methods), i = 0; i < names.length; ++i)
          service.add(Method.fromJSON(names[i], json.methods[names[i]]));
      if (json.nested)
        service.addJSON(json.nested);
      service.comment = json.comment;
      return service;
    };
    Service.prototype.toJSON = function toJSON(toJSONOptions) {
      var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util.toObject([
        "options",
        inherited && inherited.options || void 0,
        "methods",
        Namespace.arrayToJSON(this.methodsArray, toJSONOptions) || /* istanbul ignore next */
        {},
        "nested",
        inherited && inherited.nested || void 0,
        "comment",
        keepComments ? this.comment : void 0
      ]);
    };
    Object.defineProperty(Service.prototype, "methodsArray", {
      get: function() {
        return this._methodsArray || (this._methodsArray = util.toArray(this.methods));
      }
    });
    function clearCache(service) {
      service._methodsArray = null;
      return service;
    }
    Service.prototype.get = function get2(name) {
      return this.methods[name] || Namespace.prototype.get.call(this, name);
    };
    Service.prototype.resolveAll = function resolveAll() {
      var methods = this.methodsArray;
      for (var i = 0; i < methods.length; ++i)
        methods[i].resolve();
      return Namespace.prototype.resolve.call(this);
    };
    Service.prototype.add = function add(object) {
      if (this.get(object.name))
        throw Error("duplicate name '" + object.name + "' in " + this);
      if (object instanceof Method) {
        this.methods[object.name] = object;
        object.parent = this;
        return clearCache(this);
      }
      return Namespace.prototype.add.call(this, object);
    };
    Service.prototype.remove = function remove(object) {
      if (object instanceof Method) {
        if (this.methods[object.name] !== object)
          throw Error(object + " is not a member of " + this);
        delete this.methods[object.name];
        object.parent = null;
        return clearCache(this);
      }
      return Namespace.prototype.remove.call(this, object);
    };
    Service.prototype.create = function create(rpcImpl, requestDelimited, responseDelimited) {
      var rpcService = new rpc.Service(rpcImpl, requestDelimited, responseDelimited);
      for (var i = 0, method; i < /* initializes */
      this.methodsArray.length; ++i) {
        var methodName = util.lcFirst((method = this._methodsArray[i]).resolve().name).replace(/[^$\w_]/g, "");
        rpcService[methodName] = util.codegen(["r", "c"], util.isReserved(methodName) ? methodName + "_" : methodName)("return this.rpcCall(m,q,s,r,c)")({
          m: method,
          q: method.resolvedRequestType.ctor,
          s: method.resolvedResponseType.ctor
        });
      }
      return rpcService;
    };
  }
});

// node_modules/protobufjs/src/message.js
var require_message = __commonJS({
  "node_modules/protobufjs/src/message.js"(exports2, module2) {
    "use strict";
    module2.exports = Message;
    var util = require_minimal();
    function Message(properties) {
      if (properties)
        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          this[keys[i]] = properties[keys[i]];
    }
    Message.create = function create(properties) {
      return this.$type.create(properties);
    };
    Message.encode = function encode(message, writer) {
      return this.$type.encode(message, writer);
    };
    Message.encodeDelimited = function encodeDelimited(message, writer) {
      return this.$type.encodeDelimited(message, writer);
    };
    Message.decode = function decode(reader) {
      return this.$type.decode(reader);
    };
    Message.decodeDelimited = function decodeDelimited(reader) {
      return this.$type.decodeDelimited(reader);
    };
    Message.verify = function verify(message) {
      return this.$type.verify(message);
    };
    Message.fromObject = function fromObject(object) {
      return this.$type.fromObject(object);
    };
    Message.toObject = function toObject(message, options) {
      return this.$type.toObject(message, options);
    };
    Message.prototype.toJSON = function toJSON() {
      return this.$type.toObject(this, util.toJSONOptions);
    };
  }
});

// node_modules/protobufjs/src/decoder.js
var require_decoder = __commonJS({
  "node_modules/protobufjs/src/decoder.js"(exports2, module2) {
    "use strict";
    module2.exports = decoder;
    var Enum = require_enum3();
    var types = require_types2();
    var util = require_util3();
    function missing(field) {
      return "missing required '" + field.name + "'";
    }
    function decoder(mtype) {
      var gen = util.codegen(["r", "l"], mtype.name + "$decode")("if(!(r instanceof Reader))")("r=Reader.create(r)")("var c=l===undefined?r.len:r.pos+l,m=new this.ctor" + (mtype.fieldsArray.filter(function(field2) {
        return field2.map;
      }).length ? ",k,value" : ""))("while(r.pos<c){")("var t=r.uint32()");
      if (mtype.group) gen("if((t&7)===4)")("break");
      gen("switch(t>>>3){");
      var i = 0;
      for (; i < /* initializes */
      mtype.fieldsArray.length; ++i) {
        var field = mtype._fieldsArray[i].resolve(), type = field.resolvedType instanceof Enum ? "int32" : field.type, ref = "m" + util.safeProp(field.name);
        gen("case %i: {", field.id);
        if (field.map) {
          gen("if(%s===util.emptyObject)", ref)("%s={}", ref)("var c2 = r.uint32()+r.pos");
          if (types.defaults[field.keyType] !== void 0) gen("k=%j", types.defaults[field.keyType]);
          else gen("k=null");
          if (types.defaults[type] !== void 0) gen("value=%j", types.defaults[type]);
          else gen("value=null");
          gen("while(r.pos<c2){")("var tag2=r.uint32()")("switch(tag2>>>3){")("case 1: k=r.%s(); break", field.keyType)("case 2:");
          if (types.basic[type] === void 0) gen("value=types[%i].decode(r,r.uint32())", i);
          else gen("value=r.%s()", type);
          gen("break")("default:")("r.skipType(tag2&7)")("break")("}")("}");
          if (types.long[field.keyType] !== void 0) gen('%s[typeof k==="object"?util.longToHash(k):k]=value', ref);
          else gen("%s[k]=value", ref);
        } else if (field.repeated) {
          gen("if(!(%s&&%s.length))", ref, ref)("%s=[]", ref);
          if (types.packed[type] !== void 0) gen("if((t&7)===2){")("var c2=r.uint32()+r.pos")("while(r.pos<c2)")("%s.push(r.%s())", ref, type)("}else");
          if (types.basic[type] === void 0) gen(field.resolvedType.group ? "%s.push(types[%i].decode(r))" : "%s.push(types[%i].decode(r,r.uint32()))", ref, i);
          else gen("%s.push(r.%s())", ref, type);
        } else if (types.basic[type] === void 0) gen(field.resolvedType.group ? "%s=types[%i].decode(r)" : "%s=types[%i].decode(r,r.uint32())", ref, i);
        else gen("%s=r.%s()", ref, type);
        gen("break")("}");
      }
      gen("default:")("r.skipType(t&7)")("break")("}")("}");
      for (i = 0; i < mtype._fieldsArray.length; ++i) {
        var rfield = mtype._fieldsArray[i];
        if (rfield.required) gen("if(!m.hasOwnProperty(%j))", rfield.name)("throw util.ProtocolError(%j,{instance:m})", missing(rfield));
      }
      return gen("return m");
    }
  }
});

// node_modules/protobufjs/src/verifier.js
var require_verifier = __commonJS({
  "node_modules/protobufjs/src/verifier.js"(exports2, module2) {
    "use strict";
    module2.exports = verifier;
    var Enum = require_enum3();
    var util = require_util3();
    function invalid(field, expected) {
      return field.name + ": " + expected + (field.repeated && expected !== "array" ? "[]" : field.map && expected !== "object" ? "{k:" + field.keyType + "}" : "") + " expected";
    }
    function genVerifyValue(gen, field, fieldIndex, ref) {
      if (field.resolvedType) {
        if (field.resolvedType instanceof Enum) {
          gen("switch(%s){", ref)("default:")("return%j", invalid(field, "enum value"));
          for (var keys = Object.keys(field.resolvedType.values), j = 0; j < keys.length; ++j) gen("case %i:", field.resolvedType.values[keys[j]]);
          gen("break")("}");
        } else {
          gen("{")("var e=types[%i].verify(%s);", fieldIndex, ref)("if(e)")("return%j+e", field.name + ".")("}");
        }
      } else {
        switch (field.type) {
          case "int32":
          case "uint32":
          case "sint32":
          case "fixed32":
          case "sfixed32":
            gen("if(!util.isInteger(%s))", ref)("return%j", invalid(field, "integer"));
            break;
          case "int64":
          case "uint64":
          case "sint64":
          case "fixed64":
          case "sfixed64":
            gen("if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))", ref, ref, ref, ref)("return%j", invalid(field, "integer|Long"));
            break;
          case "float":
          case "double":
            gen('if(typeof %s!=="number")', ref)("return%j", invalid(field, "number"));
            break;
          case "bool":
            gen('if(typeof %s!=="boolean")', ref)("return%j", invalid(field, "boolean"));
            break;
          case "string":
            gen("if(!util.isString(%s))", ref)("return%j", invalid(field, "string"));
            break;
          case "bytes":
            gen('if(!(%s&&typeof %s.length==="number"||util.isString(%s)))', ref, ref, ref)("return%j", invalid(field, "buffer"));
            break;
        }
      }
      return gen;
    }
    function genVerifyKey(gen, field, ref) {
      switch (field.keyType) {
        case "int32":
        case "uint32":
        case "sint32":
        case "fixed32":
        case "sfixed32":
          gen("if(!util.key32Re.test(%s))", ref)("return%j", invalid(field, "integer key"));
          break;
        case "int64":
        case "uint64":
        case "sint64":
        case "fixed64":
        case "sfixed64":
          gen("if(!util.key64Re.test(%s))", ref)("return%j", invalid(field, "integer|Long key"));
          break;
        case "bool":
          gen("if(!util.key2Re.test(%s))", ref)("return%j", invalid(field, "boolean key"));
          break;
      }
      return gen;
    }
    function verifier(mtype) {
      var gen = util.codegen(["m"], mtype.name + "$verify")('if(typeof m!=="object"||m===null)')("return%j", "object expected");
      var oneofs = mtype.oneofsArray, seenFirstField = {};
      if (oneofs.length) gen("var p={}");
      for (var i = 0; i < /* initializes */
      mtype.fieldsArray.length; ++i) {
        var field = mtype._fieldsArray[i].resolve(), ref = "m" + util.safeProp(field.name);
        if (field.optional) gen("if(%s!=null&&m.hasOwnProperty(%j)){", ref, field.name);
        if (field.map) {
          gen("if(!util.isObject(%s))", ref)("return%j", invalid(field, "object"))("var k=Object.keys(%s)", ref)("for(var i=0;i<k.length;++i){");
          genVerifyKey(gen, field, "k[i]");
          genVerifyValue(gen, field, i, ref + "[k[i]]")("}");
        } else if (field.repeated) {
          gen("if(!Array.isArray(%s))", ref)("return%j", invalid(field, "array"))("for(var i=0;i<%s.length;++i){", ref);
          genVerifyValue(gen, field, i, ref + "[i]")("}");
        } else {
          if (field.partOf) {
            var oneofProp = util.safeProp(field.partOf.name);
            if (seenFirstField[field.partOf.name] === 1) gen("if(p%s===1)", oneofProp)("return%j", field.partOf.name + ": multiple values");
            seenFirstField[field.partOf.name] = 1;
            gen("p%s=1", oneofProp);
          }
          genVerifyValue(gen, field, i, ref);
        }
        if (field.optional) gen("}");
      }
      return gen("return null");
    }
  }
});

// node_modules/protobufjs/src/converter.js
var require_converter2 = __commonJS({
  "node_modules/protobufjs/src/converter.js"(exports2) {
    "use strict";
    var converter = exports2;
    var Enum = require_enum3();
    var util = require_util3();
    function genValuePartial_fromObject(gen, field, fieldIndex, prop) {
      var defaultAlreadyEmitted = false;
      if (field.resolvedType) {
        if (field.resolvedType instanceof Enum) {
          gen("switch(d%s){", prop);
          for (var values = field.resolvedType.values, keys = Object.keys(values), i = 0; i < keys.length; ++i) {
            if (values[keys[i]] === field.typeDefault && !defaultAlreadyEmitted) {
              gen("default:")('if(typeof(d%s)==="number"){m%s=d%s;break}', prop, prop, prop);
              if (!field.repeated) gen("break");
              defaultAlreadyEmitted = true;
            }
            gen("case%j:", keys[i])("case %i:", values[keys[i]])("m%s=%j", prop, values[keys[i]])("break");
          }
          gen("}");
        } else gen('if(typeof d%s!=="object")', prop)("throw TypeError(%j)", field.fullName + ": object expected")("m%s=types[%i].fromObject(d%s)", prop, fieldIndex, prop);
      } else {
        var isUnsigned = false;
        switch (field.type) {
          case "double":
          case "float":
            gen("m%s=Number(d%s)", prop, prop);
            break;
          case "uint32":
          case "fixed32":
            gen("m%s=d%s>>>0", prop, prop);
            break;
          case "int32":
          case "sint32":
          case "sfixed32":
            gen("m%s=d%s|0", prop, prop);
            break;
          case "uint64":
            isUnsigned = true;
          // eslint-disable-next-line no-fallthrough
          case "int64":
          case "sint64":
          case "fixed64":
          case "sfixed64":
            gen("if(util.Long)")("(m%s=util.Long.fromValue(d%s)).unsigned=%j", prop, prop, isUnsigned)('else if(typeof d%s==="string")', prop)("m%s=parseInt(d%s,10)", prop, prop)('else if(typeof d%s==="number")', prop)("m%s=d%s", prop, prop)('else if(typeof d%s==="object")', prop)("m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)", prop, prop, prop, isUnsigned ? "true" : "");
            break;
          case "bytes":
            gen('if(typeof d%s==="string")', prop)("util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)", prop, prop, prop)("else if(d%s.length >= 0)", prop)("m%s=d%s", prop, prop);
            break;
          case "string":
            gen("m%s=String(d%s)", prop, prop);
            break;
          case "bool":
            gen("m%s=Boolean(d%s)", prop, prop);
            break;
        }
      }
      return gen;
    }
    converter.fromObject = function fromObject(mtype) {
      var fields = mtype.fieldsArray;
      var gen = util.codegen(["d"], mtype.name + "$fromObject")("if(d instanceof this.ctor)")("return d");
      if (!fields.length) return gen("return new this.ctor");
      gen("var m=new this.ctor");
      for (var i = 0; i < fields.length; ++i) {
        var field = fields[i].resolve(), prop = util.safeProp(field.name);
        if (field.map) {
          gen("if(d%s){", prop)('if(typeof d%s!=="object")', prop)("throw TypeError(%j)", field.fullName + ": object expected")("m%s={}", prop)("for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){", prop);
          genValuePartial_fromObject(
            gen,
            field,
            /* not sorted */
            i,
            prop + "[ks[i]]"
          )("}")("}");
        } else if (field.repeated) {
          gen("if(d%s){", prop)("if(!Array.isArray(d%s))", prop)("throw TypeError(%j)", field.fullName + ": array expected")("m%s=[]", prop)("for(var i=0;i<d%s.length;++i){", prop);
          genValuePartial_fromObject(
            gen,
            field,
            /* not sorted */
            i,
            prop + "[i]"
          )("}")("}");
        } else {
          if (!(field.resolvedType instanceof Enum)) gen("if(d%s!=null){", prop);
          genValuePartial_fromObject(
            gen,
            field,
            /* not sorted */
            i,
            prop
          );
          if (!(field.resolvedType instanceof Enum)) gen("}");
        }
      }
      return gen("return m");
    };
    function genValuePartial_toObject(gen, field, fieldIndex, prop) {
      if (field.resolvedType) {
        if (field.resolvedType instanceof Enum) gen("d%s=o.enums===String?(types[%i].values[m%s]===undefined?m%s:types[%i].values[m%s]):m%s", prop, fieldIndex, prop, prop, fieldIndex, prop, prop);
        else gen("d%s=types[%i].toObject(m%s,o)", prop, fieldIndex, prop);
      } else {
        var isUnsigned = false;
        switch (field.type) {
          case "double":
          case "float":
            gen("d%s=o.json&&!isFinite(m%s)?String(m%s):m%s", prop, prop, prop, prop);
            break;
          case "uint64":
            isUnsigned = true;
          // eslint-disable-next-line no-fallthrough
          case "int64":
          case "sint64":
          case "fixed64":
          case "sfixed64":
            gen('if(typeof m%s==="number")', prop)("d%s=o.longs===String?String(m%s):m%s", prop, prop, prop)("else")("d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s", prop, prop, prop, prop, isUnsigned ? "true" : "", prop);
            break;
          case "bytes":
            gen("d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s", prop, prop, prop, prop, prop);
            break;
          default:
            gen("d%s=m%s", prop, prop);
            break;
        }
      }
      return gen;
    }
    converter.toObject = function toObject(mtype) {
      var fields = mtype.fieldsArray.slice().sort(util.compareFieldsById);
      if (!fields.length)
        return util.codegen()("return {}");
      var gen = util.codegen(["m", "o"], mtype.name + "$toObject")("if(!o)")("o={}")("var d={}");
      var repeatedFields = [], mapFields = [], normalFields = [], i = 0;
      for (; i < fields.length; ++i)
        if (!fields[i].partOf)
          (fields[i].resolve().repeated ? repeatedFields : fields[i].map ? mapFields : normalFields).push(fields[i]);
      if (repeatedFields.length) {
        gen("if(o.arrays||o.defaults){");
        for (i = 0; i < repeatedFields.length; ++i) gen("d%s=[]", util.safeProp(repeatedFields[i].name));
        gen("}");
      }
      if (mapFields.length) {
        gen("if(o.objects||o.defaults){");
        for (i = 0; i < mapFields.length; ++i) gen("d%s={}", util.safeProp(mapFields[i].name));
        gen("}");
      }
      if (normalFields.length) {
        gen("if(o.defaults){");
        for (i = 0; i < normalFields.length; ++i) {
          var field = normalFields[i], prop = util.safeProp(field.name);
          if (field.resolvedType instanceof Enum) gen("d%s=o.enums===String?%j:%j", prop, field.resolvedType.valuesById[field.typeDefault], field.typeDefault);
          else if (field.long) gen("if(util.Long){")("var n=new util.Long(%i,%i,%j)", field.typeDefault.low, field.typeDefault.high, field.typeDefault.unsigned)("d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n", prop)("}else")("d%s=o.longs===String?%j:%i", prop, field.typeDefault.toString(), field.typeDefault.toNumber());
          else if (field.bytes) {
            var arrayDefault = "[" + Array.prototype.slice.call(field.typeDefault).join(",") + "]";
            gen("if(o.bytes===String)d%s=%j", prop, String.fromCharCode.apply(String, field.typeDefault))("else{")("d%s=%s", prop, arrayDefault)("if(o.bytes!==Array)d%s=util.newBuffer(d%s)", prop, prop)("}");
          } else gen("d%s=%j", prop, field.typeDefault);
        }
        gen("}");
      }
      var hasKs2 = false;
      for (i = 0; i < fields.length; ++i) {
        var field = fields[i], index = mtype._fieldsArray.indexOf(field), prop = util.safeProp(field.name);
        if (field.map) {
          if (!hasKs2) {
            hasKs2 = true;
            gen("var ks2");
          }
          gen("if(m%s&&(ks2=Object.keys(m%s)).length){", prop, prop)("d%s={}", prop)("for(var j=0;j<ks2.length;++j){");
          genValuePartial_toObject(
            gen,
            field,
            /* sorted */
            index,
            prop + "[ks2[j]]"
          )("}");
        } else if (field.repeated) {
          gen("if(m%s&&m%s.length){", prop, prop)("d%s=[]", prop)("for(var j=0;j<m%s.length;++j){", prop);
          genValuePartial_toObject(
            gen,
            field,
            /* sorted */
            index,
            prop + "[j]"
          )("}");
        } else {
          gen("if(m%s!=null&&m.hasOwnProperty(%j)){", prop, field.name);
          genValuePartial_toObject(
            gen,
            field,
            /* sorted */
            index,
            prop
          );
          if (field.partOf) gen("if(o.oneofs)")("d%s=%j", util.safeProp(field.partOf.name), field.name);
        }
        gen("}");
      }
      return gen("return d");
    };
  }
});

// node_modules/protobufjs/src/wrappers.js
var require_wrappers = __commonJS({
  "node_modules/protobufjs/src/wrappers.js"(exports2) {
    "use strict";
    var wrappers = exports2;
    var Message = require_message();
    wrappers[".google.protobuf.Any"] = {
      fromObject: function(object) {
        if (object && object["@type"]) {
          var name = object["@type"].substring(object["@type"].lastIndexOf("/") + 1);
          var type = this.lookup(name);
          if (type) {
            var type_url = object["@type"].charAt(0) === "." ? object["@type"].slice(1) : object["@type"];
            if (type_url.indexOf("/") === -1) {
              type_url = "/" + type_url;
            }
            return this.create({
              type_url,
              value: type.encode(type.fromObject(object)).finish()
            });
          }
        }
        return this.fromObject(object);
      },
      toObject: function(message, options) {
        var googleApi = "type.googleapis.com/";
        var prefix = "";
        var name = "";
        if (options && options.json && message.type_url && message.value) {
          name = message.type_url.substring(message.type_url.lastIndexOf("/") + 1);
          prefix = message.type_url.substring(0, message.type_url.lastIndexOf("/") + 1);
          var type = this.lookup(name);
          if (type)
            message = type.decode(message.value);
        }
        if (!(message instanceof this.ctor) && message instanceof Message) {
          var object = message.$type.toObject(message, options);
          var messageName = message.$type.fullName[0] === "." ? message.$type.fullName.slice(1) : message.$type.fullName;
          if (prefix === "") {
            prefix = googleApi;
          }
          name = prefix + messageName;
          object["@type"] = name;
          return object;
        }
        return this.toObject(message, options);
      }
    };
  }
});

// node_modules/protobufjs/src/type.js
var require_type8 = __commonJS({
  "node_modules/protobufjs/src/type.js"(exports2, module2) {
    "use strict";
    module2.exports = Type;
    var Namespace = require_namespace();
    ((Type.prototype = Object.create(Namespace.prototype)).constructor = Type).className = "Type";
    var Enum = require_enum3();
    var OneOf = require_oneof();
    var Field2 = require_field();
    var MapField = require_mapfield();
    var Service = require_service2();
    var Message = require_message();
    var Reader = require_reader();
    var Writer = require_writer();
    var util = require_util3();
    var encoder = require_encoder();
    var decoder = require_decoder();
    var verifier = require_verifier();
    var converter = require_converter2();
    var wrappers = require_wrappers();
    function Type(name, options) {
      Namespace.call(this, name, options);
      this.fields = {};
      this.oneofs = void 0;
      this.extensions = void 0;
      this.reserved = void 0;
      this.group = void 0;
      this._fieldsById = null;
      this._fieldsArray = null;
      this._oneofsArray = null;
      this._ctor = null;
    }
    Object.defineProperties(Type.prototype, {
      /**
       * Message fields by id.
       * @name Type#fieldsById
       * @type {Object.<number,Field>}
       * @readonly
       */
      fieldsById: {
        get: function() {
          if (this._fieldsById)
            return this._fieldsById;
          this._fieldsById = {};
          for (var names = Object.keys(this.fields), i = 0; i < names.length; ++i) {
            var field = this.fields[names[i]], id2 = field.id;
            if (this._fieldsById[id2])
              throw Error("duplicate id " + id2 + " in " + this);
            this._fieldsById[id2] = field;
          }
          return this._fieldsById;
        }
      },
      /**
       * Fields of this message as an array for iteration.
       * @name Type#fieldsArray
       * @type {Field[]}
       * @readonly
       */
      fieldsArray: {
        get: function() {
          return this._fieldsArray || (this._fieldsArray = util.toArray(this.fields));
        }
      },
      /**
       * Oneofs of this message as an array for iteration.
       * @name Type#oneofsArray
       * @type {OneOf[]}
       * @readonly
       */
      oneofsArray: {
        get: function() {
          return this._oneofsArray || (this._oneofsArray = util.toArray(this.oneofs));
        }
      },
      /**
       * The registered constructor, if any registered, otherwise a generic constructor.
       * Assigning a function replaces the internal constructor. If the function does not extend {@link Message} yet, its prototype will be setup accordingly and static methods will be populated. If it already extends {@link Message}, it will just replace the internal constructor.
       * @name Type#ctor
       * @type {Constructor<{}>}
       */
      ctor: {
        get: function() {
          return this._ctor || (this.ctor = Type.generateConstructor(this)());
        },
        set: function(ctor) {
          var prototype = ctor.prototype;
          if (!(prototype instanceof Message)) {
            (ctor.prototype = new Message()).constructor = ctor;
            util.merge(ctor.prototype, prototype);
          }
          ctor.$type = ctor.prototype.$type = this;
          util.merge(ctor, Message, true);
          this._ctor = ctor;
          var i = 0;
          for (; i < /* initializes */
          this.fieldsArray.length; ++i)
            this._fieldsArray[i].resolve();
          var ctorProperties = {};
          for (i = 0; i < /* initializes */
          this.oneofsArray.length; ++i)
            ctorProperties[this._oneofsArray[i].resolve().name] = {
              get: util.oneOfGetter(this._oneofsArray[i].oneof),
              set: util.oneOfSetter(this._oneofsArray[i].oneof)
            };
          if (i)
            Object.defineProperties(ctor.prototype, ctorProperties);
        }
      }
    });
    Type.generateConstructor = function generateConstructor(mtype) {
      var gen = util.codegen(["p"], mtype.name);
      for (var i = 0, field; i < mtype.fieldsArray.length; ++i)
        if ((field = mtype._fieldsArray[i]).map) gen("this%s={}", util.safeProp(field.name));
        else if (field.repeated) gen("this%s=[]", util.safeProp(field.name));
      return gen("if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)")("this[ks[i]]=p[ks[i]]");
    };
    function clearCache(type) {
      type._fieldsById = type._fieldsArray = type._oneofsArray = null;
      delete type.encode;
      delete type.decode;
      delete type.verify;
      return type;
    }
    Type.fromJSON = function fromJSON(name, json) {
      var type = new Type(name, json.options);
      type.extensions = json.extensions;
      type.reserved = json.reserved;
      var names = Object.keys(json.fields), i = 0;
      for (; i < names.length; ++i)
        type.add(
          (typeof json.fields[names[i]].keyType !== "undefined" ? MapField.fromJSON : Field2.fromJSON)(names[i], json.fields[names[i]])
        );
      if (json.oneofs)
        for (names = Object.keys(json.oneofs), i = 0; i < names.length; ++i)
          type.add(OneOf.fromJSON(names[i], json.oneofs[names[i]]));
      if (json.nested)
        for (names = Object.keys(json.nested), i = 0; i < names.length; ++i) {
          var nested = json.nested[names[i]];
          type.add(
            // most to least likely
            (nested.id !== void 0 ? Field2.fromJSON : nested.fields !== void 0 ? Type.fromJSON : nested.values !== void 0 ? Enum.fromJSON : nested.methods !== void 0 ? Service.fromJSON : Namespace.fromJSON)(names[i], nested)
          );
        }
      if (json.extensions && json.extensions.length)
        type.extensions = json.extensions;
      if (json.reserved && json.reserved.length)
        type.reserved = json.reserved;
      if (json.group)
        type.group = true;
      if (json.comment)
        type.comment = json.comment;
      return type;
    };
    Type.prototype.toJSON = function toJSON(toJSONOptions) {
      var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util.toObject([
        "options",
        inherited && inherited.options || void 0,
        "oneofs",
        Namespace.arrayToJSON(this.oneofsArray, toJSONOptions),
        "fields",
        Namespace.arrayToJSON(this.fieldsArray.filter(function(obj) {
          return !obj.declaringField;
        }), toJSONOptions) || {},
        "extensions",
        this.extensions && this.extensions.length ? this.extensions : void 0,
        "reserved",
        this.reserved && this.reserved.length ? this.reserved : void 0,
        "group",
        this.group || void 0,
        "nested",
        inherited && inherited.nested || void 0,
        "comment",
        keepComments ? this.comment : void 0
      ]);
    };
    Type.prototype.resolveAll = function resolveAll() {
      var fields = this.fieldsArray, i = 0;
      while (i < fields.length)
        fields[i++].resolve();
      var oneofs = this.oneofsArray;
      i = 0;
      while (i < oneofs.length)
        oneofs[i++].resolve();
      return Namespace.prototype.resolveAll.call(this);
    };
    Type.prototype.get = function get2(name) {
      return this.fields[name] || this.oneofs && this.oneofs[name] || this.nested && this.nested[name] || null;
    };
    Type.prototype.add = function add(object) {
      if (this.get(object.name))
        throw Error("duplicate name '" + object.name + "' in " + this);
      if (object instanceof Field2 && object.extend === void 0) {
        if (this._fieldsById ? (
          /* istanbul ignore next */
          this._fieldsById[object.id]
        ) : this.fieldsById[object.id])
          throw Error("duplicate id " + object.id + " in " + this);
        if (this.isReservedId(object.id))
          throw Error("id " + object.id + " is reserved in " + this);
        if (this.isReservedName(object.name))
          throw Error("name '" + object.name + "' is reserved in " + this);
        if (object.parent)
          object.parent.remove(object);
        this.fields[object.name] = object;
        object.message = this;
        object.onAdd(this);
        return clearCache(this);
      }
      if (object instanceof OneOf) {
        if (!this.oneofs)
          this.oneofs = {};
        this.oneofs[object.name] = object;
        object.onAdd(this);
        return clearCache(this);
      }
      return Namespace.prototype.add.call(this, object);
    };
    Type.prototype.remove = function remove(object) {
      if (object instanceof Field2 && object.extend === void 0) {
        if (!this.fields || this.fields[object.name] !== object)
          throw Error(object + " is not a member of " + this);
        delete this.fields[object.name];
        object.parent = null;
        object.onRemove(this);
        return clearCache(this);
      }
      if (object instanceof OneOf) {
        if (!this.oneofs || this.oneofs[object.name] !== object)
          throw Error(object + " is not a member of " + this);
        delete this.oneofs[object.name];
        object.parent = null;
        object.onRemove(this);
        return clearCache(this);
      }
      return Namespace.prototype.remove.call(this, object);
    };
    Type.prototype.isReservedId = function isReservedId(id2) {
      return Namespace.isReservedId(this.reserved, id2);
    };
    Type.prototype.isReservedName = function isReservedName(name) {
      return Namespace.isReservedName(this.reserved, name);
    };
    Type.prototype.create = function create(properties) {
      return new this.ctor(properties);
    };
    Type.prototype.setup = function setup() {
      var fullName = this.fullName, types = [];
      for (var i = 0; i < /* initializes */
      this.fieldsArray.length; ++i)
        types.push(this._fieldsArray[i].resolve().resolvedType);
      this.encode = encoder(this)({
        Writer,
        types,
        util
      });
      this.decode = decoder(this)({
        Reader,
        types,
        util
      });
      this.verify = verifier(this)({
        types,
        util
      });
      this.fromObject = converter.fromObject(this)({
        types,
        util
      });
      this.toObject = converter.toObject(this)({
        types,
        util
      });
      var wrapper = wrappers[fullName];
      if (wrapper) {
        var originalThis = Object.create(this);
        originalThis.fromObject = this.fromObject;
        this.fromObject = wrapper.fromObject.bind(originalThis);
        originalThis.toObject = this.toObject;
        this.toObject = wrapper.toObject.bind(originalThis);
      }
      return this;
    };
    Type.prototype.encode = function encode_setup(message, writer) {
      return this.setup().encode(message, writer);
    };
    Type.prototype.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();
    };
    Type.prototype.decode = function decode_setup(reader, length) {
      return this.setup().decode(reader, length);
    };
    Type.prototype.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof Reader))
        reader = Reader.create(reader);
      return this.decode(reader, reader.uint32());
    };
    Type.prototype.verify = function verify_setup(message) {
      return this.setup().verify(message);
    };
    Type.prototype.fromObject = function fromObject(object) {
      return this.setup().fromObject(object);
    };
    Type.prototype.toObject = function toObject(message, options) {
      return this.setup().toObject(message, options);
    };
    Type.d = function decorateType(typeName) {
      return function typeDecorator(target) {
        util.decorateType(target, typeName);
      };
    };
  }
});

// node_modules/protobufjs/src/root.js
var require_root = __commonJS({
  "node_modules/protobufjs/src/root.js"(exports2, module2) {
    "use strict";
    module2.exports = Root;
    var Namespace = require_namespace();
    ((Root.prototype = Object.create(Namespace.prototype)).constructor = Root).className = "Root";
    var Field2 = require_field();
    var Enum = require_enum3();
    var OneOf = require_oneof();
    var util = require_util3();
    var Type;
    var parse;
    var common;
    function Root(options) {
      Namespace.call(this, "", options);
      this.deferred = [];
      this.files = [];
    }
    Root.fromJSON = function fromJSON(json, root) {
      if (!root)
        root = new Root();
      if (json.options)
        root.setOptions(json.options);
      return root.addJSON(json.nested);
    };
    Root.prototype.resolvePath = util.path.resolve;
    Root.prototype.fetch = util.fetch;
    function SYNC() {
    }
    Root.prototype.load = function load(filename, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = void 0;
      }
      var self2 = this;
      if (!callback)
        return util.asPromise(load, self2, filename, options);
      var sync = callback === SYNC;
      function finish(err, root) {
        if (!callback)
          return;
        if (sync)
          throw err;
        var cb = callback;
        callback = null;
        cb(err, root);
      }
      function getBundledFileName(filename2) {
        var idx = filename2.lastIndexOf("google/protobuf/");
        if (idx > -1) {
          var altname = filename2.substring(idx);
          if (altname in common) return altname;
        }
        return null;
      }
      function process2(filename2, source) {
        try {
          if (util.isString(source) && source.charAt(0) === "{")
            source = JSON.parse(source);
          if (!util.isString(source))
            self2.setOptions(source.options).addJSON(source.nested);
          else {
            parse.filename = filename2;
            var parsed = parse(source, self2, options), resolved2, i2 = 0;
            if (parsed.imports) {
              for (; i2 < parsed.imports.length; ++i2)
                if (resolved2 = getBundledFileName(parsed.imports[i2]) || self2.resolvePath(filename2, parsed.imports[i2]))
                  fetch(resolved2);
            }
            if (parsed.weakImports) {
              for (i2 = 0; i2 < parsed.weakImports.length; ++i2)
                if (resolved2 = getBundledFileName(parsed.weakImports[i2]) || self2.resolvePath(filename2, parsed.weakImports[i2]))
                  fetch(resolved2, true);
            }
          }
        } catch (err) {
          finish(err);
        }
        if (!sync && !queued)
          finish(null, self2);
      }
      function fetch(filename2, weak) {
        filename2 = getBundledFileName(filename2) || filename2;
        if (self2.files.indexOf(filename2) > -1)
          return;
        self2.files.push(filename2);
        if (filename2 in common) {
          if (sync)
            process2(filename2, common[filename2]);
          else {
            ++queued;
            setTimeout(function() {
              --queued;
              process2(filename2, common[filename2]);
            });
          }
          return;
        }
        if (sync) {
          var source;
          try {
            source = util.fs.readFileSync(filename2).toString("utf8");
          } catch (err) {
            if (!weak)
              finish(err);
            return;
          }
          process2(filename2, source);
        } else {
          ++queued;
          self2.fetch(filename2, function(err, source2) {
            --queued;
            if (!callback)
              return;
            if (err) {
              if (!weak)
                finish(err);
              else if (!queued)
                finish(null, self2);
              return;
            }
            process2(filename2, source2);
          });
        }
      }
      var queued = 0;
      if (util.isString(filename))
        filename = [filename];
      for (var i = 0, resolved; i < filename.length; ++i)
        if (resolved = self2.resolvePath("", filename[i]))
          fetch(resolved);
      if (sync)
        return self2;
      if (!queued)
        finish(null, self2);
      return void 0;
    };
    Root.prototype.loadSync = function loadSync(filename, options) {
      if (!util.isNode)
        throw Error("not supported");
      return this.load(filename, options, SYNC);
    };
    Root.prototype.resolveAll = function resolveAll() {
      if (this.deferred.length)
        throw Error("unresolvable extensions: " + this.deferred.map(function(field) {
          return "'extend " + field.extend + "' in " + field.parent.fullName;
        }).join(", "));
      return Namespace.prototype.resolveAll.call(this);
    };
    var exposeRe = /^[A-Z]/;
    function tryHandleExtension(root, field) {
      var extendedType = field.parent.lookup(field.extend);
      if (extendedType) {
        var sisterField = new Field2(field.fullName, field.id, field.type, field.rule, void 0, field.options);
        if (extendedType.get(sisterField.name)) {
          return true;
        }
        sisterField.declaringField = field;
        field.extensionField = sisterField;
        extendedType.add(sisterField);
        return true;
      }
      return false;
    }
    Root.prototype._handleAdd = function _handleAdd(object) {
      if (object instanceof Field2) {
        if (
          /* an extension field (implies not part of a oneof) */
          object.extend !== void 0 && /* not already handled */
          !object.extensionField
        ) {
          if (!tryHandleExtension(this, object))
            this.deferred.push(object);
        }
      } else if (object instanceof Enum) {
        if (exposeRe.test(object.name))
          object.parent[object.name] = object.values;
      } else if (!(object instanceof OneOf)) {
        if (object instanceof Type)
          for (var i = 0; i < this.deferred.length; )
            if (tryHandleExtension(this, this.deferred[i]))
              this.deferred.splice(i, 1);
            else
              ++i;
        for (var j = 0; j < /* initializes */
        object.nestedArray.length; ++j)
          this._handleAdd(object._nestedArray[j]);
        if (exposeRe.test(object.name))
          object.parent[object.name] = object;
      }
    };
    Root.prototype._handleRemove = function _handleRemove(object) {
      if (object instanceof Field2) {
        if (
          /* an extension field */
          object.extend !== void 0
        ) {
          if (
            /* already handled */
            object.extensionField
          ) {
            object.extensionField.parent.remove(object.extensionField);
            object.extensionField = null;
          } else {
            var index = this.deferred.indexOf(object);
            if (index > -1)
              this.deferred.splice(index, 1);
          }
        }
      } else if (object instanceof Enum) {
        if (exposeRe.test(object.name))
          delete object.parent[object.name];
      } else if (object instanceof Namespace) {
        for (var i = 0; i < /* initializes */
        object.nestedArray.length; ++i)
          this._handleRemove(object._nestedArray[i]);
        if (exposeRe.test(object.name))
          delete object.parent[object.name];
      }
    };
    Root._configure = function(Type_, parse_, common_) {
      Type = Type_;
      parse = parse_;
      common = common_;
    };
  }
});

// node_modules/protobufjs/src/util.js
var require_util3 = __commonJS({
  "node_modules/protobufjs/src/util.js"(exports2, module2) {
    "use strict";
    var util = module2.exports = require_minimal();
    var roots = require_roots();
    var Type;
    var Enum;
    util.codegen = require_codegen();
    util.fetch = require_fetch();
    util.path = require_path();
    util.fs = util.inquire("fs");
    util.toArray = function toArray(object) {
      if (object) {
        var keys = Object.keys(object), array = new Array(keys.length), index = 0;
        while (index < keys.length)
          array[index] = object[keys[index++]];
        return array;
      }
      return [];
    };
    util.toObject = function toObject(array) {
      var object = {}, index = 0;
      while (index < array.length) {
        var key = array[index++], val = array[index++];
        if (val !== void 0)
          object[key] = val;
      }
      return object;
    };
    var safePropBackslashRe = /\\/g;
    var safePropQuoteRe = /"/g;
    util.isReserved = function isReserved(name) {
      return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(name);
    };
    util.safeProp = function safeProp(prop) {
      if (!/^[$\w_]+$/.test(prop) || util.isReserved(prop))
        return '["' + prop.replace(safePropBackslashRe, "\\\\").replace(safePropQuoteRe, '\\"') + '"]';
      return "." + prop;
    };
    util.ucFirst = function ucFirst(str) {
      return str.charAt(0).toUpperCase() + str.substring(1);
    };
    var camelCaseRe = /_([a-z])/g;
    util.camelCase = function camelCase(str) {
      return str.substring(0, 1) + str.substring(1).replace(camelCaseRe, function($0, $1) {
        return $1.toUpperCase();
      });
    };
    util.compareFieldsById = function compareFieldsById(a, b2) {
      return a.id - b2.id;
    };
    util.decorateType = function decorateType(ctor, typeName) {
      if (ctor.$type) {
        if (typeName && ctor.$type.name !== typeName) {
          util.decorateRoot.remove(ctor.$type);
          ctor.$type.name = typeName;
          util.decorateRoot.add(ctor.$type);
        }
        return ctor.$type;
      }
      if (!Type)
        Type = require_type8();
      var type = new Type(typeName || ctor.name);
      util.decorateRoot.add(type);
      type.ctor = ctor;
      Object.defineProperty(ctor, "$type", { value: type, enumerable: false });
      Object.defineProperty(ctor.prototype, "$type", { value: type, enumerable: false });
      return type;
    };
    var decorateEnumIndex = 0;
    util.decorateEnum = function decorateEnum(object) {
      if (object.$type)
        return object.$type;
      if (!Enum)
        Enum = require_enum3();
      var enm = new Enum("Enum" + decorateEnumIndex++, object);
      util.decorateRoot.add(enm);
      Object.defineProperty(object, "$type", { value: enm, enumerable: false });
      return enm;
    };
    util.setProperty = function setProperty(dst, path, value) {
      function setProp(dst2, path2, value2) {
        var part = path2.shift();
        if (part === "__proto__" || part === "prototype") {
          return dst2;
        }
        if (path2.length > 0) {
          dst2[part] = setProp(dst2[part] || {}, path2, value2);
        } else {
          var prevValue = dst2[part];
          if (prevValue)
            value2 = [].concat(prevValue).concat(value2);
          dst2[part] = value2;
        }
        return dst2;
      }
      if (typeof dst !== "object")
        throw TypeError("dst must be an object");
      if (!path)
        throw TypeError("path must be specified");
      path = path.split(".");
      return setProp(dst, path, value);
    };
    Object.defineProperty(util, "decorateRoot", {
      get: function() {
        return roots["decorated"] || (roots["decorated"] = new (require_root())());
      }
    });
  }
});

// node_modules/protobufjs/src/object.js
var require_object3 = __commonJS({
  "node_modules/protobufjs/src/object.js"(exports2, module2) {
    "use strict";
    module2.exports = ReflectionObject;
    ReflectionObject.className = "ReflectionObject";
    var util = require_util3();
    var Root;
    function ReflectionObject(name, options) {
      if (!util.isString(name))
        throw TypeError("name must be a string");
      if (options && !util.isObject(options))
        throw TypeError("options must be an object");
      this.options = options;
      this.parsedOptions = null;
      this.name = name;
      this.parent = null;
      this.resolved = false;
      this.comment = null;
      this.filename = null;
    }
    Object.defineProperties(ReflectionObject.prototype, {
      /**
       * Reference to the root namespace.
       * @name ReflectionObject#root
       * @type {Root}
       * @readonly
       */
      root: {
        get: function() {
          var ptr = this;
          while (ptr.parent !== null)
            ptr = ptr.parent;
          return ptr;
        }
      },
      /**
       * Full name including leading dot.
       * @name ReflectionObject#fullName
       * @type {string}
       * @readonly
       */
      fullName: {
        get: function() {
          var path = [this.name], ptr = this.parent;
          while (ptr) {
            path.unshift(ptr.name);
            ptr = ptr.parent;
          }
          return path.join(".");
        }
      }
    });
    ReflectionObject.prototype.toJSON = /* istanbul ignore next */
    function toJSON() {
      throw Error();
    };
    ReflectionObject.prototype.onAdd = function onAdd(parent) {
      if (this.parent && this.parent !== parent)
        this.parent.remove(this);
      this.parent = parent;
      this.resolved = false;
      var root = parent.root;
      if (root instanceof Root)
        root._handleAdd(this);
    };
    ReflectionObject.prototype.onRemove = function onRemove(parent) {
      var root = parent.root;
      if (root instanceof Root)
        root._handleRemove(this);
      this.parent = null;
      this.resolved = false;
    };
    ReflectionObject.prototype.resolve = function resolve() {
      if (this.resolved)
        return this;
      if (this.root instanceof Root)
        this.resolved = true;
      return this;
    };
    ReflectionObject.prototype.getOption = function getOption(name) {
      if (this.options)
        return this.options[name];
      return void 0;
    };
    ReflectionObject.prototype.setOption = function setOption(name, value, ifNotSet) {
      if (!ifNotSet || !this.options || this.options[name] === void 0)
        (this.options || (this.options = {}))[name] = value;
      return this;
    };
    ReflectionObject.prototype.setParsedOption = function setParsedOption(name, value, propName) {
      if (!this.parsedOptions) {
        this.parsedOptions = [];
      }
      var parsedOptions = this.parsedOptions;
      if (propName) {
        var opt = parsedOptions.find(function(opt2) {
          return Object.prototype.hasOwnProperty.call(opt2, name);
        });
        if (opt) {
          var newValue = opt[name];
          util.setProperty(newValue, propName, value);
        } else {
          opt = {};
          opt[name] = util.setProperty({}, propName, value);
          parsedOptions.push(opt);
        }
      } else {
        var newOpt = {};
        newOpt[name] = value;
        parsedOptions.push(newOpt);
      }
      return this;
    };
    ReflectionObject.prototype.setOptions = function setOptions(options, ifNotSet) {
      if (options)
        for (var keys = Object.keys(options), i = 0; i < keys.length; ++i)
          this.setOption(keys[i], options[keys[i]], ifNotSet);
      return this;
    };
    ReflectionObject.prototype.toString = function toString() {
      var className = this.constructor.className, fullName = this.fullName;
      if (fullName.length)
        return className + " " + fullName;
      return className;
    };
    ReflectionObject._configure = function(Root_) {
      Root = Root_;
    };
  }
});

// node_modules/protobufjs/src/enum.js
var require_enum3 = __commonJS({
  "node_modules/protobufjs/src/enum.js"(exports2, module2) {
    "use strict";
    module2.exports = Enum;
    var ReflectionObject = require_object3();
    ((Enum.prototype = Object.create(ReflectionObject.prototype)).constructor = Enum).className = "Enum";
    var Namespace = require_namespace();
    var util = require_util3();
    function Enum(name, values, options, comment, comments, valuesOptions) {
      ReflectionObject.call(this, name, options);
      if (values && typeof values !== "object")
        throw TypeError("values must be an object");
      this.valuesById = {};
      this.values = Object.create(this.valuesById);
      this.comment = comment;
      this.comments = comments || {};
      this.valuesOptions = valuesOptions;
      this.reserved = void 0;
      if (values) {
        for (var keys = Object.keys(values), i = 0; i < keys.length; ++i)
          if (typeof values[keys[i]] === "number")
            this.valuesById[this.values[keys[i]] = values[keys[i]]] = keys[i];
      }
    }
    Enum.fromJSON = function fromJSON(name, json) {
      var enm = new Enum(name, json.values, json.options, json.comment, json.comments);
      enm.reserved = json.reserved;
      return enm;
    };
    Enum.prototype.toJSON = function toJSON(toJSONOptions) {
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util.toObject([
        "options",
        this.options,
        "valuesOptions",
        this.valuesOptions,
        "values",
        this.values,
        "reserved",
        this.reserved && this.reserved.length ? this.reserved : void 0,
        "comment",
        keepComments ? this.comment : void 0,
        "comments",
        keepComments ? this.comments : void 0
      ]);
    };
    Enum.prototype.add = function add(name, id2, comment, options) {
      if (!util.isString(name))
        throw TypeError("name must be a string");
      if (!util.isInteger(id2))
        throw TypeError("id must be an integer");
      if (this.values[name] !== void 0)
        throw Error("duplicate name '" + name + "' in " + this);
      if (this.isReservedId(id2))
        throw Error("id " + id2 + " is reserved in " + this);
      if (this.isReservedName(name))
        throw Error("name '" + name + "' is reserved in " + this);
      if (this.valuesById[id2] !== void 0) {
        if (!(this.options && this.options.allow_alias))
          throw Error("duplicate id " + id2 + " in " + this);
        this.values[name] = id2;
      } else
        this.valuesById[this.values[name] = id2] = name;
      if (options) {
        if (this.valuesOptions === void 0)
          this.valuesOptions = {};
        this.valuesOptions[name] = options || null;
      }
      this.comments[name] = comment || null;
      return this;
    };
    Enum.prototype.remove = function remove(name) {
      if (!util.isString(name))
        throw TypeError("name must be a string");
      var val = this.values[name];
      if (val == null)
        throw Error("name '" + name + "' does not exist in " + this);
      delete this.valuesById[val];
      delete this.values[name];
      delete this.comments[name];
      if (this.valuesOptions)
        delete this.valuesOptions[name];
      return this;
    };
    Enum.prototype.isReservedId = function isReservedId(id2) {
      return Namespace.isReservedId(this.reserved, id2);
    };
    Enum.prototype.isReservedName = function isReservedName(name) {
      return Namespace.isReservedName(this.reserved, name);
    };
  }
});

// node_modules/protobufjs/src/encoder.js
var require_encoder = __commonJS({
  "node_modules/protobufjs/src/encoder.js"(exports2, module2) {
    "use strict";
    module2.exports = encoder;
    var Enum = require_enum3();
    var types = require_types2();
    var util = require_util3();
    function genTypePartial(gen, field, fieldIndex, ref) {
      return field.resolvedType.group ? gen("types[%i].encode(%s,w.uint32(%i)).uint32(%i)", fieldIndex, ref, (field.id << 3 | 3) >>> 0, (field.id << 3 | 4) >>> 0) : gen("types[%i].encode(%s,w.uint32(%i).fork()).ldelim()", fieldIndex, ref, (field.id << 3 | 2) >>> 0);
    }
    function encoder(mtype) {
      var gen = util.codegen(["m", "w"], mtype.name + "$encode")("if(!w)")("w=Writer.create()");
      var i, ref;
      var fields = (
        /* initializes */
        mtype.fieldsArray.slice().sort(util.compareFieldsById)
      );
      for (var i = 0; i < fields.length; ++i) {
        var field = fields[i].resolve(), index = mtype._fieldsArray.indexOf(field), type = field.resolvedType instanceof Enum ? "int32" : field.type, wireType = types.basic[type];
        ref = "m" + util.safeProp(field.name);
        if (field.map) {
          gen("if(%s!=null&&Object.hasOwnProperty.call(m,%j)){", ref, field.name)("for(var ks=Object.keys(%s),i=0;i<ks.length;++i){", ref)("w.uint32(%i).fork().uint32(%i).%s(ks[i])", (field.id << 3 | 2) >>> 0, 8 | types.mapKey[field.keyType], field.keyType);
          if (wireType === void 0) gen("types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()", index, ref);
          else gen(".uint32(%i).%s(%s[ks[i]]).ldelim()", 16 | wireType, type, ref);
          gen("}")("}");
        } else if (field.repeated) {
          gen("if(%s!=null&&%s.length){", ref, ref);
          if (field.packed && types.packed[type] !== void 0) {
            gen("w.uint32(%i).fork()", (field.id << 3 | 2) >>> 0)("for(var i=0;i<%s.length;++i)", ref)("w.%s(%s[i])", type, ref)("w.ldelim()");
          } else {
            gen("for(var i=0;i<%s.length;++i)", ref);
            if (wireType === void 0)
              genTypePartial(gen, field, index, ref + "[i]");
            else gen("w.uint32(%i).%s(%s[i])", (field.id << 3 | wireType) >>> 0, type, ref);
          }
          gen("}");
        } else {
          if (field.optional) gen("if(%s!=null&&Object.hasOwnProperty.call(m,%j))", ref, field.name);
          if (wireType === void 0)
            genTypePartial(gen, field, index, ref);
          else gen("w.uint32(%i).%s(%s)", (field.id << 3 | wireType) >>> 0, type, ref);
        }
      }
      return gen("return w");
    }
  }
});

// node_modules/protobufjs/src/index-light.js
var require_index_light = __commonJS({
  "node_modules/protobufjs/src/index-light.js"(exports2, module2) {
    "use strict";
    var protobuf = module2.exports = require_index_minimal();
    protobuf.build = "light";
    function load(filename, root, callback) {
      if (typeof root === "function") {
        callback = root;
        root = new protobuf.Root();
      } else if (!root)
        root = new protobuf.Root();
      return root.load(filename, callback);
    }
    protobuf.load = load;
    function loadSync(filename, root) {
      if (!root)
        root = new protobuf.Root();
      return root.loadSync(filename);
    }
    protobuf.loadSync = loadSync;
    protobuf.encoder = require_encoder();
    protobuf.decoder = require_decoder();
    protobuf.verifier = require_verifier();
    protobuf.converter = require_converter2();
    protobuf.ReflectionObject = require_object3();
    protobuf.Namespace = require_namespace();
    protobuf.Root = require_root();
    protobuf.Enum = require_enum3();
    protobuf.Type = require_type8();
    protobuf.Field = require_field();
    protobuf.OneOf = require_oneof();
    protobuf.MapField = require_mapfield();
    protobuf.Service = require_service2();
    protobuf.Method = require_method();
    protobuf.Message = require_message();
    protobuf.wrappers = require_wrappers();
    protobuf.types = require_types2();
    protobuf.util = require_util3();
    protobuf.ReflectionObject._configure(protobuf.Root);
    protobuf.Namespace._configure(protobuf.Type, protobuf.Service, protobuf.Enum);
    protobuf.Root._configure(protobuf.Type);
    protobuf.Field._configure(protobuf.Type);
  }
});

// node_modules/protobufjs/light.js
var require_light = __commonJS({
  "node_modules/protobufjs/light.js"(exports2, module2) {
    "use strict";
    module2.exports = require_index_light();
  }
});

// node_modules/@trezor/protobuf/lib/utils.js
var require_utils6 = __commonJS({
  "node_modules/@trezor/protobuf/lib/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createMessageFromType = exports2.createMessageFromName = exports2.isPrimitiveField = void 0;
    exports2.parseConfigure = parseConfigure;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var protobuf = tslib_1.__importStar(require_light());
    var primitiveTypes = [
      "bool",
      "string",
      "bytes",
      "int32",
      "int64",
      "uint32",
      "uint64",
      "sint32",
      "sint64",
      "fixed32",
      "fixed64",
      "sfixed32",
      "sfixed64",
      "double",
      "float"
    ];
    var isPrimitiveField = (field) => primitiveTypes.includes(field);
    exports2.isPrimitiveField = isPrimitiveField;
    function parseConfigure(data) {
      if (typeof data === "string") {
        return protobuf.Root.fromJSON(JSON.parse(data));
      }
      return protobuf.Root.fromJSON(data);
    }
    var createMessageFromName = (messages, name) => {
      const Message = messages.lookupType(name);
      const messageTypes = messages.lookupEnum("MessageType");
      let messageTypeId = messageTypes.values[name];
      if (typeof messageTypeId !== "number" && Message.options) {
        messageTypeId = Message.options["(wire_type)"];
      }
      return {
        Message,
        messageType: messageTypeId ?? name
      };
    };
    exports2.createMessageFromName = createMessageFromName;
    var createMessageFromType = (messages, messageType) => {
      if (typeof messageType === "string") {
        const Message2 = messages.lookupType(messageType);
        return {
          Message: Message2,
          messageName: messageType
        };
      }
      const messageTypes = messages.lookupEnum("MessageType");
      const messageName = messageTypes.valuesById[messageType];
      const Message = messages.lookupType(messageName);
      return {
        Message,
        messageName
      };
    };
    exports2.createMessageFromType = createMessageFromType;
  }
});

// node_modules/@trezor/protobuf/lib/decode.js
var require_decode2 = __commonJS({
  "node_modules/@trezor/protobuf/lib/decode.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeMessage = exports2.decode = void 0;
    var utils_1 = require_utils6();
    var transform = (field, value) => {
      if ((0, utils_1.isPrimitiveField)(field.type)) {
        if (field.optional && typeof value === "undefined") {
          return null;
        }
        if (field.type === "bytes") {
          return Buffer.from(value).toString("hex");
        }
        if (field.long) {
          if (Number.isSafeInteger(value.toNumber())) {
            return value.toNumber();
          }
          return value.toString();
        }
        return value;
      }
      if ("valuesById" in field.resolvedType) {
        return field.resolvedType.valuesById[value];
      }
      if (field.resolvedType.fields) {
        return messageToJSON(value, field.resolvedType.fields);
      }
      throw new Error(`transport: decode: case not handled: ${field}`);
    };
    function messageToJSON(MessageParam, fields) {
      if (!MessageParam) {
        return {};
      }
      const { ...message } = MessageParam;
      const res = {};
      Object.keys(fields).forEach((key) => {
        const field = fields[key];
        const value = message[key];
        if (field.repeated) {
          res[key] = value.map((v) => transform(field, v));
        } else {
          res[key] = transform(field, value);
        }
      });
      return res;
    }
    var decode = (MessageParam, data) => {
      const decoded = MessageParam.decode(new Uint8Array(data));
      return messageToJSON(decoded, decoded.$type.fields);
    };
    exports2.decode = decode;
    var decodeMessage = (messages, messageType, data) => {
      const { Message, messageName } = (0, utils_1.createMessageFromType)(messages, messageType);
      const message = (0, exports2.decode)(Message, data);
      return { type: messageName, message };
    };
    exports2.decodeMessage = decodeMessage;
  }
});

// node_modules/@trezor/protobuf/lib/encode.js
var require_encode = __commonJS({
  "node_modules/@trezor/protobuf/lib/encode.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.encodeMessage = exports2.encode = void 0;
    var light_1 = require_light();
    var utils_1 = require_utils6();
    var transform = (fieldType, value) => {
      if (fieldType === "bytes") {
        if (typeof value === "string" && !value)
          return value;
        return Buffer.from(value, "hex");
      }
      if (typeof value === "number" && !Number.isSafeInteger(value)) {
        throw new RangeError("field value is not within safe integer range");
      }
      if (fieldType === "string" && typeof value === "string") {
        value = value.replace(/[]/g, "'");
      }
      return value;
    };
    function patch(Message, payload) {
      const patched = {};
      if (!Message.fields) {
        return patched;
      }
      Object.keys(Message.fields).forEach((key) => {
        const field = Message.fields[key];
        const value = payload[key];
        if (typeof value === "undefined") {
          return;
        }
        if ((0, utils_1.isPrimitiveField)(field.type)) {
          if (field.repeated) {
            patched[key] = value.map((v) => transform(field.type, v));
          } else {
            patched[key] = transform(field.type, value);
          }
          return;
        }
        if (field.repeated) {
          const fieldType = Message.lookupTypeOrEnum(field.type);
          if (fieldType instanceof light_1.Enum) {
            patched[key] = value;
          } else {
            patched[key] = value.map((v) => patch(fieldType, v));
          }
        } else if (typeof value === "object" && value !== null) {
          const RefMessage = Message.lookupType(field.type);
          patched[key] = patch(RefMessage, value);
        } else if (typeof value === "number") {
          const RefMessage = Message.lookupEnum(field.type);
          patched[key] = RefMessage.values[value];
        } else {
          patched[key] = value;
        }
      });
      return patched;
    }
    var encode = (Message, data) => {
      const payload = patch(Message, data);
      const message = Message.fromObject(payload);
      const bytes = Message.encode(message).finish();
      return Buffer.from(bytes);
    };
    exports2.encode = encode;
    var encodeMessage = (messages, messageName, data) => {
      const { Message, messageType } = (0, utils_1.createMessageFromName)(messages, messageName);
      const message = (0, exports2.encode)(Message, data);
      return { messageType, message };
    };
    exports2.encodeMessage = encodeMessage;
  }
});

// node_modules/@trezor/protobuf/lib/messages.js
var require_messages = __commonJS({
  "node_modules/@trezor/protobuf/lib/messages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TezosBallotType = exports2.TezosContractType = exports2.StellarSignerType = exports2.StellarMemoType = exports2.StellarAssetType = exports2.NEMImportanceTransferMode = exports2.NEMModificationType = exports2.NEMSupplyChangeType = exports2.NEMMosaicLevy = exports2.BootCommand = exports2.Enum_WordRequestType = exports2.SdProtectOperationType = exports2.Enum_RecoveryType = exports2.RecoveryDeviceInputMethod = exports2.Enum_Capability = exports2.Enum_RecoveryStatus = exports2.Enum_BackupAvailability = exports2.Enum_HomescreenFormat = exports2.Enum_DisplayRotation = exports2.Enum_SafetyCheckLevel = exports2.Enum_BackupType = exports2.EthereumDataType = exports2.DefinitionType = exports2.DebugWaitType = exports2.DebugTouchEventType = exports2.DebugPhysicalButton = exports2.DebugButton = exports2.Enum_PinMatrixRequestType = exports2.Enum_ButtonRequestType = exports2.Enum_FailureType = exports2.CardanoTxWitnessType = exports2.CardanoTxSigningMode = exports2.CardanoCVoteRegistrationFormat = exports2.CardanoTxAuxiliaryDataSupplementType = exports2.CardanoPoolRelayType = exports2.CardanoDRepType = exports2.CardanoCertificateType = exports2.CardanoTxOutputSerializationFormat = exports2.CardanoNativeScriptHashDisplayFormat = exports2.CardanoNativeScriptType = exports2.CardanoAddressType = exports2.CardanoDerivationType = exports2.Enum_RequestType = exports2.MultisigPubkeysOrder = exports2.AmountUnit = exports2.DecredStakingSpendType = exports2.Enum_OutputScriptType = exports2.Enum_InputScriptType = exports2.DeviceModelInternal = void 0;
    var DeviceModelInternal;
    (function(DeviceModelInternal2) {
      DeviceModelInternal2["T1B1"] = "T1B1";
      DeviceModelInternal2["T2T1"] = "T2T1";
      DeviceModelInternal2["T2B1"] = "T2B1";
      DeviceModelInternal2["T3B1"] = "T3B1";
      DeviceModelInternal2["T3T1"] = "T3T1";
      DeviceModelInternal2["T3W1"] = "T3W1";
      DeviceModelInternal2["UNKNOWN"] = "UNKNOWN";
    })(DeviceModelInternal || (exports2.DeviceModelInternal = DeviceModelInternal = {}));
    var Enum_InputScriptType;
    (function(Enum_InputScriptType2) {
      Enum_InputScriptType2[Enum_InputScriptType2["SPENDADDRESS"] = 0] = "SPENDADDRESS";
      Enum_InputScriptType2[Enum_InputScriptType2["SPENDMULTISIG"] = 1] = "SPENDMULTISIG";
      Enum_InputScriptType2[Enum_InputScriptType2["EXTERNAL"] = 2] = "EXTERNAL";
      Enum_InputScriptType2[Enum_InputScriptType2["SPENDWITNESS"] = 3] = "SPENDWITNESS";
      Enum_InputScriptType2[Enum_InputScriptType2["SPENDP2SHWITNESS"] = 4] = "SPENDP2SHWITNESS";
      Enum_InputScriptType2[Enum_InputScriptType2["SPENDTAPROOT"] = 5] = "SPENDTAPROOT";
    })(Enum_InputScriptType || (exports2.Enum_InputScriptType = Enum_InputScriptType = {}));
    var Enum_OutputScriptType;
    (function(Enum_OutputScriptType2) {
      Enum_OutputScriptType2[Enum_OutputScriptType2["PAYTOADDRESS"] = 0] = "PAYTOADDRESS";
      Enum_OutputScriptType2[Enum_OutputScriptType2["PAYTOSCRIPTHASH"] = 1] = "PAYTOSCRIPTHASH";
      Enum_OutputScriptType2[Enum_OutputScriptType2["PAYTOMULTISIG"] = 2] = "PAYTOMULTISIG";
      Enum_OutputScriptType2[Enum_OutputScriptType2["PAYTOOPRETURN"] = 3] = "PAYTOOPRETURN";
      Enum_OutputScriptType2[Enum_OutputScriptType2["PAYTOWITNESS"] = 4] = "PAYTOWITNESS";
      Enum_OutputScriptType2[Enum_OutputScriptType2["PAYTOP2SHWITNESS"] = 5] = "PAYTOP2SHWITNESS";
      Enum_OutputScriptType2[Enum_OutputScriptType2["PAYTOTAPROOT"] = 6] = "PAYTOTAPROOT";
    })(Enum_OutputScriptType || (exports2.Enum_OutputScriptType = Enum_OutputScriptType = {}));
    var DecredStakingSpendType;
    (function(DecredStakingSpendType2) {
      DecredStakingSpendType2[DecredStakingSpendType2["SSGen"] = 0] = "SSGen";
      DecredStakingSpendType2[DecredStakingSpendType2["SSRTX"] = 1] = "SSRTX";
    })(DecredStakingSpendType || (exports2.DecredStakingSpendType = DecredStakingSpendType = {}));
    var AmountUnit;
    (function(AmountUnit2) {
      AmountUnit2[AmountUnit2["BITCOIN"] = 0] = "BITCOIN";
      AmountUnit2[AmountUnit2["MILLIBITCOIN"] = 1] = "MILLIBITCOIN";
      AmountUnit2[AmountUnit2["MICROBITCOIN"] = 2] = "MICROBITCOIN";
      AmountUnit2[AmountUnit2["SATOSHI"] = 3] = "SATOSHI";
    })(AmountUnit || (exports2.AmountUnit = AmountUnit = {}));
    var MultisigPubkeysOrder;
    (function(MultisigPubkeysOrder2) {
      MultisigPubkeysOrder2[MultisigPubkeysOrder2["PRESERVED"] = 0] = "PRESERVED";
      MultisigPubkeysOrder2[MultisigPubkeysOrder2["LEXICOGRAPHIC"] = 1] = "LEXICOGRAPHIC";
    })(MultisigPubkeysOrder || (exports2.MultisigPubkeysOrder = MultisigPubkeysOrder = {}));
    var Enum_RequestType;
    (function(Enum_RequestType2) {
      Enum_RequestType2[Enum_RequestType2["TXINPUT"] = 0] = "TXINPUT";
      Enum_RequestType2[Enum_RequestType2["TXOUTPUT"] = 1] = "TXOUTPUT";
      Enum_RequestType2[Enum_RequestType2["TXMETA"] = 2] = "TXMETA";
      Enum_RequestType2[Enum_RequestType2["TXFINISHED"] = 3] = "TXFINISHED";
      Enum_RequestType2[Enum_RequestType2["TXEXTRADATA"] = 4] = "TXEXTRADATA";
      Enum_RequestType2[Enum_RequestType2["TXORIGINPUT"] = 5] = "TXORIGINPUT";
      Enum_RequestType2[Enum_RequestType2["TXORIGOUTPUT"] = 6] = "TXORIGOUTPUT";
      Enum_RequestType2[Enum_RequestType2["TXPAYMENTREQ"] = 7] = "TXPAYMENTREQ";
    })(Enum_RequestType || (exports2.Enum_RequestType = Enum_RequestType = {}));
    var CardanoDerivationType;
    (function(CardanoDerivationType2) {
      CardanoDerivationType2[CardanoDerivationType2["LEDGER"] = 0] = "LEDGER";
      CardanoDerivationType2[CardanoDerivationType2["ICARUS"] = 1] = "ICARUS";
      CardanoDerivationType2[CardanoDerivationType2["ICARUS_TREZOR"] = 2] = "ICARUS_TREZOR";
    })(CardanoDerivationType || (exports2.CardanoDerivationType = CardanoDerivationType = {}));
    var CardanoAddressType;
    (function(CardanoAddressType2) {
      CardanoAddressType2[CardanoAddressType2["BASE"] = 0] = "BASE";
      CardanoAddressType2[CardanoAddressType2["BASE_SCRIPT_KEY"] = 1] = "BASE_SCRIPT_KEY";
      CardanoAddressType2[CardanoAddressType2["BASE_KEY_SCRIPT"] = 2] = "BASE_KEY_SCRIPT";
      CardanoAddressType2[CardanoAddressType2["BASE_SCRIPT_SCRIPT"] = 3] = "BASE_SCRIPT_SCRIPT";
      CardanoAddressType2[CardanoAddressType2["POINTER"] = 4] = "POINTER";
      CardanoAddressType2[CardanoAddressType2["POINTER_SCRIPT"] = 5] = "POINTER_SCRIPT";
      CardanoAddressType2[CardanoAddressType2["ENTERPRISE"] = 6] = "ENTERPRISE";
      CardanoAddressType2[CardanoAddressType2["ENTERPRISE_SCRIPT"] = 7] = "ENTERPRISE_SCRIPT";
      CardanoAddressType2[CardanoAddressType2["BYRON"] = 8] = "BYRON";
      CardanoAddressType2[CardanoAddressType2["REWARD"] = 14] = "REWARD";
      CardanoAddressType2[CardanoAddressType2["REWARD_SCRIPT"] = 15] = "REWARD_SCRIPT";
    })(CardanoAddressType || (exports2.CardanoAddressType = CardanoAddressType = {}));
    var CardanoNativeScriptType;
    (function(CardanoNativeScriptType2) {
      CardanoNativeScriptType2[CardanoNativeScriptType2["PUB_KEY"] = 0] = "PUB_KEY";
      CardanoNativeScriptType2[CardanoNativeScriptType2["ALL"] = 1] = "ALL";
      CardanoNativeScriptType2[CardanoNativeScriptType2["ANY"] = 2] = "ANY";
      CardanoNativeScriptType2[CardanoNativeScriptType2["N_OF_K"] = 3] = "N_OF_K";
      CardanoNativeScriptType2[CardanoNativeScriptType2["INVALID_BEFORE"] = 4] = "INVALID_BEFORE";
      CardanoNativeScriptType2[CardanoNativeScriptType2["INVALID_HEREAFTER"] = 5] = "INVALID_HEREAFTER";
    })(CardanoNativeScriptType || (exports2.CardanoNativeScriptType = CardanoNativeScriptType = {}));
    var CardanoNativeScriptHashDisplayFormat;
    (function(CardanoNativeScriptHashDisplayFormat2) {
      CardanoNativeScriptHashDisplayFormat2[CardanoNativeScriptHashDisplayFormat2["HIDE"] = 0] = "HIDE";
      CardanoNativeScriptHashDisplayFormat2[CardanoNativeScriptHashDisplayFormat2["BECH32"] = 1] = "BECH32";
      CardanoNativeScriptHashDisplayFormat2[CardanoNativeScriptHashDisplayFormat2["POLICY_ID"] = 2] = "POLICY_ID";
    })(CardanoNativeScriptHashDisplayFormat || (exports2.CardanoNativeScriptHashDisplayFormat = CardanoNativeScriptHashDisplayFormat = {}));
    var CardanoTxOutputSerializationFormat;
    (function(CardanoTxOutputSerializationFormat2) {
      CardanoTxOutputSerializationFormat2[CardanoTxOutputSerializationFormat2["ARRAY_LEGACY"] = 0] = "ARRAY_LEGACY";
      CardanoTxOutputSerializationFormat2[CardanoTxOutputSerializationFormat2["MAP_BABBAGE"] = 1] = "MAP_BABBAGE";
    })(CardanoTxOutputSerializationFormat || (exports2.CardanoTxOutputSerializationFormat = CardanoTxOutputSerializationFormat = {}));
    var CardanoCertificateType;
    (function(CardanoCertificateType2) {
      CardanoCertificateType2[CardanoCertificateType2["STAKE_REGISTRATION"] = 0] = "STAKE_REGISTRATION";
      CardanoCertificateType2[CardanoCertificateType2["STAKE_DEREGISTRATION"] = 1] = "STAKE_DEREGISTRATION";
      CardanoCertificateType2[CardanoCertificateType2["STAKE_DELEGATION"] = 2] = "STAKE_DELEGATION";
      CardanoCertificateType2[CardanoCertificateType2["STAKE_POOL_REGISTRATION"] = 3] = "STAKE_POOL_REGISTRATION";
      CardanoCertificateType2[CardanoCertificateType2["STAKE_REGISTRATION_CONWAY"] = 7] = "STAKE_REGISTRATION_CONWAY";
      CardanoCertificateType2[CardanoCertificateType2["STAKE_DEREGISTRATION_CONWAY"] = 8] = "STAKE_DEREGISTRATION_CONWAY";
      CardanoCertificateType2[CardanoCertificateType2["VOTE_DELEGATION"] = 9] = "VOTE_DELEGATION";
    })(CardanoCertificateType || (exports2.CardanoCertificateType = CardanoCertificateType = {}));
    var CardanoDRepType;
    (function(CardanoDRepType2) {
      CardanoDRepType2[CardanoDRepType2["KEY_HASH"] = 0] = "KEY_HASH";
      CardanoDRepType2[CardanoDRepType2["SCRIPT_HASH"] = 1] = "SCRIPT_HASH";
      CardanoDRepType2[CardanoDRepType2["ABSTAIN"] = 2] = "ABSTAIN";
      CardanoDRepType2[CardanoDRepType2["NO_CONFIDENCE"] = 3] = "NO_CONFIDENCE";
    })(CardanoDRepType || (exports2.CardanoDRepType = CardanoDRepType = {}));
    var CardanoPoolRelayType;
    (function(CardanoPoolRelayType2) {
      CardanoPoolRelayType2[CardanoPoolRelayType2["SINGLE_HOST_IP"] = 0] = "SINGLE_HOST_IP";
      CardanoPoolRelayType2[CardanoPoolRelayType2["SINGLE_HOST_NAME"] = 1] = "SINGLE_HOST_NAME";
      CardanoPoolRelayType2[CardanoPoolRelayType2["MULTIPLE_HOST_NAME"] = 2] = "MULTIPLE_HOST_NAME";
    })(CardanoPoolRelayType || (exports2.CardanoPoolRelayType = CardanoPoolRelayType = {}));
    var CardanoTxAuxiliaryDataSupplementType;
    (function(CardanoTxAuxiliaryDataSupplementType2) {
      CardanoTxAuxiliaryDataSupplementType2[CardanoTxAuxiliaryDataSupplementType2["NONE"] = 0] = "NONE";
      CardanoTxAuxiliaryDataSupplementType2[CardanoTxAuxiliaryDataSupplementType2["CVOTE_REGISTRATION_SIGNATURE"] = 1] = "CVOTE_REGISTRATION_SIGNATURE";
    })(CardanoTxAuxiliaryDataSupplementType || (exports2.CardanoTxAuxiliaryDataSupplementType = CardanoTxAuxiliaryDataSupplementType = {}));
    var CardanoCVoteRegistrationFormat;
    (function(CardanoCVoteRegistrationFormat2) {
      CardanoCVoteRegistrationFormat2[CardanoCVoteRegistrationFormat2["CIP15"] = 0] = "CIP15";
      CardanoCVoteRegistrationFormat2[CardanoCVoteRegistrationFormat2["CIP36"] = 1] = "CIP36";
    })(CardanoCVoteRegistrationFormat || (exports2.CardanoCVoteRegistrationFormat = CardanoCVoteRegistrationFormat = {}));
    var CardanoTxSigningMode;
    (function(CardanoTxSigningMode2) {
      CardanoTxSigningMode2[CardanoTxSigningMode2["ORDINARY_TRANSACTION"] = 0] = "ORDINARY_TRANSACTION";
      CardanoTxSigningMode2[CardanoTxSigningMode2["POOL_REGISTRATION_AS_OWNER"] = 1] = "POOL_REGISTRATION_AS_OWNER";
      CardanoTxSigningMode2[CardanoTxSigningMode2["MULTISIG_TRANSACTION"] = 2] = "MULTISIG_TRANSACTION";
      CardanoTxSigningMode2[CardanoTxSigningMode2["PLUTUS_TRANSACTION"] = 3] = "PLUTUS_TRANSACTION";
    })(CardanoTxSigningMode || (exports2.CardanoTxSigningMode = CardanoTxSigningMode = {}));
    var CardanoTxWitnessType;
    (function(CardanoTxWitnessType2) {
      CardanoTxWitnessType2[CardanoTxWitnessType2["BYRON_WITNESS"] = 0] = "BYRON_WITNESS";
      CardanoTxWitnessType2[CardanoTxWitnessType2["SHELLEY_WITNESS"] = 1] = "SHELLEY_WITNESS";
    })(CardanoTxWitnessType || (exports2.CardanoTxWitnessType = CardanoTxWitnessType = {}));
    var Enum_FailureType;
    (function(Enum_FailureType2) {
      Enum_FailureType2[Enum_FailureType2["Failure_UnexpectedMessage"] = 1] = "Failure_UnexpectedMessage";
      Enum_FailureType2[Enum_FailureType2["Failure_ButtonExpected"] = 2] = "Failure_ButtonExpected";
      Enum_FailureType2[Enum_FailureType2["Failure_DataError"] = 3] = "Failure_DataError";
      Enum_FailureType2[Enum_FailureType2["Failure_ActionCancelled"] = 4] = "Failure_ActionCancelled";
      Enum_FailureType2[Enum_FailureType2["Failure_PinExpected"] = 5] = "Failure_PinExpected";
      Enum_FailureType2[Enum_FailureType2["Failure_PinCancelled"] = 6] = "Failure_PinCancelled";
      Enum_FailureType2[Enum_FailureType2["Failure_PinInvalid"] = 7] = "Failure_PinInvalid";
      Enum_FailureType2[Enum_FailureType2["Failure_InvalidSignature"] = 8] = "Failure_InvalidSignature";
      Enum_FailureType2[Enum_FailureType2["Failure_ProcessError"] = 9] = "Failure_ProcessError";
      Enum_FailureType2[Enum_FailureType2["Failure_NotEnoughFunds"] = 10] = "Failure_NotEnoughFunds";
      Enum_FailureType2[Enum_FailureType2["Failure_NotInitialized"] = 11] = "Failure_NotInitialized";
      Enum_FailureType2[Enum_FailureType2["Failure_PinMismatch"] = 12] = "Failure_PinMismatch";
      Enum_FailureType2[Enum_FailureType2["Failure_WipeCodeMismatch"] = 13] = "Failure_WipeCodeMismatch";
      Enum_FailureType2[Enum_FailureType2["Failure_InvalidSession"] = 14] = "Failure_InvalidSession";
      Enum_FailureType2[Enum_FailureType2["Failure_Busy"] = 15] = "Failure_Busy";
      Enum_FailureType2[Enum_FailureType2["Failure_ThpUnallocatedSession"] = 16] = "Failure_ThpUnallocatedSession";
      Enum_FailureType2[Enum_FailureType2["Failure_InvalidProtocol"] = 17] = "Failure_InvalidProtocol";
      Enum_FailureType2[Enum_FailureType2["Failure_BufferError"] = 18] = "Failure_BufferError";
      Enum_FailureType2[Enum_FailureType2["Failure_FirmwareError"] = 99] = "Failure_FirmwareError";
    })(Enum_FailureType || (exports2.Enum_FailureType = Enum_FailureType = {}));
    var Enum_ButtonRequestType;
    (function(Enum_ButtonRequestType2) {
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_Other"] = 1] = "ButtonRequest_Other";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_FeeOverThreshold"] = 2] = "ButtonRequest_FeeOverThreshold";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_ConfirmOutput"] = 3] = "ButtonRequest_ConfirmOutput";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_ResetDevice"] = 4] = "ButtonRequest_ResetDevice";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_ConfirmWord"] = 5] = "ButtonRequest_ConfirmWord";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_WipeDevice"] = 6] = "ButtonRequest_WipeDevice";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_ProtectCall"] = 7] = "ButtonRequest_ProtectCall";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_SignTx"] = 8] = "ButtonRequest_SignTx";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_FirmwareCheck"] = 9] = "ButtonRequest_FirmwareCheck";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_Address"] = 10] = "ButtonRequest_Address";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_PublicKey"] = 11] = "ButtonRequest_PublicKey";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_MnemonicWordCount"] = 12] = "ButtonRequest_MnemonicWordCount";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_MnemonicInput"] = 13] = "ButtonRequest_MnemonicInput";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["_Deprecated_ButtonRequest_PassphraseType"] = 14] = "_Deprecated_ButtonRequest_PassphraseType";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_UnknownDerivationPath"] = 15] = "ButtonRequest_UnknownDerivationPath";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_RecoveryHomepage"] = 16] = "ButtonRequest_RecoveryHomepage";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_Success"] = 17] = "ButtonRequest_Success";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_Warning"] = 18] = "ButtonRequest_Warning";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_PassphraseEntry"] = 19] = "ButtonRequest_PassphraseEntry";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_PinEntry"] = 20] = "ButtonRequest_PinEntry";
    })(Enum_ButtonRequestType || (exports2.Enum_ButtonRequestType = Enum_ButtonRequestType = {}));
    var Enum_PinMatrixRequestType;
    (function(Enum_PinMatrixRequestType2) {
      Enum_PinMatrixRequestType2[Enum_PinMatrixRequestType2["PinMatrixRequestType_Current"] = 1] = "PinMatrixRequestType_Current";
      Enum_PinMatrixRequestType2[Enum_PinMatrixRequestType2["PinMatrixRequestType_NewFirst"] = 2] = "PinMatrixRequestType_NewFirst";
      Enum_PinMatrixRequestType2[Enum_PinMatrixRequestType2["PinMatrixRequestType_NewSecond"] = 3] = "PinMatrixRequestType_NewSecond";
      Enum_PinMatrixRequestType2[Enum_PinMatrixRequestType2["PinMatrixRequestType_WipeCodeFirst"] = 4] = "PinMatrixRequestType_WipeCodeFirst";
      Enum_PinMatrixRequestType2[Enum_PinMatrixRequestType2["PinMatrixRequestType_WipeCodeSecond"] = 5] = "PinMatrixRequestType_WipeCodeSecond";
    })(Enum_PinMatrixRequestType || (exports2.Enum_PinMatrixRequestType = Enum_PinMatrixRequestType = {}));
    var DebugButton;
    (function(DebugButton2) {
      DebugButton2[DebugButton2["NO"] = 0] = "NO";
      DebugButton2[DebugButton2["YES"] = 1] = "YES";
      DebugButton2[DebugButton2["INFO"] = 2] = "INFO";
    })(DebugButton || (exports2.DebugButton = DebugButton = {}));
    var DebugPhysicalButton;
    (function(DebugPhysicalButton2) {
      DebugPhysicalButton2[DebugPhysicalButton2["LEFT_BTN"] = 0] = "LEFT_BTN";
      DebugPhysicalButton2[DebugPhysicalButton2["MIDDLE_BTN"] = 1] = "MIDDLE_BTN";
      DebugPhysicalButton2[DebugPhysicalButton2["RIGHT_BTN"] = 2] = "RIGHT_BTN";
    })(DebugPhysicalButton || (exports2.DebugPhysicalButton = DebugPhysicalButton = {}));
    var DebugTouchEventType;
    (function(DebugTouchEventType2) {
      DebugTouchEventType2[DebugTouchEventType2["TOUCH_FULL_CLICK"] = 0] = "TOUCH_FULL_CLICK";
      DebugTouchEventType2[DebugTouchEventType2["TOUCH_START"] = 1] = "TOUCH_START";
      DebugTouchEventType2[DebugTouchEventType2["TOUCH_END"] = 2] = "TOUCH_END";
    })(DebugTouchEventType || (exports2.DebugTouchEventType = DebugTouchEventType = {}));
    var DebugWaitType;
    (function(DebugWaitType2) {
      DebugWaitType2[DebugWaitType2["IMMEDIATE"] = 0] = "IMMEDIATE";
      DebugWaitType2[DebugWaitType2["NEXT_LAYOUT"] = 1] = "NEXT_LAYOUT";
      DebugWaitType2[DebugWaitType2["CURRENT_LAYOUT"] = 2] = "CURRENT_LAYOUT";
    })(DebugWaitType || (exports2.DebugWaitType = DebugWaitType = {}));
    var DefinitionType;
    (function(DefinitionType2) {
      DefinitionType2[DefinitionType2["ETHEREUM_NETWORK"] = 0] = "ETHEREUM_NETWORK";
      DefinitionType2[DefinitionType2["ETHEREUM_TOKEN"] = 1] = "ETHEREUM_TOKEN";
      DefinitionType2[DefinitionType2["SOLANA_TOKEN"] = 2] = "SOLANA_TOKEN";
    })(DefinitionType || (exports2.DefinitionType = DefinitionType = {}));
    var EthereumDataType;
    (function(EthereumDataType2) {
      EthereumDataType2[EthereumDataType2["UINT"] = 1] = "UINT";
      EthereumDataType2[EthereumDataType2["INT"] = 2] = "INT";
      EthereumDataType2[EthereumDataType2["BYTES"] = 3] = "BYTES";
      EthereumDataType2[EthereumDataType2["STRING"] = 4] = "STRING";
      EthereumDataType2[EthereumDataType2["BOOL"] = 5] = "BOOL";
      EthereumDataType2[EthereumDataType2["ADDRESS"] = 6] = "ADDRESS";
      EthereumDataType2[EthereumDataType2["ARRAY"] = 7] = "ARRAY";
      EthereumDataType2[EthereumDataType2["STRUCT"] = 8] = "STRUCT";
    })(EthereumDataType || (exports2.EthereumDataType = EthereumDataType = {}));
    var Enum_BackupType;
    (function(Enum_BackupType2) {
      Enum_BackupType2[Enum_BackupType2["Bip39"] = 0] = "Bip39";
      Enum_BackupType2[Enum_BackupType2["Slip39_Basic"] = 1] = "Slip39_Basic";
      Enum_BackupType2[Enum_BackupType2["Slip39_Advanced"] = 2] = "Slip39_Advanced";
      Enum_BackupType2[Enum_BackupType2["Slip39_Single_Extendable"] = 3] = "Slip39_Single_Extendable";
      Enum_BackupType2[Enum_BackupType2["Slip39_Basic_Extendable"] = 4] = "Slip39_Basic_Extendable";
      Enum_BackupType2[Enum_BackupType2["Slip39_Advanced_Extendable"] = 5] = "Slip39_Advanced_Extendable";
    })(Enum_BackupType || (exports2.Enum_BackupType = Enum_BackupType = {}));
    var Enum_SafetyCheckLevel;
    (function(Enum_SafetyCheckLevel2) {
      Enum_SafetyCheckLevel2[Enum_SafetyCheckLevel2["Strict"] = 0] = "Strict";
      Enum_SafetyCheckLevel2[Enum_SafetyCheckLevel2["PromptAlways"] = 1] = "PromptAlways";
      Enum_SafetyCheckLevel2[Enum_SafetyCheckLevel2["PromptTemporarily"] = 2] = "PromptTemporarily";
    })(Enum_SafetyCheckLevel || (exports2.Enum_SafetyCheckLevel = Enum_SafetyCheckLevel = {}));
    var Enum_DisplayRotation;
    (function(Enum_DisplayRotation2) {
      Enum_DisplayRotation2[Enum_DisplayRotation2["North"] = 0] = "North";
      Enum_DisplayRotation2[Enum_DisplayRotation2["East"] = 90] = "East";
      Enum_DisplayRotation2[Enum_DisplayRotation2["South"] = 180] = "South";
      Enum_DisplayRotation2[Enum_DisplayRotation2["West"] = 270] = "West";
    })(Enum_DisplayRotation || (exports2.Enum_DisplayRotation = Enum_DisplayRotation = {}));
    var Enum_HomescreenFormat;
    (function(Enum_HomescreenFormat2) {
      Enum_HomescreenFormat2[Enum_HomescreenFormat2["Toif"] = 1] = "Toif";
      Enum_HomescreenFormat2[Enum_HomescreenFormat2["Jpeg"] = 2] = "Jpeg";
      Enum_HomescreenFormat2[Enum_HomescreenFormat2["ToiG"] = 3] = "ToiG";
    })(Enum_HomescreenFormat || (exports2.Enum_HomescreenFormat = Enum_HomescreenFormat = {}));
    var Enum_BackupAvailability;
    (function(Enum_BackupAvailability2) {
      Enum_BackupAvailability2[Enum_BackupAvailability2["NotAvailable"] = 0] = "NotAvailable";
      Enum_BackupAvailability2[Enum_BackupAvailability2["Required"] = 1] = "Required";
      Enum_BackupAvailability2[Enum_BackupAvailability2["Available"] = 2] = "Available";
    })(Enum_BackupAvailability || (exports2.Enum_BackupAvailability = Enum_BackupAvailability = {}));
    var Enum_RecoveryStatus;
    (function(Enum_RecoveryStatus2) {
      Enum_RecoveryStatus2[Enum_RecoveryStatus2["Nothing"] = 0] = "Nothing";
      Enum_RecoveryStatus2[Enum_RecoveryStatus2["Recovery"] = 1] = "Recovery";
      Enum_RecoveryStatus2[Enum_RecoveryStatus2["Backup"] = 2] = "Backup";
    })(Enum_RecoveryStatus || (exports2.Enum_RecoveryStatus = Enum_RecoveryStatus = {}));
    var Enum_Capability;
    (function(Enum_Capability2) {
      Enum_Capability2[Enum_Capability2["Capability_Bitcoin"] = 1] = "Capability_Bitcoin";
      Enum_Capability2[Enum_Capability2["Capability_Bitcoin_like"] = 2] = "Capability_Bitcoin_like";
      Enum_Capability2[Enum_Capability2["Capability_Binance"] = 3] = "Capability_Binance";
      Enum_Capability2[Enum_Capability2["Capability_Cardano"] = 4] = "Capability_Cardano";
      Enum_Capability2[Enum_Capability2["Capability_Crypto"] = 5] = "Capability_Crypto";
      Enum_Capability2[Enum_Capability2["Capability_EOS"] = 6] = "Capability_EOS";
      Enum_Capability2[Enum_Capability2["Capability_Ethereum"] = 7] = "Capability_Ethereum";
      Enum_Capability2[Enum_Capability2["Capability_Lisk"] = 8] = "Capability_Lisk";
      Enum_Capability2[Enum_Capability2["Capability_Monero"] = 9] = "Capability_Monero";
      Enum_Capability2[Enum_Capability2["Capability_NEM"] = 10] = "Capability_NEM";
      Enum_Capability2[Enum_Capability2["Capability_Ripple"] = 11] = "Capability_Ripple";
      Enum_Capability2[Enum_Capability2["Capability_Stellar"] = 12] = "Capability_Stellar";
      Enum_Capability2[Enum_Capability2["Capability_Tezos"] = 13] = "Capability_Tezos";
      Enum_Capability2[Enum_Capability2["Capability_U2F"] = 14] = "Capability_U2F";
      Enum_Capability2[Enum_Capability2["Capability_Shamir"] = 15] = "Capability_Shamir";
      Enum_Capability2[Enum_Capability2["Capability_ShamirGroups"] = 16] = "Capability_ShamirGroups";
      Enum_Capability2[Enum_Capability2["Capability_PassphraseEntry"] = 17] = "Capability_PassphraseEntry";
      Enum_Capability2[Enum_Capability2["Capability_Solana"] = 18] = "Capability_Solana";
      Enum_Capability2[Enum_Capability2["Capability_Translations"] = 19] = "Capability_Translations";
      Enum_Capability2[Enum_Capability2["Capability_Brightness"] = 20] = "Capability_Brightness";
      Enum_Capability2[Enum_Capability2["Capability_Haptic"] = 21] = "Capability_Haptic";
      Enum_Capability2[Enum_Capability2["Capability_BLE"] = 22] = "Capability_BLE";
      Enum_Capability2[Enum_Capability2["Capability_NFC"] = 23] = "Capability_NFC";
    })(Enum_Capability || (exports2.Enum_Capability = Enum_Capability = {}));
    var RecoveryDeviceInputMethod;
    (function(RecoveryDeviceInputMethod2) {
      RecoveryDeviceInputMethod2[RecoveryDeviceInputMethod2["ScrambledWords"] = 0] = "ScrambledWords";
      RecoveryDeviceInputMethod2[RecoveryDeviceInputMethod2["Matrix"] = 1] = "Matrix";
    })(RecoveryDeviceInputMethod || (exports2.RecoveryDeviceInputMethod = RecoveryDeviceInputMethod = {}));
    var Enum_RecoveryType;
    (function(Enum_RecoveryType2) {
      Enum_RecoveryType2[Enum_RecoveryType2["NormalRecovery"] = 0] = "NormalRecovery";
      Enum_RecoveryType2[Enum_RecoveryType2["DryRun"] = 1] = "DryRun";
      Enum_RecoveryType2[Enum_RecoveryType2["UnlockRepeatedBackup"] = 2] = "UnlockRepeatedBackup";
    })(Enum_RecoveryType || (exports2.Enum_RecoveryType = Enum_RecoveryType = {}));
    var SdProtectOperationType;
    (function(SdProtectOperationType2) {
      SdProtectOperationType2[SdProtectOperationType2["DISABLE"] = 0] = "DISABLE";
      SdProtectOperationType2[SdProtectOperationType2["ENABLE"] = 1] = "ENABLE";
      SdProtectOperationType2[SdProtectOperationType2["REFRESH"] = 2] = "REFRESH";
    })(SdProtectOperationType || (exports2.SdProtectOperationType = SdProtectOperationType = {}));
    var Enum_WordRequestType;
    (function(Enum_WordRequestType2) {
      Enum_WordRequestType2[Enum_WordRequestType2["WordRequestType_Plain"] = 0] = "WordRequestType_Plain";
      Enum_WordRequestType2[Enum_WordRequestType2["WordRequestType_Matrix9"] = 1] = "WordRequestType_Matrix9";
      Enum_WordRequestType2[Enum_WordRequestType2["WordRequestType_Matrix6"] = 2] = "WordRequestType_Matrix6";
    })(Enum_WordRequestType || (exports2.Enum_WordRequestType = Enum_WordRequestType = {}));
    var BootCommand;
    (function(BootCommand2) {
      BootCommand2[BootCommand2["STOP_AND_WAIT"] = 0] = "STOP_AND_WAIT";
      BootCommand2[BootCommand2["INSTALL_UPGRADE"] = 1] = "INSTALL_UPGRADE";
    })(BootCommand || (exports2.BootCommand = BootCommand = {}));
    var NEMMosaicLevy;
    (function(NEMMosaicLevy2) {
      NEMMosaicLevy2[NEMMosaicLevy2["MosaicLevy_Absolute"] = 1] = "MosaicLevy_Absolute";
      NEMMosaicLevy2[NEMMosaicLevy2["MosaicLevy_Percentile"] = 2] = "MosaicLevy_Percentile";
    })(NEMMosaicLevy || (exports2.NEMMosaicLevy = NEMMosaicLevy = {}));
    var NEMSupplyChangeType;
    (function(NEMSupplyChangeType2) {
      NEMSupplyChangeType2[NEMSupplyChangeType2["SupplyChange_Increase"] = 1] = "SupplyChange_Increase";
      NEMSupplyChangeType2[NEMSupplyChangeType2["SupplyChange_Decrease"] = 2] = "SupplyChange_Decrease";
    })(NEMSupplyChangeType || (exports2.NEMSupplyChangeType = NEMSupplyChangeType = {}));
    var NEMModificationType;
    (function(NEMModificationType2) {
      NEMModificationType2[NEMModificationType2["CosignatoryModification_Add"] = 1] = "CosignatoryModification_Add";
      NEMModificationType2[NEMModificationType2["CosignatoryModification_Delete"] = 2] = "CosignatoryModification_Delete";
    })(NEMModificationType || (exports2.NEMModificationType = NEMModificationType = {}));
    var NEMImportanceTransferMode;
    (function(NEMImportanceTransferMode2) {
      NEMImportanceTransferMode2[NEMImportanceTransferMode2["ImportanceTransfer_Activate"] = 1] = "ImportanceTransfer_Activate";
      NEMImportanceTransferMode2[NEMImportanceTransferMode2["ImportanceTransfer_Deactivate"] = 2] = "ImportanceTransfer_Deactivate";
    })(NEMImportanceTransferMode || (exports2.NEMImportanceTransferMode = NEMImportanceTransferMode = {}));
    var StellarAssetType;
    (function(StellarAssetType2) {
      StellarAssetType2[StellarAssetType2["NATIVE"] = 0] = "NATIVE";
      StellarAssetType2[StellarAssetType2["ALPHANUM4"] = 1] = "ALPHANUM4";
      StellarAssetType2[StellarAssetType2["ALPHANUM12"] = 2] = "ALPHANUM12";
    })(StellarAssetType || (exports2.StellarAssetType = StellarAssetType = {}));
    var StellarMemoType;
    (function(StellarMemoType2) {
      StellarMemoType2[StellarMemoType2["NONE"] = 0] = "NONE";
      StellarMemoType2[StellarMemoType2["TEXT"] = 1] = "TEXT";
      StellarMemoType2[StellarMemoType2["ID"] = 2] = "ID";
      StellarMemoType2[StellarMemoType2["HASH"] = 3] = "HASH";
      StellarMemoType2[StellarMemoType2["RETURN"] = 4] = "RETURN";
    })(StellarMemoType || (exports2.StellarMemoType = StellarMemoType = {}));
    var StellarSignerType;
    (function(StellarSignerType2) {
      StellarSignerType2[StellarSignerType2["ACCOUNT"] = 0] = "ACCOUNT";
      StellarSignerType2[StellarSignerType2["PRE_AUTH"] = 1] = "PRE_AUTH";
      StellarSignerType2[StellarSignerType2["HASH"] = 2] = "HASH";
    })(StellarSignerType || (exports2.StellarSignerType = StellarSignerType = {}));
    var TezosContractType;
    (function(TezosContractType2) {
      TezosContractType2[TezosContractType2["Implicit"] = 0] = "Implicit";
      TezosContractType2[TezosContractType2["Originated"] = 1] = "Originated";
    })(TezosContractType || (exports2.TezosContractType = TezosContractType = {}));
    var TezosBallotType;
    (function(TezosBallotType2) {
      TezosBallotType2[TezosBallotType2["Yay"] = 0] = "Yay";
      TezosBallotType2[TezosBallotType2["Nay"] = 1] = "Nay";
      TezosBallotType2[TezosBallotType2["Pass"] = 2] = "Pass";
    })(TezosBallotType || (exports2.TezosBallotType = TezosBallotType = {}));
  }
});

// node_modules/@trezor/protobuf/lib/load-definitions.js
var require_load_definitions = __commonJS({
  "node_modules/@trezor/protobuf/lib/load-definitions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.loadDefinitions = void 0;
    var loadDefinitions = async (messages, packageName, packageLoader) => {
      try {
        const pkg2 = messages.lookup(packageName);
        if (pkg2) {
          return;
        }
      } catch {
      }
      let enumType;
      try {
        enumType = messages.lookupEnum("MessageType");
      } catch {
      }
      const packageMessages = await packageLoader();
      const pkg = messages.define(packageName, packageMessages);
      let packageEnumType;
      try {
        packageEnumType = pkg.lookupEnum("MessageType");
      } catch {
      }
      if (enumType && packageEnumType) {
        try {
          Object.keys(packageEnumType.values).forEach((key) => {
            enumType.add(key, packageEnumType.values[key]);
          });
          pkg.remove(packageEnumType);
        } catch (e) {
          messages.remove(pkg);
          throw e;
        }
      }
    };
    exports2.loadDefinitions = loadDefinitions;
  }
});

// node_modules/@trezor/protobuf/lib/messages-schema.js
var require_messages_schema = __commonJS({
  "node_modules/@trezor/protobuf/lib/messages-schema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PrevOutput = exports2.PrevInput = exports2.PrevTx = exports2.TxOutput = exports2.TxOutputType = exports2.ChangeOutputScriptType = exports2.TxOutputBinType = exports2.TxInput = exports2.TxInputType = exports2.InternalInputScriptType = exports2.TxRequest = exports2.TxRequestSerializedType = exports2.TxRequestDetailsType = exports2.RequestType = exports2.EnumEnum_RequestType = exports2.Enum_RequestType = exports2.SignTx = exports2.CoinJoinRequest = exports2.VerifyMessage = exports2.MessageSignature = exports2.SignMessage = exports2.OwnershipId = exports2.GetOwnershipId = exports2.Address = exports2.GetAddress = exports2.PublicKey = exports2.GetPublicKey = exports2.MultisigRedeemScriptType = exports2.HDNodePathType = exports2.HDNodeType = exports2.EnumMultisigPubkeysOrder = exports2.MultisigPubkeysOrder = exports2.EnumAmountUnit = exports2.AmountUnit = exports2.PaymentRequest = exports2.PaymentRequestMemo = exports2.TextDetailsMemo = exports2.CoinPurchaseMemo = exports2.RefundMemo = exports2.TextMemo = exports2.EnumDecredStakingSpendType = exports2.DecredStakingSpendType = exports2.OutputScriptType = exports2.EnumEnum_OutputScriptType = exports2.Enum_OutputScriptType = exports2.InputScriptType = exports2.EnumEnum_InputScriptType = exports2.Enum_InputScriptType = exports2.EnumDeviceModelInternal = exports2.DeviceModelInternal = void 0;
    exports2.CardanoAddressParametersType = exports2.CardanoNativeScriptHash = exports2.CardanoGetNativeScriptHash = exports2.CardanoNativeScript = exports2.CardanoBlockchainPointerType = exports2.EnumCardanoTxWitnessType = exports2.CardanoTxWitnessType = exports2.EnumCardanoTxSigningMode = exports2.CardanoTxSigningMode = exports2.EnumCardanoCVoteRegistrationFormat = exports2.CardanoCVoteRegistrationFormat = exports2.EnumCardanoTxAuxiliaryDataSupplementType = exports2.CardanoTxAuxiliaryDataSupplementType = exports2.EnumCardanoPoolRelayType = exports2.CardanoPoolRelayType = exports2.EnumCardanoDRepType = exports2.CardanoDRepType = exports2.EnumCardanoCertificateType = exports2.CardanoCertificateType = exports2.EnumCardanoTxOutputSerializationFormat = exports2.CardanoTxOutputSerializationFormat = exports2.EnumCardanoNativeScriptHashDisplayFormat = exports2.CardanoNativeScriptHashDisplayFormat = exports2.EnumCardanoNativeScriptType = exports2.CardanoNativeScriptType = exports2.EnumCardanoAddressType = exports2.CardanoAddressType = exports2.EnumCardanoDerivationType = exports2.CardanoDerivationType = exports2.ProdTestT1 = exports2.FirmwareUpload = exports2.FirmwareRequest = exports2.FirmwareErase = exports2.BleUnpair = exports2.AuthorizeCoinJoin = exports2.OwnershipProof = exports2.GetOwnershipProof = exports2.TxAckPrevExtraData = exports2.TxAckPrevExtraDataWrapper = exports2.TxAckPrevOutput = exports2.TxAckPrevOutputWrapper = exports2.TxAckPrevInput = exports2.TxAckPrevInputWrapper = exports2.TxAckPrevMeta = exports2.TxAckOutput = exports2.TxAckOutputWrapper = exports2.TxAckInput = exports2.TxAckInputWrapper = exports2.TxAck = exports2.TxAckResponse = void 0;
    exports2.PinMatrixRequest = exports2.PinMatrixRequestType = exports2.EnumEnum_PinMatrixRequestType = exports2.Enum_PinMatrixRequestType = exports2.ButtonAck = exports2.ButtonRequest = exports2.ButtonRequestType = exports2.EnumEnum_ButtonRequestType = exports2.Enum_ButtonRequestType = exports2.Failure = exports2.FailureType = exports2.EnumEnum_FailureType = exports2.Enum_FailureType = exports2.Success = exports2.CardanoMessageSignature = exports2.CardanoMessageDataResponse = exports2.CardanoMessageDataRequest = exports2.CardanoSignMessageInit = exports2.CardanoSignTxFinished = exports2.CardanoTxBodyHash = exports2.CardanoTxHostAck = exports2.CardanoTxWitnessResponse = exports2.CardanoTxWitnessRequest = exports2.CardanoTxAuxiliaryDataSupplement = exports2.CardanoTxItemAck = exports2.CardanoTxReferenceInput = exports2.CardanoTxRequiredSigner = exports2.CardanoTxCollateralInput = exports2.CardanoTxMint = exports2.CardanoTxAuxiliaryData = exports2.CardanoCVoteRegistrationParametersType = exports2.CardanoCVoteRegistrationDelegation = exports2.CardanoTxWithdrawal = exports2.CardanoTxCertificate = exports2.CardanoDRep = exports2.CardanoPoolParametersType = exports2.CardanoPoolMetadataType = exports2.CardanoPoolRelayParameters = exports2.CardanoPoolOwner = exports2.CardanoTxReferenceScriptChunk = exports2.CardanoTxInlineDatumChunk = exports2.CardanoToken = exports2.CardanoAssetGroup = exports2.CardanoTxOutput = exports2.CardanoTxInput = exports2.CardanoSignTxInit = exports2.CardanoPublicKey = exports2.CardanoGetPublicKey = exports2.CardanoAddress = exports2.CardanoGetAddress = void 0;
    exports2.EosActionBuyRam = exports2.EosActionRefund = exports2.EosActionUndelegate = exports2.EosActionDelegate = exports2.EosActionTransfer = exports2.EosActionCommon = exports2.EosAuthorization = exports2.EosAuthorizationWait = exports2.EosAuthorizationAccount = exports2.EosAuthorizationKey = exports2.EosPermissionLevel = exports2.EosAsset = exports2.EosTxActionRequest = exports2.EosSignTx = exports2.EosTxHeader = exports2.EosPublicKey = exports2.EosGetPublicKey = exports2.SolanaTokenInfo = exports2.EthereumTokenInfo = exports2.EthereumNetworkInfo = exports2.EnumDefinitionType = exports2.DefinitionType = exports2.DebugLinkGcInfo = exports2.DebugLinkGcInfoItem = exports2.DebugLinkGetGcInfo = exports2.DebugLinkOptigaSetSecMax = exports2.DebugLinkResetDebugEvents = exports2.DebugLinkPairingInfo = exports2.DebugLinkGetPairingInfo = exports2.EnumDebugWaitType = exports2.DebugWaitType = exports2.EnumDebugTouchEventType = exports2.DebugTouchEventType = exports2.EnumDebugPhysicalButton = exports2.DebugPhysicalButton = exports2.EnumDebugButton = exports2.DebugButton = exports2.PaymentNotification = exports2.ECDHSessionKey = exports2.GetECDHSessionKey = exports2.SignedIdentity = exports2.SignIdentity = exports2.IdentityType = exports2.CipheredKeyValue = exports2.CipherKeyValue = exports2.Deprecated_PassphraseStateAck = exports2.Deprecated_PassphraseStateRequest = exports2.PassphraseAck = exports2.PassphraseRequest = exports2.PinMatrixAck = void 0;
    exports2.Initialize = exports2.HomescreenFormat = exports2.EnumEnum_HomescreenFormat = exports2.Enum_HomescreenFormat = exports2.DisplayRotation = exports2.EnumEnum_DisplayRotation = exports2.Enum_DisplayRotation = exports2.SafetyCheckLevel = exports2.EnumEnum_SafetyCheckLevel = exports2.Enum_SafetyCheckLevel = exports2.BackupType = exports2.EnumEnum_BackupType = exports2.Enum_BackupType = exports2.EvoluNode = exports2.EvoluGetNode = exports2.EthereumTypedDataSignature = exports2.EthereumSignTypedHash = exports2.EthereumVerifyMessage = exports2.EthereumMessageSignature = exports2.EthereumSignMessage = exports2.EthereumTxAck = exports2.EthereumTxRequest = exports2.EthereumSignTxEIP1559 = exports2.EthereumAccessList = exports2.EthereumSignTx = exports2.EthereumAddress = exports2.EthereumGetAddress = exports2.EthereumPublicKey = exports2.EthereumGetPublicKey = exports2.EthereumTypedDataValueAck = exports2.EthereumTypedDataValueRequest = exports2.EthereumTypedDataStructAck = exports2.EthereumStructMember = exports2.EthereumFieldType = exports2.EnumEthereumDataType = exports2.EthereumDataType = exports2.EthereumTypedDataStructRequest = exports2.EthereumSignTypedData = exports2.EthereumDefinitions = exports2.EosSignedTx = exports2.EosTxActionAck = exports2.EosActionUnknown = exports2.EosActionNewAccount = exports2.EosActionUnlinkAuth = exports2.EosActionLinkAuth = exports2.EosActionDeleteAuth = exports2.EosActionUpdateAuth = exports2.EosActionVoteProducer = exports2.EosActionSellRam = exports2.EosActionBuyRamBytes = void 0;
    exports2.WordRequestType = exports2.EnumEnum_WordRequestType = exports2.Enum_WordRequestType = exports2.EntropyCheckContinue = exports2.EntropyCheckReady = exports2.EntropyAck = exports2.EntropyRequest = exports2.BackupDevice = exports2.Slip39Group = exports2.ResetDevice = exports2.LoadDevice = exports2.WipeDevice = exports2.AuthenticityProof = exports2.AuthenticateDevice = exports2.FirmwareHash = exports2.GetFirmwareHash = exports2.Entropy = exports2.GetEntropy = exports2.Cancel = exports2.Ping = exports2.SdProtect = exports2.EnumSdProtectOperationType = exports2.SdProtectOperationType = exports2.ChangeWipeCode = exports2.ChangePin = exports2.ApplyFlags = exports2.DataChunkAck = exports2.DataChunkRequest = exports2.ChangeLanguage = exports2.ApplySettings = exports2.EndSession = exports2.SetBusy = exports2.LockDevice = exports2.Features = exports2.RecoveryDevice = exports2.RecoveryType = exports2.EnumEnum_RecoveryType = exports2.Enum_RecoveryType = exports2.EnumRecoveryDeviceInputMethod = exports2.RecoveryDeviceInputMethod = exports2.Capability = exports2.EnumEnum_Capability = exports2.Enum_Capability = exports2.RecoveryStatus = exports2.EnumEnum_RecoveryStatus = exports2.Enum_RecoveryStatus = exports2.BackupAvailability = exports2.EnumEnum_BackupAvailability = exports2.Enum_BackupAvailability = exports2.GetFeatures = void 0;
    exports2.SolanaGetAddress = exports2.SolanaPublicKey = exports2.SolanaGetPublicKey = exports2.RippleSignedTx = exports2.RippleSignTx = exports2.RipplePayment = exports2.RippleAddress = exports2.RippleGetAddress = exports2.NEMDecryptedMessage = exports2.NEMDecryptMessage = exports2.NEMSignedTx = exports2.NEMSignTx = exports2.NEMImportanceTransfer = exports2.EnumNEMImportanceTransferMode = exports2.NEMImportanceTransferMode = exports2.NEMAggregateModification = exports2.NEMCosignatoryModification = exports2.EnumNEMModificationType = exports2.NEMModificationType = exports2.NEMMosaicSupplyChange = exports2.EnumNEMSupplyChangeType = exports2.NEMSupplyChangeType = exports2.NEMMosaicCreation = exports2.NEMMosaicDefinition = exports2.EnumNEMMosaicLevy = exports2.NEMMosaicLevy = exports2.NEMProvisionNamespace = exports2.NEMTransfer = exports2.NEMMosaic = exports2.NEMTransactionCommon = exports2.NEMAddress = exports2.NEMGetAddress = exports2.SetBrightness = exports2.UnlockBootloader = exports2.ShowDeviceTutorial = exports2.UnlockedPathRequest = exports2.UnlockPath = exports2.Nonce = exports2.GetNonce = exports2.RebootToBootloader = exports2.EnumBootCommand = exports2.BootCommand = exports2.CancelAuthorization = exports2.PreauthorizedRequest = exports2.DoPreauthorized = exports2.NextU2FCounter = exports2.GetNextU2FCounter = exports2.SetU2FCounter = exports2.WordAck = exports2.WordRequest = void 0;
    exports2.TezosSignedTx = exports2.TezosSignTx = exports2.TezosBallotOp = exports2.EnumTezosBallotType = exports2.TezosBallotType = exports2.TezosProposalOp = exports2.TezosDelegationOp = exports2.TezosOriginationOp = exports2.TezosTransactionOp = exports2.TezosParametersManager = exports2.TezosManagerTransfer = exports2.TezosRevealOp = exports2.TezosContractID = exports2.EnumTezosContractType = exports2.TezosContractType = exports2.TezosPublicKey = exports2.TezosGetPublicKey = exports2.TezosAddress = exports2.TezosGetAddress = exports2.StellarSignedTx = exports2.StellarClaimClaimableBalanceOp = exports2.StellarBumpSequenceOp = exports2.StellarManageDataOp = exports2.StellarAccountMergeOp = exports2.StellarAllowTrustOp = exports2.StellarChangeTrustOp = exports2.StellarSetOptionsOp = exports2.EnumStellarSignerType = exports2.StellarSignerType = exports2.StellarCreatePassiveSellOfferOp = exports2.StellarManageBuyOfferOp = exports2.StellarManageSellOfferOp = exports2.StellarPathPaymentStrictSendOp = exports2.StellarPathPaymentStrictReceiveOp = exports2.StellarCreateAccountOp = exports2.StellarPaymentOp = exports2.StellarTxOpRequest = exports2.StellarSignTx = exports2.EnumStellarMemoType = exports2.StellarMemoType = exports2.StellarAddress = exports2.StellarGetAddress = exports2.StellarAsset = exports2.EnumStellarAssetType = exports2.StellarAssetType = exports2.SolanaTxSignature = exports2.SolanaSignTx = exports2.SolanaTxAdditionalInfo = exports2.SolanaTxTokenAccountInfo = exports2.SolanaAddress = void 0;
    exports2.MessageType = void 0;
    var schema_utils_1 = require_lib2();
    var DeviceModelInternal;
    (function(DeviceModelInternal2) {
      DeviceModelInternal2["T1B1"] = "T1B1";
      DeviceModelInternal2["T2T1"] = "T2T1";
      DeviceModelInternal2["T2B1"] = "T2B1";
      DeviceModelInternal2["T3B1"] = "T3B1";
      DeviceModelInternal2["T3T1"] = "T3T1";
      DeviceModelInternal2["T3W1"] = "T3W1";
      DeviceModelInternal2["UNKNOWN"] = "UNKNOWN";
    })(DeviceModelInternal || (exports2.DeviceModelInternal = DeviceModelInternal = {}));
    exports2.EnumDeviceModelInternal = schema_utils_1.Type.Enum(DeviceModelInternal);
    var Enum_InputScriptType;
    (function(Enum_InputScriptType2) {
      Enum_InputScriptType2[Enum_InputScriptType2["SPENDADDRESS"] = 0] = "SPENDADDRESS";
      Enum_InputScriptType2[Enum_InputScriptType2["SPENDMULTISIG"] = 1] = "SPENDMULTISIG";
      Enum_InputScriptType2[Enum_InputScriptType2["EXTERNAL"] = 2] = "EXTERNAL";
      Enum_InputScriptType2[Enum_InputScriptType2["SPENDWITNESS"] = 3] = "SPENDWITNESS";
      Enum_InputScriptType2[Enum_InputScriptType2["SPENDP2SHWITNESS"] = 4] = "SPENDP2SHWITNESS";
      Enum_InputScriptType2[Enum_InputScriptType2["SPENDTAPROOT"] = 5] = "SPENDTAPROOT";
    })(Enum_InputScriptType || (exports2.Enum_InputScriptType = Enum_InputScriptType = {}));
    exports2.EnumEnum_InputScriptType = schema_utils_1.Type.Enum(Enum_InputScriptType);
    exports2.InputScriptType = schema_utils_1.Type.KeyOfEnum(Enum_InputScriptType, { $id: "InputScriptType" });
    var Enum_OutputScriptType;
    (function(Enum_OutputScriptType2) {
      Enum_OutputScriptType2[Enum_OutputScriptType2["PAYTOADDRESS"] = 0] = "PAYTOADDRESS";
      Enum_OutputScriptType2[Enum_OutputScriptType2["PAYTOSCRIPTHASH"] = 1] = "PAYTOSCRIPTHASH";
      Enum_OutputScriptType2[Enum_OutputScriptType2["PAYTOMULTISIG"] = 2] = "PAYTOMULTISIG";
      Enum_OutputScriptType2[Enum_OutputScriptType2["PAYTOOPRETURN"] = 3] = "PAYTOOPRETURN";
      Enum_OutputScriptType2[Enum_OutputScriptType2["PAYTOWITNESS"] = 4] = "PAYTOWITNESS";
      Enum_OutputScriptType2[Enum_OutputScriptType2["PAYTOP2SHWITNESS"] = 5] = "PAYTOP2SHWITNESS";
      Enum_OutputScriptType2[Enum_OutputScriptType2["PAYTOTAPROOT"] = 6] = "PAYTOTAPROOT";
    })(Enum_OutputScriptType || (exports2.Enum_OutputScriptType = Enum_OutputScriptType = {}));
    exports2.EnumEnum_OutputScriptType = schema_utils_1.Type.Enum(Enum_OutputScriptType);
    exports2.OutputScriptType = schema_utils_1.Type.KeyOfEnum(Enum_OutputScriptType, { $id: "OutputScriptType" });
    var DecredStakingSpendType;
    (function(DecredStakingSpendType2) {
      DecredStakingSpendType2[DecredStakingSpendType2["SSGen"] = 0] = "SSGen";
      DecredStakingSpendType2[DecredStakingSpendType2["SSRTX"] = 1] = "SSRTX";
    })(DecredStakingSpendType || (exports2.DecredStakingSpendType = DecredStakingSpendType = {}));
    exports2.EnumDecredStakingSpendType = schema_utils_1.Type.Enum(DecredStakingSpendType);
    exports2.TextMemo = schema_utils_1.Type.Object({
      text: schema_utils_1.Type.String()
    }, { $id: "TextMemo" });
    exports2.RefundMemo = schema_utils_1.Type.Object({
      address: schema_utils_1.Type.String(),
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      mac: schema_utils_1.Type.String()
    }, { $id: "RefundMemo" });
    exports2.CoinPurchaseMemo = schema_utils_1.Type.Object({
      coin_type: schema_utils_1.Type.Number(),
      amount: schema_utils_1.Type.String(),
      address: schema_utils_1.Type.String(),
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      mac: schema_utils_1.Type.String()
    }, { $id: "CoinPurchaseMemo" });
    exports2.TextDetailsMemo = schema_utils_1.Type.Object({
      title: schema_utils_1.Type.String(),
      text: schema_utils_1.Type.String()
    }, { $id: "TextDetailsMemo" });
    exports2.PaymentRequestMemo = schema_utils_1.Type.Object({
      text_memo: schema_utils_1.Type.Optional(exports2.TextMemo),
      refund_memo: schema_utils_1.Type.Optional(exports2.RefundMemo),
      coin_purchase_memo: schema_utils_1.Type.Optional(exports2.CoinPurchaseMemo),
      text_details_memo: schema_utils_1.Type.Optional(exports2.TextDetailsMemo)
    }, { $id: "PaymentRequestMemo" });
    exports2.PaymentRequest = schema_utils_1.Type.Object({
      nonce: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      recipient_name: schema_utils_1.Type.String(),
      memos: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(exports2.PaymentRequestMemo)),
      amount: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint()),
      signature: schema_utils_1.Type.String()
    }, { $id: "PaymentRequest" });
    var AmountUnit;
    (function(AmountUnit2) {
      AmountUnit2[AmountUnit2["BITCOIN"] = 0] = "BITCOIN";
      AmountUnit2[AmountUnit2["MILLIBITCOIN"] = 1] = "MILLIBITCOIN";
      AmountUnit2[AmountUnit2["MICROBITCOIN"] = 2] = "MICROBITCOIN";
      AmountUnit2[AmountUnit2["SATOSHI"] = 3] = "SATOSHI";
    })(AmountUnit || (exports2.AmountUnit = AmountUnit = {}));
    exports2.EnumAmountUnit = schema_utils_1.Type.Enum(AmountUnit);
    var MultisigPubkeysOrder;
    (function(MultisigPubkeysOrder2) {
      MultisigPubkeysOrder2[MultisigPubkeysOrder2["PRESERVED"] = 0] = "PRESERVED";
      MultisigPubkeysOrder2[MultisigPubkeysOrder2["LEXICOGRAPHIC"] = 1] = "LEXICOGRAPHIC";
    })(MultisigPubkeysOrder || (exports2.MultisigPubkeysOrder = MultisigPubkeysOrder = {}));
    exports2.EnumMultisigPubkeysOrder = schema_utils_1.Type.Enum(MultisigPubkeysOrder);
    exports2.HDNodeType = schema_utils_1.Type.Object({
      depth: schema_utils_1.Type.Number(),
      fingerprint: schema_utils_1.Type.Number(),
      child_num: schema_utils_1.Type.Number(),
      chain_code: schema_utils_1.Type.String(),
      private_key: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      public_key: schema_utils_1.Type.String()
    }, { $id: "HDNodeType" });
    exports2.HDNodePathType = schema_utils_1.Type.Object({
      node: schema_utils_1.Type.Union([exports2.HDNodeType, schema_utils_1.Type.String()]),
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number())
    }, { $id: "HDNodePathType" });
    exports2.MultisigRedeemScriptType = schema_utils_1.Type.Object({
      pubkeys: schema_utils_1.Type.Array(exports2.HDNodePathType),
      signatures: schema_utils_1.Type.Array(schema_utils_1.Type.String()),
      m: schema_utils_1.Type.Number(),
      nodes: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(exports2.HDNodeType)),
      address_n: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(schema_utils_1.Type.Number())),
      pubkeys_order: schema_utils_1.Type.Optional(exports2.EnumMultisigPubkeysOrder)
    }, { $id: "MultisigRedeemScriptType" });
    exports2.GetPublicKey = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      ecdsa_curve_name: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      show_display: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      coin_name: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      script_type: schema_utils_1.Type.Optional(exports2.InputScriptType),
      ignore_xpub_magic: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, { $id: "GetPublicKey" });
    exports2.PublicKey = schema_utils_1.Type.Object({
      node: exports2.HDNodeType,
      xpub: schema_utils_1.Type.String(),
      root_fingerprint: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      descriptor: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, { $id: "PublicKey" });
    exports2.GetAddress = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      coin_name: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      show_display: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      multisig: schema_utils_1.Type.Optional(exports2.MultisigRedeemScriptType),
      script_type: schema_utils_1.Type.Optional(exports2.InputScriptType),
      ignore_xpub_magic: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, { $id: "GetAddress" });
    exports2.Address = schema_utils_1.Type.Object({
      address: schema_utils_1.Type.String(),
      mac: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, { $id: "Address" });
    exports2.GetOwnershipId = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      coin_name: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      multisig: schema_utils_1.Type.Optional(exports2.MultisigRedeemScriptType),
      script_type: schema_utils_1.Type.Optional(exports2.InputScriptType)
    }, { $id: "GetOwnershipId" });
    exports2.OwnershipId = schema_utils_1.Type.Object({
      ownership_id: schema_utils_1.Type.String()
    }, { $id: "OwnershipId" });
    exports2.SignMessage = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      message: schema_utils_1.Type.String(),
      coin_name: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      script_type: schema_utils_1.Type.Optional(exports2.InputScriptType),
      no_script_type: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, { $id: "SignMessage" });
    exports2.MessageSignature = schema_utils_1.Type.Object({
      address: schema_utils_1.Type.String(),
      signature: schema_utils_1.Type.String()
    }, { $id: "MessageSignature" });
    exports2.VerifyMessage = schema_utils_1.Type.Object({
      address: schema_utils_1.Type.String(),
      signature: schema_utils_1.Type.String(),
      message: schema_utils_1.Type.String(),
      coin_name: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, { $id: "VerifyMessage" });
    exports2.CoinJoinRequest = schema_utils_1.Type.Object({
      fee_rate: schema_utils_1.Type.Number(),
      no_fee_threshold: schema_utils_1.Type.Number(),
      min_registrable_amount: schema_utils_1.Type.Number(),
      mask_public_key: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      signature: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, { $id: "CoinJoinRequest" });
    exports2.SignTx = schema_utils_1.Type.Object({
      outputs_count: schema_utils_1.Type.Number(),
      inputs_count: schema_utils_1.Type.Number(),
      coin_name: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      version: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      lock_time: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      expiry: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      overwintered: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      version_group_id: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      timestamp: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      branch_id: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      amount_unit: schema_utils_1.Type.Optional(exports2.EnumAmountUnit),
      decred_staking_ticket: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      serialize: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      coinjoin_request: schema_utils_1.Type.Optional(exports2.CoinJoinRequest),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, { $id: "SignTx" });
    var Enum_RequestType;
    (function(Enum_RequestType2) {
      Enum_RequestType2[Enum_RequestType2["TXINPUT"] = 0] = "TXINPUT";
      Enum_RequestType2[Enum_RequestType2["TXOUTPUT"] = 1] = "TXOUTPUT";
      Enum_RequestType2[Enum_RequestType2["TXMETA"] = 2] = "TXMETA";
      Enum_RequestType2[Enum_RequestType2["TXFINISHED"] = 3] = "TXFINISHED";
      Enum_RequestType2[Enum_RequestType2["TXEXTRADATA"] = 4] = "TXEXTRADATA";
      Enum_RequestType2[Enum_RequestType2["TXORIGINPUT"] = 5] = "TXORIGINPUT";
      Enum_RequestType2[Enum_RequestType2["TXORIGOUTPUT"] = 6] = "TXORIGOUTPUT";
      Enum_RequestType2[Enum_RequestType2["TXPAYMENTREQ"] = 7] = "TXPAYMENTREQ";
    })(Enum_RequestType || (exports2.Enum_RequestType = Enum_RequestType = {}));
    exports2.EnumEnum_RequestType = schema_utils_1.Type.Enum(Enum_RequestType);
    exports2.RequestType = schema_utils_1.Type.KeyOfEnum(Enum_RequestType, { $id: "RequestType" });
    exports2.TxRequestDetailsType = schema_utils_1.Type.Object({
      request_index: schema_utils_1.Type.Number(),
      tx_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      extra_data_len: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      extra_data_offset: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    }, { $id: "TxRequestDetailsType" });
    exports2.TxRequestSerializedType = schema_utils_1.Type.Object({
      signature_index: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      signature: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      serialized_tx: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, { $id: "TxRequestSerializedType" });
    exports2.TxRequest = schema_utils_1.Type.Object({
      request_type: exports2.RequestType,
      details: exports2.TxRequestDetailsType,
      serialized: schema_utils_1.Type.Optional(exports2.TxRequestSerializedType)
    }, { $id: "TxRequest" });
    exports2.InternalInputScriptType = schema_utils_1.Type.Exclude(exports2.InputScriptType, schema_utils_1.Type.Literal("EXTERNAL"), {
      $id: "InternalInputScriptType"
    });
    var CommonTxInputType = schema_utils_1.Type.Object({
      prev_hash: schema_utils_1.Type.String(),
      prev_index: schema_utils_1.Type.Number(),
      amount: schema_utils_1.Type.Uint(),
      sequence: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      multisig: schema_utils_1.Type.Optional(exports2.MultisigRedeemScriptType),
      decred_tree: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      orig_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      orig_index: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      decred_staking_spend: schema_utils_1.Type.Optional(exports2.EnumDecredStakingSpendType),
      script_pubkey: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      coinjoin_flags: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      script_sig: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      witness: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      ownership_proof: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      commitment_data: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, { $id: "CommonTxInputType" });
    exports2.TxInputType = schema_utils_1.Type.Union([
      schema_utils_1.Type.Intersect([
        CommonTxInputType,
        schema_utils_1.Type.Object({
          address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
          script_type: schema_utils_1.Type.Optional(exports2.InternalInputScriptType)
        })
      ]),
      schema_utils_1.Type.Intersect([
        CommonTxInputType,
        schema_utils_1.Type.Object({
          address_n: schema_utils_1.Type.Optional(schema_utils_1.Type.Undefined()),
          script_type: schema_utils_1.Type.Literal("EXTERNAL"),
          script_pubkey: schema_utils_1.Type.String()
        })
      ])
    ], { $id: "TxInputType" });
    exports2.TxInput = (0, schema_utils_1.CloneType)(exports2.TxInputType, { $id: "TxInput" });
    exports2.TxOutputBinType = schema_utils_1.Type.Object({
      amount: schema_utils_1.Type.Uint(),
      script_pubkey: schema_utils_1.Type.String(),
      decred_script_version: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    }, { $id: "TxOutputBinType" });
    exports2.ChangeOutputScriptType = schema_utils_1.Type.Exclude(exports2.OutputScriptType, schema_utils_1.Type.Literal("PAYTOOPRETURN"), { $id: "ChangeOutputScriptType" });
    exports2.TxOutputType = schema_utils_1.Type.Union([
      schema_utils_1.Type.Object({
        address: schema_utils_1.Type.String(),
        address_n: schema_utils_1.Type.Optional(schema_utils_1.Type.Undefined()),
        script_type: schema_utils_1.Type.Literal("PAYTOADDRESS"),
        amount: schema_utils_1.Type.Uint(),
        multisig: schema_utils_1.Type.Optional(exports2.MultisigRedeemScriptType),
        orig_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
        orig_index: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
        payment_req_index: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
      }),
      schema_utils_1.Type.Object({
        address: schema_utils_1.Type.Optional(schema_utils_1.Type.Undefined()),
        address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
        script_type: schema_utils_1.Type.Optional(exports2.ChangeOutputScriptType),
        amount: schema_utils_1.Type.Uint(),
        multisig: schema_utils_1.Type.Optional(exports2.MultisigRedeemScriptType),
        orig_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
        orig_index: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
        payment_req_index: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
      }),
      schema_utils_1.Type.Object({
        address: schema_utils_1.Type.String(),
        address_n: schema_utils_1.Type.Optional(schema_utils_1.Type.Undefined()),
        script_type: schema_utils_1.Type.Optional(exports2.ChangeOutputScriptType),
        amount: schema_utils_1.Type.Uint(),
        multisig: schema_utils_1.Type.Optional(exports2.MultisigRedeemScriptType),
        orig_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
        orig_index: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
        payment_req_index: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
      }),
      schema_utils_1.Type.Object({
        address: schema_utils_1.Type.Optional(schema_utils_1.Type.Undefined()),
        address_n: schema_utils_1.Type.Optional(schema_utils_1.Type.Undefined()),
        amount: schema_utils_1.Type.Union([schema_utils_1.Type.Literal("0"), schema_utils_1.Type.Literal(0)]),
        op_return_data: schema_utils_1.Type.String(),
        script_type: schema_utils_1.Type.Literal("PAYTOOPRETURN"),
        orig_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
        orig_index: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
        payment_req_index: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
      })
    ], { $id: "TxOutputType" });
    exports2.TxOutput = (0, schema_utils_1.CloneType)(exports2.TxOutputType, { $id: "TxOutput" });
    exports2.PrevTx = schema_utils_1.Type.Object({
      version: schema_utils_1.Type.Number(),
      lock_time: schema_utils_1.Type.Number(),
      inputs_count: schema_utils_1.Type.Number(),
      outputs_count: schema_utils_1.Type.Number(),
      extra_data_len: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      expiry: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      version_group_id: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      timestamp: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      branch_id: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    }, { $id: "PrevTx" });
    exports2.PrevInput = schema_utils_1.Type.Object({
      prev_hash: schema_utils_1.Type.String(),
      prev_index: schema_utils_1.Type.Number(),
      script_sig: schema_utils_1.Type.String(),
      sequence: schema_utils_1.Type.Number(),
      decred_tree: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    }, { $id: "PrevInput" });
    exports2.PrevOutput = schema_utils_1.Type.Object({
      amount: schema_utils_1.Type.Uint(),
      script_pubkey: schema_utils_1.Type.String(),
      decred_script_version: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    }, { $id: "PrevOutput" });
    exports2.TxAckResponse = schema_utils_1.Type.Union([
      schema_utils_1.Type.Object({
        inputs: schema_utils_1.Type.Array(schema_utils_1.Type.Union([exports2.TxInputType, exports2.PrevInput]))
      }),
      schema_utils_1.Type.Object({
        bin_outputs: schema_utils_1.Type.Array(exports2.TxOutputBinType)
      }),
      schema_utils_1.Type.Object({
        outputs: schema_utils_1.Type.Array(exports2.TxOutputType)
      }),
      schema_utils_1.Type.Object({
        extra_data: schema_utils_1.Type.String()
      }),
      schema_utils_1.Type.Object({
        version: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
        lock_time: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
        inputs_cnt: schema_utils_1.Type.Number(),
        outputs_cnt: schema_utils_1.Type.Number(),
        extra_data: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
        extra_data_len: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
        timestamp: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
        version_group_id: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
        expiry: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
        branch_id: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
      })
    ], { $id: "TxAckResponse" });
    exports2.TxAck = schema_utils_1.Type.Object({
      tx: exports2.TxAckResponse
    }, { $id: "TxAck" });
    exports2.TxAckInputWrapper = schema_utils_1.Type.Object({
      input: exports2.TxInput
    }, { $id: "TxAckInputWrapper" });
    exports2.TxAckInput = schema_utils_1.Type.Object({
      tx: exports2.TxAckInputWrapper
    }, { $id: "TxAckInput" });
    exports2.TxAckOutputWrapper = schema_utils_1.Type.Object({
      output: exports2.TxOutput
    }, { $id: "TxAckOutputWrapper" });
    exports2.TxAckOutput = schema_utils_1.Type.Object({
      tx: exports2.TxAckOutputWrapper
    }, { $id: "TxAckOutput" });
    exports2.TxAckPrevMeta = schema_utils_1.Type.Object({
      tx: exports2.PrevTx
    }, { $id: "TxAckPrevMeta" });
    exports2.TxAckPrevInputWrapper = schema_utils_1.Type.Object({
      input: exports2.PrevInput
    }, { $id: "TxAckPrevInputWrapper" });
    exports2.TxAckPrevInput = schema_utils_1.Type.Object({
      tx: exports2.TxAckPrevInputWrapper
    }, { $id: "TxAckPrevInput" });
    exports2.TxAckPrevOutputWrapper = schema_utils_1.Type.Object({
      output: exports2.PrevOutput
    }, { $id: "TxAckPrevOutputWrapper" });
    exports2.TxAckPrevOutput = schema_utils_1.Type.Object({
      tx: exports2.TxAckPrevOutputWrapper
    }, { $id: "TxAckPrevOutput" });
    exports2.TxAckPrevExtraDataWrapper = schema_utils_1.Type.Object({
      extra_data_chunk: schema_utils_1.Type.String()
    }, { $id: "TxAckPrevExtraDataWrapper" });
    exports2.TxAckPrevExtraData = schema_utils_1.Type.Object({
      tx: exports2.TxAckPrevExtraDataWrapper
    }, { $id: "TxAckPrevExtraData" });
    exports2.GetOwnershipProof = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      coin_name: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      script_type: schema_utils_1.Type.Optional(exports2.InputScriptType),
      multisig: schema_utils_1.Type.Optional(exports2.MultisigRedeemScriptType),
      user_confirmation: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      ownership_ids: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(schema_utils_1.Type.String())),
      commitment_data: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, { $id: "GetOwnershipProof" });
    exports2.OwnershipProof = schema_utils_1.Type.Object({
      ownership_proof: schema_utils_1.Type.String(),
      signature: schema_utils_1.Type.String()
    }, { $id: "OwnershipProof" });
    exports2.AuthorizeCoinJoin = schema_utils_1.Type.Object({
      coordinator: schema_utils_1.Type.String(),
      max_rounds: schema_utils_1.Type.Number(),
      max_coordinator_fee_rate: schema_utils_1.Type.Number(),
      max_fee_per_kvbyte: schema_utils_1.Type.Number(),
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      coin_name: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      script_type: schema_utils_1.Type.Optional(exports2.InputScriptType),
      amount_unit: schema_utils_1.Type.Optional(exports2.EnumAmountUnit)
    }, { $id: "AuthorizeCoinJoin" });
    exports2.BleUnpair = schema_utils_1.Type.Object({
      all: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      addr: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, { $id: "BleUnpair" });
    exports2.FirmwareErase = schema_utils_1.Type.Object({
      length: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    }, { $id: "FirmwareErase" });
    exports2.FirmwareRequest = schema_utils_1.Type.Object({
      offset: schema_utils_1.Type.Number(),
      length: schema_utils_1.Type.Number()
    }, { $id: "FirmwareRequest" });
    exports2.FirmwareUpload = schema_utils_1.Type.Object({
      payload: schema_utils_1.Type.Union([schema_utils_1.Type.Buffer(), schema_utils_1.Type.ArrayBuffer()]),
      hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, { $id: "FirmwareUpload" });
    exports2.ProdTestT1 = schema_utils_1.Type.Object({
      payload: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, { $id: "ProdTestT1" });
    var CardanoDerivationType;
    (function(CardanoDerivationType2) {
      CardanoDerivationType2[CardanoDerivationType2["LEDGER"] = 0] = "LEDGER";
      CardanoDerivationType2[CardanoDerivationType2["ICARUS"] = 1] = "ICARUS";
      CardanoDerivationType2[CardanoDerivationType2["ICARUS_TREZOR"] = 2] = "ICARUS_TREZOR";
    })(CardanoDerivationType || (exports2.CardanoDerivationType = CardanoDerivationType = {}));
    exports2.EnumCardanoDerivationType = schema_utils_1.Type.Enum(CardanoDerivationType);
    var CardanoAddressType;
    (function(CardanoAddressType2) {
      CardanoAddressType2[CardanoAddressType2["BASE"] = 0] = "BASE";
      CardanoAddressType2[CardanoAddressType2["BASE_SCRIPT_KEY"] = 1] = "BASE_SCRIPT_KEY";
      CardanoAddressType2[CardanoAddressType2["BASE_KEY_SCRIPT"] = 2] = "BASE_KEY_SCRIPT";
      CardanoAddressType2[CardanoAddressType2["BASE_SCRIPT_SCRIPT"] = 3] = "BASE_SCRIPT_SCRIPT";
      CardanoAddressType2[CardanoAddressType2["POINTER"] = 4] = "POINTER";
      CardanoAddressType2[CardanoAddressType2["POINTER_SCRIPT"] = 5] = "POINTER_SCRIPT";
      CardanoAddressType2[CardanoAddressType2["ENTERPRISE"] = 6] = "ENTERPRISE";
      CardanoAddressType2[CardanoAddressType2["ENTERPRISE_SCRIPT"] = 7] = "ENTERPRISE_SCRIPT";
      CardanoAddressType2[CardanoAddressType2["BYRON"] = 8] = "BYRON";
      CardanoAddressType2[CardanoAddressType2["REWARD"] = 14] = "REWARD";
      CardanoAddressType2[CardanoAddressType2["REWARD_SCRIPT"] = 15] = "REWARD_SCRIPT";
    })(CardanoAddressType || (exports2.CardanoAddressType = CardanoAddressType = {}));
    exports2.EnumCardanoAddressType = schema_utils_1.Type.Enum(CardanoAddressType);
    var CardanoNativeScriptType;
    (function(CardanoNativeScriptType2) {
      CardanoNativeScriptType2[CardanoNativeScriptType2["PUB_KEY"] = 0] = "PUB_KEY";
      CardanoNativeScriptType2[CardanoNativeScriptType2["ALL"] = 1] = "ALL";
      CardanoNativeScriptType2[CardanoNativeScriptType2["ANY"] = 2] = "ANY";
      CardanoNativeScriptType2[CardanoNativeScriptType2["N_OF_K"] = 3] = "N_OF_K";
      CardanoNativeScriptType2[CardanoNativeScriptType2["INVALID_BEFORE"] = 4] = "INVALID_BEFORE";
      CardanoNativeScriptType2[CardanoNativeScriptType2["INVALID_HEREAFTER"] = 5] = "INVALID_HEREAFTER";
    })(CardanoNativeScriptType || (exports2.CardanoNativeScriptType = CardanoNativeScriptType = {}));
    exports2.EnumCardanoNativeScriptType = schema_utils_1.Type.Enum(CardanoNativeScriptType);
    var CardanoNativeScriptHashDisplayFormat;
    (function(CardanoNativeScriptHashDisplayFormat2) {
      CardanoNativeScriptHashDisplayFormat2[CardanoNativeScriptHashDisplayFormat2["HIDE"] = 0] = "HIDE";
      CardanoNativeScriptHashDisplayFormat2[CardanoNativeScriptHashDisplayFormat2["BECH32"] = 1] = "BECH32";
      CardanoNativeScriptHashDisplayFormat2[CardanoNativeScriptHashDisplayFormat2["POLICY_ID"] = 2] = "POLICY_ID";
    })(CardanoNativeScriptHashDisplayFormat || (exports2.CardanoNativeScriptHashDisplayFormat = CardanoNativeScriptHashDisplayFormat = {}));
    exports2.EnumCardanoNativeScriptHashDisplayFormat = schema_utils_1.Type.Enum(CardanoNativeScriptHashDisplayFormat);
    var CardanoTxOutputSerializationFormat;
    (function(CardanoTxOutputSerializationFormat2) {
      CardanoTxOutputSerializationFormat2[CardanoTxOutputSerializationFormat2["ARRAY_LEGACY"] = 0] = "ARRAY_LEGACY";
      CardanoTxOutputSerializationFormat2[CardanoTxOutputSerializationFormat2["MAP_BABBAGE"] = 1] = "MAP_BABBAGE";
    })(CardanoTxOutputSerializationFormat || (exports2.CardanoTxOutputSerializationFormat = CardanoTxOutputSerializationFormat = {}));
    exports2.EnumCardanoTxOutputSerializationFormat = schema_utils_1.Type.Enum(CardanoTxOutputSerializationFormat);
    var CardanoCertificateType;
    (function(CardanoCertificateType2) {
      CardanoCertificateType2[CardanoCertificateType2["STAKE_REGISTRATION"] = 0] = "STAKE_REGISTRATION";
      CardanoCertificateType2[CardanoCertificateType2["STAKE_DEREGISTRATION"] = 1] = "STAKE_DEREGISTRATION";
      CardanoCertificateType2[CardanoCertificateType2["STAKE_DELEGATION"] = 2] = "STAKE_DELEGATION";
      CardanoCertificateType2[CardanoCertificateType2["STAKE_POOL_REGISTRATION"] = 3] = "STAKE_POOL_REGISTRATION";
      CardanoCertificateType2[CardanoCertificateType2["STAKE_REGISTRATION_CONWAY"] = 7] = "STAKE_REGISTRATION_CONWAY";
      CardanoCertificateType2[CardanoCertificateType2["STAKE_DEREGISTRATION_CONWAY"] = 8] = "STAKE_DEREGISTRATION_CONWAY";
      CardanoCertificateType2[CardanoCertificateType2["VOTE_DELEGATION"] = 9] = "VOTE_DELEGATION";
    })(CardanoCertificateType || (exports2.CardanoCertificateType = CardanoCertificateType = {}));
    exports2.EnumCardanoCertificateType = schema_utils_1.Type.Enum(CardanoCertificateType);
    var CardanoDRepType;
    (function(CardanoDRepType2) {
      CardanoDRepType2[CardanoDRepType2["KEY_HASH"] = 0] = "KEY_HASH";
      CardanoDRepType2[CardanoDRepType2["SCRIPT_HASH"] = 1] = "SCRIPT_HASH";
      CardanoDRepType2[CardanoDRepType2["ABSTAIN"] = 2] = "ABSTAIN";
      CardanoDRepType2[CardanoDRepType2["NO_CONFIDENCE"] = 3] = "NO_CONFIDENCE";
    })(CardanoDRepType || (exports2.CardanoDRepType = CardanoDRepType = {}));
    exports2.EnumCardanoDRepType = schema_utils_1.Type.Enum(CardanoDRepType);
    var CardanoPoolRelayType;
    (function(CardanoPoolRelayType2) {
      CardanoPoolRelayType2[CardanoPoolRelayType2["SINGLE_HOST_IP"] = 0] = "SINGLE_HOST_IP";
      CardanoPoolRelayType2[CardanoPoolRelayType2["SINGLE_HOST_NAME"] = 1] = "SINGLE_HOST_NAME";
      CardanoPoolRelayType2[CardanoPoolRelayType2["MULTIPLE_HOST_NAME"] = 2] = "MULTIPLE_HOST_NAME";
    })(CardanoPoolRelayType || (exports2.CardanoPoolRelayType = CardanoPoolRelayType = {}));
    exports2.EnumCardanoPoolRelayType = schema_utils_1.Type.Enum(CardanoPoolRelayType);
    var CardanoTxAuxiliaryDataSupplementType;
    (function(CardanoTxAuxiliaryDataSupplementType2) {
      CardanoTxAuxiliaryDataSupplementType2[CardanoTxAuxiliaryDataSupplementType2["NONE"] = 0] = "NONE";
      CardanoTxAuxiliaryDataSupplementType2[CardanoTxAuxiliaryDataSupplementType2["CVOTE_REGISTRATION_SIGNATURE"] = 1] = "CVOTE_REGISTRATION_SIGNATURE";
    })(CardanoTxAuxiliaryDataSupplementType || (exports2.CardanoTxAuxiliaryDataSupplementType = CardanoTxAuxiliaryDataSupplementType = {}));
    exports2.EnumCardanoTxAuxiliaryDataSupplementType = schema_utils_1.Type.Enum(CardanoTxAuxiliaryDataSupplementType);
    var CardanoCVoteRegistrationFormat;
    (function(CardanoCVoteRegistrationFormat2) {
      CardanoCVoteRegistrationFormat2[CardanoCVoteRegistrationFormat2["CIP15"] = 0] = "CIP15";
      CardanoCVoteRegistrationFormat2[CardanoCVoteRegistrationFormat2["CIP36"] = 1] = "CIP36";
    })(CardanoCVoteRegistrationFormat || (exports2.CardanoCVoteRegistrationFormat = CardanoCVoteRegistrationFormat = {}));
    exports2.EnumCardanoCVoteRegistrationFormat = schema_utils_1.Type.Enum(CardanoCVoteRegistrationFormat);
    var CardanoTxSigningMode;
    (function(CardanoTxSigningMode2) {
      CardanoTxSigningMode2[CardanoTxSigningMode2["ORDINARY_TRANSACTION"] = 0] = "ORDINARY_TRANSACTION";
      CardanoTxSigningMode2[CardanoTxSigningMode2["POOL_REGISTRATION_AS_OWNER"] = 1] = "POOL_REGISTRATION_AS_OWNER";
      CardanoTxSigningMode2[CardanoTxSigningMode2["MULTISIG_TRANSACTION"] = 2] = "MULTISIG_TRANSACTION";
      CardanoTxSigningMode2[CardanoTxSigningMode2["PLUTUS_TRANSACTION"] = 3] = "PLUTUS_TRANSACTION";
    })(CardanoTxSigningMode || (exports2.CardanoTxSigningMode = CardanoTxSigningMode = {}));
    exports2.EnumCardanoTxSigningMode = schema_utils_1.Type.Enum(CardanoTxSigningMode);
    var CardanoTxWitnessType;
    (function(CardanoTxWitnessType2) {
      CardanoTxWitnessType2[CardanoTxWitnessType2["BYRON_WITNESS"] = 0] = "BYRON_WITNESS";
      CardanoTxWitnessType2[CardanoTxWitnessType2["SHELLEY_WITNESS"] = 1] = "SHELLEY_WITNESS";
    })(CardanoTxWitnessType || (exports2.CardanoTxWitnessType = CardanoTxWitnessType = {}));
    exports2.EnumCardanoTxWitnessType = schema_utils_1.Type.Enum(CardanoTxWitnessType);
    exports2.CardanoBlockchainPointerType = schema_utils_1.Type.Object({
      block_index: schema_utils_1.Type.Number(),
      tx_index: schema_utils_1.Type.Number(),
      certificate_index: schema_utils_1.Type.Number()
    }, { $id: "CardanoBlockchainPointerType" });
    exports2.CardanoNativeScript = schema_utils_1.Type.Recursive((This) => schema_utils_1.Type.Object({
      type: exports2.EnumCardanoNativeScriptType,
      scripts: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(This)),
      key_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      key_path: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(schema_utils_1.Type.Number())),
      required_signatures_count: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      invalid_before: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint()),
      invalid_hereafter: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint())
    }), { $id: "CardanoNativeScript" });
    exports2.CardanoGetNativeScriptHash = schema_utils_1.Type.Object({
      script: exports2.CardanoNativeScript,
      display_format: exports2.EnumCardanoNativeScriptHashDisplayFormat,
      derivation_type: exports2.EnumCardanoDerivationType
    }, { $id: "CardanoGetNativeScriptHash" });
    exports2.CardanoNativeScriptHash = schema_utils_1.Type.Object({
      script_hash: schema_utils_1.Type.String()
    }, { $id: "CardanoNativeScriptHash" });
    exports2.CardanoAddressParametersType = schema_utils_1.Type.Object({
      address_type: exports2.EnumCardanoAddressType,
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      address_n_staking: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      staking_key_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      certificate_pointer: schema_utils_1.Type.Optional(exports2.CardanoBlockchainPointerType),
      script_payment_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      script_staking_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, { $id: "CardanoAddressParametersType" });
    exports2.CardanoGetAddress = schema_utils_1.Type.Object({
      show_display: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      protocol_magic: schema_utils_1.Type.Number(),
      network_id: schema_utils_1.Type.Number(),
      address_parameters: exports2.CardanoAddressParametersType,
      derivation_type: exports2.EnumCardanoDerivationType,
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, { $id: "CardanoGetAddress" });
    exports2.CardanoAddress = schema_utils_1.Type.Object({
      address: schema_utils_1.Type.String(),
      mac: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, { $id: "CardanoAddress" });
    exports2.CardanoGetPublicKey = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      show_display: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      derivation_type: exports2.EnumCardanoDerivationType
    }, { $id: "CardanoGetPublicKey" });
    exports2.CardanoPublicKey = schema_utils_1.Type.Object({
      xpub: schema_utils_1.Type.String(),
      node: exports2.HDNodeType
    }, { $id: "CardanoPublicKey" });
    exports2.CardanoSignTxInit = schema_utils_1.Type.Object({
      signing_mode: exports2.EnumCardanoTxSigningMode,
      protocol_magic: schema_utils_1.Type.Number(),
      network_id: schema_utils_1.Type.Number(),
      inputs_count: schema_utils_1.Type.Number(),
      outputs_count: schema_utils_1.Type.Number(),
      fee: schema_utils_1.Type.Uint(),
      ttl: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint()),
      certificates_count: schema_utils_1.Type.Number(),
      withdrawals_count: schema_utils_1.Type.Number(),
      has_auxiliary_data: schema_utils_1.Type.Boolean(),
      validity_interval_start: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint()),
      witness_requests_count: schema_utils_1.Type.Number(),
      minting_asset_groups_count: schema_utils_1.Type.Number(),
      derivation_type: exports2.EnumCardanoDerivationType,
      include_network_id: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      script_data_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      collateral_inputs_count: schema_utils_1.Type.Number(),
      required_signers_count: schema_utils_1.Type.Number(),
      has_collateral_return: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      total_collateral: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint()),
      reference_inputs_count: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      tag_cbor_sets: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      payment_req: schema_utils_1.Type.Optional(exports2.PaymentRequest)
    }, { $id: "CardanoSignTxInit" });
    exports2.CardanoTxInput = schema_utils_1.Type.Object({
      prev_hash: schema_utils_1.Type.String(),
      prev_index: schema_utils_1.Type.Number()
    }, { $id: "CardanoTxInput" });
    exports2.CardanoTxOutput = schema_utils_1.Type.Object({
      address: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      address_parameters: schema_utils_1.Type.Optional(exports2.CardanoAddressParametersType),
      amount: schema_utils_1.Type.Uint(),
      asset_groups_count: schema_utils_1.Type.Number(),
      datum_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      format: schema_utils_1.Type.Optional(exports2.EnumCardanoTxOutputSerializationFormat),
      inline_datum_size: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      reference_script_size: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    }, { $id: "CardanoTxOutput" });
    exports2.CardanoAssetGroup = schema_utils_1.Type.Object({
      policy_id: schema_utils_1.Type.String(),
      tokens_count: schema_utils_1.Type.Number()
    }, { $id: "CardanoAssetGroup" });
    exports2.CardanoToken = schema_utils_1.Type.Object({
      asset_name_bytes: schema_utils_1.Type.String(),
      amount: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint()),
      mint_amount: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint({ allowNegative: true }))
    }, { $id: "CardanoToken" });
    exports2.CardanoTxInlineDatumChunk = schema_utils_1.Type.Object({
      data: schema_utils_1.Type.String()
    }, { $id: "CardanoTxInlineDatumChunk" });
    exports2.CardanoTxReferenceScriptChunk = schema_utils_1.Type.Object({
      data: schema_utils_1.Type.String()
    }, { $id: "CardanoTxReferenceScriptChunk" });
    exports2.CardanoPoolOwner = schema_utils_1.Type.Object({
      staking_key_path: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(schema_utils_1.Type.Number())),
      staking_key_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, { $id: "CardanoPoolOwner" });
    exports2.CardanoPoolRelayParameters = schema_utils_1.Type.Object({
      type: exports2.EnumCardanoPoolRelayType,
      ipv4_address: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      ipv6_address: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      host_name: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      port: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    }, { $id: "CardanoPoolRelayParameters" });
    exports2.CardanoPoolMetadataType = schema_utils_1.Type.Object({
      url: schema_utils_1.Type.String(),
      hash: schema_utils_1.Type.String()
    }, { $id: "CardanoPoolMetadataType" });
    exports2.CardanoPoolParametersType = schema_utils_1.Type.Object({
      pool_id: schema_utils_1.Type.String(),
      vrf_key_hash: schema_utils_1.Type.String(),
      pledge: schema_utils_1.Type.Uint(),
      cost: schema_utils_1.Type.Uint(),
      margin_numerator: schema_utils_1.Type.Uint(),
      margin_denominator: schema_utils_1.Type.Uint(),
      reward_account: schema_utils_1.Type.String(),
      metadata: schema_utils_1.Type.Optional(exports2.CardanoPoolMetadataType),
      owners_count: schema_utils_1.Type.Number(),
      relays_count: schema_utils_1.Type.Number()
    }, { $id: "CardanoPoolParametersType" });
    exports2.CardanoDRep = schema_utils_1.Type.Object({
      type: exports2.EnumCardanoDRepType,
      key_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      script_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, { $id: "CardanoDRep" });
    exports2.CardanoTxCertificate = schema_utils_1.Type.Object({
      type: exports2.EnumCardanoCertificateType,
      path: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(schema_utils_1.Type.Number())),
      pool: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      pool_parameters: schema_utils_1.Type.Optional(exports2.CardanoPoolParametersType),
      script_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      key_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      deposit: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint()),
      drep: schema_utils_1.Type.Optional(exports2.CardanoDRep)
    }, { $id: "CardanoTxCertificate" });
    exports2.CardanoTxWithdrawal = schema_utils_1.Type.Object({
      path: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(schema_utils_1.Type.Number())),
      amount: schema_utils_1.Type.Uint(),
      script_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      key_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, { $id: "CardanoTxWithdrawal" });
    exports2.CardanoCVoteRegistrationDelegation = schema_utils_1.Type.Object({
      vote_public_key: schema_utils_1.Type.String(),
      weight: schema_utils_1.Type.Uint()
    }, { $id: "CardanoCVoteRegistrationDelegation" });
    exports2.CardanoCVoteRegistrationParametersType = schema_utils_1.Type.Object({
      vote_public_key: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      staking_path: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      payment_address_parameters: schema_utils_1.Type.Optional(exports2.CardanoAddressParametersType),
      nonce: schema_utils_1.Type.Uint(),
      format: schema_utils_1.Type.Optional(exports2.EnumCardanoCVoteRegistrationFormat),
      delegations: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(exports2.CardanoCVoteRegistrationDelegation)),
      voting_purpose: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint()),
      payment_address: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, { $id: "CardanoCVoteRegistrationParametersType" });
    exports2.CardanoTxAuxiliaryData = schema_utils_1.Type.Object({
      cvote_registration_parameters: schema_utils_1.Type.Optional(exports2.CardanoCVoteRegistrationParametersType),
      hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, { $id: "CardanoTxAuxiliaryData" });
    exports2.CardanoTxMint = schema_utils_1.Type.Object({
      asset_groups_count: schema_utils_1.Type.Number()
    }, { $id: "CardanoTxMint" });
    exports2.CardanoTxCollateralInput = schema_utils_1.Type.Object({
      prev_hash: schema_utils_1.Type.String(),
      prev_index: schema_utils_1.Type.Number()
    }, { $id: "CardanoTxCollateralInput" });
    exports2.CardanoTxRequiredSigner = schema_utils_1.Type.Object({
      key_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      key_path: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(schema_utils_1.Type.Number()))
    }, { $id: "CardanoTxRequiredSigner" });
    exports2.CardanoTxReferenceInput = schema_utils_1.Type.Object({
      prev_hash: schema_utils_1.Type.String(),
      prev_index: schema_utils_1.Type.Number()
    }, { $id: "CardanoTxReferenceInput" });
    exports2.CardanoTxItemAck = schema_utils_1.Type.Object({}, { $id: "CardanoTxItemAck" });
    exports2.CardanoTxAuxiliaryDataSupplement = schema_utils_1.Type.Object({
      type: exports2.EnumCardanoTxAuxiliaryDataSupplementType,
      auxiliary_data_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      cvote_registration_signature: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, { $id: "CardanoTxAuxiliaryDataSupplement" });
    exports2.CardanoTxWitnessRequest = schema_utils_1.Type.Object({
      path: schema_utils_1.Type.Array(schema_utils_1.Type.Number())
    }, { $id: "CardanoTxWitnessRequest" });
    exports2.CardanoTxWitnessResponse = schema_utils_1.Type.Object({
      type: exports2.EnumCardanoTxWitnessType,
      pub_key: schema_utils_1.Type.String(),
      signature: schema_utils_1.Type.String(),
      chain_code: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, { $id: "CardanoTxWitnessResponse" });
    exports2.CardanoTxHostAck = schema_utils_1.Type.Object({}, { $id: "CardanoTxHostAck" });
    exports2.CardanoTxBodyHash = schema_utils_1.Type.Object({
      tx_hash: schema_utils_1.Type.String()
    }, { $id: "CardanoTxBodyHash" });
    exports2.CardanoSignTxFinished = schema_utils_1.Type.Object({}, { $id: "CardanoSignTxFinished" });
    exports2.CardanoSignMessageInit = schema_utils_1.Type.Object({
      protocol_magic: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      network_id: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      signing_path: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      payload_size: schema_utils_1.Type.Number(),
      prefer_hex_display: schema_utils_1.Type.Boolean(),
      address_parameters: schema_utils_1.Type.Optional(exports2.CardanoAddressParametersType),
      derivation_type: exports2.EnumCardanoDerivationType
    }, { $id: "CardanoSignMessageInit" });
    exports2.CardanoMessageDataRequest = schema_utils_1.Type.Object({
      length: schema_utils_1.Type.Number(),
      offset: schema_utils_1.Type.Number()
    }, { $id: "CardanoMessageDataRequest" });
    exports2.CardanoMessageDataResponse = schema_utils_1.Type.Object({
      data: schema_utils_1.Type.String()
    }, { $id: "CardanoMessageDataResponse" });
    exports2.CardanoMessageSignature = schema_utils_1.Type.Object({
      signature: schema_utils_1.Type.String(),
      address: schema_utils_1.Type.String(),
      pub_key: schema_utils_1.Type.String()
    }, { $id: "CardanoMessageSignature" });
    exports2.Success = schema_utils_1.Type.Object({
      message: schema_utils_1.Type.String()
    }, { $id: "Success" });
    var Enum_FailureType;
    (function(Enum_FailureType2) {
      Enum_FailureType2[Enum_FailureType2["Failure_UnexpectedMessage"] = 1] = "Failure_UnexpectedMessage";
      Enum_FailureType2[Enum_FailureType2["Failure_ButtonExpected"] = 2] = "Failure_ButtonExpected";
      Enum_FailureType2[Enum_FailureType2["Failure_DataError"] = 3] = "Failure_DataError";
      Enum_FailureType2[Enum_FailureType2["Failure_ActionCancelled"] = 4] = "Failure_ActionCancelled";
      Enum_FailureType2[Enum_FailureType2["Failure_PinExpected"] = 5] = "Failure_PinExpected";
      Enum_FailureType2[Enum_FailureType2["Failure_PinCancelled"] = 6] = "Failure_PinCancelled";
      Enum_FailureType2[Enum_FailureType2["Failure_PinInvalid"] = 7] = "Failure_PinInvalid";
      Enum_FailureType2[Enum_FailureType2["Failure_InvalidSignature"] = 8] = "Failure_InvalidSignature";
      Enum_FailureType2[Enum_FailureType2["Failure_ProcessError"] = 9] = "Failure_ProcessError";
      Enum_FailureType2[Enum_FailureType2["Failure_NotEnoughFunds"] = 10] = "Failure_NotEnoughFunds";
      Enum_FailureType2[Enum_FailureType2["Failure_NotInitialized"] = 11] = "Failure_NotInitialized";
      Enum_FailureType2[Enum_FailureType2["Failure_PinMismatch"] = 12] = "Failure_PinMismatch";
      Enum_FailureType2[Enum_FailureType2["Failure_WipeCodeMismatch"] = 13] = "Failure_WipeCodeMismatch";
      Enum_FailureType2[Enum_FailureType2["Failure_InvalidSession"] = 14] = "Failure_InvalidSession";
      Enum_FailureType2[Enum_FailureType2["Failure_Busy"] = 15] = "Failure_Busy";
      Enum_FailureType2[Enum_FailureType2["Failure_ThpUnallocatedSession"] = 16] = "Failure_ThpUnallocatedSession";
      Enum_FailureType2[Enum_FailureType2["Failure_InvalidProtocol"] = 17] = "Failure_InvalidProtocol";
      Enum_FailureType2[Enum_FailureType2["Failure_BufferError"] = 18] = "Failure_BufferError";
      Enum_FailureType2[Enum_FailureType2["Failure_FirmwareError"] = 99] = "Failure_FirmwareError";
    })(Enum_FailureType || (exports2.Enum_FailureType = Enum_FailureType = {}));
    exports2.EnumEnum_FailureType = schema_utils_1.Type.Enum(Enum_FailureType);
    exports2.FailureType = schema_utils_1.Type.KeyOfEnum(Enum_FailureType, { $id: "FailureType" });
    exports2.Failure = schema_utils_1.Type.Object({
      code: schema_utils_1.Type.Optional(exports2.FailureType),
      message: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, { $id: "Failure" });
    var Enum_ButtonRequestType;
    (function(Enum_ButtonRequestType2) {
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_Other"] = 1] = "ButtonRequest_Other";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_FeeOverThreshold"] = 2] = "ButtonRequest_FeeOverThreshold";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_ConfirmOutput"] = 3] = "ButtonRequest_ConfirmOutput";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_ResetDevice"] = 4] = "ButtonRequest_ResetDevice";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_ConfirmWord"] = 5] = "ButtonRequest_ConfirmWord";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_WipeDevice"] = 6] = "ButtonRequest_WipeDevice";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_ProtectCall"] = 7] = "ButtonRequest_ProtectCall";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_SignTx"] = 8] = "ButtonRequest_SignTx";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_FirmwareCheck"] = 9] = "ButtonRequest_FirmwareCheck";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_Address"] = 10] = "ButtonRequest_Address";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_PublicKey"] = 11] = "ButtonRequest_PublicKey";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_MnemonicWordCount"] = 12] = "ButtonRequest_MnemonicWordCount";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_MnemonicInput"] = 13] = "ButtonRequest_MnemonicInput";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["_Deprecated_ButtonRequest_PassphraseType"] = 14] = "_Deprecated_ButtonRequest_PassphraseType";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_UnknownDerivationPath"] = 15] = "ButtonRequest_UnknownDerivationPath";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_RecoveryHomepage"] = 16] = "ButtonRequest_RecoveryHomepage";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_Success"] = 17] = "ButtonRequest_Success";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_Warning"] = 18] = "ButtonRequest_Warning";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_PassphraseEntry"] = 19] = "ButtonRequest_PassphraseEntry";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_PinEntry"] = 20] = "ButtonRequest_PinEntry";
    })(Enum_ButtonRequestType || (exports2.Enum_ButtonRequestType = Enum_ButtonRequestType = {}));
    exports2.EnumEnum_ButtonRequestType = schema_utils_1.Type.Enum(Enum_ButtonRequestType);
    exports2.ButtonRequestType = schema_utils_1.Type.KeyOfEnum(Enum_ButtonRequestType, {
      $id: "ButtonRequestType"
    });
    exports2.ButtonRequest = schema_utils_1.Type.Object({
      code: schema_utils_1.Type.Optional(exports2.ButtonRequestType),
      pages: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      name: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, { $id: "ButtonRequest" });
    exports2.ButtonAck = schema_utils_1.Type.Object({}, { $id: "ButtonAck" });
    var Enum_PinMatrixRequestType;
    (function(Enum_PinMatrixRequestType2) {
      Enum_PinMatrixRequestType2[Enum_PinMatrixRequestType2["PinMatrixRequestType_Current"] = 1] = "PinMatrixRequestType_Current";
      Enum_PinMatrixRequestType2[Enum_PinMatrixRequestType2["PinMatrixRequestType_NewFirst"] = 2] = "PinMatrixRequestType_NewFirst";
      Enum_PinMatrixRequestType2[Enum_PinMatrixRequestType2["PinMatrixRequestType_NewSecond"] = 3] = "PinMatrixRequestType_NewSecond";
      Enum_PinMatrixRequestType2[Enum_PinMatrixRequestType2["PinMatrixRequestType_WipeCodeFirst"] = 4] = "PinMatrixRequestType_WipeCodeFirst";
      Enum_PinMatrixRequestType2[Enum_PinMatrixRequestType2["PinMatrixRequestType_WipeCodeSecond"] = 5] = "PinMatrixRequestType_WipeCodeSecond";
    })(Enum_PinMatrixRequestType || (exports2.Enum_PinMatrixRequestType = Enum_PinMatrixRequestType = {}));
    exports2.EnumEnum_PinMatrixRequestType = schema_utils_1.Type.Enum(Enum_PinMatrixRequestType);
    exports2.PinMatrixRequestType = schema_utils_1.Type.KeyOfEnum(Enum_PinMatrixRequestType, {
      $id: "PinMatrixRequestType"
    });
    exports2.PinMatrixRequest = schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Optional(exports2.PinMatrixRequestType)
    }, { $id: "PinMatrixRequest" });
    exports2.PinMatrixAck = schema_utils_1.Type.Object({
      pin: schema_utils_1.Type.String()
    }, { $id: "PinMatrixAck" });
    exports2.PassphraseRequest = schema_utils_1.Type.Object({
      _on_device: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, { $id: "PassphraseRequest" });
    exports2.PassphraseAck = schema_utils_1.Type.Object({
      passphrase: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      _state: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      on_device: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, { $id: "PassphraseAck" });
    exports2.Deprecated_PassphraseStateRequest = schema_utils_1.Type.Object({
      state: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, { $id: "Deprecated_PassphraseStateRequest" });
    exports2.Deprecated_PassphraseStateAck = schema_utils_1.Type.Object({}, { $id: "Deprecated_PassphraseStateAck" });
    exports2.CipherKeyValue = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      key: schema_utils_1.Type.String(),
      value: schema_utils_1.Type.String(),
      encrypt: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      ask_on_encrypt: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      ask_on_decrypt: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      iv: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, { $id: "CipherKeyValue" });
    exports2.CipheredKeyValue = schema_utils_1.Type.Object({
      value: schema_utils_1.Type.String()
    }, { $id: "CipheredKeyValue" });
    exports2.IdentityType = schema_utils_1.Type.Object({
      proto: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      user: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      host: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      port: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      path: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      index: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    }, { $id: "IdentityType" });
    exports2.SignIdentity = schema_utils_1.Type.Object({
      identity: exports2.IdentityType,
      challenge_hidden: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      challenge_visual: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      ecdsa_curve_name: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, { $id: "SignIdentity" });
    exports2.SignedIdentity = schema_utils_1.Type.Object({
      address: schema_utils_1.Type.String(),
      public_key: schema_utils_1.Type.String(),
      signature: schema_utils_1.Type.String()
    }, { $id: "SignedIdentity" });
    exports2.GetECDHSessionKey = schema_utils_1.Type.Object({
      identity: exports2.IdentityType,
      peer_public_key: schema_utils_1.Type.String(),
      ecdsa_curve_name: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, { $id: "GetECDHSessionKey" });
    exports2.ECDHSessionKey = schema_utils_1.Type.Object({
      session_key: schema_utils_1.Type.String(),
      public_key: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, { $id: "ECDHSessionKey" });
    exports2.PaymentNotification = schema_utils_1.Type.Object({
      payment_req: schema_utils_1.Type.Optional(exports2.PaymentRequest)
    }, { $id: "PaymentNotification" });
    var DebugButton;
    (function(DebugButton2) {
      DebugButton2[DebugButton2["NO"] = 0] = "NO";
      DebugButton2[DebugButton2["YES"] = 1] = "YES";
      DebugButton2[DebugButton2["INFO"] = 2] = "INFO";
    })(DebugButton || (exports2.DebugButton = DebugButton = {}));
    exports2.EnumDebugButton = schema_utils_1.Type.Enum(DebugButton);
    var DebugPhysicalButton;
    (function(DebugPhysicalButton2) {
      DebugPhysicalButton2[DebugPhysicalButton2["LEFT_BTN"] = 0] = "LEFT_BTN";
      DebugPhysicalButton2[DebugPhysicalButton2["MIDDLE_BTN"] = 1] = "MIDDLE_BTN";
      DebugPhysicalButton2[DebugPhysicalButton2["RIGHT_BTN"] = 2] = "RIGHT_BTN";
    })(DebugPhysicalButton || (exports2.DebugPhysicalButton = DebugPhysicalButton = {}));
    exports2.EnumDebugPhysicalButton = schema_utils_1.Type.Enum(DebugPhysicalButton);
    var DebugTouchEventType;
    (function(DebugTouchEventType2) {
      DebugTouchEventType2[DebugTouchEventType2["TOUCH_FULL_CLICK"] = 0] = "TOUCH_FULL_CLICK";
      DebugTouchEventType2[DebugTouchEventType2["TOUCH_START"] = 1] = "TOUCH_START";
      DebugTouchEventType2[DebugTouchEventType2["TOUCH_END"] = 2] = "TOUCH_END";
    })(DebugTouchEventType || (exports2.DebugTouchEventType = DebugTouchEventType = {}));
    exports2.EnumDebugTouchEventType = schema_utils_1.Type.Enum(DebugTouchEventType);
    var DebugWaitType;
    (function(DebugWaitType2) {
      DebugWaitType2[DebugWaitType2["IMMEDIATE"] = 0] = "IMMEDIATE";
      DebugWaitType2[DebugWaitType2["NEXT_LAYOUT"] = 1] = "NEXT_LAYOUT";
      DebugWaitType2[DebugWaitType2["CURRENT_LAYOUT"] = 2] = "CURRENT_LAYOUT";
    })(DebugWaitType || (exports2.DebugWaitType = DebugWaitType = {}));
    exports2.EnumDebugWaitType = schema_utils_1.Type.Enum(DebugWaitType);
    exports2.DebugLinkGetPairingInfo = schema_utils_1.Type.Object({
      channel_id: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      handshake_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      nfc_secret_host: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, { $id: "DebugLinkGetPairingInfo" });
    exports2.DebugLinkPairingInfo = schema_utils_1.Type.Object({
      channel_id: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      handshake_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      code_entry_code: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      code_qr_code: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      nfc_secret_trezor: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, { $id: "DebugLinkPairingInfo" });
    exports2.DebugLinkResetDebugEvents = schema_utils_1.Type.Object({}, { $id: "DebugLinkResetDebugEvents" });
    exports2.DebugLinkOptigaSetSecMax = schema_utils_1.Type.Object({}, { $id: "DebugLinkOptigaSetSecMax" });
    exports2.DebugLinkGetGcInfo = schema_utils_1.Type.Object({}, { $id: "DebugLinkGetGcInfo" });
    exports2.DebugLinkGcInfoItem = schema_utils_1.Type.Object({
      name: schema_utils_1.Type.String(),
      value: schema_utils_1.Type.Number()
    }, { $id: "DebugLinkGcInfoItem" });
    exports2.DebugLinkGcInfo = schema_utils_1.Type.Object({
      items: schema_utils_1.Type.Array(exports2.DebugLinkGcInfoItem)
    }, { $id: "DebugLinkGcInfo" });
    var DefinitionType;
    (function(DefinitionType2) {
      DefinitionType2[DefinitionType2["ETHEREUM_NETWORK"] = 0] = "ETHEREUM_NETWORK";
      DefinitionType2[DefinitionType2["ETHEREUM_TOKEN"] = 1] = "ETHEREUM_TOKEN";
      DefinitionType2[DefinitionType2["SOLANA_TOKEN"] = 2] = "SOLANA_TOKEN";
    })(DefinitionType || (exports2.DefinitionType = DefinitionType = {}));
    exports2.EnumDefinitionType = schema_utils_1.Type.Enum(DefinitionType);
    exports2.EthereumNetworkInfo = schema_utils_1.Type.Object({
      chain_id: schema_utils_1.Type.Number(),
      symbol: schema_utils_1.Type.String(),
      slip44: schema_utils_1.Type.Number(),
      name: schema_utils_1.Type.String()
    }, { $id: "EthereumNetworkInfo" });
    exports2.EthereumTokenInfo = schema_utils_1.Type.Object({
      address: schema_utils_1.Type.String(),
      chain_id: schema_utils_1.Type.Number(),
      symbol: schema_utils_1.Type.String(),
      decimals: schema_utils_1.Type.Number(),
      name: schema_utils_1.Type.String()
    }, { $id: "EthereumTokenInfo" });
    exports2.SolanaTokenInfo = schema_utils_1.Type.Object({
      mint: schema_utils_1.Type.String(),
      symbol: schema_utils_1.Type.String(),
      name: schema_utils_1.Type.String()
    }, { $id: "SolanaTokenInfo" });
    exports2.EosGetPublicKey = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      show_display: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, { $id: "EosGetPublicKey" });
    exports2.EosPublicKey = schema_utils_1.Type.Object({
      wif_public_key: schema_utils_1.Type.String(),
      raw_public_key: schema_utils_1.Type.String()
    }, { $id: "EosPublicKey" });
    exports2.EosTxHeader = schema_utils_1.Type.Object({
      expiration: schema_utils_1.Type.Number(),
      ref_block_num: schema_utils_1.Type.Number(),
      ref_block_prefix: schema_utils_1.Type.Number(),
      max_net_usage_words: schema_utils_1.Type.Number(),
      max_cpu_usage_ms: schema_utils_1.Type.Number(),
      delay_sec: schema_utils_1.Type.Number()
    }, { $id: "EosTxHeader" });
    exports2.EosSignTx = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      chain_id: schema_utils_1.Type.String(),
      header: exports2.EosTxHeader,
      num_actions: schema_utils_1.Type.Number(),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, { $id: "EosSignTx" });
    exports2.EosTxActionRequest = schema_utils_1.Type.Object({
      data_size: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    }, { $id: "EosTxActionRequest" });
    exports2.EosAsset = schema_utils_1.Type.Object({
      amount: schema_utils_1.Type.Uint(),
      symbol: schema_utils_1.Type.String()
    }, { $id: "EosAsset" });
    exports2.EosPermissionLevel = schema_utils_1.Type.Object({
      actor: schema_utils_1.Type.String(),
      permission: schema_utils_1.Type.String()
    }, { $id: "EosPermissionLevel" });
    exports2.EosAuthorizationKey = schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      key: schema_utils_1.Type.String(),
      address_n: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(schema_utils_1.Type.Number())),
      weight: schema_utils_1.Type.Number()
    }, { $id: "EosAuthorizationKey" });
    exports2.EosAuthorizationAccount = schema_utils_1.Type.Object({
      account: exports2.EosPermissionLevel,
      weight: schema_utils_1.Type.Number()
    }, { $id: "EosAuthorizationAccount" });
    exports2.EosAuthorizationWait = schema_utils_1.Type.Object({
      wait_sec: schema_utils_1.Type.Number(),
      weight: schema_utils_1.Type.Number()
    }, { $id: "EosAuthorizationWait" });
    exports2.EosAuthorization = schema_utils_1.Type.Object({
      threshold: schema_utils_1.Type.Number(),
      keys: schema_utils_1.Type.Array(exports2.EosAuthorizationKey),
      accounts: schema_utils_1.Type.Array(exports2.EosAuthorizationAccount),
      waits: schema_utils_1.Type.Array(exports2.EosAuthorizationWait)
    }, { $id: "EosAuthorization" });
    exports2.EosActionCommon = schema_utils_1.Type.Object({
      account: schema_utils_1.Type.String(),
      name: schema_utils_1.Type.String(),
      authorization: schema_utils_1.Type.Array(exports2.EosPermissionLevel)
    }, { $id: "EosActionCommon" });
    exports2.EosActionTransfer = schema_utils_1.Type.Object({
      sender: schema_utils_1.Type.String(),
      receiver: schema_utils_1.Type.String(),
      quantity: exports2.EosAsset,
      memo: schema_utils_1.Type.String()
    }, { $id: "EosActionTransfer" });
    exports2.EosActionDelegate = schema_utils_1.Type.Object({
      sender: schema_utils_1.Type.String(),
      receiver: schema_utils_1.Type.String(),
      net_quantity: exports2.EosAsset,
      cpu_quantity: exports2.EosAsset,
      transfer: schema_utils_1.Type.Boolean()
    }, { $id: "EosActionDelegate" });
    exports2.EosActionUndelegate = schema_utils_1.Type.Object({
      sender: schema_utils_1.Type.String(),
      receiver: schema_utils_1.Type.String(),
      net_quantity: exports2.EosAsset,
      cpu_quantity: exports2.EosAsset
    }, { $id: "EosActionUndelegate" });
    exports2.EosActionRefund = schema_utils_1.Type.Object({
      owner: schema_utils_1.Type.String()
    }, { $id: "EosActionRefund" });
    exports2.EosActionBuyRam = schema_utils_1.Type.Object({
      payer: schema_utils_1.Type.String(),
      receiver: schema_utils_1.Type.String(),
      quantity: exports2.EosAsset
    }, { $id: "EosActionBuyRam" });
    exports2.EosActionBuyRamBytes = schema_utils_1.Type.Object({
      payer: schema_utils_1.Type.String(),
      receiver: schema_utils_1.Type.String(),
      bytes: schema_utils_1.Type.Number()
    }, { $id: "EosActionBuyRamBytes" });
    exports2.EosActionSellRam = schema_utils_1.Type.Object({
      account: schema_utils_1.Type.String(),
      bytes: schema_utils_1.Type.Number()
    }, { $id: "EosActionSellRam" });
    exports2.EosActionVoteProducer = schema_utils_1.Type.Object({
      voter: schema_utils_1.Type.String(),
      proxy: schema_utils_1.Type.String(),
      producers: schema_utils_1.Type.Array(schema_utils_1.Type.String())
    }, { $id: "EosActionVoteProducer" });
    exports2.EosActionUpdateAuth = schema_utils_1.Type.Object({
      account: schema_utils_1.Type.String(),
      permission: schema_utils_1.Type.String(),
      parent: schema_utils_1.Type.String(),
      auth: exports2.EosAuthorization
    }, { $id: "EosActionUpdateAuth" });
    exports2.EosActionDeleteAuth = schema_utils_1.Type.Object({
      account: schema_utils_1.Type.String(),
      permission: schema_utils_1.Type.String()
    }, { $id: "EosActionDeleteAuth" });
    exports2.EosActionLinkAuth = schema_utils_1.Type.Object({
      account: schema_utils_1.Type.String(),
      code: schema_utils_1.Type.String(),
      type: schema_utils_1.Type.String(),
      requirement: schema_utils_1.Type.String()
    }, { $id: "EosActionLinkAuth" });
    exports2.EosActionUnlinkAuth = schema_utils_1.Type.Object({
      account: schema_utils_1.Type.String(),
      code: schema_utils_1.Type.String(),
      type: schema_utils_1.Type.String()
    }, { $id: "EosActionUnlinkAuth" });
    exports2.EosActionNewAccount = schema_utils_1.Type.Object({
      creator: schema_utils_1.Type.String(),
      name: schema_utils_1.Type.String(),
      owner: exports2.EosAuthorization,
      active: exports2.EosAuthorization
    }, { $id: "EosActionNewAccount" });
    exports2.EosActionUnknown = schema_utils_1.Type.Object({
      data_size: schema_utils_1.Type.Number(),
      data_chunk: schema_utils_1.Type.String()
    }, { $id: "EosActionUnknown" });
    exports2.EosTxActionAck = schema_utils_1.Type.Object({
      common: exports2.EosActionCommon,
      transfer: schema_utils_1.Type.Optional(exports2.EosActionTransfer),
      delegate: schema_utils_1.Type.Optional(exports2.EosActionDelegate),
      undelegate: schema_utils_1.Type.Optional(exports2.EosActionUndelegate),
      refund: schema_utils_1.Type.Optional(exports2.EosActionRefund),
      buy_ram: schema_utils_1.Type.Optional(exports2.EosActionBuyRam),
      buy_ram_bytes: schema_utils_1.Type.Optional(exports2.EosActionBuyRamBytes),
      sell_ram: schema_utils_1.Type.Optional(exports2.EosActionSellRam),
      vote_producer: schema_utils_1.Type.Optional(exports2.EosActionVoteProducer),
      update_auth: schema_utils_1.Type.Optional(exports2.EosActionUpdateAuth),
      delete_auth: schema_utils_1.Type.Optional(exports2.EosActionDeleteAuth),
      link_auth: schema_utils_1.Type.Optional(exports2.EosActionLinkAuth),
      unlink_auth: schema_utils_1.Type.Optional(exports2.EosActionUnlinkAuth),
      new_account: schema_utils_1.Type.Optional(exports2.EosActionNewAccount),
      unknown: schema_utils_1.Type.Optional(exports2.EosActionUnknown)
    }, { $id: "EosTxActionAck" });
    exports2.EosSignedTx = schema_utils_1.Type.Object({
      signature: schema_utils_1.Type.String()
    }, { $id: "EosSignedTx" });
    exports2.EthereumDefinitions = schema_utils_1.Type.Object({
      encoded_network: schema_utils_1.Type.Optional(schema_utils_1.Type.ArrayBuffer()),
      encoded_token: schema_utils_1.Type.Optional(schema_utils_1.Type.ArrayBuffer())
    }, { $id: "EthereumDefinitions" });
    exports2.EthereumSignTypedData = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      primary_type: schema_utils_1.Type.String(),
      metamask_v4_compat: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      definitions: schema_utils_1.Type.Optional(exports2.EthereumDefinitions),
      show_message_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, { $id: "EthereumSignTypedData" });
    exports2.EthereumTypedDataStructRequest = schema_utils_1.Type.Object({
      name: schema_utils_1.Type.String()
    }, { $id: "EthereumTypedDataStructRequest" });
    var EthereumDataType;
    (function(EthereumDataType2) {
      EthereumDataType2[EthereumDataType2["UINT"] = 1] = "UINT";
      EthereumDataType2[EthereumDataType2["INT"] = 2] = "INT";
      EthereumDataType2[EthereumDataType2["BYTES"] = 3] = "BYTES";
      EthereumDataType2[EthereumDataType2["STRING"] = 4] = "STRING";
      EthereumDataType2[EthereumDataType2["BOOL"] = 5] = "BOOL";
      EthereumDataType2[EthereumDataType2["ADDRESS"] = 6] = "ADDRESS";
      EthereumDataType2[EthereumDataType2["ARRAY"] = 7] = "ARRAY";
      EthereumDataType2[EthereumDataType2["STRUCT"] = 8] = "STRUCT";
    })(EthereumDataType || (exports2.EthereumDataType = EthereumDataType = {}));
    exports2.EnumEthereumDataType = schema_utils_1.Type.Enum(EthereumDataType);
    exports2.EthereumFieldType = schema_utils_1.Type.Recursive((This) => schema_utils_1.Type.Object({
      data_type: exports2.EnumEthereumDataType,
      size: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      entry_type: schema_utils_1.Type.Optional(This),
      struct_name: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }), { $id: "EthereumFieldType" });
    exports2.EthereumStructMember = schema_utils_1.Type.Object({
      type: exports2.EthereumFieldType,
      name: schema_utils_1.Type.String()
    }, { $id: "EthereumStructMember" });
    exports2.EthereumTypedDataStructAck = schema_utils_1.Type.Object({
      members: schema_utils_1.Type.Array(exports2.EthereumStructMember)
    }, { $id: "EthereumTypedDataStructAck" });
    exports2.EthereumTypedDataValueRequest = schema_utils_1.Type.Object({
      member_path: schema_utils_1.Type.Array(schema_utils_1.Type.Number())
    }, { $id: "EthereumTypedDataValueRequest" });
    exports2.EthereumTypedDataValueAck = schema_utils_1.Type.Object({
      value: schema_utils_1.Type.String()
    }, { $id: "EthereumTypedDataValueAck" });
    exports2.EthereumGetPublicKey = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      show_display: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, { $id: "EthereumGetPublicKey" });
    exports2.EthereumPublicKey = schema_utils_1.Type.Object({
      node: exports2.HDNodeType,
      xpub: schema_utils_1.Type.String()
    }, { $id: "EthereumPublicKey" });
    exports2.EthereumGetAddress = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      show_display: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      encoded_network: schema_utils_1.Type.Optional(schema_utils_1.Type.ArrayBuffer()),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, { $id: "EthereumGetAddress" });
    exports2.EthereumAddress = schema_utils_1.Type.Object({
      _old_address: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      address: schema_utils_1.Type.String(),
      mac: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, { $id: "EthereumAddress" });
    exports2.EthereumSignTx = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      nonce: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      gas_price: schema_utils_1.Type.String(),
      gas_limit: schema_utils_1.Type.String(),
      to: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      value: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      data_initial_chunk: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      data_length: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      chain_id: schema_utils_1.Type.Number(),
      tx_type: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      definitions: schema_utils_1.Type.Optional(exports2.EthereumDefinitions),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      payment_req: schema_utils_1.Type.Optional(exports2.PaymentRequest)
    }, { $id: "EthereumSignTx" });
    exports2.EthereumAccessList = schema_utils_1.Type.Object({
      address: schema_utils_1.Type.String(),
      storage_keys: schema_utils_1.Type.Array(schema_utils_1.Type.String())
    }, { $id: "EthereumAccessList" });
    exports2.EthereumSignTxEIP1559 = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      nonce: schema_utils_1.Type.String(),
      max_gas_fee: schema_utils_1.Type.String(),
      max_priority_fee: schema_utils_1.Type.String(),
      gas_limit: schema_utils_1.Type.String(),
      to: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      value: schema_utils_1.Type.String(),
      data_initial_chunk: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      data_length: schema_utils_1.Type.Number(),
      chain_id: schema_utils_1.Type.Number(),
      access_list: schema_utils_1.Type.Array(exports2.EthereumAccessList),
      definitions: schema_utils_1.Type.Optional(exports2.EthereumDefinitions),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      payment_req: schema_utils_1.Type.Optional(exports2.PaymentRequest)
    }, { $id: "EthereumSignTxEIP1559" });
    exports2.EthereumTxRequest = schema_utils_1.Type.Object({
      data_length: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      signature_v: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      signature_r: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      signature_s: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, { $id: "EthereumTxRequest" });
    exports2.EthereumTxAck = schema_utils_1.Type.Object({
      data_chunk: schema_utils_1.Type.String()
    }, { $id: "EthereumTxAck" });
    exports2.EthereumSignMessage = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      message: schema_utils_1.Type.String(),
      encoded_network: schema_utils_1.Type.Optional(schema_utils_1.Type.ArrayBuffer()),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, { $id: "EthereumSignMessage" });
    exports2.EthereumMessageSignature = schema_utils_1.Type.Object({
      signature: schema_utils_1.Type.String(),
      address: schema_utils_1.Type.String()
    }, { $id: "EthereumMessageSignature" });
    exports2.EthereumVerifyMessage = schema_utils_1.Type.Object({
      signature: schema_utils_1.Type.String(),
      message: schema_utils_1.Type.String(),
      address: schema_utils_1.Type.String(),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, { $id: "EthereumVerifyMessage" });
    exports2.EthereumSignTypedHash = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      domain_separator_hash: schema_utils_1.Type.String(),
      message_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      encoded_network: schema_utils_1.Type.Optional(schema_utils_1.Type.ArrayBuffer())
    }, { $id: "EthereumSignTypedHash" });
    exports2.EthereumTypedDataSignature = schema_utils_1.Type.Object({
      signature: schema_utils_1.Type.String(),
      address: schema_utils_1.Type.String()
    }, { $id: "EthereumTypedDataSignature" });
    exports2.EvoluGetNode = schema_utils_1.Type.Object({}, { $id: "EvoluGetNode" });
    exports2.EvoluNode = schema_utils_1.Type.Object({
      data: schema_utils_1.Type.String()
    }, { $id: "EvoluNode" });
    var Enum_BackupType;
    (function(Enum_BackupType2) {
      Enum_BackupType2[Enum_BackupType2["Bip39"] = 0] = "Bip39";
      Enum_BackupType2[Enum_BackupType2["Slip39_Basic"] = 1] = "Slip39_Basic";
      Enum_BackupType2[Enum_BackupType2["Slip39_Advanced"] = 2] = "Slip39_Advanced";
      Enum_BackupType2[Enum_BackupType2["Slip39_Single_Extendable"] = 3] = "Slip39_Single_Extendable";
      Enum_BackupType2[Enum_BackupType2["Slip39_Basic_Extendable"] = 4] = "Slip39_Basic_Extendable";
      Enum_BackupType2[Enum_BackupType2["Slip39_Advanced_Extendable"] = 5] = "Slip39_Advanced_Extendable";
    })(Enum_BackupType || (exports2.Enum_BackupType = Enum_BackupType = {}));
    exports2.EnumEnum_BackupType = schema_utils_1.Type.Enum(Enum_BackupType);
    exports2.BackupType = schema_utils_1.Type.KeyOfEnum(Enum_BackupType, { $id: "BackupType" });
    var Enum_SafetyCheckLevel;
    (function(Enum_SafetyCheckLevel2) {
      Enum_SafetyCheckLevel2[Enum_SafetyCheckLevel2["Strict"] = 0] = "Strict";
      Enum_SafetyCheckLevel2[Enum_SafetyCheckLevel2["PromptAlways"] = 1] = "PromptAlways";
      Enum_SafetyCheckLevel2[Enum_SafetyCheckLevel2["PromptTemporarily"] = 2] = "PromptTemporarily";
    })(Enum_SafetyCheckLevel || (exports2.Enum_SafetyCheckLevel = Enum_SafetyCheckLevel = {}));
    exports2.EnumEnum_SafetyCheckLevel = schema_utils_1.Type.Enum(Enum_SafetyCheckLevel);
    exports2.SafetyCheckLevel = schema_utils_1.Type.KeyOfEnum(Enum_SafetyCheckLevel, { $id: "SafetyCheckLevel" });
    var Enum_DisplayRotation;
    (function(Enum_DisplayRotation2) {
      Enum_DisplayRotation2[Enum_DisplayRotation2["North"] = 0] = "North";
      Enum_DisplayRotation2[Enum_DisplayRotation2["East"] = 90] = "East";
      Enum_DisplayRotation2[Enum_DisplayRotation2["South"] = 180] = "South";
      Enum_DisplayRotation2[Enum_DisplayRotation2["West"] = 270] = "West";
    })(Enum_DisplayRotation || (exports2.Enum_DisplayRotation = Enum_DisplayRotation = {}));
    exports2.EnumEnum_DisplayRotation = schema_utils_1.Type.Enum(Enum_DisplayRotation);
    exports2.DisplayRotation = schema_utils_1.Type.KeyOfEnum(Enum_DisplayRotation, { $id: "DisplayRotation" });
    var Enum_HomescreenFormat;
    (function(Enum_HomescreenFormat2) {
      Enum_HomescreenFormat2[Enum_HomescreenFormat2["Toif"] = 1] = "Toif";
      Enum_HomescreenFormat2[Enum_HomescreenFormat2["Jpeg"] = 2] = "Jpeg";
      Enum_HomescreenFormat2[Enum_HomescreenFormat2["ToiG"] = 3] = "ToiG";
    })(Enum_HomescreenFormat || (exports2.Enum_HomescreenFormat = Enum_HomescreenFormat = {}));
    exports2.EnumEnum_HomescreenFormat = schema_utils_1.Type.Enum(Enum_HomescreenFormat);
    exports2.HomescreenFormat = schema_utils_1.Type.KeyOfEnum(Enum_HomescreenFormat, { $id: "HomescreenFormat" });
    exports2.Initialize = schema_utils_1.Type.Object({
      session_id: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      _skip_passphrase: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      derive_cardano: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, { $id: "Initialize" });
    exports2.GetFeatures = schema_utils_1.Type.Object({}, { $id: "GetFeatures" });
    var Enum_BackupAvailability;
    (function(Enum_BackupAvailability2) {
      Enum_BackupAvailability2[Enum_BackupAvailability2["NotAvailable"] = 0] = "NotAvailable";
      Enum_BackupAvailability2[Enum_BackupAvailability2["Required"] = 1] = "Required";
      Enum_BackupAvailability2[Enum_BackupAvailability2["Available"] = 2] = "Available";
    })(Enum_BackupAvailability || (exports2.Enum_BackupAvailability = Enum_BackupAvailability = {}));
    exports2.EnumEnum_BackupAvailability = schema_utils_1.Type.Enum(Enum_BackupAvailability);
    exports2.BackupAvailability = schema_utils_1.Type.KeyOfEnum(Enum_BackupAvailability, {
      $id: "BackupAvailability"
    });
    var Enum_RecoveryStatus;
    (function(Enum_RecoveryStatus2) {
      Enum_RecoveryStatus2[Enum_RecoveryStatus2["Nothing"] = 0] = "Nothing";
      Enum_RecoveryStatus2[Enum_RecoveryStatus2["Recovery"] = 1] = "Recovery";
      Enum_RecoveryStatus2[Enum_RecoveryStatus2["Backup"] = 2] = "Backup";
    })(Enum_RecoveryStatus || (exports2.Enum_RecoveryStatus = Enum_RecoveryStatus = {}));
    exports2.EnumEnum_RecoveryStatus = schema_utils_1.Type.Enum(Enum_RecoveryStatus);
    exports2.RecoveryStatus = schema_utils_1.Type.KeyOfEnum(Enum_RecoveryStatus, { $id: "RecoveryStatus" });
    var Enum_Capability;
    (function(Enum_Capability2) {
      Enum_Capability2[Enum_Capability2["Capability_Bitcoin"] = 1] = "Capability_Bitcoin";
      Enum_Capability2[Enum_Capability2["Capability_Bitcoin_like"] = 2] = "Capability_Bitcoin_like";
      Enum_Capability2[Enum_Capability2["Capability_Binance"] = 3] = "Capability_Binance";
      Enum_Capability2[Enum_Capability2["Capability_Cardano"] = 4] = "Capability_Cardano";
      Enum_Capability2[Enum_Capability2["Capability_Crypto"] = 5] = "Capability_Crypto";
      Enum_Capability2[Enum_Capability2["Capability_EOS"] = 6] = "Capability_EOS";
      Enum_Capability2[Enum_Capability2["Capability_Ethereum"] = 7] = "Capability_Ethereum";
      Enum_Capability2[Enum_Capability2["Capability_Lisk"] = 8] = "Capability_Lisk";
      Enum_Capability2[Enum_Capability2["Capability_Monero"] = 9] = "Capability_Monero";
      Enum_Capability2[Enum_Capability2["Capability_NEM"] = 10] = "Capability_NEM";
      Enum_Capability2[Enum_Capability2["Capability_Ripple"] = 11] = "Capability_Ripple";
      Enum_Capability2[Enum_Capability2["Capability_Stellar"] = 12] = "Capability_Stellar";
      Enum_Capability2[Enum_Capability2["Capability_Tezos"] = 13] = "Capability_Tezos";
      Enum_Capability2[Enum_Capability2["Capability_U2F"] = 14] = "Capability_U2F";
      Enum_Capability2[Enum_Capability2["Capability_Shamir"] = 15] = "Capability_Shamir";
      Enum_Capability2[Enum_Capability2["Capability_ShamirGroups"] = 16] = "Capability_ShamirGroups";
      Enum_Capability2[Enum_Capability2["Capability_PassphraseEntry"] = 17] = "Capability_PassphraseEntry";
      Enum_Capability2[Enum_Capability2["Capability_Solana"] = 18] = "Capability_Solana";
      Enum_Capability2[Enum_Capability2["Capability_Translations"] = 19] = "Capability_Translations";
      Enum_Capability2[Enum_Capability2["Capability_Brightness"] = 20] = "Capability_Brightness";
      Enum_Capability2[Enum_Capability2["Capability_Haptic"] = 21] = "Capability_Haptic";
      Enum_Capability2[Enum_Capability2["Capability_BLE"] = 22] = "Capability_BLE";
      Enum_Capability2[Enum_Capability2["Capability_NFC"] = 23] = "Capability_NFC";
    })(Enum_Capability || (exports2.Enum_Capability = Enum_Capability = {}));
    exports2.EnumEnum_Capability = schema_utils_1.Type.Enum(Enum_Capability);
    exports2.Capability = schema_utils_1.Type.KeyOfEnum(Enum_Capability, { $id: "Capability" });
    var RecoveryDeviceInputMethod;
    (function(RecoveryDeviceInputMethod2) {
      RecoveryDeviceInputMethod2[RecoveryDeviceInputMethod2["ScrambledWords"] = 0] = "ScrambledWords";
      RecoveryDeviceInputMethod2[RecoveryDeviceInputMethod2["Matrix"] = 1] = "Matrix";
    })(RecoveryDeviceInputMethod || (exports2.RecoveryDeviceInputMethod = RecoveryDeviceInputMethod = {}));
    exports2.EnumRecoveryDeviceInputMethod = schema_utils_1.Type.Enum(RecoveryDeviceInputMethod);
    var Enum_RecoveryType;
    (function(Enum_RecoveryType2) {
      Enum_RecoveryType2[Enum_RecoveryType2["NormalRecovery"] = 0] = "NormalRecovery";
      Enum_RecoveryType2[Enum_RecoveryType2["DryRun"] = 1] = "DryRun";
      Enum_RecoveryType2[Enum_RecoveryType2["UnlockRepeatedBackup"] = 2] = "UnlockRepeatedBackup";
    })(Enum_RecoveryType || (exports2.Enum_RecoveryType = Enum_RecoveryType = {}));
    exports2.EnumEnum_RecoveryType = schema_utils_1.Type.Enum(Enum_RecoveryType);
    exports2.RecoveryType = schema_utils_1.Type.KeyOfEnum(Enum_RecoveryType, { $id: "RecoveryType" });
    exports2.RecoveryDevice = schema_utils_1.Type.Object({
      word_count: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      passphrase_protection: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      pin_protection: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      language: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      label: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      enforce_wordlist: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      input_method: schema_utils_1.Type.Optional(exports2.EnumRecoveryDeviceInputMethod),
      u2f_counter: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      type: schema_utils_1.Type.Optional(exports2.RecoveryType)
    }, { $id: "RecoveryDevice" });
    exports2.Features = schema_utils_1.Type.Object({
      vendor: schema_utils_1.Type.String(),
      major_version: schema_utils_1.Type.Number(),
      minor_version: schema_utils_1.Type.Number(),
      patch_version: schema_utils_1.Type.Number(),
      bootloader_mode: schema_utils_1.Type.Union([schema_utils_1.Type.Boolean(), schema_utils_1.Type.Null()]),
      device_id: schema_utils_1.Type.Union([schema_utils_1.Type.String(), schema_utils_1.Type.Null()]),
      pin_protection: schema_utils_1.Type.Union([schema_utils_1.Type.Boolean(), schema_utils_1.Type.Null()]),
      passphrase_protection: schema_utils_1.Type.Union([schema_utils_1.Type.Boolean(), schema_utils_1.Type.Null()]),
      language: schema_utils_1.Type.Union([schema_utils_1.Type.String(), schema_utils_1.Type.Null()]),
      label: schema_utils_1.Type.Union([schema_utils_1.Type.String(), schema_utils_1.Type.Null()]),
      initialized: schema_utils_1.Type.Union([schema_utils_1.Type.Boolean(), schema_utils_1.Type.Null()]),
      revision: schema_utils_1.Type.Union([schema_utils_1.Type.String(), schema_utils_1.Type.Null()]),
      bootloader_hash: schema_utils_1.Type.Union([schema_utils_1.Type.String(), schema_utils_1.Type.Null()]),
      imported: schema_utils_1.Type.Union([schema_utils_1.Type.Boolean(), schema_utils_1.Type.Null()]),
      unlocked: schema_utils_1.Type.Union([schema_utils_1.Type.Boolean(), schema_utils_1.Type.Null()]),
      _passphrase_cached: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      firmware_present: schema_utils_1.Type.Union([schema_utils_1.Type.Boolean(), schema_utils_1.Type.Null()]),
      backup_availability: schema_utils_1.Type.Union([exports2.BackupAvailability, schema_utils_1.Type.Null()]),
      flags: schema_utils_1.Type.Union([schema_utils_1.Type.Number(), schema_utils_1.Type.Null()]),
      model: schema_utils_1.Type.String(),
      fw_major: schema_utils_1.Type.Union([schema_utils_1.Type.Number(), schema_utils_1.Type.Null()]),
      fw_minor: schema_utils_1.Type.Union([schema_utils_1.Type.Number(), schema_utils_1.Type.Null()]),
      fw_patch: schema_utils_1.Type.Union([schema_utils_1.Type.Number(), schema_utils_1.Type.Null()]),
      fw_vendor: schema_utils_1.Type.Union([schema_utils_1.Type.String(), schema_utils_1.Type.Null()]),
      unfinished_backup: schema_utils_1.Type.Union([schema_utils_1.Type.Boolean(), schema_utils_1.Type.Null()]),
      no_backup: schema_utils_1.Type.Union([schema_utils_1.Type.Boolean(), schema_utils_1.Type.Null()]),
      recovery_status: schema_utils_1.Type.Union([exports2.RecoveryStatus, schema_utils_1.Type.Null()]),
      capabilities: schema_utils_1.Type.Array(exports2.Capability),
      backup_type: schema_utils_1.Type.Union([exports2.BackupType, schema_utils_1.Type.Null()]),
      sd_card_present: schema_utils_1.Type.Union([schema_utils_1.Type.Boolean(), schema_utils_1.Type.Null()]),
      sd_protection: schema_utils_1.Type.Union([schema_utils_1.Type.Boolean(), schema_utils_1.Type.Null()]),
      wipe_code_protection: schema_utils_1.Type.Union([schema_utils_1.Type.Boolean(), schema_utils_1.Type.Null()]),
      session_id: schema_utils_1.Type.Union([schema_utils_1.Type.String(), schema_utils_1.Type.Null()]),
      passphrase_always_on_device: schema_utils_1.Type.Union([schema_utils_1.Type.Boolean(), schema_utils_1.Type.Null()]),
      safety_checks: schema_utils_1.Type.Union([exports2.SafetyCheckLevel, schema_utils_1.Type.Null()]),
      auto_lock_delay_ms: schema_utils_1.Type.Union([schema_utils_1.Type.Number(), schema_utils_1.Type.Null()]),
      display_rotation: schema_utils_1.Type.Union([exports2.DisplayRotation, schema_utils_1.Type.Null()]),
      experimental_features: schema_utils_1.Type.Union([schema_utils_1.Type.Boolean(), schema_utils_1.Type.Null()]),
      busy: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      homescreen_format: schema_utils_1.Type.Optional(exports2.HomescreenFormat),
      hide_passphrase_from_host: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      internal_model: exports2.EnumDeviceModelInternal,
      unit_color: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      unit_btconly: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      homescreen_width: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      homescreen_height: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      bootloader_locked: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      language_version_matches: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      unit_packaging: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      haptic_feedback: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      recovery_type: schema_utils_1.Type.Optional(exports2.RecoveryType),
      optiga_sec: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      soc: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      firmware_corrupted: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, { $id: "Features" });
    exports2.LockDevice = schema_utils_1.Type.Object({}, { $id: "LockDevice" });
    exports2.SetBusy = schema_utils_1.Type.Object({
      expiry_ms: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    }, { $id: "SetBusy" });
    exports2.EndSession = schema_utils_1.Type.Object({}, { $id: "EndSession" });
    exports2.ApplySettings = schema_utils_1.Type.Object({
      language: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      label: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      use_passphrase: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      homescreen: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      _passphrase_source: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      auto_lock_delay_ms: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      display_rotation: schema_utils_1.Type.Optional(schema_utils_1.Type.Union([exports2.DisplayRotation, exports2.EnumEnum_DisplayRotation])),
      passphrase_always_on_device: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      safety_checks: schema_utils_1.Type.Optional(exports2.SafetyCheckLevel),
      experimental_features: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      hide_passphrase_from_host: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      haptic_feedback: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      homescreen_length: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      auto_lock_delay_battery_ms: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    }, { $id: "ApplySettings" });
    exports2.ChangeLanguage = schema_utils_1.Type.Object({
      data_length: schema_utils_1.Type.Number(),
      show_display: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, { $id: "ChangeLanguage" });
    exports2.DataChunkRequest = schema_utils_1.Type.Object({
      data_length: schema_utils_1.Type.Number(),
      data_offset: schema_utils_1.Type.Number()
    }, { $id: "DataChunkRequest" });
    exports2.DataChunkAck = schema_utils_1.Type.Object({
      data_chunk: schema_utils_1.Type.String()
    }, { $id: "DataChunkAck" });
    exports2.ApplyFlags = schema_utils_1.Type.Object({
      flags: schema_utils_1.Type.Number()
    }, { $id: "ApplyFlags" });
    exports2.ChangePin = schema_utils_1.Type.Object({
      remove: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, { $id: "ChangePin" });
    exports2.ChangeWipeCode = schema_utils_1.Type.Object({
      remove: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, { $id: "ChangeWipeCode" });
    var SdProtectOperationType;
    (function(SdProtectOperationType2) {
      SdProtectOperationType2[SdProtectOperationType2["DISABLE"] = 0] = "DISABLE";
      SdProtectOperationType2[SdProtectOperationType2["ENABLE"] = 1] = "ENABLE";
      SdProtectOperationType2[SdProtectOperationType2["REFRESH"] = 2] = "REFRESH";
    })(SdProtectOperationType || (exports2.SdProtectOperationType = SdProtectOperationType = {}));
    exports2.EnumSdProtectOperationType = schema_utils_1.Type.Enum(SdProtectOperationType);
    exports2.SdProtect = schema_utils_1.Type.Object({
      operation: exports2.EnumSdProtectOperationType
    }, { $id: "SdProtect" });
    exports2.Ping = schema_utils_1.Type.Object({
      message: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      button_protection: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, { $id: "Ping" });
    exports2.Cancel = schema_utils_1.Type.Object({}, { $id: "Cancel" });
    exports2.GetEntropy = schema_utils_1.Type.Object({
      size: schema_utils_1.Type.Number()
    }, { $id: "GetEntropy" });
    exports2.Entropy = schema_utils_1.Type.Object({
      entropy: schema_utils_1.Type.String()
    }, { $id: "Entropy" });
    exports2.GetFirmwareHash = schema_utils_1.Type.Object({
      challenge: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, { $id: "GetFirmwareHash" });
    exports2.FirmwareHash = schema_utils_1.Type.Object({
      hash: schema_utils_1.Type.String()
    }, { $id: "FirmwareHash" });
    exports2.AuthenticateDevice = schema_utils_1.Type.Object({
      challenge: schema_utils_1.Type.String()
    }, { $id: "AuthenticateDevice" });
    exports2.AuthenticityProof = schema_utils_1.Type.Object({
      optiga_certificates: schema_utils_1.Type.Array(schema_utils_1.Type.String()),
      optiga_signature: schema_utils_1.Type.String(),
      tropic_certificates: schema_utils_1.Type.Array(schema_utils_1.Type.String()),
      tropic_signature: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, { $id: "AuthenticityProof" });
    exports2.WipeDevice = schema_utils_1.Type.Object({}, { $id: "WipeDevice" });
    exports2.LoadDevice = schema_utils_1.Type.Object({
      mnemonics: schema_utils_1.Type.Array(schema_utils_1.Type.String()),
      pin: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      passphrase_protection: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      language: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      label: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      skip_checksum: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      u2f_counter: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      needs_backup: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      no_backup: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, { $id: "LoadDevice" });
    exports2.ResetDevice = schema_utils_1.Type.Object({
      strength: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      passphrase_protection: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      pin_protection: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      language: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      label: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      u2f_counter: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      skip_backup: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      no_backup: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      backup_type: schema_utils_1.Type.Optional(exports2.EnumEnum_BackupType),
      entropy_check: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, { $id: "ResetDevice" });
    exports2.Slip39Group = schema_utils_1.Type.Object({
      member_threshold: schema_utils_1.Type.Number(),
      member_count: schema_utils_1.Type.Number()
    }, { $id: "Slip39Group" });
    exports2.BackupDevice = schema_utils_1.Type.Object({
      group_threshold: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      groups: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(exports2.Slip39Group))
    }, { $id: "BackupDevice" });
    exports2.EntropyRequest = schema_utils_1.Type.Object({
      entropy_commitment: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      prev_entropy: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, { $id: "EntropyRequest" });
    exports2.EntropyAck = schema_utils_1.Type.Object({
      entropy: schema_utils_1.Type.String()
    }, { $id: "EntropyAck" });
    exports2.EntropyCheckReady = schema_utils_1.Type.Object({}, { $id: "EntropyCheckReady" });
    exports2.EntropyCheckContinue = schema_utils_1.Type.Object({
      finish: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, { $id: "EntropyCheckContinue" });
    var Enum_WordRequestType;
    (function(Enum_WordRequestType2) {
      Enum_WordRequestType2[Enum_WordRequestType2["WordRequestType_Plain"] = 0] = "WordRequestType_Plain";
      Enum_WordRequestType2[Enum_WordRequestType2["WordRequestType_Matrix9"] = 1] = "WordRequestType_Matrix9";
      Enum_WordRequestType2[Enum_WordRequestType2["WordRequestType_Matrix6"] = 2] = "WordRequestType_Matrix6";
    })(Enum_WordRequestType || (exports2.Enum_WordRequestType = Enum_WordRequestType = {}));
    exports2.EnumEnum_WordRequestType = schema_utils_1.Type.Enum(Enum_WordRequestType);
    exports2.WordRequestType = schema_utils_1.Type.KeyOfEnum(Enum_WordRequestType, { $id: "WordRequestType" });
    exports2.WordRequest = schema_utils_1.Type.Object({
      type: exports2.WordRequestType
    }, { $id: "WordRequest" });
    exports2.WordAck = schema_utils_1.Type.Object({
      word: schema_utils_1.Type.String()
    }, { $id: "WordAck" });
    exports2.SetU2FCounter = schema_utils_1.Type.Object({
      u2f_counter: schema_utils_1.Type.Number()
    }, { $id: "SetU2FCounter" });
    exports2.GetNextU2FCounter = schema_utils_1.Type.Object({}, { $id: "GetNextU2FCounter" });
    exports2.NextU2FCounter = schema_utils_1.Type.Object({
      u2f_counter: schema_utils_1.Type.Number()
    }, { $id: "NextU2FCounter" });
    exports2.DoPreauthorized = schema_utils_1.Type.Object({}, { $id: "DoPreauthorized" });
    exports2.PreauthorizedRequest = schema_utils_1.Type.Object({}, { $id: "PreauthorizedRequest" });
    exports2.CancelAuthorization = schema_utils_1.Type.Object({}, { $id: "CancelAuthorization" });
    var BootCommand;
    (function(BootCommand2) {
      BootCommand2[BootCommand2["STOP_AND_WAIT"] = 0] = "STOP_AND_WAIT";
      BootCommand2[BootCommand2["INSTALL_UPGRADE"] = 1] = "INSTALL_UPGRADE";
    })(BootCommand || (exports2.BootCommand = BootCommand = {}));
    exports2.EnumBootCommand = schema_utils_1.Type.Enum(BootCommand);
    exports2.RebootToBootloader = schema_utils_1.Type.Object({
      boot_command: schema_utils_1.Type.Optional(exports2.EnumBootCommand),
      firmware_header: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      language_data_length: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    }, { $id: "RebootToBootloader" });
    exports2.GetNonce = schema_utils_1.Type.Object({}, { $id: "GetNonce" });
    exports2.Nonce = schema_utils_1.Type.Object({
      nonce: schema_utils_1.Type.String()
    }, { $id: "Nonce" });
    exports2.UnlockPath = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      mac: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, { $id: "UnlockPath" });
    exports2.UnlockedPathRequest = schema_utils_1.Type.Object({
      mac: schema_utils_1.Type.String()
    }, { $id: "UnlockedPathRequest" });
    exports2.ShowDeviceTutorial = schema_utils_1.Type.Object({}, { $id: "ShowDeviceTutorial" });
    exports2.UnlockBootloader = schema_utils_1.Type.Object({}, { $id: "UnlockBootloader" });
    exports2.SetBrightness = schema_utils_1.Type.Object({
      value: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    }, { $id: "SetBrightness" });
    exports2.NEMGetAddress = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      network: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      show_display: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, { $id: "NEMGetAddress" });
    exports2.NEMAddress = schema_utils_1.Type.Object({
      address: schema_utils_1.Type.String()
    }, { $id: "NEMAddress" });
    exports2.NEMTransactionCommon = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(schema_utils_1.Type.Number())),
      network: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      timestamp: schema_utils_1.Type.Number(),
      fee: schema_utils_1.Type.Uint(),
      deadline: schema_utils_1.Type.Number(),
      signer: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, { $id: "NEMTransactionCommon" });
    exports2.NEMMosaic = schema_utils_1.Type.Object({
      namespace: schema_utils_1.Type.String(),
      mosaic: schema_utils_1.Type.String(),
      quantity: schema_utils_1.Type.Number()
    }, { $id: "NEMMosaic" });
    exports2.NEMTransfer = schema_utils_1.Type.Object({
      recipient: schema_utils_1.Type.String(),
      amount: schema_utils_1.Type.Uint(),
      payload: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      public_key: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      mosaics: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(exports2.NEMMosaic))
    }, { $id: "NEMTransfer" });
    exports2.NEMProvisionNamespace = schema_utils_1.Type.Object({
      namespace: schema_utils_1.Type.String(),
      parent: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      sink: schema_utils_1.Type.String(),
      fee: schema_utils_1.Type.Uint()
    }, { $id: "NEMProvisionNamespace" });
    var NEMMosaicLevy;
    (function(NEMMosaicLevy2) {
      NEMMosaicLevy2[NEMMosaicLevy2["MosaicLevy_Absolute"] = 1] = "MosaicLevy_Absolute";
      NEMMosaicLevy2[NEMMosaicLevy2["MosaicLevy_Percentile"] = 2] = "MosaicLevy_Percentile";
    })(NEMMosaicLevy || (exports2.NEMMosaicLevy = NEMMosaicLevy = {}));
    exports2.EnumNEMMosaicLevy = schema_utils_1.Type.Enum(NEMMosaicLevy);
    exports2.NEMMosaicDefinition = schema_utils_1.Type.Object({
      name: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      ticker: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      namespace: schema_utils_1.Type.String(),
      mosaic: schema_utils_1.Type.String(),
      divisibility: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      levy: schema_utils_1.Type.Optional(exports2.EnumNEMMosaicLevy),
      fee: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint()),
      levy_address: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      levy_namespace: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      levy_mosaic: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      supply: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      mutable_supply: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      transferable: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      description: schema_utils_1.Type.String(),
      networks: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(schema_utils_1.Type.Number()))
    }, { $id: "NEMMosaicDefinition" });
    exports2.NEMMosaicCreation = schema_utils_1.Type.Object({
      definition: exports2.NEMMosaicDefinition,
      sink: schema_utils_1.Type.String(),
      fee: schema_utils_1.Type.Uint()
    }, { $id: "NEMMosaicCreation" });
    var NEMSupplyChangeType;
    (function(NEMSupplyChangeType2) {
      NEMSupplyChangeType2[NEMSupplyChangeType2["SupplyChange_Increase"] = 1] = "SupplyChange_Increase";
      NEMSupplyChangeType2[NEMSupplyChangeType2["SupplyChange_Decrease"] = 2] = "SupplyChange_Decrease";
    })(NEMSupplyChangeType || (exports2.NEMSupplyChangeType = NEMSupplyChangeType = {}));
    exports2.EnumNEMSupplyChangeType = schema_utils_1.Type.Enum(NEMSupplyChangeType);
    exports2.NEMMosaicSupplyChange = schema_utils_1.Type.Object({
      namespace: schema_utils_1.Type.String(),
      mosaic: schema_utils_1.Type.String(),
      type: exports2.EnumNEMSupplyChangeType,
      delta: schema_utils_1.Type.Number()
    }, { $id: "NEMMosaicSupplyChange" });
    var NEMModificationType;
    (function(NEMModificationType2) {
      NEMModificationType2[NEMModificationType2["CosignatoryModification_Add"] = 1] = "CosignatoryModification_Add";
      NEMModificationType2[NEMModificationType2["CosignatoryModification_Delete"] = 2] = "CosignatoryModification_Delete";
    })(NEMModificationType || (exports2.NEMModificationType = NEMModificationType = {}));
    exports2.EnumNEMModificationType = schema_utils_1.Type.Enum(NEMModificationType);
    exports2.NEMCosignatoryModification = schema_utils_1.Type.Object({
      type: exports2.EnumNEMModificationType,
      public_key: schema_utils_1.Type.String()
    }, { $id: "NEMCosignatoryModification" });
    exports2.NEMAggregateModification = schema_utils_1.Type.Object({
      modifications: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(exports2.NEMCosignatoryModification)),
      relative_change: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    }, { $id: "NEMAggregateModification" });
    var NEMImportanceTransferMode;
    (function(NEMImportanceTransferMode2) {
      NEMImportanceTransferMode2[NEMImportanceTransferMode2["ImportanceTransfer_Activate"] = 1] = "ImportanceTransfer_Activate";
      NEMImportanceTransferMode2[NEMImportanceTransferMode2["ImportanceTransfer_Deactivate"] = 2] = "ImportanceTransfer_Deactivate";
    })(NEMImportanceTransferMode || (exports2.NEMImportanceTransferMode = NEMImportanceTransferMode = {}));
    exports2.EnumNEMImportanceTransferMode = schema_utils_1.Type.Enum(NEMImportanceTransferMode);
    exports2.NEMImportanceTransfer = schema_utils_1.Type.Object({
      mode: exports2.EnumNEMImportanceTransferMode,
      public_key: schema_utils_1.Type.String()
    }, { $id: "NEMImportanceTransfer" });
    exports2.NEMSignTx = schema_utils_1.Type.Object({
      transaction: exports2.NEMTransactionCommon,
      multisig: schema_utils_1.Type.Optional(exports2.NEMTransactionCommon),
      transfer: schema_utils_1.Type.Optional(exports2.NEMTransfer),
      cosigning: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      provision_namespace: schema_utils_1.Type.Optional(exports2.NEMProvisionNamespace),
      mosaic_creation: schema_utils_1.Type.Optional(exports2.NEMMosaicCreation),
      supply_change: schema_utils_1.Type.Optional(exports2.NEMMosaicSupplyChange),
      aggregate_modification: schema_utils_1.Type.Optional(exports2.NEMAggregateModification),
      importance_transfer: schema_utils_1.Type.Optional(exports2.NEMImportanceTransfer),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, { $id: "NEMSignTx" });
    exports2.NEMSignedTx = schema_utils_1.Type.Object({
      data: schema_utils_1.Type.String(),
      signature: schema_utils_1.Type.String()
    }, { $id: "NEMSignedTx" });
    exports2.NEMDecryptMessage = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      network: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      public_key: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      payload: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, { $id: "NEMDecryptMessage" });
    exports2.NEMDecryptedMessage = schema_utils_1.Type.Object({
      payload: schema_utils_1.Type.String()
    }, { $id: "NEMDecryptedMessage" });
    exports2.RippleGetAddress = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      show_display: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, { $id: "RippleGetAddress" });
    exports2.RippleAddress = schema_utils_1.Type.Object({
      address: schema_utils_1.Type.String(),
      mac: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, { $id: "RippleAddress" });
    exports2.RipplePayment = schema_utils_1.Type.Object({
      amount: schema_utils_1.Type.Uint(),
      destination: schema_utils_1.Type.String(),
      destination_tag: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    }, { $id: "RipplePayment" });
    exports2.RippleSignTx = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      fee: schema_utils_1.Type.Uint(),
      flags: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      sequence: schema_utils_1.Type.Number(),
      last_ledger_sequence: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      payment: exports2.RipplePayment,
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      payment_req: schema_utils_1.Type.Optional(exports2.PaymentRequest)
    }, { $id: "RippleSignTx" });
    exports2.RippleSignedTx = schema_utils_1.Type.Object({
      signature: schema_utils_1.Type.String(),
      serialized_tx: schema_utils_1.Type.String()
    }, { $id: "RippleSignedTx" });
    exports2.SolanaGetPublicKey = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      show_display: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, { $id: "SolanaGetPublicKey" });
    exports2.SolanaPublicKey = schema_utils_1.Type.Object({
      public_key: schema_utils_1.Type.String()
    }, { $id: "SolanaPublicKey" });
    exports2.SolanaGetAddress = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      show_display: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, { $id: "SolanaGetAddress" });
    exports2.SolanaAddress = schema_utils_1.Type.Object({
      address: schema_utils_1.Type.String(),
      mac: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, { $id: "SolanaAddress" });
    exports2.SolanaTxTokenAccountInfo = schema_utils_1.Type.Object({
      base_address: schema_utils_1.Type.String(),
      token_program: schema_utils_1.Type.String(),
      token_mint: schema_utils_1.Type.String(),
      token_account: schema_utils_1.Type.String()
    }, { $id: "SolanaTxTokenAccountInfo" });
    exports2.SolanaTxAdditionalInfo = schema_utils_1.Type.Object({
      token_accounts_infos: schema_utils_1.Type.Array(exports2.SolanaTxTokenAccountInfo),
      encoded_token: schema_utils_1.Type.Optional(schema_utils_1.Type.ArrayBuffer())
    }, { $id: "SolanaTxAdditionalInfo" });
    exports2.SolanaSignTx = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      serialized_tx: schema_utils_1.Type.String(),
      additional_info: schema_utils_1.Type.Optional(exports2.SolanaTxAdditionalInfo),
      payment_req: schema_utils_1.Type.Optional(exports2.PaymentRequest)
    }, { $id: "SolanaSignTx" });
    exports2.SolanaTxSignature = schema_utils_1.Type.Object({
      signature: schema_utils_1.Type.String()
    }, { $id: "SolanaTxSignature" });
    var StellarAssetType;
    (function(StellarAssetType2) {
      StellarAssetType2[StellarAssetType2["NATIVE"] = 0] = "NATIVE";
      StellarAssetType2[StellarAssetType2["ALPHANUM4"] = 1] = "ALPHANUM4";
      StellarAssetType2[StellarAssetType2["ALPHANUM12"] = 2] = "ALPHANUM12";
    })(StellarAssetType || (exports2.StellarAssetType = StellarAssetType = {}));
    exports2.EnumStellarAssetType = schema_utils_1.Type.Enum(StellarAssetType);
    exports2.StellarAsset = schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Union([
        schema_utils_1.Type.Literal(0),
        schema_utils_1.Type.Literal(1),
        schema_utils_1.Type.Literal(2),
        schema_utils_1.Type.Literal("NATIVE"),
        schema_utils_1.Type.Literal("ALPHANUM4"),
        schema_utils_1.Type.Literal("ALPHANUM12")
      ]),
      code: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      issuer: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, { $id: "StellarAsset" });
    exports2.StellarGetAddress = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      show_display: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, { $id: "StellarGetAddress" });
    exports2.StellarAddress = schema_utils_1.Type.Object({
      address: schema_utils_1.Type.String(),
      mac: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, { $id: "StellarAddress" });
    var StellarMemoType;
    (function(StellarMemoType2) {
      StellarMemoType2[StellarMemoType2["NONE"] = 0] = "NONE";
      StellarMemoType2[StellarMemoType2["TEXT"] = 1] = "TEXT";
      StellarMemoType2[StellarMemoType2["ID"] = 2] = "ID";
      StellarMemoType2[StellarMemoType2["HASH"] = 3] = "HASH";
      StellarMemoType2[StellarMemoType2["RETURN"] = 4] = "RETURN";
    })(StellarMemoType || (exports2.StellarMemoType = StellarMemoType = {}));
    exports2.EnumStellarMemoType = schema_utils_1.Type.Enum(StellarMemoType);
    exports2.StellarSignTx = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      network_passphrase: schema_utils_1.Type.String(),
      source_account: schema_utils_1.Type.String(),
      fee: schema_utils_1.Type.Uint(),
      sequence_number: schema_utils_1.Type.Uint(),
      timebounds_start: schema_utils_1.Type.Number(),
      timebounds_end: schema_utils_1.Type.Number(),
      memo_type: exports2.EnumStellarMemoType,
      memo_text: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      memo_id: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint()),
      memo_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.Union([schema_utils_1.Type.Buffer(), schema_utils_1.Type.String()])),
      num_operations: schema_utils_1.Type.Number(),
      payment_req: schema_utils_1.Type.Optional(exports2.PaymentRequest)
    }, { $id: "StellarSignTx" });
    exports2.StellarTxOpRequest = schema_utils_1.Type.Object({}, { $id: "StellarTxOpRequest" });
    exports2.StellarPaymentOp = schema_utils_1.Type.Object({
      source_account: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      destination_account: schema_utils_1.Type.String(),
      asset: exports2.StellarAsset,
      amount: schema_utils_1.Type.Uint()
    }, { $id: "StellarPaymentOp" });
    exports2.StellarCreateAccountOp = schema_utils_1.Type.Object({
      source_account: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      new_account: schema_utils_1.Type.String(),
      starting_balance: schema_utils_1.Type.Uint()
    }, { $id: "StellarCreateAccountOp" });
    exports2.StellarPathPaymentStrictReceiveOp = schema_utils_1.Type.Object({
      source_account: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      send_asset: exports2.StellarAsset,
      send_max: schema_utils_1.Type.Uint(),
      destination_account: schema_utils_1.Type.String(),
      destination_asset: exports2.StellarAsset,
      destination_amount: schema_utils_1.Type.Uint(),
      paths: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(exports2.StellarAsset))
    }, { $id: "StellarPathPaymentStrictReceiveOp" });
    exports2.StellarPathPaymentStrictSendOp = schema_utils_1.Type.Object({
      source_account: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      send_asset: exports2.StellarAsset,
      send_amount: schema_utils_1.Type.Uint(),
      destination_account: schema_utils_1.Type.String(),
      destination_asset: exports2.StellarAsset,
      destination_min: schema_utils_1.Type.Uint(),
      paths: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(exports2.StellarAsset))
    }, { $id: "StellarPathPaymentStrictSendOp" });
    exports2.StellarManageSellOfferOp = schema_utils_1.Type.Object({
      source_account: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      selling_asset: exports2.StellarAsset,
      buying_asset: exports2.StellarAsset,
      amount: schema_utils_1.Type.Uint(),
      price_n: schema_utils_1.Type.Number(),
      price_d: schema_utils_1.Type.Number(),
      offer_id: schema_utils_1.Type.Uint()
    }, { $id: "StellarManageSellOfferOp" });
    exports2.StellarManageBuyOfferOp = schema_utils_1.Type.Object({
      source_account: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      selling_asset: exports2.StellarAsset,
      buying_asset: exports2.StellarAsset,
      amount: schema_utils_1.Type.Uint(),
      price_n: schema_utils_1.Type.Number(),
      price_d: schema_utils_1.Type.Number(),
      offer_id: schema_utils_1.Type.Uint()
    }, { $id: "StellarManageBuyOfferOp" });
    exports2.StellarCreatePassiveSellOfferOp = schema_utils_1.Type.Object({
      source_account: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      selling_asset: exports2.StellarAsset,
      buying_asset: exports2.StellarAsset,
      amount: schema_utils_1.Type.Uint(),
      price_n: schema_utils_1.Type.Number(),
      price_d: schema_utils_1.Type.Number()
    }, { $id: "StellarCreatePassiveSellOfferOp" });
    var StellarSignerType;
    (function(StellarSignerType2) {
      StellarSignerType2[StellarSignerType2["ACCOUNT"] = 0] = "ACCOUNT";
      StellarSignerType2[StellarSignerType2["PRE_AUTH"] = 1] = "PRE_AUTH";
      StellarSignerType2[StellarSignerType2["HASH"] = 2] = "HASH";
    })(StellarSignerType || (exports2.StellarSignerType = StellarSignerType = {}));
    exports2.EnumStellarSignerType = schema_utils_1.Type.Enum(StellarSignerType);
    exports2.StellarSetOptionsOp = schema_utils_1.Type.Object({
      source_account: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      inflation_destination_account: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      clear_flags: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      set_flags: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      master_weight: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint()),
      low_threshold: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint()),
      medium_threshold: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint()),
      high_threshold: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint()),
      home_domain: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      signer_type: schema_utils_1.Type.Optional(exports2.EnumStellarSignerType),
      signer_key: schema_utils_1.Type.Optional(schema_utils_1.Type.Union([schema_utils_1.Type.Buffer(), schema_utils_1.Type.String()])),
      signer_weight: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    }, { $id: "StellarSetOptionsOp" });
    exports2.StellarChangeTrustOp = schema_utils_1.Type.Object({
      source_account: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      asset: exports2.StellarAsset,
      limit: schema_utils_1.Type.Uint()
    }, { $id: "StellarChangeTrustOp" });
    exports2.StellarAllowTrustOp = schema_utils_1.Type.Object({
      source_account: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      trusted_account: schema_utils_1.Type.String(),
      asset_type: exports2.EnumStellarAssetType,
      asset_code: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      is_authorized: schema_utils_1.Type.Boolean()
    }, { $id: "StellarAllowTrustOp" });
    exports2.StellarAccountMergeOp = schema_utils_1.Type.Object({
      source_account: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      destination_account: schema_utils_1.Type.String()
    }, { $id: "StellarAccountMergeOp" });
    exports2.StellarManageDataOp = schema_utils_1.Type.Object({
      source_account: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      key: schema_utils_1.Type.String(),
      value: schema_utils_1.Type.Optional(schema_utils_1.Type.Union([schema_utils_1.Type.Buffer(), schema_utils_1.Type.String()]))
    }, { $id: "StellarManageDataOp" });
    exports2.StellarBumpSequenceOp = schema_utils_1.Type.Object({
      source_account: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      bump_to: schema_utils_1.Type.Uint()
    }, { $id: "StellarBumpSequenceOp" });
    exports2.StellarClaimClaimableBalanceOp = schema_utils_1.Type.Object({
      source_account: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      balance_id: schema_utils_1.Type.String()
    }, { $id: "StellarClaimClaimableBalanceOp" });
    exports2.StellarSignedTx = schema_utils_1.Type.Object({
      public_key: schema_utils_1.Type.String(),
      signature: schema_utils_1.Type.String()
    }, { $id: "StellarSignedTx" });
    exports2.TezosGetAddress = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      show_display: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, { $id: "TezosGetAddress" });
    exports2.TezosAddress = schema_utils_1.Type.Object({
      address: schema_utils_1.Type.String(),
      mac: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, { $id: "TezosAddress" });
    exports2.TezosGetPublicKey = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      show_display: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, { $id: "TezosGetPublicKey" });
    exports2.TezosPublicKey = schema_utils_1.Type.Object({
      public_key: schema_utils_1.Type.String()
    }, { $id: "TezosPublicKey" });
    var TezosContractType;
    (function(TezosContractType2) {
      TezosContractType2[TezosContractType2["Implicit"] = 0] = "Implicit";
      TezosContractType2[TezosContractType2["Originated"] = 1] = "Originated";
    })(TezosContractType || (exports2.TezosContractType = TezosContractType = {}));
    exports2.EnumTezosContractType = schema_utils_1.Type.Enum(TezosContractType);
    exports2.TezosContractID = schema_utils_1.Type.Object({
      tag: schema_utils_1.Type.Number(),
      hash: schema_utils_1.Type.Uint8Array()
    }, { $id: "TezosContractID" });
    exports2.TezosRevealOp = schema_utils_1.Type.Object({
      source: schema_utils_1.Type.Uint8Array(),
      fee: schema_utils_1.Type.Uint(),
      counter: schema_utils_1.Type.Number(),
      gas_limit: schema_utils_1.Type.Number(),
      storage_limit: schema_utils_1.Type.Number(),
      public_key: schema_utils_1.Type.Uint8Array()
    }, { $id: "TezosRevealOp" });
    exports2.TezosManagerTransfer = schema_utils_1.Type.Object({
      destination: exports2.TezosContractID,
      amount: schema_utils_1.Type.Uint()
    }, { $id: "TezosManagerTransfer" });
    exports2.TezosParametersManager = schema_utils_1.Type.Object({
      set_delegate: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint8Array()),
      cancel_delegate: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      transfer: schema_utils_1.Type.Optional(exports2.TezosManagerTransfer)
    }, { $id: "TezosParametersManager" });
    exports2.TezosTransactionOp = schema_utils_1.Type.Object({
      source: schema_utils_1.Type.Uint8Array(),
      fee: schema_utils_1.Type.Uint(),
      counter: schema_utils_1.Type.Number(),
      gas_limit: schema_utils_1.Type.Number(),
      storage_limit: schema_utils_1.Type.Number(),
      amount: schema_utils_1.Type.Uint(),
      destination: exports2.TezosContractID,
      parameters: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(schema_utils_1.Type.Number())),
      parameters_manager: schema_utils_1.Type.Optional(exports2.TezosParametersManager)
    }, { $id: "TezosTransactionOp" });
    exports2.TezosOriginationOp = schema_utils_1.Type.Object({
      source: schema_utils_1.Type.Uint8Array(),
      fee: schema_utils_1.Type.Uint(),
      counter: schema_utils_1.Type.Number(),
      gas_limit: schema_utils_1.Type.Number(),
      storage_limit: schema_utils_1.Type.Number(),
      manager_pubkey: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      balance: schema_utils_1.Type.Number(),
      spendable: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      delegatable: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      delegate: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint8Array()),
      script: schema_utils_1.Type.Union([schema_utils_1.Type.String(), schema_utils_1.Type.Array(schema_utils_1.Type.Number())])
    }, { $id: "TezosOriginationOp" });
    exports2.TezosDelegationOp = schema_utils_1.Type.Object({
      source: schema_utils_1.Type.Uint8Array(),
      fee: schema_utils_1.Type.Uint(),
      counter: schema_utils_1.Type.Number(),
      gas_limit: schema_utils_1.Type.Number(),
      storage_limit: schema_utils_1.Type.Number(),
      delegate: schema_utils_1.Type.Uint8Array()
    }, { $id: "TezosDelegationOp" });
    exports2.TezosProposalOp = schema_utils_1.Type.Object({
      source: schema_utils_1.Type.String(),
      period: schema_utils_1.Type.Number(),
      proposals: schema_utils_1.Type.Array(schema_utils_1.Type.String())
    }, { $id: "TezosProposalOp" });
    var TezosBallotType;
    (function(TezosBallotType2) {
      TezosBallotType2[TezosBallotType2["Yay"] = 0] = "Yay";
      TezosBallotType2[TezosBallotType2["Nay"] = 1] = "Nay";
      TezosBallotType2[TezosBallotType2["Pass"] = 2] = "Pass";
    })(TezosBallotType || (exports2.TezosBallotType = TezosBallotType = {}));
    exports2.EnumTezosBallotType = schema_utils_1.Type.Enum(TezosBallotType);
    exports2.TezosBallotOp = schema_utils_1.Type.Object({
      source: schema_utils_1.Type.String(),
      period: schema_utils_1.Type.Number(),
      proposal: schema_utils_1.Type.String(),
      ballot: exports2.EnumTezosBallotType
    }, { $id: "TezosBallotOp" });
    exports2.TezosSignTx = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      branch: schema_utils_1.Type.Uint8Array(),
      reveal: schema_utils_1.Type.Optional(exports2.TezosRevealOp),
      transaction: schema_utils_1.Type.Optional(exports2.TezosTransactionOp),
      origination: schema_utils_1.Type.Optional(exports2.TezosOriginationOp),
      delegation: schema_utils_1.Type.Optional(exports2.TezosDelegationOp),
      proposal: schema_utils_1.Type.Optional(exports2.TezosProposalOp),
      ballot: schema_utils_1.Type.Optional(exports2.TezosBallotOp),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, { $id: "TezosSignTx" });
    exports2.TezosSignedTx = schema_utils_1.Type.Object({
      signature: schema_utils_1.Type.String(),
      sig_op_contents: schema_utils_1.Type.String(),
      operation_hash: schema_utils_1.Type.String()
    }, { $id: "TezosSignedTx" });
    exports2.MessageType = schema_utils_1.Type.Object({
      TextMemo: exports2.TextMemo,
      RefundMemo: exports2.RefundMemo,
      CoinPurchaseMemo: exports2.CoinPurchaseMemo,
      TextDetailsMemo: exports2.TextDetailsMemo,
      PaymentRequestMemo: exports2.PaymentRequestMemo,
      PaymentRequest: exports2.PaymentRequest,
      HDNodeType: exports2.HDNodeType,
      HDNodePathType: exports2.HDNodePathType,
      MultisigRedeemScriptType: exports2.MultisigRedeemScriptType,
      GetPublicKey: exports2.GetPublicKey,
      PublicKey: exports2.PublicKey,
      GetAddress: exports2.GetAddress,
      Address: exports2.Address,
      GetOwnershipId: exports2.GetOwnershipId,
      OwnershipId: exports2.OwnershipId,
      SignMessage: exports2.SignMessage,
      MessageSignature: exports2.MessageSignature,
      VerifyMessage: exports2.VerifyMessage,
      CoinJoinRequest: exports2.CoinJoinRequest,
      SignTx: exports2.SignTx,
      TxRequestDetailsType: exports2.TxRequestDetailsType,
      TxRequestSerializedType: exports2.TxRequestSerializedType,
      TxRequest: exports2.TxRequest,
      TxInputType: exports2.TxInputType,
      TxOutputBinType: exports2.TxOutputBinType,
      TxOutputType: exports2.TxOutputType,
      PrevTx: exports2.PrevTx,
      PrevInput: exports2.PrevInput,
      PrevOutput: exports2.PrevOutput,
      TxAck: exports2.TxAck,
      TxAckInputWrapper: exports2.TxAckInputWrapper,
      TxAckInput: exports2.TxAckInput,
      TxAckOutputWrapper: exports2.TxAckOutputWrapper,
      TxAckOutput: exports2.TxAckOutput,
      TxAckPrevMeta: exports2.TxAckPrevMeta,
      TxAckPrevInputWrapper: exports2.TxAckPrevInputWrapper,
      TxAckPrevInput: exports2.TxAckPrevInput,
      TxAckPrevOutputWrapper: exports2.TxAckPrevOutputWrapper,
      TxAckPrevOutput: exports2.TxAckPrevOutput,
      TxAckPrevExtraDataWrapper: exports2.TxAckPrevExtraDataWrapper,
      TxAckPrevExtraData: exports2.TxAckPrevExtraData,
      GetOwnershipProof: exports2.GetOwnershipProof,
      OwnershipProof: exports2.OwnershipProof,
      AuthorizeCoinJoin: exports2.AuthorizeCoinJoin,
      BleUnpair: exports2.BleUnpair,
      FirmwareErase: exports2.FirmwareErase,
      FirmwareRequest: exports2.FirmwareRequest,
      FirmwareUpload: exports2.FirmwareUpload,
      ProdTestT1: exports2.ProdTestT1,
      CardanoBlockchainPointerType: exports2.CardanoBlockchainPointerType,
      CardanoNativeScript: exports2.CardanoNativeScript,
      CardanoGetNativeScriptHash: exports2.CardanoGetNativeScriptHash,
      CardanoNativeScriptHash: exports2.CardanoNativeScriptHash,
      CardanoAddressParametersType: exports2.CardanoAddressParametersType,
      CardanoGetAddress: exports2.CardanoGetAddress,
      CardanoAddress: exports2.CardanoAddress,
      CardanoGetPublicKey: exports2.CardanoGetPublicKey,
      CardanoPublicKey: exports2.CardanoPublicKey,
      CardanoSignTxInit: exports2.CardanoSignTxInit,
      CardanoTxInput: exports2.CardanoTxInput,
      CardanoTxOutput: exports2.CardanoTxOutput,
      CardanoAssetGroup: exports2.CardanoAssetGroup,
      CardanoToken: exports2.CardanoToken,
      CardanoTxInlineDatumChunk: exports2.CardanoTxInlineDatumChunk,
      CardanoTxReferenceScriptChunk: exports2.CardanoTxReferenceScriptChunk,
      CardanoPoolOwner: exports2.CardanoPoolOwner,
      CardanoPoolRelayParameters: exports2.CardanoPoolRelayParameters,
      CardanoPoolMetadataType: exports2.CardanoPoolMetadataType,
      CardanoPoolParametersType: exports2.CardanoPoolParametersType,
      CardanoDRep: exports2.CardanoDRep,
      CardanoTxCertificate: exports2.CardanoTxCertificate,
      CardanoTxWithdrawal: exports2.CardanoTxWithdrawal,
      CardanoCVoteRegistrationDelegation: exports2.CardanoCVoteRegistrationDelegation,
      CardanoCVoteRegistrationParametersType: exports2.CardanoCVoteRegistrationParametersType,
      CardanoTxAuxiliaryData: exports2.CardanoTxAuxiliaryData,
      CardanoTxMint: exports2.CardanoTxMint,
      CardanoTxCollateralInput: exports2.CardanoTxCollateralInput,
      CardanoTxRequiredSigner: exports2.CardanoTxRequiredSigner,
      CardanoTxReferenceInput: exports2.CardanoTxReferenceInput,
      CardanoTxItemAck: exports2.CardanoTxItemAck,
      CardanoTxAuxiliaryDataSupplement: exports2.CardanoTxAuxiliaryDataSupplement,
      CardanoTxWitnessRequest: exports2.CardanoTxWitnessRequest,
      CardanoTxWitnessResponse: exports2.CardanoTxWitnessResponse,
      CardanoTxHostAck: exports2.CardanoTxHostAck,
      CardanoTxBodyHash: exports2.CardanoTxBodyHash,
      CardanoSignTxFinished: exports2.CardanoSignTxFinished,
      CardanoSignMessageInit: exports2.CardanoSignMessageInit,
      CardanoMessageDataRequest: exports2.CardanoMessageDataRequest,
      CardanoMessageDataResponse: exports2.CardanoMessageDataResponse,
      CardanoMessageSignature: exports2.CardanoMessageSignature,
      Success: exports2.Success,
      Failure: exports2.Failure,
      ButtonRequest: exports2.ButtonRequest,
      ButtonAck: exports2.ButtonAck,
      PinMatrixRequest: exports2.PinMatrixRequest,
      PinMatrixAck: exports2.PinMatrixAck,
      PassphraseRequest: exports2.PassphraseRequest,
      PassphraseAck: exports2.PassphraseAck,
      Deprecated_PassphraseStateRequest: exports2.Deprecated_PassphraseStateRequest,
      Deprecated_PassphraseStateAck: exports2.Deprecated_PassphraseStateAck,
      CipherKeyValue: exports2.CipherKeyValue,
      CipheredKeyValue: exports2.CipheredKeyValue,
      IdentityType: exports2.IdentityType,
      SignIdentity: exports2.SignIdentity,
      SignedIdentity: exports2.SignedIdentity,
      GetECDHSessionKey: exports2.GetECDHSessionKey,
      ECDHSessionKey: exports2.ECDHSessionKey,
      PaymentNotification: exports2.PaymentNotification,
      DebugLinkGetPairingInfo: exports2.DebugLinkGetPairingInfo,
      DebugLinkPairingInfo: exports2.DebugLinkPairingInfo,
      DebugLinkResetDebugEvents: exports2.DebugLinkResetDebugEvents,
      DebugLinkOptigaSetSecMax: exports2.DebugLinkOptigaSetSecMax,
      DebugLinkGetGcInfo: exports2.DebugLinkGetGcInfo,
      DebugLinkGcInfoItem: exports2.DebugLinkGcInfoItem,
      DebugLinkGcInfo: exports2.DebugLinkGcInfo,
      EthereumNetworkInfo: exports2.EthereumNetworkInfo,
      EthereumTokenInfo: exports2.EthereumTokenInfo,
      SolanaTokenInfo: exports2.SolanaTokenInfo,
      EosGetPublicKey: exports2.EosGetPublicKey,
      EosPublicKey: exports2.EosPublicKey,
      EosTxHeader: exports2.EosTxHeader,
      EosSignTx: exports2.EosSignTx,
      EosTxActionRequest: exports2.EosTxActionRequest,
      EosAsset: exports2.EosAsset,
      EosPermissionLevel: exports2.EosPermissionLevel,
      EosAuthorizationKey: exports2.EosAuthorizationKey,
      EosAuthorizationAccount: exports2.EosAuthorizationAccount,
      EosAuthorizationWait: exports2.EosAuthorizationWait,
      EosAuthorization: exports2.EosAuthorization,
      EosActionCommon: exports2.EosActionCommon,
      EosActionTransfer: exports2.EosActionTransfer,
      EosActionDelegate: exports2.EosActionDelegate,
      EosActionUndelegate: exports2.EosActionUndelegate,
      EosActionRefund: exports2.EosActionRefund,
      EosActionBuyRam: exports2.EosActionBuyRam,
      EosActionBuyRamBytes: exports2.EosActionBuyRamBytes,
      EosActionSellRam: exports2.EosActionSellRam,
      EosActionVoteProducer: exports2.EosActionVoteProducer,
      EosActionUpdateAuth: exports2.EosActionUpdateAuth,
      EosActionDeleteAuth: exports2.EosActionDeleteAuth,
      EosActionLinkAuth: exports2.EosActionLinkAuth,
      EosActionUnlinkAuth: exports2.EosActionUnlinkAuth,
      EosActionNewAccount: exports2.EosActionNewAccount,
      EosActionUnknown: exports2.EosActionUnknown,
      EosTxActionAck: exports2.EosTxActionAck,
      EosSignedTx: exports2.EosSignedTx,
      EthereumDefinitions: exports2.EthereumDefinitions,
      EthereumSignTypedData: exports2.EthereumSignTypedData,
      EthereumTypedDataStructRequest: exports2.EthereumTypedDataStructRequest,
      EthereumFieldType: exports2.EthereumFieldType,
      EthereumStructMember: exports2.EthereumStructMember,
      EthereumTypedDataStructAck: exports2.EthereumTypedDataStructAck,
      EthereumTypedDataValueRequest: exports2.EthereumTypedDataValueRequest,
      EthereumTypedDataValueAck: exports2.EthereumTypedDataValueAck,
      EthereumGetPublicKey: exports2.EthereumGetPublicKey,
      EthereumPublicKey: exports2.EthereumPublicKey,
      EthereumGetAddress: exports2.EthereumGetAddress,
      EthereumAddress: exports2.EthereumAddress,
      EthereumSignTx: exports2.EthereumSignTx,
      EthereumAccessList: exports2.EthereumAccessList,
      EthereumSignTxEIP1559: exports2.EthereumSignTxEIP1559,
      EthereumTxRequest: exports2.EthereumTxRequest,
      EthereumTxAck: exports2.EthereumTxAck,
      EthereumSignMessage: exports2.EthereumSignMessage,
      EthereumMessageSignature: exports2.EthereumMessageSignature,
      EthereumVerifyMessage: exports2.EthereumVerifyMessage,
      EthereumSignTypedHash: exports2.EthereumSignTypedHash,
      EthereumTypedDataSignature: exports2.EthereumTypedDataSignature,
      EvoluGetNode: exports2.EvoluGetNode,
      EvoluNode: exports2.EvoluNode,
      Initialize: exports2.Initialize,
      GetFeatures: exports2.GetFeatures,
      RecoveryDevice: exports2.RecoveryDevice,
      Features: exports2.Features,
      LockDevice: exports2.LockDevice,
      SetBusy: exports2.SetBusy,
      EndSession: exports2.EndSession,
      ApplySettings: exports2.ApplySettings,
      ChangeLanguage: exports2.ChangeLanguage,
      DataChunkRequest: exports2.DataChunkRequest,
      DataChunkAck: exports2.DataChunkAck,
      ApplyFlags: exports2.ApplyFlags,
      ChangePin: exports2.ChangePin,
      ChangeWipeCode: exports2.ChangeWipeCode,
      SdProtect: exports2.SdProtect,
      Ping: exports2.Ping,
      Cancel: exports2.Cancel,
      GetEntropy: exports2.GetEntropy,
      Entropy: exports2.Entropy,
      GetFirmwareHash: exports2.GetFirmwareHash,
      FirmwareHash: exports2.FirmwareHash,
      AuthenticateDevice: exports2.AuthenticateDevice,
      AuthenticityProof: exports2.AuthenticityProof,
      WipeDevice: exports2.WipeDevice,
      LoadDevice: exports2.LoadDevice,
      ResetDevice: exports2.ResetDevice,
      Slip39Group: exports2.Slip39Group,
      BackupDevice: exports2.BackupDevice,
      EntropyRequest: exports2.EntropyRequest,
      EntropyAck: exports2.EntropyAck,
      EntropyCheckReady: exports2.EntropyCheckReady,
      EntropyCheckContinue: exports2.EntropyCheckContinue,
      WordRequest: exports2.WordRequest,
      WordAck: exports2.WordAck,
      SetU2FCounter: exports2.SetU2FCounter,
      GetNextU2FCounter: exports2.GetNextU2FCounter,
      NextU2FCounter: exports2.NextU2FCounter,
      DoPreauthorized: exports2.DoPreauthorized,
      PreauthorizedRequest: exports2.PreauthorizedRequest,
      CancelAuthorization: exports2.CancelAuthorization,
      RebootToBootloader: exports2.RebootToBootloader,
      GetNonce: exports2.GetNonce,
      Nonce: exports2.Nonce,
      UnlockPath: exports2.UnlockPath,
      UnlockedPathRequest: exports2.UnlockedPathRequest,
      ShowDeviceTutorial: exports2.ShowDeviceTutorial,
      UnlockBootloader: exports2.UnlockBootloader,
      SetBrightness: exports2.SetBrightness,
      NEMGetAddress: exports2.NEMGetAddress,
      NEMAddress: exports2.NEMAddress,
      NEMTransactionCommon: exports2.NEMTransactionCommon,
      NEMMosaic: exports2.NEMMosaic,
      NEMTransfer: exports2.NEMTransfer,
      NEMProvisionNamespace: exports2.NEMProvisionNamespace,
      NEMMosaicDefinition: exports2.NEMMosaicDefinition,
      NEMMosaicCreation: exports2.NEMMosaicCreation,
      NEMMosaicSupplyChange: exports2.NEMMosaicSupplyChange,
      NEMCosignatoryModification: exports2.NEMCosignatoryModification,
      NEMAggregateModification: exports2.NEMAggregateModification,
      NEMImportanceTransfer: exports2.NEMImportanceTransfer,
      NEMSignTx: exports2.NEMSignTx,
      NEMSignedTx: exports2.NEMSignedTx,
      NEMDecryptMessage: exports2.NEMDecryptMessage,
      NEMDecryptedMessage: exports2.NEMDecryptedMessage,
      RippleGetAddress: exports2.RippleGetAddress,
      RippleAddress: exports2.RippleAddress,
      RipplePayment: exports2.RipplePayment,
      RippleSignTx: exports2.RippleSignTx,
      RippleSignedTx: exports2.RippleSignedTx,
      SolanaGetPublicKey: exports2.SolanaGetPublicKey,
      SolanaPublicKey: exports2.SolanaPublicKey,
      SolanaGetAddress: exports2.SolanaGetAddress,
      SolanaAddress: exports2.SolanaAddress,
      SolanaTxTokenAccountInfo: exports2.SolanaTxTokenAccountInfo,
      SolanaTxAdditionalInfo: exports2.SolanaTxAdditionalInfo,
      SolanaSignTx: exports2.SolanaSignTx,
      SolanaTxSignature: exports2.SolanaTxSignature,
      StellarAsset: exports2.StellarAsset,
      StellarGetAddress: exports2.StellarGetAddress,
      StellarAddress: exports2.StellarAddress,
      StellarSignTx: exports2.StellarSignTx,
      StellarTxOpRequest: exports2.StellarTxOpRequest,
      StellarPaymentOp: exports2.StellarPaymentOp,
      StellarCreateAccountOp: exports2.StellarCreateAccountOp,
      StellarPathPaymentStrictReceiveOp: exports2.StellarPathPaymentStrictReceiveOp,
      StellarPathPaymentStrictSendOp: exports2.StellarPathPaymentStrictSendOp,
      StellarManageSellOfferOp: exports2.StellarManageSellOfferOp,
      StellarManageBuyOfferOp: exports2.StellarManageBuyOfferOp,
      StellarCreatePassiveSellOfferOp: exports2.StellarCreatePassiveSellOfferOp,
      StellarSetOptionsOp: exports2.StellarSetOptionsOp,
      StellarChangeTrustOp: exports2.StellarChangeTrustOp,
      StellarAllowTrustOp: exports2.StellarAllowTrustOp,
      StellarAccountMergeOp: exports2.StellarAccountMergeOp,
      StellarManageDataOp: exports2.StellarManageDataOp,
      StellarBumpSequenceOp: exports2.StellarBumpSequenceOp,
      StellarClaimClaimableBalanceOp: exports2.StellarClaimClaimableBalanceOp,
      StellarSignedTx: exports2.StellarSignedTx,
      TezosGetAddress: exports2.TezosGetAddress,
      TezosAddress: exports2.TezosAddress,
      TezosGetPublicKey: exports2.TezosGetPublicKey,
      TezosPublicKey: exports2.TezosPublicKey,
      TezosContractID: exports2.TezosContractID,
      TezosRevealOp: exports2.TezosRevealOp,
      TezosManagerTransfer: exports2.TezosManagerTransfer,
      TezosParametersManager: exports2.TezosParametersManager,
      TezosTransactionOp: exports2.TezosTransactionOp,
      TezosOriginationOp: exports2.TezosOriginationOp,
      TezosDelegationOp: exports2.TezosDelegationOp,
      TezosProposalOp: exports2.TezosProposalOp,
      TezosBallotOp: exports2.TezosBallotOp,
      TezosSignTx: exports2.TezosSignTx,
      TezosSignedTx: exports2.TezosSignedTx
    }, { $id: "MessageType" });
  }
});

// node_modules/@trezor/protobuf/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/@trezor/protobuf/lib/index.js"(exports2) {
    "use strict";
    var _a;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MessagesSchema = exports2.loadDefinitions = exports2.Messages = exports2.encodeMessage = exports2.decodeMessage = exports2.parseConfigure = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var long_1 = tslib_1.__importDefault(require_umd());
    var protobuf = tslib_1.__importStar(require_light());
    var decode_1 = require_decode2();
    var encode_1 = require_encode();
    var utils_1 = require_utils6();
    _a = (() => {
      protobuf.util.Long = long_1.default;
      protobuf.configure();
      return { parseConfigure: utils_1.parseConfigure, decodeMessage: decode_1.decodeMessage, encodeMessage: encode_1.encodeMessage };
    })(), exports2.parseConfigure = _a.parseConfigure, exports2.decodeMessage = _a.decodeMessage, exports2.encodeMessage = _a.encodeMessage;
    exports2.Messages = tslib_1.__importStar(require_messages());
    var load_definitions_1 = require_load_definitions();
    Object.defineProperty(exports2, "loadDefinitions", { enumerable: true, get: function() {
      return load_definitions_1.loadDefinitions;
    } });
    exports2.MessagesSchema = tslib_1.__importStar(require_messages_schema());
  }
});

// node_modules/@trezor/connect/lib/constants/index.js
var require_constants4 = __commonJS({
  "node_modules/@trezor/connect/lib/constants/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PROTO = exports2.DEFAULT_SORTING_STRATEGY = exports2.FIRMWARE = exports2.NEM = exports2.CARDANO = exports2.NETWORK = exports2.ERRORS = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    exports2.ERRORS = tslib_1.__importStar(require_errors2());
    exports2.NETWORK = tslib_1.__importStar(require_network());
    exports2.CARDANO = tslib_1.__importStar(require_cardano());
    exports2.NEM = tslib_1.__importStar(require_nem());
    exports2.FIRMWARE = tslib_1.__importStar(require_firmware());
    var utxo_1 = require_utxo();
    Object.defineProperty(exports2, "DEFAULT_SORTING_STRATEGY", { enumerable: true, get: function() {
      return utxo_1.DEFAULT_SORTING_STRATEGY;
    } });
    var protobuf_1 = require_lib3();
    Object.defineProperty(exports2, "PROTO", { enumerable: true, get: function() {
      return protobuf_1.MessagesSchema;
    } });
  }
});

// node_modules/@trezor/connect/lib/utils/proxy-event-emitter.js
var require_proxy_event_emitter = __commonJS({
  "node_modules/@trezor/connect/lib/utils/proxy-event-emitter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProxyEventEmitter = void 0;
    var ProxyEventEmitter = class {
      eventEmitters;
      constructor(eventEmitters) {
        this.eventEmitters = eventEmitters;
      }
      emit(eventName, ...args) {
        this.eventEmitters.forEach((emitter) => emitter.emit(eventName, ...args));
        return true;
      }
      on(eventName, listener) {
        this.eventEmitters.forEach((emitter) => emitter.on(eventName, listener));
        return this;
      }
      off(eventName, listener) {
        this.eventEmitters.forEach((emitter) => emitter.off(eventName, listener));
        return this;
      }
      once(eventName, listener) {
        this.eventEmitters.forEach((emitter) => emitter.once(eventName, listener));
        return this;
      }
      addListener(eventName, listener) {
        this.eventEmitters.forEach((emitter) => emitter.addListener(eventName, listener));
        return this;
      }
      prependListener(eventName, listener) {
        this.eventEmitters.forEach((emitter) => emitter.prependListener(eventName, listener));
        return this;
      }
      prependOnceListener(eventName, listener) {
        this.eventEmitters.forEach((emitter) => emitter.prependOnceListener(eventName, listener));
        return this;
      }
      removeAllListeners(event) {
        this.eventEmitters.forEach((emitter) => emitter.removeAllListeners(event));
        return this;
      }
      removeListener(eventName, listener) {
        this.eventEmitters.forEach((emitter) => emitter.removeListener(eventName, listener));
        return this;
      }
      setMaxListeners(n) {
        this.eventEmitters.forEach((emitter) => emitter.setMaxListeners(n));
        return this;
      }
      eventNames() {
        return this.eventEmitters[0].eventNames();
      }
      getMaxListeners() {
        return this.eventEmitters[0].getMaxListeners();
      }
      listenerCount(eventName, listener) {
        return this.eventEmitters[0].listenerCount(eventName, listener);
      }
      rawListeners(eventName) {
        return this.eventEmitters[0].rawListeners(eventName);
      }
      listeners(eventName) {
        return this.eventEmitters[0].listeners(eventName);
      }
    };
    exports2.ProxyEventEmitter = ProxyEventEmitter;
  }
});

// node_modules/@trezor/connect/lib/impl/dynamic.js
var require_dynamic = __commonJS({
  "node_modules/@trezor/connect/lib/impl/dynamic.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TrezorConnectDynamic = void 0;
    var utils_1 = require_lib();
    var constants_1 = require_constants4();
    var events_1 = require_events2();
    var proxy_event_emitter_1 = require_proxy_event_emitter();
    var TrezorConnectDynamic = class {
      eventEmitter;
      currentTarget;
      implementations;
      getInitTarget;
      handleBeforeCall;
      handleErrorFallback;
      lastSettings;
      callPending = 0;
      beforeCallSynchronize = (0, utils_1.getSynchronize)();
      constructor({ implementations, getInitTarget, handleBeforeCall, handleErrorFallback }) {
        this.implementations = implementations;
        this.currentTarget = this.implementations[0].type;
        this.getInitTarget = getInitTarget;
        this.handleBeforeCall = handleBeforeCall;
        this.handleErrorFallback = handleErrorFallback;
        this.eventEmitter = new proxy_event_emitter_1.ProxyEventEmitter(this.implementations.map((impl) => impl.impl.eventEmitter));
      }
      getTarget() {
        return this.implementations.find((impl) => impl.type === this.currentTarget).impl;
      }
      getTargetType() {
        return this.currentTarget;
      }
      async switchTarget(target) {
        if (this.currentTarget === target) {
          return;
        }
        if (!this.lastSettings) {
          throw constants_1.ERRORS.TypedError("Init_ManifestMissing");
        }
        const oldTargetType = this.getTargetType();
        const oldTarget = this.getTarget();
        try {
          this.currentTarget = target;
          await this.getTarget().init(this.lastSettings);
          await oldTarget.dispose();
        } catch {
          this.currentTarget = oldTargetType;
        }
      }
      manifest(manifest) {
        this.lastSettings = { ...this.lastSettings, manifest };
        this.getTarget().manifest(manifest);
      }
      async init(settings2) {
        if (!settings2?.manifest) {
          throw constants_1.ERRORS.TypedError("Init_ManifestMissing");
        }
        this.lastSettings = settings2;
        this.currentTarget = this.getInitTarget(settings2);
        this.callPending = 0;
        try {
          return await this.getTarget().init(this.lastSettings);
        } catch (error) {
          if (await this.handleErrorFallback(error.code)) {
            return;
          }
          throw error;
        }
      }
      setTransports({ transports }) {
        this.lastSettings = { ...this.lastSettings, transports };
        this.getTarget().setTransports({ transports });
      }
      async call(params) {
        try {
          if (this.callPending === 0) {
            await this.beforeCallSynchronize(async () => {
              this.callPending++;
              await this.handleBeforeCall();
            });
          }
          const response = await this.getTarget().call(params);
          if (!response.success) {
            if (await this.handleErrorFallback(response.payload.code)) {
              return await this.getTarget().call(params);
            }
          }
          return response;
        } catch (error) {
          return (0, events_1.createErrorMessage)(error);
        } finally {
          this.callPending--;
        }
      }
      requestLogin(params) {
        return this.getTarget().requestLogin(params);
      }
      uiResponse(params) {
        return this.getTarget().uiResponse(params);
      }
      cancel(error) {
        return this.getTarget().cancel(error);
      }
      dispose() {
        this.eventEmitter.removeAllListeners();
        this.callPending = 0;
        return this.getTarget().dispose();
      }
    };
    exports2.TrezorConnectDynamic = TrezorConnectDynamic;
  }
});

// node_modules/@trezor/connect/lib/data/thpSettings.js
var require_thpSettings = __commonJS({
  "node_modules/@trezor/connect/lib/data/thpSettings.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseThpSettings = void 0;
    var parseThpSettings = ({ manifest, thp }) => {
      const settings2 = {
        pairingMethods: []
      };
      if (Array.isArray(thp?.pairingMethods)) {
        settings2.pairingMethods = thp.pairingMethods;
      } else {
        settings2.pairingMethods = ["CodeEntry"];
      }
      if (typeof thp?.hostName === "string") {
        settings2.hostName = thp.hostName;
      }
      if (typeof thp?.appName === "string") {
        settings2.appName = thp.appName;
      } else if (typeof manifest?.appName === "string") {
        settings2.appName = manifest?.appName;
      }
      if (typeof thp?.staticKey === "string") {
        settings2.staticKey = thp.staticKey;
      }
      if (Array.isArray(thp?.knownCredentials)) {
        settings2.knownCredentials = thp.knownCredentials.flatMap((k) => {
          if (k && typeof k === "object" && typeof k.credential === "string" && typeof k.trezor_static_public_key === "string") {
            return k;
          }
          return [];
        });
      }
      return settings2;
    };
    exports2.parseThpSettings = parseThpSettings;
  }
});

// node_modules/@trezor/connect/lib/data/version.js
var require_version = __commonJS({
  "node_modules/@trezor/connect/lib/data/version.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DEEPLINK_VERSION = exports2.CONTENT_SCRIPT_VERSION = exports2.DEFAULT_DOMAIN = exports2.DEFAULT_DOMAIN_MAJOR_VER = exports2.VERSION = void 0;
    exports2.VERSION = "9.6.4";
    var versionN = exports2.VERSION.split(".").map((s) => parseInt(s, 10));
    var isBeta = exports2.VERSION.includes("beta");
    exports2.DEFAULT_DOMAIN_MAJOR_VER = `https://connect.trezor.io/${versionN[0]}/`;
    exports2.DEFAULT_DOMAIN = isBeta ? `https://connect.trezor.io/${exports2.VERSION}/` : exports2.DEFAULT_DOMAIN_MAJOR_VER;
    exports2.CONTENT_SCRIPT_VERSION = 1;
    exports2.DEEPLINK_VERSION = 1;
  }
});

// node_modules/@trezor/connect/lib/data/connectSettings.js
var require_connectSettings = __commonJS({
  "node_modules/@trezor/connect/lib/data/connectSettings.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseConnectSettings = exports2.corsValidator = exports2.parseLocalFirmwares = exports2.DEFAULT_PRIORITY = void 0;
    var thpSettings_1 = require_thpSettings();
    var version_1 = require_version();
    exports2.DEFAULT_PRIORITY = 2;
    var initialSettings = {
      configSrc: "./data/config.json",
      version: version_1.VERSION,
      debug: false,
      priority: exports2.DEFAULT_PRIORITY,
      trustedHost: true,
      connectSrc: version_1.DEFAULT_DOMAIN,
      iframeSrc: `${version_1.DEFAULT_DOMAIN}iframe.html`,
      popup: false,
      popupSrc: `${version_1.DEFAULT_DOMAIN}popup.html`,
      webusbSrc: `${version_1.DEFAULT_DOMAIN}webusb.html`,
      transports: void 0,
      pendingTransportEvent: true,
      env: "node",
      lazyLoad: false,
      timestamp: (/* @__PURE__ */ new Date()).getTime(),
      interactionTimeout: 1200,
      sharedLogger: true,
      deeplinkUrl: `${version_1.DEFAULT_DOMAIN}deeplink/${version_1.DEEPLINK_VERSION}/`,
      transportReconnect: true
    };
    var parseManifest = (manifest) => {
      if (!manifest)
        return;
      if (typeof manifest.email !== "string")
        return;
      if (typeof manifest.appUrl !== "string")
        return;
      if (typeof manifest.appName !== "undefined" && typeof manifest.appName !== "string")
        return;
      if (typeof manifest.appIcon !== "undefined" && typeof manifest.appIcon !== "string")
        return;
      return {
        email: manifest.email,
        appUrl: manifest.appUrl,
        appName: manifest.appName,
        appIcon: manifest.appIcon
      };
    };
    var parseLocalFirmwares = (localFirmwares) => {
      if (!localFirmwares)
        return;
      if (typeof localFirmwares.firmwareDir !== "string")
        return;
      if (!Array.isArray(localFirmwares.firmwareList))
        return;
      return {
        firmwareDir: localFirmwares.firmwareDir,
        firmwareList: localFirmwares.firmwareList
      };
    };
    exports2.parseLocalFirmwares = parseLocalFirmwares;
    var corsValidator = (url) => {
      if (typeof url !== "string")
        return;
      if (url === "../")
        return url;
      if (url.match(/^https:\/\/([A-Za-z0-9\-_]+\.)*trezor\.io\//))
        return url;
      if (url.match(/^https?:\/\/localhost:[58][0-9]{3}\//))
        return url;
      if (url.match(/^https:\/\/([A-Za-z0-9\-_]+\.)*sldev\.cz\//))
        return url;
      if (url.match(/^https?:\/\/([A-Za-z0-9\-_]+\.)*trezoriovpjcahpzkrewelclulmszwbqpzmzgub37gbcjlvluxtruqad\.onion\//))
        return url;
    };
    exports2.corsValidator = corsValidator;
    var parseConnectSettings = (input = {}) => {
      const settings2 = { ...initialSettings };
      if ("debug" in input) {
        if (typeof input.debug === "boolean") {
          settings2.debug = input.debug;
        } else if (typeof input.debug === "string") {
          settings2.debug = input.debug === "true";
        }
      }
      if (input.trustedHost === false) {
        settings2.trustedHost = input.trustedHost;
      }
      if (typeof input.connectSrc === "string") {
        settings2.connectSrc = (0, exports2.corsValidator)(input.connectSrc);
      } else if (settings2.trustedHost) {
        settings2.connectSrc = input.connectSrc;
      }
      const src = settings2.connectSrc || version_1.DEFAULT_DOMAIN;
      settings2.iframeSrc = `${src}iframe.html`;
      settings2.popupSrc = `${src}popup.html`;
      settings2.webusbSrc = `${src}webusb.html`;
      if (typeof input.transportReconnect === "boolean") {
        settings2.transportReconnect = input.transportReconnect;
      }
      if (typeof input.localFirmwares === "object") {
        settings2.localFirmwares = (0, exports2.parseLocalFirmwares)(input.localFirmwares);
      }
      if (typeof input.firmwareUpdateSource === "string") {
        settings2.firmwareUpdateSource = input.firmwareUpdateSource;
      }
      if (Array.isArray(input.transports)) {
        settings2.transports = input.transports;
      }
      if (typeof input.popup === "boolean") {
        settings2.popup = input.popup;
      }
      if (typeof input.lazyLoad === "boolean") {
        settings2.lazyLoad = input.lazyLoad;
      }
      if (typeof input.pendingTransportEvent === "boolean") {
        settings2.pendingTransportEvent = input.pendingTransportEvent;
      }
      if (typeof input.extension === "string") {
        settings2.extension = input.extension;
      }
      if (typeof input.env === "string") {
        settings2.env = input.env;
      }
      if (typeof input.timestamp === "number") {
        settings2.timestamp = input.timestamp;
      }
      if (typeof input.interactionTimeout === "number") {
        settings2.interactionTimeout = input.interactionTimeout;
      }
      if (typeof input.manifest === "object") {
        settings2.manifest = parseManifest(input.manifest);
      }
      if (typeof input.sharedLogger === "boolean") {
        settings2.sharedLogger = input.sharedLogger;
      }
      if (typeof input.coreMode === "string" && ["auto", "popup", "iframe", "suite-desktop"].includes(input.coreMode)) {
        settings2.coreMode = input.coreMode;
      }
      if (typeof input._extendWebextensionLifetime === "boolean") {
        settings2._extendWebextensionLifetime = input._extendWebextensionLifetime;
      }
      if (typeof input.binFilesBaseUrl === "string") {
        settings2.binFilesBaseUrl = input.binFilesBaseUrl;
      }
      if (typeof input.enableFirmwareHashCheck === "boolean") {
        settings2.enableFirmwareHashCheck = Boolean(input.enableFirmwareHashCheck);
      }
      if (typeof input.firmwareHashCheckTimeouts === "object" && input.firmwareHashCheckTimeouts !== null) {
        settings2.firmwareHashCheckTimeouts = input.firmwareHashCheckTimeouts;
      }
      if (typeof input.npmVersion === "string") {
        settings2.npmVersion = input.npmVersion;
      }
      settings2.thp = (0, thpSettings_1.parseThpSettings)(input);
      return settings2;
    };
    exports2.parseConnectSettings = parseConnectSettings;
  }
});

// node_modules/@trezor/connect-web/lib/connectSettings.js
var require_connectSettings2 = __commonJS({
  "node_modules/@trezor/connect-web/lib/connectSettings.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseConnectSettings = exports2.getEnv = void 0;
    var connectSettings_1 = require_connectSettings();
    var getEnv = () => {
      if (typeof chrome !== "undefined" && typeof chrome.runtime?.onConnect !== "undefined") {
        return "webextension";
      }
      if (typeof navigator !== "undefined") {
        if (typeof navigator.product === "string" && navigator.product.toLowerCase() === "reactnative") {
          return "react-native";
        }
        const userAgent = navigator.userAgent.toLowerCase();
        if (userAgent.indexOf(" electron/") > -1) {
          return "electron";
        }
      }
      return "web";
    };
    exports2.getEnv = getEnv;
    var parseConnectSettings = (input = {}) => {
      const settings2 = { popup: true, ...input };
      let globalSrc;
      if (typeof window !== "undefined") {
        globalSrc = window.__TREZOR_CONNECT_SRC;
      } else if (typeof globalThis !== "undefined") {
        globalSrc = globalThis.__TREZOR_CONNECT_SRC;
      }
      if (typeof globalSrc === "string") {
        settings2.connectSrc = globalSrc;
        settings2.debug = true;
      }
      if (typeof input.env !== "string") {
        settings2.env = (0, exports2.getEnv)();
      }
      return (0, connectSettings_1.parseConnectSettings)(settings2);
    };
    exports2.parseConnectSettings = parseConnectSettings;
  }
});

// node_modules/@trezor/connect/lib/data/config.js
var require_config = __commonJS({
  "node_modules/@trezor/connect/lib/data/config.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.config = void 0;
    var constants_1 = require_constants3();
    exports2.config = {
      webusb: constants_1.TREZOR_USB_DESCRIPTORS,
      whitelist: [
        { origin: "chrome-extension://imloifkgjagghnncjkhggdhalmcnfklk", priority: 1 },
        { origin: "chrome-extension://niebkpllfhmpfbffbfifagfgoamhpflf", priority: 1 },
        { origin: "file://", priority: 2 },
        { origin: "trezor.io", priority: 0 },
        { origin: "sldev.cz", priority: 0 },
        { origin: "localhost", priority: 0 },
        { origin: "trezoriovpjcahpzkrewelclulmszwbqpzmzgub37gbcjlvluxtruqad.onion", priority: 0 }
      ],
      management: [{ origin: "trezor.io" }, { origin: "sldev.cz" }, { origin: "localhost" }],
      knownHosts: [
        {
          origin: "imloifkgjagghnncjkhggdhalmcnfklk",
          label: "Trezor Password Manager (Develop)"
        },
        { origin: "niebkpllfhmpfbffbfifagfgoamhpflf", label: "Trezor Password Manager" },
        {
          origin: "mnpfhpndmjholfdlhpkjfmjkgppmodaf",
          label: "MetaMask"
        },
        {
          origin: "webextension@metamask.io",
          label: "MetaMask"
        },
        {
          origin: "nkbihfbeogaeaoehlefnkodbefgpgknn",
          label: "MetaMask"
        },
        {
          origin: "bfibaipbbpipfifeecgfehbpmfhdakgo",
          label: "Nightly DEV"
        },
        {
          origin: "fiikommddbeccaoicoejoniammnalkfa",
          label: "Nightly"
        },
        {
          origin: "bpcdaglidgnlggelgbjfagekoapjmccp",
          label: "Rainbow DEV"
        },
        {
          origin: "opfgelmcmbiajamepnmloijbpoleiama",
          label: "Rainbow"
        },
        {
          origin: "acmacodkjbdgmoleebolmdjonilkdbch",
          label: "Rabby"
        },
        {
          origin: "ehnpnhnhcickeknioaiodjmielfaoajd",
          label: "Ambire DEV"
        },
        {
          origin: "ehgjhhccekdedpbkifaojjaefeohnoea",
          label: "Ambire"
        },
        { origin: "file://", label: " " }
      ],
      onionDomains: {
        "trezor.io": "trezoriovpjcahpzkrewelclulmszwbqpzmzgub37gbcjlvluxtruqad.onion"
      },
      supportedBrowsers: {
        chrome: {
          version: 59,
          download: "https://www.google.com/chrome/",
          update: "https://support.google.com/chrome/answer/95414"
        },
        mobilechrome: {
          version: 59,
          download: "https://www.google.com/chrome/",
          update: "https://support.google.com/chrome/answer/95414"
        },
        chromium: {
          version: 59,
          download: "https://www.chromium.org/",
          update: "https://www.chromium.org/"
        },
        electron: {
          version: 0,
          download: "https://www.electronjs.org/",
          update: "https://www.electronjs.org/"
        },
        firefox: {
          version: 54,
          download: "https://www.mozilla.org/en-US/firefox/new/",
          update: "https://support.mozilla.org/en-US/kb/update-firefox-latest-version"
        },
        mobilefirefox: {
          version: 54,
          download: "https://www.mozilla.org/en-US/firefox/new/",
          update: "https://support.mozilla.org/en-US/kb/update-firefox-latest-version"
        },
        brave: {
          version: 59,
          download: "https://brave.com/download/",
          update: "https://brave.com/download/"
        },
        edge: {
          version: 79,
          download: "https://www.microsoft.com/en-us/edge",
          update: "https://www.microsoft.com/en-us/edge"
        },
        opera: {
          version: 95,
          download: "https://www.opera.com/download",
          update: "https://www.opera.com/download"
        }
      },
      supportedFirmware: [
        {
          coin: ["xrp", "txrp"],
          methods: ["getAccountInfo"],
          min: { T1B1: "0", T2T1: "2.1.0" },
          max: void 0,
          comment: [
            "Since firmware 2.1.0 there is a new protobuf field 'destination_tag' in RippleSignTx"
          ]
        },
        {
          coin: ["bnb"],
          min: { T1B1: "1.9.0", T2T1: "2.3.0" },
          comment: [
            "There were protobuf backwards incompatible changes with introduction of 1.9.0/2.3.0 firmwares"
          ]
        },
        {
          coin: ["eth", "tsep", "thod"],
          min: { T1B1: "1.8.0", T2T1: "2.1.0" },
          comment: ["There were protobuf backwards incompatible changes."]
        },
        {
          coin: ["ada", "tada"],
          min: { T1B1: "0", T2T1: "2.4.3" },
          comment: ["Since 2.4.3 there is initialize.derive_cardano message"]
        },
        {
          methods: ["rippleGetAddress", "rippleSignTransaction"],
          min: { T1B1: "0", T2T1: "2.1.0" },
          comment: [
            "Since firmware 2.1.0 there is a new protobuf field 'destination_tag' in RippleSignTx"
          ]
        },
        {
          methods: ["cardanoGetAddress", "cardanoGetPublicKey"],
          min: { T1B1: "0", T2T1: "2.4.3" },
          comment: ["Since 2.4.3 Cardano derivation behavior has changed"]
        },
        {
          methods: ["cardanoSignTransaction"],
          min: { T1B1: "0", T2T1: "2.6.0" },
          comment: ["Before 2.6.0 not all Cardano transactions were supported"]
        },
        {
          methods: ["cardanoGetNativeScriptHash"],
          min: { T1B1: "0", T2T1: "2.4.3" },
          comment: ["Since 2.4.3 Cardano derivation behavior has changed"]
        },
        {
          methods: ["tezosSignTransaction"],
          min: { T1B1: "0", T2T1: "2.1.8" },
          comment: [
            "Since 2.1.8 there are new protobuf fields in tezos transaction (Babylon fork)"
          ]
        },
        {
          methods: ["stellarSignTransaction"],
          min: { T1B1: "1.9.0", T2T1: "2.3.0" },
          comment: [
            "There were protobuf backwards incompatible changes with introduction of 1.9.0/2.3.0 firmwares"
          ]
        },
        {
          capabilities: ["replaceTransaction", "amountUnit"],
          min: { T1B1: "1.9.4", T2T1: "2.3.5" },
          comment: ["new sign tx process since 1.9.4/2.3.5"]
        },
        {
          capabilities: ["decreaseOutput"],
          min: { T1B1: "1.10.0", T2T1: "2.4.0" },
          comment: ["allow reduce output in RBF transaction since 1.10.0/2.4.0"]
        },
        {
          capabilities: ["eip1559"],
          min: { T1B1: "1.10.4", T2T1: "2.4.2" },
          comment: ["new eth transaction pricing mechanism (EIP1559) since 1.10.4/2.4.2"]
        },
        {
          capabilities: ["taproot", "signMessageNoScriptType"],
          min: { T1B1: "1.10.4", T2T1: "2.4.3" },
          comment: [
            "new btc accounts taproot since 1.10.4/2.4.3 (BTC + TEST only)",
            "SignMessage with no_script_type support"
          ]
        },
        {
          coin: ["dcr", "tdcr"],
          methods: ["signTransaction"],
          min: { T1B1: "1.10.1", T2T1: "2.4.0" },
          comment: [""]
        },
        {
          methods: ["ethereumSignTypedData"],
          min: { T1B1: "1.10.5", T2T1: "2.4.3" },
          comment: ["EIP-712 typed signing support added in 1.10.5/2.4.3"]
        },
        {
          capabilities: ["eip712-domain-only"],
          min: { T1B1: "1.10.6", T2T1: "2.4.4" },
          comment: ["EIP-712 domain-only signing, when primaryType=EIP712Domain"]
        },
        {
          capabilities: ["coinjoin"],
          methods: [
            "authorizeCoinjoin",
            "cancelCoinjoinAuthorization",
            "getOwnershipId",
            "getOwnershipProof",
            "setBusy",
            "unlockPath"
          ],
          min: { T1B1: "1.12.1", T2T1: "2.5.3" }
        },
        {
          capabilities: ["tutorial"],
          methods: ["showDeviceTutorial"],
          min: {
            T1B1: "0",
            T2T1: "0",
            T3T1: "2.8.0"
          }
        },
        {
          methods: ["authenticateDevice"],
          min: {
            T1B1: "0",
            T2T1: "0",
            T3T1: "2.8.0"
          }
        },
        {
          capabilities: ["getFirmwareHash"],
          methods: ["getFirmwareHash"],
          min: { T1B1: "1.11.1", T2T1: "2.5.1" }
        },
        {
          methods: ["solanaGetPublicKey", "solanaGetAddress", "solanaSignTransaction"],
          min: {
            T1B1: "0",
            T2T1: "2.6.4",
            T2B1: "2.6.4"
          }
        },
        {
          capabilities: ["chunkify"],
          min: {
            T1B1: "0",
            T2T1: "2.6.3",
            T2B1: "2.6.3"
          },
          comment: [
            "Since firmware 2.6.3 there is a new protobuf field 'chunkify' in almost all getAddress and signTx methods"
          ]
        },
        {
          methods: ["changeLanguage"],
          min: {
            T1B1: "0",
            T2T1: "2.7.0",
            T2B1: "2.7.0"
          }
        },
        {
          capabilities: ["entropyCheck"],
          min: { T1B1: "1.13.1", T2T1: "2.8.7", T2B1: "2.8.7", T3B1: "2.8.7", T3T1: "2.8.7" }
        },
        {
          capabilities: ["evmApproval"],
          min: { T1B1: "0", T2T1: "2.9.0", T2B1: "2.9.0", T3B1: "2.9.0", T3T1: "2.9.0" },
          comment: ["EVM approval flow for ERC20 tokens, introduced in firmware 2.9.0"]
        },
        {
          capabilities: ["slip24"],
          methods: ["getNonce"],
          min: { T1B1: "0", T2T1: "2.9.1", T2B1: "2.9.1", T3B1: "2.9.1", T3T1: "2.9.1" },
          comment: ["Since firmware 2.9.1 SLIP-24 is supported"]
        },
        {
          methods: ["cardanoSignMessage"],
          min: { T1B1: "0", T2T1: "2.9.1", T2B1: "2.9.1", T3B1: "2.9.1", T3T1: "2.9.1" },
          comment: ["Cardano SignMessage call added in 2.9.1"]
        },
        {
          capabilities: ["evolu"],
          methods: ["evoluGetNode"],
          min: {
            T1B1: "0",
            T2T1: "2.9.2",
            T2B1: "2.9.2",
            T3B1: "2.9.2",
            T3T1: "2.9.2"
          }
        }
      ]
    };
  }
});

// node_modules/@trezor/connect/lib/utils/debug.js
var require_debug2 = __commonJS({
  "node_modules/@trezor/connect/lib/utils/debug.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getLog = exports2.enableLogByPrefix = exports2.enableLog = exports2.setLogWriter = exports2.initLog = void 0;
    var utils_1 = require_lib();
    var green = "#bada55";
    var blue = "#20abd8";
    var orange = "#f4a744";
    var yellow = "#fbd948";
    var colors = {
      "@trezor/connect": `color: ${blue}; background: #000;`,
      "@trezor/connect-web": `color: ${blue}; background: #000;`,
      "@trezor/connect-webextension": `color: ${blue}; background: #000;`,
      IFrame: `color: ${orange}; background: #000;`,
      Core: `color: ${orange}; background: #000;`,
      DeviceList: `color: ${green}; background: #000;`,
      Device: `color: ${green}; background: #000;`,
      DeviceCommands: `color: ${green}; background: #000;`,
      "@trezor/transport": `color: ${green}; background: #000;`,
      InteractionTimeout: `color: ${green}; background: #000;`,
      "@trezor/connect-popup": `color: ${yellow}; background: #000;`
    };
    var logsManager = new utils_1.LogsManager({ colors });
    exports2.initLog = logsManager.initLog.bind(logsManager);
    exports2.setLogWriter = logsManager.setLogWriter.bind(logsManager);
    exports2.enableLog = logsManager.enableLog.bind(logsManager);
    exports2.enableLogByPrefix = logsManager.enableLogByPrefix.bind(logsManager);
    exports2.getLog = logsManager.getLog.bind(logsManager);
  }
});

// node_modules/@trezor/connect/lib/utils/urlUtils.js
var require_urlUtils = __commonJS({
  "node_modules/@trezor/connect/lib/utils/urlUtils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getOnionDomain = exports2.getHost = exports2.getOrigin = void 0;
    var utils_1 = require_lib();
    var getOrigin = (url) => {
      if (typeof url !== "string")
        return "unknown";
      if (url.indexOf("file://") === 0)
        return "file://";
      const [origin] = url.match(/^https?:\/\/[^/]+/) ?? [];
      return origin ?? "unknown";
    };
    exports2.getOrigin = getOrigin;
    var getHost = (url) => {
      if (typeof url !== "string")
        return;
      const [, , uri] = url.match(/^(https?):\/\/([^:/]+)?/i) ?? [];
      if (uri) {
        const parts = uri.split(".");
        if (parts[parts.length - 1] === "localhost")
          return "localhost";
        return parts.length > 2 ? parts.slice(parts.length - 2, parts.length).join(".") : uri;
      }
    };
    exports2.getHost = getHost;
    var getOnionDomain = (url, dict) => {
      if (Array.isArray(url))
        return url.map((u) => (0, utils_1.urlToOnion)(u, dict) ?? u);
      if (typeof url === "string")
        return (0, utils_1.urlToOnion)(url, dict) ?? url;
      return url;
    };
    exports2.getOnionDomain = getOnionDomain;
  }
});

// node_modules/@trezor/connect-web/lib/iframe/inlineStyles.js
var require_inlineStyles = __commonJS({
  "node_modules/@trezor/connect-web/lib/iframe/inlineStyles.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var css = '.trezorconnect-container{position:fixed!important;display:-webkit-box!important;display:-webkit-flex!important;display:-ms-flexbox!important;display:flex!important;-webkit-box-orient:vertical!important;-webkit-box-direction:normal!important;-webkit-flex-direction:column!important;-ms-flex-direction:column!important;flex-direction:column!important;-webkit-box-align:center!important;-webkit-align-items:center!important;-ms-flex-align:center!important;align-items:center!important;z-index:10000!important;width:100%!important;height:100%!important;top:0!important;left:0!important;background:rgba(0,0,0,.35)!important;overflow:auto!important;padding:20px!important;margin:0!important}.trezorconnect-container .trezorconnect-window{position:relative!important;display:block!important;width:370px!important;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif!important;margin:auto!important;border-radius:3px!important;background-color:#fff!important;text-align:center!important;overflow:hidden!important}.trezorconnect-container .trezorconnect-window .trezorconnect-head{text-align:left;padding:12px 24px!important;display:-webkit-box!important;display:-webkit-flex!important;display:-ms-flexbox!important;display:flex!important;-webkit-box-align:center!important;-webkit-align-items:center!important;-ms-flex-align:center!important;align-items:center!important}.trezorconnect-container .trezorconnect-window .trezorconnect-head .trezorconnect-logo{-webkit-box-flex:1;-webkit-flex:1;-ms-flex:1;flex:1}.trezorconnect-container .trezorconnect-window .trezorconnect-head .trezorconnect-close{cursor:pointer!important;height:24px!important}.trezorconnect-container .trezorconnect-window .trezorconnect-head .trezorconnect-close svg{fill:#757575;-webkit-transition:fill .3s ease-in-out!important;transition:fill .3s ease-in-out!important}.trezorconnect-container .trezorconnect-window .trezorconnect-head .trezorconnect-close:hover svg{fill:#494949}.trezorconnect-container .trezorconnect-window .trezorconnect-body{padding:24px 24px 32px!important;background:#FBFBFB!important;border-top:1px solid #EBEBEB}.trezorconnect-container .trezorconnect-window .trezorconnect-body h3{color:#505050!important;font-size:16px!important;font-weight:500!important}.trezorconnect-container .trezorconnect-window .trezorconnect-body p{margin:8px 0 24px!important;font-weight:400!important;color:#A9A9A9!important;font-size:12px!important}.trezorconnect-container .trezorconnect-window .trezorconnect-body button{width:100%!important;padding:12px 24px!important;margin:0!important;border-radius:3px!important;font-size:14px!important;font-weight:300!important;cursor:pointer!important;background:#01B757!important;color:#fff!important;border:0!important;-webkit-transition:background-color .3s ease-in-out!important;transition:background-color .3s ease-in-out!important}.trezorconnect-container .trezorconnect-window .trezorconnect-body button:hover{background-color:#00AB51!important}.trezorconnect-container .trezorconnect-window .trezorconnect-body button:active{background-color:#009546!important}/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImlucHV0IiwiJHN0ZGluIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQWNBLHlCQUNJLFNBQUEsZ0JBQ0EsUUFBQSxzQkFDQSxRQUFBLHVCQUNBLFFBQUEsc0JBRUEsUUFBQSxlQUNBLG1CQUFBLG1CQUNBLHNCQUFBLGlCQUNBLHVCQUFBLGlCQUNBLG1CQUFBLGlCQUNBLGVBQUEsaUJBRUEsa0JBQUEsaUJBQ0Esb0JBQUEsaUJBQ0EsZUFBQSxpQkNmTSxZQUFhLGlCREFyQixRQUFTLGdCQWtCSCxNQUFBLGVBQ0EsT0FBQSxlQUNBLElBQUEsWUFDQSxLQUFBLFlBQ0EsV0FBQSwwQkFDQSxTQUFBLGVBQ0EsUUFBQSxlQUNBLE9BQUEsWUNkUiwrQ0RYRSxTQUFVLG1CQTZCQSxRQUFBLGdCQUNBLE1BQUEsZ0JBQ0EsWUFBQSxjQUFBLG1CQUFBLFdBQUEsT0FBQSxpQkFBQSxNQUFBLHFCQUNBLE9BQUEsZUNmVixjQUFlLGNEakJmLGlCQWlCRSxlQWtCWSxXQUFBLGlCQ2ZkLFNBQVUsaUJEbUJJLG1FQUNBLFdBQUEsS0NoQmQsUUFBUyxLQUFLLGVEeEJkLFFBQVMsc0JBMENTLFFBQUEsdUJBQ0EsUUFBQSxzQkNmbEIsUUFBUyxlRGlCSyxrQkE1QlosaUJBOEJvQixvQkFBQSxpQkNoQmxCLGVBQWdCLGlCRC9CWixZQWlCTixpQkFzQ1EsdUZBQ0EsaUJBQUEsRUNwQlYsYUFBYyxFRHBDVixTQUFVLEVBMkRBLEtBQUEsRUFFQSx3RkNwQmQsT0FBUSxrQkR6Q1IsT0FBUSxlQWlFTSw0RkFDQSxLQUFBLFFBQ0EsbUJBQUEsS0FBQSxJQUFBLHNCQ3BCZCxXQUFZLEtBQUssSUFBSyxzQkR3QlIsa0dBQ0EsS0FBQSxRQUVBLG1FQUNBLFFBQUEsS0FBQSxLQUFBLGVBQ0EsV0FBQSxrQkFDQSxXQUFBLElBQUEsTUFBQSxRQUVBLHNFQUNBLE1BQUEsa0JBQ0EsVUFBQSxlQ3JCZCxZQUFhLGNEd0JLLHFFQ3JCbEIsT0FBUSxJQUFJLEVBQUksZUR3QkYsWUFBQSxjQUNJLE1BQUEsa0JDdEJsQixVQUFXLGVBRWIsMEVBQ0UsTUFBTyxlQUNQLFFBQVMsS0FBSyxlQUNkLE9BQVEsWUFDUixjQUFlLGNBQ2YsVUFBVyxlQUNYLFlBQWEsY0FDYixPQUFRLGtCQUNSLFdBQVksa0JBQ1osTUFBTyxlQUNQLE9BQVEsWUFDUixtQkFBb0IsaUJBQWlCLElBQUssc0JBQzFDLFdBQVksaUJBQWlCLElBQUssc0JBRXBDLGdGQUNFLGlCQUFrQixrQkFFcEIsaUZBQ0UsaUJBQWtCIn0= */';
    exports2.default = css;
  }
});

// node_modules/@trezor/connect-web/lib/iframe/index.js
var require_iframe2 = __commonJS({
  "node_modules/@trezor/connect-web/lib/iframe/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.initIframeLogger = exports2.clearTimeout = exports2.postMessage = exports2.init = exports2.dispose = exports2.error = exports2.timeout = exports2.initPromise = exports2.origin = exports2.instance = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var ERRORS = tslib_1.__importStar(require_errors2());
    var events_1 = require_events2();
    var debug_1 = require_debug2();
    var urlUtils_1 = require_urlUtils();
    var utils_1 = require_lib();
    var inlineStyles_1 = tslib_1.__importDefault(require_inlineStyles());
    exports2.initPromise = (0, utils_1.createDeferred)();
    exports2.timeout = 0;
    var dispose = () => {
      if (exports2.instance && exports2.instance.parentNode) {
        try {
          exports2.instance.parentNode.removeChild(exports2.instance);
        } catch {
        }
      }
      exports2.instance = null;
      exports2.timeout = 0;
    };
    exports2.dispose = dispose;
    var handleIframeBlocked = () => {
      window.clearTimeout(exports2.timeout);
      exports2.error = ERRORS.TypedError("Init_IframeBlocked");
      (0, exports2.dispose)();
      exports2.initPromise.reject(exports2.error);
    };
    var injectStyleSheet = () => {
      if (!exports2.instance) {
        throw ERRORS.TypedError("Init_IframeBlocked");
      }
      const doc = exports2.instance.ownerDocument;
      const head = doc.head || doc.getElementsByTagName("head")[0];
      const style = document.createElement("style");
      style.setAttribute("type", "text/css");
      style.setAttribute("id", "TrezorConnectStylesheet");
      if (style.styleSheet) {
        style.styleSheet.cssText = inlineStyles_1.default;
        head.appendChild(style);
      } else {
        style.appendChild(document.createTextNode(inlineStyles_1.default));
        head.append(style);
      }
    };
    var init = async (settings2) => {
      exports2.initPromise = (0, utils_1.createDeferred)();
      const existedFrame = document.getElementById("trezorconnect");
      if (existedFrame) {
        exports2.instance = existedFrame;
      } else {
        exports2.instance = document.createElement("iframe");
        exports2.instance.frameBorder = "0";
        exports2.instance.width = "0px";
        exports2.instance.height = "0px";
        exports2.instance.style.position = "absolute";
        exports2.instance.style.display = "none";
        exports2.instance.style.border = "0px";
        exports2.instance.style.width = "0px";
        exports2.instance.style.height = "0px";
        exports2.instance.id = "trezorconnect";
      }
      let src;
      if (settings2.env === "web") {
        const manifestString = settings2.manifest ? JSON.stringify(settings2.manifest) : "undefined";
        const manifest = `version=${settings2.version}&manifest=${encodeURIComponent(btoa(JSON.stringify(manifestString)))}`;
        src = `${settings2.iframeSrc}?${manifest}`;
      } else {
        src = settings2.iframeSrc;
      }
      if (!src.startsWith("http://") && !src.startsWith("https://")) {
        return;
      }
      exports2.instance.setAttribute("src", src);
      if (navigator.usb) {
        exports2.instance.setAttribute("allow", "usb");
      }
      exports2.origin = (0, urlUtils_1.getOrigin)(exports2.instance.src);
      exports2.timeout = window.setTimeout(() => {
        exports2.initPromise.reject(ERRORS.TypedError("Init_IframeTimeout"));
      }, 1e4);
      const onLoad = () => {
        if (!exports2.instance) {
          exports2.initPromise.reject(ERRORS.TypedError("Init_IframeBlocked"));
          return;
        }
        try {
          const iframeOrigin = exports2.instance.contentWindow?.location.origin;
          if (!iframeOrigin || iframeOrigin === "null") {
            handleIframeBlocked();
            return;
          }
        } catch {
        }
        let extension;
        if (typeof chrome !== "undefined" && chrome.runtime && typeof chrome.runtime.onConnect !== "undefined") {
          chrome.runtime.onConnect.addListener(() => {
          });
          extension = chrome.runtime.id;
        }
        exports2.instance.contentWindow?.postMessage({
          type: events_1.IFRAME.INIT,
          payload: {
            settings: settings2,
            extension
          }
        }, exports2.origin);
        exports2.instance.onload = null;
      };
      if (exports2.instance.attachEvent) {
        exports2.instance.attachEvent("onload", onLoad);
      } else {
        exports2.instance.onload = onLoad;
      }
      if (document.body) {
        document.body.appendChild(exports2.instance);
        injectStyleSheet();
      }
      try {
        await exports2.initPromise.promise;
      } catch (e) {
        if (exports2.instance) {
          if (exports2.instance.parentNode) {
            exports2.instance.parentNode.removeChild(exports2.instance);
          }
          exports2.instance = null;
        }
        throw e;
      } finally {
        window.clearTimeout(exports2.timeout);
        exports2.timeout = 0;
      }
    };
    exports2.init = init;
    var postMessage = (message) => {
      if (!exports2.instance) {
        throw ERRORS.TypedError("Init_IframeBlocked");
      }
      exports2.instance.contentWindow?.postMessage(message, exports2.origin);
    };
    exports2.postMessage = postMessage;
    var clearTimeout2 = () => {
      window.clearTimeout(exports2.timeout);
    };
    exports2.clearTimeout = clearTimeout2;
    var initIframeLogger = () => {
      const logWriterFactory = () => ({
        add: (message) => {
          (0, exports2.postMessage)({
            type: events_1.IFRAME.LOG,
            payload: message
          });
        }
      });
      (0, debug_1.setLogWriter)(logWriterFactory);
    };
    exports2.initIframeLogger = initIframeLogger;
  }
});

// node_modules/@trezor/connect-web/lib/popup/showPopupRequest.js
var require_showPopupRequest = __commonJS({
  "node_modules/@trezor/connect-web/lib/popup/showPopupRequest.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.showPopupRequest = void 0;
    var LAYER_ID = "TrezorConnectInteractionLayer";
    var HTML = `
    <div class="trezorconnect-container" id="${LAYER_ID}">
        <div class="trezorconnect-window">
            <div class="trezorconnect-head">
                <svg class="trezorconnect-logo" x="0px" y="0px" viewBox="0 0 163.7 41.9" width="78px" height="20px" preserveAspectRatio="xMinYMin meet">
                    <polygon points="101.1,12.8 118.2,12.8 118.2,17.3 108.9,29.9 118.2,29.9 118.2,35.2 101.1,35.2 101.1,30.7 110.4,18.1 101.1,18.1"/>
                    <path d="M158.8,26.9c2.1-0.8,4.3-2.9,4.3-6.6c0-4.5-3.1-7.4-7.7-7.4h-10.5v22.3h5.8v-7.5h2.2l4.1,7.5h6.7L158.8,26.9z M154.7,22.5 h-4V18h4c1.5,0,2.5,0.9,2.5,2.2C157.2,21.6,156.2,22.5,154.7,22.5z"/>
                    <path d="M130.8,12.5c-6.8,0-11.6,4.9-11.6,11.5s4.9,11.5,11.6,11.5s11.7-4.9,11.7-11.5S137.6,12.5,130.8,12.5z M130.8,30.3 c-3.4,0-5.7-2.6-5.7-6.3c0-3.8,2.3-6.3,5.7-6.3c3.4,0,5.8,2.6,5.8,6.3C136.6,27.7,134.2,30.3,130.8,30.3z"/>
                    <polygon points="82.1,12.8 98.3,12.8 98.3,18 87.9,18 87.9,21.3 98,21.3 98,26.4 87.9,26.4 87.9,30 98.3,30 98.3,35.2 82.1,35.2 "/>
                    <path d="M24.6,9.7C24.6,4.4,20,0,14.4,0S4.2,4.4,4.2,9.7v3.1H0v22.3h0l14.4,6.7l14.4-6.7h0V12.9h-4.2V9.7z M9.4,9.7 c0-2.5,2.2-4.5,5-4.5s5,2,5,4.5v3.1H9.4V9.7z M23,31.5l-8.6,4l-8.6-4V18.1H23V31.5z"/>
                    <path d="M79.4,20.3c0-4.5-3.1-7.4-7.7-7.4H61.2v22.3H67v-7.5h2.2l4.1,7.5H80l-4.9-8.3C77.2,26.1,79.4,24,79.4,20.3z M71,22.5h-4V18 h4c1.5,0,2.5,0.9,2.5,2.2C73.5,21.6,72.5,22.5,71,22.5z"/>
                    <polygon points="40.5,12.8 58.6,12.8 58.6,18.1 52.4,18.1 52.4,35.2 46.6,35.2 46.6,18.1 40.5,18.1 "/>
                </svg>
                <div class="trezorconnect-close">
                    <svg x="0px" y="0px" viewBox="24 24 60 60" width="24px" height="24px" preserveAspectRatio="xMinYMin meet">
                        <polygon class="st0" points="40,67.9 42.1,70 55,57.1 67.9,70 70,67.9 57.1,55 70,42.1 67.9,40 55,52.9 42.1,40 40,42.1 52.9,55 "/>
                    </svg>
                </div>
            </div>
            <div class="trezorconnect-body">
                <h3>Popup was blocked</h3>
                <p>Please click to "Continue" to open popup manually</p>
                <button class="trezorconnect-open">Continue</button>
            </div>
        </div>
    </div>
`;
    var showPopupRequest = (open, cancel) => {
      if (document.getElementById(LAYER_ID)) {
        return;
      }
      const div = document.createElement("div");
      div.id = LAYER_ID;
      div.className = "trezorconnect-container";
      div.innerHTML = HTML;
      if (document.body) {
        document.body.appendChild(div);
      }
      const button = div.getElementsByClassName("trezorconnect-open")[0];
      button.onclick = () => {
        open();
        if (document.body) {
          document.body.removeChild(div);
        }
      };
      const close = div.getElementsByClassName("trezorconnect-close")[0];
      close.onclick = () => {
        cancel();
        if (document.body) {
          document.body.removeChild(div);
        }
      };
    };
    exports2.showPopupRequest = showPopupRequest;
  }
});

// node_modules/@trezor/connect-common/lib/storage.js
var require_storage = __commonJS({
  "node_modules/@trezor/connect-common/lib/storage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.storage = void 0;
    var utils_1 = require_lib();
    var storageVersion = 2;
    var storageName = `storage_v${storageVersion}`;
    var getEmptyState = () => ({
      origin: {}
    });
    var memoryStorage = getEmptyState();
    var getPermanentStorage = () => {
      const ls = localStorage.getItem(storageName);
      return ls ? JSON.parse(ls) : getEmptyState();
    };
    var Storage = class extends utils_1.TypedEmitter {
      save(getNewState, temporary = false) {
        if (temporary || !globalThis.window) {
          memoryStorage = getNewState(memoryStorage);
          return;
        }
        try {
          const newState = getNewState(getPermanentStorage());
          localStorage.setItem(storageName, JSON.stringify(newState));
          this.emit("changed", newState);
        } catch {
          console.warn("long term storage not available");
          memoryStorage = getNewState(memoryStorage);
        }
      }
      saveForOrigin(getNewState, origin, temporary = false) {
        this.save((state) => ({
          ...state,
          origin: {
            ...state.origin,
            [origin]: getNewState(state.origin?.[origin] || {})
          }
        }), temporary);
      }
      load(temporary = false) {
        if (temporary || !globalThis?.window?.localStorage) {
          return memoryStorage;
        }
        try {
          return getPermanentStorage();
        } catch {
          console.warn("long term storage not available");
          return memoryStorage;
        }
      }
      loadForOrigin(origin, temporary = false) {
        const state = this.load(temporary);
        return state.origin?.[origin] || {};
      }
    };
    var storage = new Storage();
    exports2.storage = storage;
  }
});

// node_modules/@trezor/connect-common/lib/messageChannel/abstract.js
var require_abstract = __commonJS({
  "node_modules/@trezor/connect-common/lib/messageChannel/abstract.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AbstractMessageChannel = void 0;
    var utils_1 = require_lib();
    var AbstractMessageChannel = class extends utils_1.TypedEmitter {
      messagePromises = {};
      messagesQueue = [];
      messageID = 0;
      isConnected = false;
      handshakeMaxRetries = 5;
      handshakeRetryInterval = 2e3;
      handshakeFinished;
      lazyHandshake;
      legacyMode;
      logger;
      sendFn;
      channel;
      constructor({ sendFn, channel, logger, lazyHandshake = false, legacyMode = false }) {
        super();
        this.channel = channel;
        this.sendFn = sendFn;
        this.lazyHandshake = lazyHandshake;
        this.legacyMode = legacyMode;
        this.logger = logger;
      }
      init() {
        if (!this.handshakeFinished) {
          this.handshakeFinished = (0, utils_1.createDeferred)();
          if (this.legacyMode) {
            setTimeout(() => {
              this.handshakeFinished?.resolve();
            }, 500);
          }
          if (!this.lazyHandshake) {
            this.handshakeWithPeer();
          }
        }
        return this.handshakeFinished.promise;
      }
      handshakeWithPeer() {
        this.logger?.log(this.channel.here, "handshake");
        return (0, utils_1.scheduleAction)(async () => {
          this.postMessage({
            type: "channel-handshake-request",
            data: { success: true, payload: void 0 }
          }, { usePromise: false, useQueue: false });
          await this.handshakeFinished?.promise;
        }, {
          attempts: this.handshakeMaxRetries,
          timeout: this.handshakeRetryInterval
        }).then(() => {
          this.logger?.log(this.channel.here, "handshake confirmed");
          this.messagesQueue.forEach((message) => {
            message.channel = this.channel;
            this.sendFn(message);
          });
          this.messagesQueue = [];
        }).catch(() => {
          this.handshakeFinished?.reject(new Error("handshake failed"));
          this.handshakeFinished = void 0;
        });
      }
      onMessage(_message) {
        let message = _message;
        if (this.legacyMode && message.type === void 0 && "data" in message && typeof message.data === "object" && message.data !== null && "type" in message.data && typeof message.data.type === "string") {
          message = message.data;
        }
        const { channel, id: id2, type, ...data } = message;
        if (!this.legacyMode) {
          if (!channel?.peer || channel.peer !== this.channel.here) {
            return;
          }
          if (!channel?.here || this.channel.peer !== channel.here) {
            return;
          }
        }
        if (type === "channel-handshake-request") {
          this.postMessage({
            type: "channel-handshake-confirm",
            data: { success: true, payload: void 0 }
          }, { usePromise: false, useQueue: false });
          if (this.lazyHandshake) {
            this.handshakeWithPeer();
          }
          return;
        }
        if (type === "channel-handshake-confirm") {
          this.handshakeFinished?.resolve(void 0);
          return;
        }
        if (this.messagePromises[id2]) {
          this.messagePromises[id2].resolve({ id: id2, ...data });
          delete this.messagePromises[id2];
        }
        const messagePromisesLength = Object.keys(this.messagePromises).length;
        if (messagePromisesLength > 5) {
          this.logger?.warn(`too many message promises (${messagePromisesLength}). this feels unexpected!`);
        }
        this.emit("message", message);
      }
      postMessage(message, { usePromise = true, useQueue = true } = {}) {
        message.channel = this.channel;
        if (!usePromise) {
          try {
            this.sendFn(message);
          } catch {
            if (useQueue) {
              this.messagesQueue.push(message);
            }
          }
          return;
        }
        this.messageID++;
        message.id = this.messageID;
        this.messagePromises[message.id] = (0, utils_1.createDeferred)();
        try {
          this.sendFn(message);
        } catch {
          if (useQueue) {
            this.messagesQueue.push(message);
          }
        }
        return this.messagePromises[message.id].promise;
      }
      resolveMessagePromises(resolvePayload) {
        Object.keys(this.messagePromises).forEach((id2) => this.messagePromises[id2].resolve({
          id: id2,
          payload: resolvePayload
        }));
      }
      clear() {
        this.handshakeFinished = void 0;
      }
    };
    exports2.AbstractMessageChannel = AbstractMessageChannel;
  }
});

// node_modules/ua-parser-js/src/main/ua-parser.js
var require_ua_parser = __commonJS({
  "node_modules/ua-parser-js/src/main/ua-parser.js"(exports2, module2) {
    (function(window2, undefined2) {
      "use strict";
      var LIBVERSION = "2.0.7", UA_MAX_LENGTH = 500, USER_AGENT = "user-agent", EMPTY = "", UNKNOWN = "?", TYPEOF = {
        FUNCTION: "function",
        OBJECT: "object",
        STRING: "string",
        UNDEFINED: "undefined"
      }, BROWSER = "browser", CPU = "cpu", DEVICE = "device", ENGINE = "engine", OS = "os", RESULT = "result", NAME = "name", TYPE = "type", VENDOR = "vendor", VERSION = "version", ARCHITECTURE = "architecture", MAJOR = "major", MODEL = "model", CONSOLE = "console", MOBILE = "mobile", TABLET = "tablet", SMARTTV = "smarttv", WEARABLE = "wearable", XR = "xr", EMBEDDED = "embedded", INAPP = "inapp", BRANDS = "brands", FORMFACTORS = "formFactors", FULLVERLIST = "fullVersionList", PLATFORM = "platform", PLATFORMVER = "platformVersion", BITNESS = "bitness", CH = "sec-ch-ua", CH_FULL_VER_LIST = CH + "-full-version-list", CH_ARCH = CH + "-arch", CH_BITNESS = CH + "-" + BITNESS, CH_FORM_FACTORS = CH + "-form-factors", CH_MOBILE = CH + "-" + MOBILE, CH_MODEL = CH + "-" + MODEL, CH_PLATFORM = CH + "-" + PLATFORM, CH_PLATFORM_VER = CH_PLATFORM + "-version", CH_ALL_VALUES = [BRANDS, FULLVERLIST, MOBILE, MODEL, PLATFORM, PLATFORMVER, ARCHITECTURE, FORMFACTORS, BITNESS], AMAZON = "Amazon", APPLE = "Apple", ASUS = "ASUS", BLACKBERRY = "BlackBerry", GOOGLE = "Google", HUAWEI = "Huawei", LENOVO = "Lenovo", HONOR = "Honor", LG = "LG", MICROSOFT = "Microsoft", MOTOROLA = "Motorola", NVIDIA = "Nvidia", ONEPLUS = "OnePlus", OPPO = "OPPO", SAMSUNG = "Samsung", SHARP = "Sharp", SONY = "Sony", XIAOMI = "Xiaomi", ZEBRA = "Zebra", CHROME = "Chrome", CHROMIUM = "Chromium", CHROMECAST = "Chromecast", EDGE = "Edge", FIREFOX = "Firefox", OPERA = "Opera", FACEBOOK = "Facebook", SOGOU = "Sogou", PREFIX_MOBILE = "Mobile ", SUFFIX_BROWSER = " Browser", WINDOWS = "Windows";
      var isWindow = typeof window2 !== TYPEOF.UNDEFINED, NAVIGATOR = isWindow && window2.navigator ? window2.navigator : undefined2, NAVIGATOR_UADATA = NAVIGATOR && NAVIGATOR.userAgentData ? NAVIGATOR.userAgentData : undefined2;
      var extend = function(defaultRgx, extensions) {
        var mergedRgx = {};
        var extraRgx = extensions;
        if (!isExtensions(extensions)) {
          extraRgx = {};
          for (var i in extensions) {
            for (var j in extensions[i]) {
              extraRgx[j] = extensions[i][j].concat(extraRgx[j] ? extraRgx[j] : []);
            }
          }
        }
        for (var k in defaultRgx) {
          mergedRgx[k] = extraRgx[k] && extraRgx[k].length % 2 === 0 ? extraRgx[k].concat(defaultRgx[k]) : defaultRgx[k];
        }
        return mergedRgx;
      }, enumerize = function(arr) {
        var enums = {};
        for (var i = 0; i < arr.length; i++) {
          enums[arr[i].toUpperCase()] = arr[i];
        }
        return enums;
      }, has = function(str1, str2) {
        if (typeof str1 === TYPEOF.OBJECT && str1.length > 0) {
          for (var i in str1) {
            if (lowerize(str2) == lowerize(str1[i])) return true;
          }
          return false;
        }
        return isString(str1) ? lowerize(str2) == lowerize(str1) : false;
      }, isExtensions = function(obj, deep) {
        for (var prop in obj) {
          return /^(browser|cpu|device|engine|os)$/.test(prop) || (deep ? isExtensions(obj[prop]) : false);
        }
      }, isString = function(val) {
        return typeof val === TYPEOF.STRING;
      }, itemListToArray = function(header) {
        if (!header) return undefined2;
        var arr = [];
        var tokens = strip(/\\?\"/g, header).split(",");
        for (var i = 0; i < tokens.length; i++) {
          if (tokens[i].indexOf(";") > -1) {
            var token = trim(tokens[i]).split(";v=");
            arr[i] = { brand: token[0], version: token[1] };
          } else {
            arr[i] = trim(tokens[i]);
          }
        }
        return arr;
      }, lowerize = function(str) {
        return isString(str) ? str.toLowerCase() : str;
      }, majorize = function(version) {
        return isString(version) ? strip(/[^\d\.]/g, version).split(".")[0] : undefined2;
      }, setProps = function(arr) {
        for (var i in arr) {
          if (!arr.hasOwnProperty(i)) continue;
          var propName = arr[i];
          if (typeof propName == TYPEOF.OBJECT && propName.length == 2) {
            this[propName[0]] = propName[1];
          } else {
            this[propName] = undefined2;
          }
        }
        return this;
      }, strip = function(pattern, str) {
        return isString(str) ? str.replace(pattern, EMPTY) : str;
      }, stripQuotes = function(str) {
        return strip(/\\?\"/g, str);
      }, trim = function(str, len) {
        str = strip(/^\s\s*/, String(str));
        return typeof len === TYPEOF.UNDEFINED ? str : str.substring(0, len);
      };
      var rgxMapper = function(ua, arrays) {
        if (!ua || !arrays) return;
        var i = 0, j, k, p, q, matches, match;
        while (i < arrays.length && !matches) {
          var regex = arrays[i], props = arrays[i + 1];
          j = k = 0;
          while (j < regex.length && !matches) {
            if (!regex[j]) {
              break;
            }
            matches = regex[j++].exec(ua);
            if (!!matches) {
              for (p = 0; p < props.length; p++) {
                match = matches[++k];
                q = props[p];
                if (typeof q === TYPEOF.OBJECT && q.length > 0) {
                  if (q.length === 2) {
                    if (typeof q[1] == TYPEOF.FUNCTION) {
                      this[q[0]] = q[1].call(this, match);
                    } else {
                      this[q[0]] = q[1];
                    }
                  } else if (q.length >= 3) {
                    if (typeof q[1] === TYPEOF.FUNCTION && !(q[1].exec && q[1].test)) {
                      if (q.length > 3) {
                        this[q[0]] = match ? q[1].apply(this, q.slice(2)) : undefined2;
                      } else {
                        this[q[0]] = match ? q[1].call(this, match, q[2]) : undefined2;
                      }
                    } else {
                      if (q.length == 3) {
                        this[q[0]] = match ? match.replace(q[1], q[2]) : undefined2;
                      } else if (q.length == 4) {
                        this[q[0]] = match ? q[3].call(this, match.replace(q[1], q[2])) : undefined2;
                      } else if (q.length > 4) {
                        this[q[0]] = match ? q[3].apply(this, [match.replace(q[1], q[2])].concat(q.slice(4))) : undefined2;
                      }
                    }
                  }
                } else {
                  this[q] = match ? match : undefined2;
                }
              }
            }
          }
          i += 2;
        }
      }, strMapper = function(str, map) {
        for (var i in map) {
          if (typeof map[i] === TYPEOF.OBJECT && map[i].length > 0) {
            for (var j = 0; j < map[i].length; j++) {
              if (has(map[i][j], str)) {
                return i === UNKNOWN ? undefined2 : i;
              }
            }
          } else if (has(map[i], str)) {
            return i === UNKNOWN ? undefined2 : i;
          }
        }
        return map.hasOwnProperty("*") ? map["*"] : str;
      };
      var windowsVersionMap = {
        "ME": "4.90",
        "NT 3.51": "3.51",
        "NT 4.0": "4.0",
        "2000": ["5.0", "5.01"],
        "XP": ["5.1", "5.2"],
        "Vista": "6.0",
        "7": "6.1",
        "8": "6.2",
        "8.1": "6.3",
        "10": ["6.4", "10.0"],
        "NT": ""
      }, formFactorsMap = {
        "embedded": "Automotive",
        "mobile": "Mobile",
        "tablet": ["Tablet", "EInk"],
        "smarttv": "TV",
        "wearable": "Watch",
        "xr": ["VR", "XR"],
        "?": ["Desktop", "Unknown"],
        "*": undefined2
      }, browserHintsMap = {
        "Chrome": "Google Chrome",
        "Edge": "Microsoft Edge",
        "Edge WebView2": "Microsoft Edge WebView2",
        "Chrome WebView": "Android WebView",
        "Chrome Headless": "HeadlessChrome",
        "Huawei Browser": "HuaweiBrowser",
        "MIUI Browser": "Miui Browser",
        "Opera Mobi": "OperaMobile",
        "Yandex": "YaBrowser"
      };
      var defaultRegexes = {
        browser: [
          [
            // Most common regardless engine
            /\b(?:crmo|crios)\/([\w\.]+)/i
            // Chrome for Android/iOS
          ],
          [VERSION, [NAME, PREFIX_MOBILE + "Chrome"]],
          [
            /webview.+edge\/([\w\.]+)/i
            // Microsoft Edge
          ],
          [VERSION, [NAME, EDGE + " WebView"]],
          [
            /edg(?:e|ios|a)?\/([\w\.]+)/i
          ],
          [VERSION, [NAME, "Edge"]],
          [
            // Presto based
            /(opera mini)\/([-\w\.]+)/i,
            // Opera Mini
            /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i,
            // Opera Mobi/Tablet
            /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i
            // Opera
          ],
          [NAME, VERSION],
          [
            /opios[\/ ]+([\w\.]+)/i
            // Opera mini on iphone >= 8.0
          ],
          [VERSION, [NAME, OPERA + " Mini"]],
          [
            /\bop(?:rg)?x\/([\w\.]+)/i
            // Opera GX
          ],
          [VERSION, [NAME, OPERA + " GX"]],
          [
            /\bopr\/([\w\.]+)/i
            // Opera Webkit
          ],
          [VERSION, [NAME, OPERA]],
          [
            // Mixed
            /\bb[ai]*d(?:uhd|[ub]*[aekoprswx]{5,6})[\/ ]?([\w\.]+)/i
            // Baidu
          ],
          [VERSION, [NAME, "Baidu"]],
          [
            /\b(?:mxbrowser|mxios|myie2)\/?([-\w\.]*)\b/i
            // Maxthon
          ],
          [VERSION, [NAME, "Maxthon"]],
          [
            /(kindle)\/([\w\.]+)/i,
            // Kindle
            /(lunascape|maxthon|netfront|jasmine|blazer|sleipnir)[\/ ]?([\w\.]*)/i,
            // Lunascape/Maxthon/Netfront/Jasmine/Blazer/Sleipnir
            // Trident based
            /(avant|iemobile|slim(?:browser|boat|jet))[\/ ]?([\d\.]*)/i,
            // Avant/IEMobile/SlimBrowser/SlimBoat/Slimjet
            /(?:ms|\()(ie) ([\w\.]+)/i,
            // Internet Explorer
            // Blink/Webkit/KHTML based                                         // Flock/RockMelt/Midori/Epiphany/Silk/Skyfire/Bolt/Iron/Iridium/PhantomJS/Bowser/QupZilla/Falkon/LG Browser/Otter/qutebrowser/Dooble/Palemoon
            /(atlas|flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|duckduckgo|klar|helio|(?=comodo_)?dragon|otter|dooble|(?:lg |qute)browser|palemoon)\/([-\w\.]+)/i,
            // Atlas/Rekonq/Puffin/Brave/Whale/QQBrowserLite/QQ//Vivaldi/DuckDuckGo/Klar/Helio/Dragon
            /(heytap|ovi|115|surf|qwant)browser\/([\d\.]+)/i,
            // HeyTap/Ovi/115/Surf
            /(qwant)(?:ios|mobile)\/([\d\.]+)/i,
            // Qwant
            /(ecosia|weibo)(?:__| \w+@)([\d\.]+)/i
            // Ecosia/Weibo
          ],
          [NAME, VERSION],
          [
            /quark(?:pc)?\/([-\w\.]+)/i
            // Quark
          ],
          [VERSION, [NAME, "Quark"]],
          [
            /\bddg\/([\w\.]+)/i
            // DuckDuckGo
          ],
          [VERSION, [NAME, "DuckDuckGo"]],
          [
            /(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i
            // UCBrowser
          ],
          [VERSION, [NAME, "UCBrowser"]],
          [
            /microm.+\bqbcore\/([\w\.]+)/i,
            // WeChat Desktop for Windows Built-in Browser
            /\bqbcore\/([\w\.]+).+microm/i,
            /micromessenger\/([\w\.]+)/i
            // WeChat
          ],
          [VERSION, [NAME, "WeChat"]],
          [
            /konqueror\/([\w\.]+)/i
            // Konqueror
          ],
          [VERSION, [NAME, "Konqueror"]],
          [
            /trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i
            // IE11
          ],
          [VERSION, [NAME, "IE"]],
          [
            /ya(?:search)?browser\/([\w\.]+)/i
            // Yandex
          ],
          [VERSION, [NAME, "Yandex"]],
          [
            /slbrowser\/([\w\.]+)/i
            // Smart Lenovo Browser
          ],
          [VERSION, [NAME, "Smart " + LENOVO + SUFFIX_BROWSER]],
          [
            /(avast|avg)\/([\w\.]+)/i
            // Avast/AVG Secure Browser
          ],
          [[NAME, /(.+)/, "$1 Secure" + SUFFIX_BROWSER], VERSION],
          [
            /\bfocus\/([\w\.]+)/i
            // Firefox Focus
          ],
          [VERSION, [NAME, FIREFOX + " Focus"]],
          [
            /\bopt\/([\w\.]+)/i
            // Opera Touch
          ],
          [VERSION, [NAME, OPERA + " Touch"]],
          [
            /coc_coc\w+\/([\w\.]+)/i
            // Coc Coc Browser
          ],
          [VERSION, [NAME, "Coc Coc"]],
          [
            /dolfin\/([\w\.]+)/i
            // Dolphin
          ],
          [VERSION, [NAME, "Dolphin"]],
          [
            /coast\/([\w\.]+)/i
            // Opera Coast
          ],
          [VERSION, [NAME, OPERA + " Coast"]],
          [
            /miuibrowser\/([\w\.]+)/i
            // MIUI Browser
          ],
          [VERSION, [NAME, "MIUI" + SUFFIX_BROWSER]],
          [
            /fxios\/([\w\.-]+)/i
            // Firefox for iOS
          ],
          [VERSION, [NAME, PREFIX_MOBILE + FIREFOX]],
          [
            /\bqihoobrowser\/?([\w\.]*)/i
            // 360
          ],
          [VERSION, [NAME, "360"]],
          [
            /\b(qq)\/([\w\.]+)/i
            // QQ
          ],
          [[NAME, /(.+)/, "$1Browser"], VERSION],
          [
            /(oculus|sailfish|huawei|vivo|pico)browser\/([\w\.]+)/i
          ],
          [[NAME, /(.+)/, "$1" + SUFFIX_BROWSER], VERSION],
          [
            // Oculus/Sailfish/HuaweiBrowser/VivoBrowser/PicoBrowser
            /samsungbrowser\/([\w\.]+)/i
            // Samsung Internet
          ],
          [VERSION, [NAME, SAMSUNG + " Internet"]],
          [
            /metasr[\/ ]?([\d\.]+)/i
            // Sogou Explorer
          ],
          [VERSION, [NAME, SOGOU + " Explorer"]],
          [
            /(sogou)mo\w+\/([\d\.]+)/i
            // Sogou Mobile
          ],
          [[NAME, SOGOU + " Mobile"], VERSION],
          [
            /(electron)\/([\w\.]+) safari/i,
            // Electron-based App
            /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i,
            // Tesla
            /m?(qqbrowser|2345(?=browser|chrome|explorer))\w*[\/ ]?v?([\w\.]+)/i
            // QQ/2345
          ],
          [NAME, VERSION],
          [
            /(lbbrowser|rekonq|steam(?= (clie|tenf|gameo)))/i
            // LieBao Browser/Rekonq/Steam
          ],
          [NAME],
          [
            /ome\/([\w\.]+) \w* ?(iron) saf/i,
            // Iron
            /ome\/([\w\.]+).+qihu (360)[es]e/i
            // 360
          ],
          [VERSION, NAME],
          [
            // WebView
            /((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i
            // Facebook App for iOS & Android
          ],
          [[NAME, FACEBOOK], VERSION, [TYPE, INAPP]],
          [
            /(kakao(?:talk|story))[\/ ]([\w\.]+)/i,
            // Kakao App
            /(naver)\(.*?(\d+\.[\w\.]+).*\)/i,
            // Naver InApp
            /(daum)apps[\/ ]([\w\.]+)/i,
            // Daum App
            /safari (line)\/([\w\.]+)/i,
            // Line App for iOS
            /\b(line)\/([\w\.]+)\/iab/i,
            // Line App for Android
            /(alipay)client\/([\w\.]+)/i,
            // Alipay
            /(twitter)(?:and| f.+e\/([\w\.]+))/i,
            // Twitter
            /(bing)(?:web|sapphire)\/([\w\.]+)/i,
            // Bing
            /(instagram|snapchat|klarna)[\/ ]([-\w\.]+)/i
            // Instagram/Snapchat/Klarna
          ],
          [NAME, VERSION, [TYPE, INAPP]],
          [
            /\bgsa\/([\w\.]+) .*safari\//i
            // Google Search Appliance on iOS
          ],
          [VERSION, [NAME, "GSA"], [TYPE, INAPP]],
          [
            /musical_ly(?:.+app_?version\/|_)([\w\.]+)/i
            // TikTok
          ],
          [VERSION, [NAME, "TikTok"], [TYPE, INAPP]],
          [
            /\[(linkedin)app\]/i
            // LinkedIn App for iOS & Android
          ],
          [NAME, [TYPE, INAPP]],
          [
            /(zalo(?:app)?)[\/\sa-z]*([\w\.-]+)/i
            // Zalo 
          ],
          [[NAME, /(.+)/, "Zalo"], VERSION, [TYPE, INAPP]],
          [
            /(chromium)[\/ ]([-\w\.]+)/i
            // Chromium
          ],
          [NAME, VERSION],
          [
            /headlesschrome(?:\/([\w\.]+)| )/i
            // Chrome Headless
          ],
          [VERSION, [NAME, CHROME + " Headless"]],
          [
            /wv\).+chrome\/([\w\.]+).+edgw\//i
            // Edge WebView2
          ],
          [VERSION, [NAME, EDGE + " WebView2"]],
          [
            / wv\).+(chrome)\/([\w\.]+)/i
            // Chrome WebView
          ],
          [[NAME, CHROME + " WebView"], VERSION],
          [
            /droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i
            // Android Browser
          ],
          [VERSION, [NAME, "Android" + SUFFIX_BROWSER]],
          [
            /chrome\/([\w\.]+) mobile/i
            // Chrome Mobile
          ],
          [VERSION, [NAME, PREFIX_MOBILE + "Chrome"]],
          [
            /(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i
            // Chrome/OmniWeb/Arora/Tizen/Nokia
          ],
          [NAME, VERSION],
          [
            /version\/([\w\.\,]+) .*mobile(?:\/\w+ | ?)safari/i
            // Safari Mobile
          ],
          [VERSION, [NAME, PREFIX_MOBILE + "Safari"]],
          [
            /iphone .*mobile(?:\/\w+ | ?)safari/i
          ],
          [[NAME, PREFIX_MOBILE + "Safari"]],
          [
            /version\/([\w\.\,]+) .*(safari)/i
            // Safari
          ],
          [VERSION, NAME],
          [
            /webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i
            // Safari < 3.0
          ],
          [NAME, [VERSION, "1"]],
          [
            /(webkit|khtml)\/([\w\.]+)/i
          ],
          [NAME, VERSION],
          [
            // Gecko based
            /(?:mobile|tablet);.*(firefox)\/([\w\.-]+)/i
            // Firefox Mobile
          ],
          [[NAME, PREFIX_MOBILE + FIREFOX], VERSION],
          [
            /(navigator|netscape\d?)\/([-\w\.]+)/i
            // Netscape
          ],
          [[NAME, "Netscape"], VERSION],
          [
            /(wolvic|librewolf)\/([\w\.]+)/i
            // Wolvic/LibreWolf
          ],
          [NAME, VERSION],
          [
            /mobile vr; rv:([\w\.]+)\).+firefox/i
            // Firefox Reality
          ],
          [VERSION, [NAME, FIREFOX + " Reality"]],
          [
            /ekiohf.+(flow)\/([\w\.]+)/i,
            // Flow
            /(swiftfox)/i,
            // Swiftfox
            /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror)[\/ ]?([\w\.\+]+)/i,
            // IceDragon/Iceweasel/Camino/Chimera/Fennec/Maemo/Minimo/Conkeror
            /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|basilisk|waterfox)\/([-\w\.]+)$/i,
            // Firefox/SeaMonkey/K-Meleon/IceCat/IceApe/Firebird/Phoenix
            /(firefox)\/([\w\.]+)/i,
            // Other Firefox-based
            /(mozilla)\/([\w\.]+(?= .+rv\:.+gecko\/\d+)|[0-4][\w\.]+(?!.+compatible))/i,
            // Mozilla
            // Other
            /(amaya|dillo|doris|icab|ladybird|lynx|mosaic|netsurf|obigo|polaris|w3m|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i,
            // Polaris/Lynx/Dillo/iCab/Doris/Amaya/w3m/NetSurf/Obigo/Mosaic/Go/ICE/UP.Browser/Ladybird
            /\b(links) \(([\w\.]+)/i
            // Links
          ],
          [NAME, [VERSION, /_/g, "."]],
          [
            /(cobalt)\/([\w\.]+)/i
            // Cobalt
          ],
          [NAME, [VERSION, /[^\d\.]+./, EMPTY]]
        ],
        cpu: [
          [
            /\b((amd|x|x86[-_]?|wow|win)64)\b/i
            // AMD64 (x64)
          ],
          [[ARCHITECTURE, "amd64"]],
          [
            /(ia32(?=;))/i,
            // IA32 (quicktime)
            /\b((i[346]|x)86)(pc)?\b/i
            // IA32 (x86)
          ],
          [[ARCHITECTURE, "ia32"]],
          [
            /\b(aarch64|arm(v?[89]e?l?|_?64))\b/i
            // ARM64
          ],
          [[ARCHITECTURE, "arm64"]],
          [
            /\b(arm(v[67])?ht?n?[fl]p?)\b/i
            // ARMHF
          ],
          [[ARCHITECTURE, "armhf"]],
          [
            // PocketPC mistakenly identified as PowerPC
            /( (ce|mobile); ppc;|\/[\w\.]+arm\b)/i
          ],
          [[ARCHITECTURE, "arm"]],
          [
            / sun4\w[;\)]/i
            // SPARC
          ],
          [[ARCHITECTURE, "sparc"]],
          [
            // IA64, 68K, ARM/64, AVR/32, IRIX/64, MIPS/64, SPARC/64, PA-RISC
            /\b(avr32|ia64(?=;)|68k(?=\))|\barm(?=v([1-7]|[5-7]1)l?|;|eabi)|(irix|mips|sparc)(64)?\b|pa-risc)/i,
            /((ppc|powerpc)(64)?)( mac|;|\))/i,
            // PowerPC
            /(?:osf1|[freopnt]{3,4}bsd) (alpha)/i
            // Alpha
          ],
          [[ARCHITECTURE, /ower/, EMPTY, lowerize]],
          [
            /mc680.0/i
          ],
          [[ARCHITECTURE, "68k"]],
          [
            /winnt.+\[axp/i
          ],
          [[ARCHITECTURE, "alpha"]]
        ],
        device: [
          [
            //////////////////////////
            // MOBILES & TABLETS
            /////////////////////////
            // Samsung
            /\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i
          ],
          [MODEL, [VENDOR, SAMSUNG], [TYPE, TABLET]],
          [
            /\b((?:s[cgp]h|gt|sm)-(?![lr])\w+|sc[g-]?[\d]+a?|galaxy nexus)/i,
            /samsung[- ]((?!sm-[lr]|browser)[-\w]+)/i,
            /sec-(sgh\w+)/i
          ],
          [MODEL, [VENDOR, SAMSUNG], [TYPE, MOBILE]],
          [
            // Apple
            /(?:\/|\()(ip(?:hone|od)[\w, ]*)[\/\);]/i
            // iPod/iPhone
          ],
          [MODEL, [VENDOR, APPLE], [TYPE, MOBILE]],
          [
            /\b(?:ios|apple\w+)\/.+[\(\/](ipad)/i,
            // iPad
            /\b(ipad)[\d,]*[;\] ].+(mac |i(pad)?)os/i
          ],
          [MODEL, [VENDOR, APPLE], [TYPE, TABLET]],
          [
            /(macintosh);/i
          ],
          [MODEL, [VENDOR, APPLE]],
          [
            // Sharp
            /\b(sh-?[altvz]?\d\d[a-ekm]?)/i
          ],
          [MODEL, [VENDOR, SHARP], [TYPE, MOBILE]],
          [
            // Honor
            /\b((?:brt|eln|hey2?|gdi|jdn)-a?[lnw]09|(?:ag[rm]3?|jdn2|kob2)-a?[lw]0[09]hn)(?: bui|\)|;)/i
          ],
          [MODEL, [VENDOR, HONOR], [TYPE, TABLET]],
          [
            /honor([-\w ]+)[;\)]/i
          ],
          [MODEL, [VENDOR, HONOR], [TYPE, MOBILE]],
          [
            // Huawei
            /\b((?:ag[rs][2356]?k?|bah[234]?|bg[2o]|bt[kv]|cmr|cpn|db[ry]2?|jdn2|got|kob2?k?|mon|pce|scm|sht?|[tw]gr|vrd)-[ad]?[lw][0125][09]b?|605hw|bg2-u03|(?:gem|fdr|m2|ple|t1)-[7a]0[1-4][lu]|t1-a2[13][lw]|mediapad[\w\. ]*(?= bui|\)))\b(?!.+d\/s)/i
          ],
          [MODEL, [VENDOR, HUAWEI], [TYPE, TABLET]],
          [
            /(?:huawei) ?([-\w ]+)[;\)]/i,
            /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][\dc][adnt]?)\b(?!.+d\/s)/i
          ],
          [MODEL, [VENDOR, HUAWEI], [TYPE, MOBILE]],
          [
            // Xiaomi
            /oid[^\)]+; (2[\dbc]{4}(182|283|rp\w{2})[cgl]|m2105k81a?c)(?: bui|\))/i,
            /\b(?:xiao)?((?:red)?mi[-_ ]?pad[\w- ]*)(?: bui|\))/i
            // Mi Pad tablets
          ],
          [[MODEL, /_/g, " "], [VENDOR, XIAOMI], [TYPE, TABLET]],
          [
            /\b; (\w+) build\/hm\1/i,
            // Xiaomi Hongmi 'numeric' models
            /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i,
            // Xiaomi Hongmi
            // Xiaomi Redmi / POCO / Black Shark / Qin
            /oid[^\)]+; (redmi[\-_ ]?(?:note|k)?[\w_ ]+|m?[12]\d[01]\d\w{3,6}|poco[\w ]+|(shark )?\w{3}-[ah]0|qin ?[1-3](s\+|ultra| pro)?)( bui|; wv|\))/i,
            // Xiaomi Mi
            /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note|max|cc)?[_ ]?(?:\d{0,2}\w?)[_ ]?(?:plus|se|lite|pro)?( 5g|lte)?)(?: bui|\))/i,
            / ([\w ]+) miui\/v?\d/i
          ],
          [[MODEL, /_/g, " "], [VENDOR, XIAOMI], [TYPE, MOBILE]],
          [
            // OnePlus
            /droid.+; (cph2[3-6]\d[13579]|((gm|hd)19|(ac|be|in|kb)20|(d[en]|eb|le|mt)21|ne22)[0-2]\d|p[g-k]\w[1m]10)\b/i,
            /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i
          ],
          [MODEL, [VENDOR, ONEPLUS], [TYPE, MOBILE]],
          [
            // OPPO
            /; (\w+) bui.+ oppo/i,
            /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i
          ],
          [MODEL, [VENDOR, OPPO], [TYPE, MOBILE]],
          [
            /\b(opd2(\d{3}a?))(?: bui|\))/i
          ],
          [MODEL, [VENDOR, strMapper, { "OnePlus": ["203", "304", "403", "404", "413", "415"], "*": OPPO }], [TYPE, TABLET]],
          [
            // BLU
            /(vivo (5r?|6|8l?|go|one|s|x[il]?[2-4]?)[\w\+ ]*)(?: bui|\))/i
            // Vivo series
          ],
          [MODEL, [VENDOR, "BLU"], [TYPE, MOBILE]],
          [
            // Vivo
            /; vivo (\w+)(?: bui|\))/i,
            /\b(v[12]\d{3}\w?[at])(?: bui|;)/i
          ],
          [MODEL, [VENDOR, "Vivo"], [TYPE, MOBILE]],
          [
            // Realme
            /\b(rmx[1-3]\d{3})(?: bui|;|\))/i
          ],
          [MODEL, [VENDOR, "Realme"], [TYPE, MOBILE]],
          [
            // Lenovo
            /(ideatab[-\w ]+|602lv|d-42a|a101lv|a2109a|a3500-hv|s[56]000|pb-6505[my]|tb-?x?\d{3,4}(?:f[cu]|xu|[av])|yt\d?-[jx]?\d+[lfmx])( bui|;|\)|\/)/i,
            /lenovo ?(b[68]0[08]0-?[hf]?|tab(?:[\w- ]+?)|tb[\w-]{6,7})( bui|;|\)|\/)/i
          ],
          [MODEL, [VENDOR, LENOVO], [TYPE, TABLET]],
          [
            /lenovo[-_ ]?([-\w ]+?)(?: bui|\)|\/)/i
          ],
          [MODEL, [VENDOR, LENOVO], [TYPE, MOBILE]],
          [
            // Motorola
            /\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i,
            /\bmot(?:orola)?[- ]([\w\s]+)(\)| bui)/i,
            /((?:moto(?! 360)[-\w\(\) ]+|xt\d{3,4}[cgkosw\+]?[-\d]*|nexus 6)(?= bui|\)))/i
          ],
          [MODEL, [VENDOR, MOTOROLA], [TYPE, MOBILE]],
          [
            /\b(mz60\d|xoom[2 ]{0,2}) build\//i
          ],
          [MODEL, [VENDOR, MOTOROLA], [TYPE, TABLET]],
          [
            // LG
            /((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i
          ],
          [MODEL, [VENDOR, LG], [TYPE, TABLET]],
          [
            /(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i,
            /\blg[-e;\/ ]+(?!.*(?:browser|netcast|android tv|watch|webos))(\w+)/i,
            /\blg-?([\d\w]+) bui/i
          ],
          [MODEL, [VENDOR, LG], [TYPE, MOBILE]],
          [
            // Nokia
            /(nokia) (t[12][01])/i
          ],
          [VENDOR, MODEL, [TYPE, TABLET]],
          [
            /(?:maemo|nokia).*(n900|lumia \d+|rm-\d+)/i,
            /nokia[-_ ]?(([-\w\. ]*?))( bui|\)|;|\/)/i
          ],
          [[MODEL, /_/g, " "], [TYPE, MOBILE], [VENDOR, "Nokia"]],
          [
            // Google
            /(pixel (c|tablet))\b/i
            // Google Pixel C/Tablet
          ],
          [MODEL, [VENDOR, GOOGLE], [TYPE, TABLET]],
          [
            // Google Pixel
            /droid.+;(?: google)? (g(01[13]a|020[aem]|025[jn]|1b60|1f8f|2ybb|4s1m|576d|5nz6|8hhn|8vou|a02099|c15s|d1yq|e2ae|ec77|gh2x|kv4x|p4bc|pj41|r83y|tt9q|ur25|wvk6)|pixel[\d ]*a?( pro)?( xl)?( fold)?( \(5g\))?)( bui|\))/i
          ],
          [MODEL, [VENDOR, GOOGLE], [TYPE, MOBILE]],
          [
            /(google) (pixelbook( go)?)/i
          ],
          [VENDOR, MODEL],
          [
            // Sony
            /droid.+; (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-\w\w\d\d)(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i
          ],
          [MODEL, [VENDOR, SONY], [TYPE, MOBILE]],
          [
            /sony tablet [ps]/i,
            /\b(?:sony)?sgp\w+(?: bui|\))/i
          ],
          [[MODEL, "Xperia Tablet"], [VENDOR, SONY], [TYPE, TABLET]],
          [
            // Amazon
            /(alexa)webm/i,
            /(kf[a-z]{2}wi|aeo(?!bc)\w\w)( bui|\))/i,
            // Kindle Fire without Silk / Echo Show
            /(kf[a-z]+)( bui|\)).+silk\//i
            // Kindle Fire HD
          ],
          [MODEL, [VENDOR, AMAZON], [TYPE, TABLET]],
          [
            /((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i
            // Fire Phone
          ],
          [[MODEL, /(.+)/g, "Fire Phone $1"], [VENDOR, AMAZON], [TYPE, MOBILE]],
          [
            // BlackBerry
            /(playbook);[-\w\),; ]+(rim)/i
            // BlackBerry PlayBook
          ],
          [MODEL, VENDOR, [TYPE, TABLET]],
          [
            /\b((?:bb[a-f]|st[hv])100-\d)/i,
            /(?:blackberry|\(bb10;) (\w+)/i
          ],
          [MODEL, [VENDOR, BLACKBERRY], [TYPE, MOBILE]],
          [
            // Asus
            /(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i
          ],
          [MODEL, [VENDOR, ASUS], [TYPE, TABLET]],
          [
            / (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i
          ],
          [MODEL, [VENDOR, ASUS], [TYPE, MOBILE]],
          [
            // HTC
            /(nexus 9)/i
            // HTC Nexus 9
          ],
          [MODEL, [VENDOR, "HTC"], [TYPE, TABLET]],
          [
            /(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i,
            // HTC
            // ZTE
            /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i,
            /(alcatel|geeksphone|nexian|panasonic(?!(?:;|\.))|sony(?!-bra))[-_ ]?([-\w]*)/i
            // Alcatel/GeeksPhone/Nexian/Panasonic/Sony
          ],
          [VENDOR, [MODEL, /_/g, " "], [TYPE, MOBILE]],
          [
            // TCL
            /tcl (xess p17aa)/i,
            /droid [\w\.]+; ((?:8[14]9[16]|9(?:0(?:48|60|8[01])|1(?:3[27]|66)|2(?:6[69]|9[56])|466))[gqswx])(_\w(\w|\w\w))?(\)| bui)/i
          ],
          [MODEL, [VENDOR, "TCL"], [TYPE, TABLET]],
          [
            /droid [\w\.]+; (418(?:7d|8v)|5087z|5102l|61(?:02[dh]|25[adfh]|27[ai]|56[dh]|59k|65[ah])|a509dl|t(?:43(?:0w|1[adepqu])|50(?:6d|7[adju])|6(?:09dl|10k|12b|71[efho]|76[hjk])|7(?:66[ahju]|67[hw]|7[045][bh]|71[hk]|73o|76[ho]|79w|81[hks]?|82h|90[bhsy]|99b)|810[hs]))(_\w(\w|\w\w))?(\)| bui)/i
          ],
          [MODEL, [VENDOR, "TCL"], [TYPE, MOBILE]],
          [
            // itel
            /(itel) ((\w+))/i
          ],
          [[VENDOR, lowerize], MODEL, [TYPE, strMapper, { "tablet": ["p10001l", "w7001"], "*": "mobile" }]],
          [
            // Acer
            /droid.+; ([ab][1-7]-?[0178a]\d\d?)/i
          ],
          [MODEL, [VENDOR, "Acer"], [TYPE, TABLET]],
          [
            // Meizu
            /droid.+; (m[1-5] note) bui/i,
            /\bmz-([-\w]{2,})/i
          ],
          [MODEL, [VENDOR, "Meizu"], [TYPE, MOBILE]],
          [
            // Ulefone
            /; ((?:power )?armor(?:[\w ]{0,8}))(?: bui|\))/i
          ],
          [MODEL, [VENDOR, "Ulefone"], [TYPE, MOBILE]],
          [
            // Energizer
            /; (energy ?\w+)(?: bui|\))/i,
            /; energizer ([\w ]+)(?: bui|\))/i
          ],
          [MODEL, [VENDOR, "Energizer"], [TYPE, MOBILE]],
          [
            // Cat
            /; cat (b35);/i,
            /; (b15q?|s22 flip|s48c|s62 pro)(?: bui|\))/i
          ],
          [MODEL, [VENDOR, "Cat"], [TYPE, MOBILE]],
          [
            // Smartfren
            /((?:new )?andromax[\w- ]+)(?: bui|\))/i
          ],
          [MODEL, [VENDOR, "Smartfren"], [TYPE, MOBILE]],
          [
            // Nothing
            /droid.+; (a(in)?(0(15|59|6[35])|142)p?)/i
          ],
          [MODEL, [VENDOR, "Nothing"], [TYPE, MOBILE]],
          [
            // Archos
            /; (x67 5g|tikeasy \w+|ac[1789]\d\w+)( b|\))/i,
            /archos ?(5|gamepad2?|([\w ]*[t1789]|hello) ?\d+[\w ]*)( b|\))/i
          ],
          [MODEL, [VENDOR, "Archos"], [TYPE, TABLET]],
          [
            /archos ([\w ]+)( b|\))/i,
            /; (ac[3-6]\d\w{2,8})( b|\))/i
          ],
          [MODEL, [VENDOR, "Archos"], [TYPE, MOBILE]],
          [
            // HMD
            /; (n159v)/i
          ],
          [MODEL, [VENDOR, "HMD"], [TYPE, MOBILE]],
          [
            // MIXED
            /(imo) (tab \w+)/i,
            // IMO
            /(infinix|tecno) (x1101b?|p904|dp(7c|8d|10a)( pro)?|p70[1-3]a?|p904|t1101)/i
            // Infinix XPad / Tecno
          ],
          [VENDOR, MODEL, [TYPE, TABLET]],
          [
            /(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus(?! zenw)|dell|jolla|meizu|motorola|polytron|tecno|micromax|advan)[-_ ]?([-\w]*)/i,
            // BlackBerry/BenQ/Palm/Sony-Ericsson/Acer/Asus/Dell/Meizu/Motorola/Polytron/Tecno/Micromax/Advan
            // BLU/HMD/IMO/Infinix/Lava/OnePlus/TCL/Wiko
            /; (blu|hmd|imo|infinix|lava|oneplus|tcl|wiko)[_ ]([\w\+ ]+?)(?: bui|\)|; r)/i,
            /(hp) ([\w ]+\w)/i,
            // HP iPAQ
            /(microsoft); (lumia[\w ]+)/i,
            // Microsoft Lumia
            /(oppo) ?([\w ]+) bui/i,
            // OPPO
            /(hisense) ([ehv][\w ]+)\)/i,
            // Hisense
            /droid[^;]+; (philips)[_ ]([sv-x][\d]{3,4}[xz]?)/i
            // Philips
          ],
          [VENDOR, MODEL, [TYPE, MOBILE]],
          [
            /(kobo)\s(ereader|touch)/i,
            // Kobo
            /(hp).+(touchpad(?!.+tablet)|tablet)/i,
            // HP TouchPad
            /(kindle)\/([\w\.]+)/i
            // Kindle
          ],
          [VENDOR, MODEL, [TYPE, TABLET]],
          [
            /(surface duo)/i
            // Surface Duo
          ],
          [MODEL, [VENDOR, MICROSOFT], [TYPE, TABLET]],
          [
            /droid [\d\.]+; (fp\du?)(?: b|\))/i
            // Fairphone
          ],
          [MODEL, [VENDOR, "Fairphone"], [TYPE, MOBILE]],
          [
            /((?:tegranote|shield t(?!.+d tv))[\w- ]*?)(?: b|\))/i
            // Nvidia Tablets
          ],
          [MODEL, [VENDOR, NVIDIA], [TYPE, TABLET]],
          [
            /(sprint) (\w+)/i
            // Sprint Phones
          ],
          [VENDOR, MODEL, [TYPE, MOBILE]],
          [
            /(kin\.[onetw]{3})/i
            // Microsoft Kin
          ],
          [[MODEL, /\./g, " "], [VENDOR, MICROSOFT], [TYPE, MOBILE]],
          [
            /droid.+; ([c6]+|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i
            // Zebra
          ],
          [MODEL, [VENDOR, ZEBRA], [TYPE, TABLET]],
          [
            /droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i
          ],
          [MODEL, [VENDOR, ZEBRA], [TYPE, MOBILE]],
          [
            ///////////////////
            // SMARTTVS
            ///////////////////
            /(philips)[\w ]+tv/i,
            // Philips
            /smart-tv.+(samsung)/i
            // Samsung
          ],
          [VENDOR, [TYPE, SMARTTV]],
          [
            /hbbtv.+maple;(\d+)/i
          ],
          [[MODEL, /^/, "SmartTV"], [VENDOR, SAMSUNG], [TYPE, SMARTTV]],
          [
            /(vizio)(?: |.+model\/)(\w+-\w+)/i,
            // Vizio
            /tcast.+(lg)e?. ([-\w]+)/i
            // LG SmartTV
          ],
          [VENDOR, MODEL, [TYPE, SMARTTV]],
          [
            /(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i
          ],
          [[VENDOR, LG], [TYPE, SMARTTV]],
          [
            /(apple) ?tv/i
            // Apple TV
          ],
          [VENDOR, [MODEL, APPLE + " TV"], [TYPE, SMARTTV]],
          [
            /crkey.*devicetype\/chromecast/i
            // Google Chromecast Third Generation
          ],
          [[MODEL, CHROMECAST + " Third Generation"], [VENDOR, GOOGLE], [TYPE, SMARTTV]],
          [
            /crkey.*devicetype\/([^/]*)/i
            // Google Chromecast with specific device type
          ],
          [[MODEL, /^/, "Chromecast "], [VENDOR, GOOGLE], [TYPE, SMARTTV]],
          [
            /fuchsia.*crkey/i
            // Google Chromecast Nest Hub
          ],
          [[MODEL, CHROMECAST + " Nest Hub"], [VENDOR, GOOGLE], [TYPE, SMARTTV]],
          [
            /crkey/i
            // Google Chromecast, Linux-based or unknown
          ],
          [[MODEL, CHROMECAST], [VENDOR, GOOGLE], [TYPE, SMARTTV]],
          [
            /(portaltv)/i
            // Facebook Portal TV
          ],
          [MODEL, [VENDOR, FACEBOOK], [TYPE, SMARTTV]],
          [
            /droid.+aft(\w+)( bui|\))/i
            // Fire TV
          ],
          [MODEL, [VENDOR, AMAZON], [TYPE, SMARTTV]],
          [
            /(shield \w+ tv)/i
            // Nvidia Shield TV
          ],
          [MODEL, [VENDOR, NVIDIA], [TYPE, SMARTTV]],
          [
            /\(dtv[\);].+(aquos)/i,
            /(aquos-tv[\w ]+)\)/i
            // Sharp
          ],
          [MODEL, [VENDOR, SHARP], [TYPE, SMARTTV]],
          [
            /(bravia[\w ]+)( bui|\))/i
            // Sony
          ],
          [MODEL, [VENDOR, SONY], [TYPE, SMARTTV]],
          [
            /(mi(tv|box)-?\w+) bui/i
            // Xiaomi
          ],
          [MODEL, [VENDOR, XIAOMI], [TYPE, SMARTTV]],
          [
            /Hbbtv.*(technisat) (.*);/i
            // TechniSAT
          ],
          [VENDOR, MODEL, [TYPE, SMARTTV]],
          [
            /\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i,
            // Roku
            /hbbtv\/\d+\.\d+\.\d+ +\([\w\+ ]*; *([\w\d][^;]*);([^;]*)/i
            // HbbTV devices
          ],
          [[VENDOR, /.+\/(\w+)/, "$1", strMapper, { "LG": "lge" }], [MODEL, trim], [TYPE, SMARTTV]],
          [
            ///////////////////
            // CONSOLES
            ///////////////////
            /(playstation \w+)/i
            // Playstation
          ],
          [MODEL, [VENDOR, SONY], [TYPE, CONSOLE]],
          [
            /\b(xbox(?: one)?(?!; xbox))[\); ]/i
            // Microsoft Xbox
          ],
          [MODEL, [VENDOR, MICROSOFT], [TYPE, CONSOLE]],
          [
            /(ouya)/i,
            // Ouya
            /(nintendo) (\w+)/i,
            // Nintendo
            /(retroid) (pocket ([^\)]+))/i,
            // Retroid Pocket
            /(valve).+(steam deck)/i,
            /droid.+; ((shield|rgcube|gr0006))( bui|\))/i
            // Nvidia Portable/Anbernic/Logitech
          ],
          [[VENDOR, strMapper, { "Nvidia": "Shield", "Anbernic": "RGCUBE", "Logitech": "GR0006" }], MODEL, [TYPE, CONSOLE]],
          [
            ///////////////////
            // WEARABLES
            ///////////////////
            /\b(sm-[lr]\d\d[0156][fnuw]?s?|gear live)\b/i
            // Samsung Galaxy Watch
          ],
          [MODEL, [VENDOR, SAMSUNG], [TYPE, WEARABLE]],
          [
            /((pebble))app/i,
            // Pebble
            /(asus|google|lg|oppo|xiaomi) ((pixel |zen)?watch[\w ]*)( bui|\))/i
            // Asus ZenWatch / LG Watch / Pixel Watch / Xiaomi Watch
          ],
          [VENDOR, MODEL, [TYPE, WEARABLE]],
          [
            /(ow(?:19|20)?we?[1-3]{1,3})/i
            // Oppo Watch
          ],
          [MODEL, [VENDOR, OPPO], [TYPE, WEARABLE]],
          [
            /(watch)(?: ?os[,\/]|\d,\d\/)[\d\.]+/i
            // Apple Watch
          ],
          [MODEL, [VENDOR, APPLE], [TYPE, WEARABLE]],
          [
            /(opwwe\d{3})/i
            // OnePlus Watch
          ],
          [MODEL, [VENDOR, ONEPLUS], [TYPE, WEARABLE]],
          [
            /(moto 360)/i
            // Motorola 360
          ],
          [MODEL, [VENDOR, MOTOROLA], [TYPE, WEARABLE]],
          [
            /(smartwatch 3)/i
            // Sony SmartWatch
          ],
          [MODEL, [VENDOR, SONY], [TYPE, WEARABLE]],
          [
            /(g watch r)/i
            // LG G Watch R
          ],
          [MODEL, [VENDOR, LG], [TYPE, WEARABLE]],
          [
            /droid.+; (wt63?0{2,3})\)/i
          ],
          [MODEL, [VENDOR, ZEBRA], [TYPE, WEARABLE]],
          [
            ///////////////////
            // XR
            ///////////////////
            /droid.+; (glass) \d/i
            // Google Glass
          ],
          [MODEL, [VENDOR, GOOGLE], [TYPE, XR]],
          [
            /(pico) ([\w ]+) os\d/i
            // Pico
          ],
          [VENDOR, MODEL, [TYPE, XR]],
          [
            /(quest( \d| pro)?s?).+vr/i
            // Meta Quest
          ],
          [MODEL, [VENDOR, FACEBOOK], [TYPE, XR]],
          [
            /mobile vr; rv.+firefox/i
            // Unidentifiable VR device using Firefox Reality / Wolvic
          ],
          [[TYPE, XR]],
          [
            ///////////////////
            // EMBEDDED
            ///////////////////
            /(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i
            // Tesla
          ],
          [VENDOR, [TYPE, EMBEDDED]],
          [
            /(aeobc)\b/i
            // Echo Dot
          ],
          [MODEL, [VENDOR, AMAZON], [TYPE, EMBEDDED]],
          [
            /(homepod).+mac os/i
            // Apple HomePod
          ],
          [MODEL, [VENDOR, APPLE], [TYPE, EMBEDDED]],
          [
            /windows iot/i
            // Unidentifiable embedded device using Windows IoT
          ],
          [[TYPE, EMBEDDED]],
          [
            ////////////////////
            // MIXED (GENERIC)
            ///////////////////
            /droid.+; ([\w- ]+) (4k|android|smart|google)[- ]?tv/i
            // Unidentifiable SmartTV
          ],
          [MODEL, [TYPE, SMARTTV]],
          [
            /\b((4k|android|smart|opera)[- ]?tv|tv; rv:|large screen[\w ]+safari)\b/i
          ],
          [[TYPE, SMARTTV]],
          [
            /droid .+?; ([^;]+?)(?: bui|; wv\)|\) applew|; hmsc).+?(mobile|vr|\d) safari/i
          ],
          [MODEL, [TYPE, strMapper, { "mobile": "Mobile", "xr": "VR", "*": TABLET }]],
          [
            /\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i
            // Unidentifiable Tablet
          ],
          [[TYPE, TABLET]],
          [
            /(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i
            // Unidentifiable Mobile
          ],
          [[TYPE, MOBILE]],
          [
            /droid .+?; ([\w\. -]+)( bui|\))/i
            // Generic Android Device
          ],
          [MODEL, [VENDOR, "Generic"]]
        ],
        engine: [
          [
            /windows.+ edge\/([\w\.]+)/i
            // EdgeHTML
          ],
          [VERSION, [NAME, EDGE + "HTML"]],
          [
            /(arkweb)\/([\w\.]+)/i
            // ArkWeb
          ],
          [NAME, VERSION],
          [
            /webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i
            // Blink
          ],
          [VERSION, [NAME, "Blink"]],
          [
            /(presto)\/([\w\.]+)/i,
            // Presto
            /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna|servo)\/([\w\.]+)/i,
            // WebKit/Trident/NetFront/NetSurf/Amaya/Lynx/w3m/Goanna/Servo
            /ekioh(flow)\/([\w\.]+)/i,
            // Flow
            /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i,
            // KHTML/Tasman/Links
            /(icab)[\/ ]([23]\.[\d\.]+)/i,
            // iCab
            /\b(libweb)/i
            // LibWeb
          ],
          [NAME, VERSION],
          [
            /ladybird\//i
          ],
          [[NAME, "LibWeb"]],
          [
            /rv\:([\w\.]{1,9})\b.+(gecko)/i
            // Gecko
          ],
          [VERSION, NAME]
        ],
        os: [
          [
            // Windows
            /(windows nt) (6\.[23]); arm/i
            // Windows RT
          ],
          [[NAME, /N/, "R"], [VERSION, strMapper, windowsVersionMap]],
          [
            /(windows (?:phone|mobile|iot))(?: os)?[\/ ]?([\d\.]*( se)?)/i,
            // Windows IoT/Mobile/Phone
            // Windows NT/3.1/95/98/ME/2000/XP/Vista/7/8/8.1/10/11
            /(windows)[\/ ](1[01]|2000|3\.1|7|8(\.1)?|9[58]|me|server 20\d\d( r2)?|vista|xp)/i
          ],
          [NAME, VERSION],
          [
            /windows nt ?([\d\.\)]*)(?!.+xbox)/i,
            /\bwin(?=3| ?9|n)(?:nt| 9x )?([\d\.;]*)/i
          ],
          [[VERSION, /(;|\))/g, "", strMapper, windowsVersionMap], [NAME, WINDOWS]],
          [
            /(windows ce)\/?([\d\.]*)/i
            // Windows CE
          ],
          [NAME, VERSION],
          [
            // iOS/macOS
            /[adehimnop]{4,7}\b(?:.*os ([\w]+) like mac|; opera)/i,
            // iOS
            /(?:ios;fbsv|ios(?=.+ip(?:ad|hone)|.+apple ?tv)|ip(?:ad|hone)(?: |.+i(?:pad)?)os|apple ?tv.+ios)[\/ ]([\w\.]+)/i,
            /\btvos ?([\w\.]+)/i,
            /cfnetwork\/.+darwin/i
          ],
          [[VERSION, /_/g, "."], [NAME, "iOS"]],
          [
            /(mac os x) ?([\w\. ]*)/i,
            /(macintosh|mac_powerpc\b)(?!.+(haiku|morphos))/i
            // Mac OS
          ],
          [[NAME, "macOS"], [VERSION, /_/g, "."]],
          [
            // Google Chromecast
            /android ([\d\.]+).*crkey/i
            // Google Chromecast, Android-based
          ],
          [VERSION, [NAME, CHROMECAST + " Android"]],
          [
            /fuchsia.*crkey\/([\d\.]+)/i
            // Google Chromecast, Fuchsia-based
          ],
          [VERSION, [NAME, CHROMECAST + " Fuchsia"]],
          [
            /crkey\/([\d\.]+).*devicetype\/smartspeaker/i
            // Google Chromecast, Linux-based Smart Speaker
          ],
          [VERSION, [NAME, CHROMECAST + " SmartSpeaker"]],
          [
            /linux.*crkey\/([\d\.]+)/i
            // Google Chromecast, Legacy Linux-based
          ],
          [VERSION, [NAME, CHROMECAST + " Linux"]],
          [
            /crkey\/([\d\.]+)/i
            // Google Chromecast, unknown
          ],
          [VERSION, [NAME, CHROMECAST]],
          [
            // Mobile OSes
            /droid ([\w\.]+)\b.+(android[- ]x86)/i
            // Android-x86
          ],
          [VERSION, NAME],
          [
            /(ubuntu) ([\w\.]+) like android/i
            // Ubuntu Touch
          ],
          [[NAME, /(.+)/, "$1 Touch"], VERSION],
          [
            /(harmonyos)[\/ ]?([\d\.]*)/i,
            // HarmonyOS
            // Android/Blackberry/WebOS/QNX/Bada/RIM/KaiOS/Maemo/MeeGo/S40/Sailfish OS/OpenHarmony/Tizen
            /(android|bada|blackberry|kaios|maemo|meego|openharmony|qnx|rim tablet os|sailfish|series40|symbian|tizen)\w*[-\/\.; ]?([\d\.]*)/i
          ],
          [NAME, VERSION],
          [
            /\(bb(10);/i
            // BlackBerry 10
          ],
          [VERSION, [NAME, BLACKBERRY]],
          [
            /(?:symbian ?os|symbos|s60(?=;)|series ?60)[-\/ ]?([\w\.]*)/i
            // Symbian
          ],
          [VERSION, [NAME, "Symbian"]],
          [
            /mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i
            // Firefox OS
          ],
          [VERSION, [NAME, FIREFOX + " OS"]],
          [
            /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i,
            // WebOS
            /webos(?:[ \/]?|\.tv-20(?=2[2-9]))(\d[\d\.]*)/i
          ],
          [VERSION, [NAME, "webOS"]],
          [
            /web0s;.+?(?:chr[o0]me|safari)\/(\d+)/i
            // https://webostv.developer.lge.com/develop/specifications/web-api-and-web-engine
          ],
          [[VERSION, strMapper, { "25": "120", "24": "108", "23": "94", "22": "87", "6": "79", "5": "68", "4": "53", "3": "38", "2": "538", "1": "537", "*": "TV" }], [NAME, "webOS"]],
          [
            /watch(?: ?os[,\/]|\d,\d\/)([\d\.]+)/i
            // watchOS
          ],
          [VERSION, [NAME, "watchOS"]],
          [
            // Google ChromeOS
            /(cros) [\w]+(?:\)| ([\w\.]+)\b)/i
            // Chromium OS
          ],
          [[NAME, "Chrome OS"], VERSION],
          [
            // Smart TVs
            /panasonic;(viera)/i,
            // Panasonic Viera
            /(netrange)mmh/i,
            // Netrange
            /(nettv)\/(\d+\.[\w\.]+)/i,
            // NetTV
            // Console
            /(nintendo|playstation) (\w+)/i,
            // Nintendo/Playstation
            /(xbox); +xbox ([^\);]+)/i,
            // Microsoft Xbox (360, One, X, S, Series X, Series S)
            /(pico) .+os([\w\.]+)/i,
            // Pico
            // Other
            /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i,
            // Joli/Palm
            /linux.+(mint)[\/\(\) ]?([\w\.]*)/i,
            // Mint
            /(mageia|vectorlinux|fuchsia|arcaos|arch(?= ?linux))[;l ]([\d\.]*)/i,
            // Mageia/VectorLinux/Fuchsia/ArcaOS/Arch
            /([kxln]?ubuntu|debian|suse|opensuse|gentoo|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire|knoppix)(?: gnu[\/ ]linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i,
            // Ubuntu/Debian/SUSE/Gentoo/Slackware/Fedora/Mandriva/CentOS/PCLinuxOS/RedHat/Zenwalk/Linpus/Raspbian/Plan9/Minix/RISCOS/Contiki/Deepin/Manjaro/elementary/Sabayon/Linspire/Knoppix
            /((?:open)?solaris)[-\/ ]?([\w\.]*)/i,
            // Solaris
            /\b(aix)[; ]([1-9\.]{0,4})/i,
            // AIX
            /(hurd|linux|morphos)(?: (?:arm|x86|ppc)\w*| ?)([\w\.]*)/i,
            // Hurd/Linux/MorphOS
            /(gnu) ?([\w\.]*)/i,
            // GNU
            /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i,
            // FreeBSD/NetBSD/OpenBSD/PC-BSD/GhostBSD/DragonFly
            /(haiku) ?(r\d)?/i
            // Haiku
          ],
          [NAME, VERSION],
          [
            /(sunos) ?([\d\.]*)/i
            // Solaris
          ],
          [[NAME, "Solaris"], VERSION],
          [
            /\b(beos|os\/2|amigaos|openvms|hp-ux|serenityos)/i,
            // BeOS/OS2/AmigaOS/OpenVMS/HP-UX/SerenityOS
            /(unix) ?([\w\.]*)/i
            // UNIX
          ],
          [NAME, VERSION]
        ]
      };
      var defaultProps = function() {
        var props = { init: {}, isIgnore: {}, isIgnoreRgx: {}, toString: {} };
        setProps.call(props.init, [
          [BROWSER, [NAME, VERSION, MAJOR, TYPE]],
          [CPU, [ARCHITECTURE]],
          [DEVICE, [TYPE, MODEL, VENDOR]],
          [ENGINE, [NAME, VERSION]],
          [OS, [NAME, VERSION]]
        ]);
        setProps.call(props.isIgnore, [
          [BROWSER, [VERSION, MAJOR]],
          [ENGINE, [VERSION]],
          [OS, [VERSION]]
        ]);
        setProps.call(props.isIgnoreRgx, [
          [BROWSER, / ?browser$/i],
          [OS, / ?os$/i]
        ]);
        setProps.call(props.toString, [
          [BROWSER, [NAME, VERSION]],
          [CPU, [ARCHITECTURE]],
          [DEVICE, [VENDOR, MODEL]],
          [ENGINE, [NAME, VERSION]],
          [OS, [NAME, VERSION]]
        ]);
        return props;
      }();
      var createIData = function(item, itemType) {
        var init_props = defaultProps.init[itemType], is_ignoreProps = defaultProps.isIgnore[itemType] || 0, is_ignoreRgx = defaultProps.isIgnoreRgx[itemType] || 0, toString_props = defaultProps.toString[itemType] || 0;
        function IData() {
          setProps.call(this, init_props);
        }
        IData.prototype.getItem = function() {
          return item;
        };
        IData.prototype.withClientHints = function() {
          if (!NAVIGATOR_UADATA) {
            return item.parseCH().get();
          }
          return NAVIGATOR_UADATA.getHighEntropyValues(CH_ALL_VALUES).then(function(res) {
            return item.setCH(new UACHData(res, false)).parseCH().get();
          });
        };
        IData.prototype.withFeatureCheck = function() {
          return item.detectFeature().get();
        };
        if (itemType != RESULT) {
          IData.prototype.is = function(strToCheck) {
            var is = false;
            for (var i in this) {
              if (this.hasOwnProperty(i) && !has(is_ignoreProps, i) && lowerize(is_ignoreRgx ? strip(is_ignoreRgx, this[i]) : this[i]) == lowerize(is_ignoreRgx ? strip(is_ignoreRgx, strToCheck) : strToCheck)) {
                is = true;
                if (strToCheck != TYPEOF.UNDEFINED) break;
              } else if (strToCheck == TYPEOF.UNDEFINED && is) {
                is = !is;
                break;
              }
            }
            return is;
          };
          IData.prototype.toString = function() {
            var str = EMPTY;
            for (var i in toString_props) {
              if (typeof this[toString_props[i]] !== TYPEOF.UNDEFINED) {
                str += (str ? " " : EMPTY) + this[toString_props[i]];
              }
            }
            return str || TYPEOF.UNDEFINED;
          };
        }
        IData.prototype.then = function(cb) {
          var that = this;
          var IDataResolve = function() {
            for (var prop in that) {
              if (that.hasOwnProperty(prop)) {
                this[prop] = that[prop];
              }
            }
          };
          IDataResolve.prototype = {
            is: IData.prototype.is,
            toString: IData.prototype.toString,
            withClientHints: IData.prototype.withClientHints,
            withFeatureCheck: IData.prototype.withFeatureCheck
          };
          var resolveData = new IDataResolve();
          cb(resolveData);
          return resolveData;
        };
        return new IData();
      };
      function UACHData(uach, isHttpUACH) {
        uach = uach || {};
        setProps.call(this, CH_ALL_VALUES);
        if (isHttpUACH) {
          setProps.call(this, [
            [BRANDS, itemListToArray(uach[CH])],
            [FULLVERLIST, itemListToArray(uach[CH_FULL_VER_LIST])],
            [MOBILE, /\?1/.test(uach[CH_MOBILE])],
            [MODEL, stripQuotes(uach[CH_MODEL])],
            [PLATFORM, stripQuotes(uach[CH_PLATFORM])],
            [PLATFORMVER, stripQuotes(uach[CH_PLATFORM_VER])],
            [ARCHITECTURE, stripQuotes(uach[CH_ARCH])],
            [FORMFACTORS, itemListToArray(uach[CH_FORM_FACTORS])],
            [BITNESS, stripQuotes(uach[CH_BITNESS])]
          ]);
        } else {
          for (var prop in uach) {
            if (this.hasOwnProperty(prop) && typeof uach[prop] !== TYPEOF.UNDEFINED) this[prop] = uach[prop];
          }
        }
      }
      function UAItem(itemType, ua, rgxMap, uaCH) {
        setProps.call(this, [
          ["itemType", itemType],
          ["ua", ua],
          ["uaCH", uaCH],
          ["rgxMap", rgxMap],
          ["data", createIData(this, itemType)]
        ]);
        return this;
      }
      UAItem.prototype.get = function(prop) {
        if (!prop) return this.data;
        return this.data.hasOwnProperty(prop) ? this.data[prop] : undefined2;
      };
      UAItem.prototype.set = function(prop, val) {
        this.data[prop] = val;
        return this;
      };
      UAItem.prototype.setCH = function(ch) {
        this.uaCH = ch;
        return this;
      };
      UAItem.prototype.detectFeature = function() {
        if (NAVIGATOR && NAVIGATOR.userAgent == this.ua) {
          switch (this.itemType) {
            case BROWSER:
              if (NAVIGATOR.brave && typeof NAVIGATOR.brave.isBrave == TYPEOF.FUNCTION) {
                this.set(NAME, "Brave");
              }
              break;
            case DEVICE:
              if (!this.get(TYPE) && NAVIGATOR_UADATA && NAVIGATOR_UADATA[MOBILE]) {
                this.set(TYPE, MOBILE);
              }
              if (this.get(MODEL) == "Macintosh" && NAVIGATOR && typeof NAVIGATOR.standalone !== TYPEOF.UNDEFINED && NAVIGATOR.maxTouchPoints && NAVIGATOR.maxTouchPoints > 2) {
                this.set(MODEL, "iPad").set(TYPE, TABLET);
              }
              break;
            case OS:
              if (!this.get(NAME) && NAVIGATOR_UADATA && NAVIGATOR_UADATA[PLATFORM]) {
                this.set(NAME, NAVIGATOR_UADATA[PLATFORM]);
              }
              break;
            case RESULT:
              var data = this.data;
              var detect = function(itemType) {
                return data[itemType].getItem().detectFeature().get();
              };
              this.set(BROWSER, detect(BROWSER)).set(CPU, detect(CPU)).set(DEVICE, detect(DEVICE)).set(ENGINE, detect(ENGINE)).set(OS, detect(OS));
          }
        }
        return this;
      };
      UAItem.prototype.parseUA = function() {
        if (this.itemType != RESULT) {
          rgxMapper.call(this.data, this.ua, this.rgxMap);
        }
        switch (this.itemType) {
          case BROWSER:
            this.set(MAJOR, majorize(this.get(VERSION)));
            break;
          case OS:
            if (this.get(NAME) == "iOS" && this.get(VERSION) == "18.6") {
              var realVersion = /\) Version\/([\d\.]+)/.exec(this.ua);
              if (realVersion && parseInt(realVersion[1].substring(0, 2), 10) >= 26) {
                this.set(VERSION, realVersion[1]);
              }
            }
            break;
        }
        return this;
      };
      UAItem.prototype.parseCH = function() {
        var uaCH = this.uaCH, rgxMap = this.rgxMap;
        switch (this.itemType) {
          case BROWSER:
          case ENGINE:
            var brands = uaCH[FULLVERLIST] || uaCH[BRANDS], prevName;
            if (brands) {
              for (var i = 0; i < brands.length; i++) {
                var brandName = brands[i].brand || brands[i], brandVersion = brands[i].version;
                if (this.itemType == BROWSER && !/not.a.brand/i.test(brandName) && (!prevName || /Chrom/.test(prevName) && brandName != CHROMIUM || prevName == EDGE && /WebView2/.test(brandName))) {
                  brandName = strMapper(brandName, browserHintsMap);
                  prevName = this.get(NAME);
                  if (!(prevName && !/Chrom/.test(prevName) && /Chrom/.test(brandName))) {
                    this.set(NAME, brandName).set(VERSION, brandVersion).set(MAJOR, majorize(brandVersion));
                  }
                  prevName = brandName;
                }
                if (this.itemType == ENGINE && brandName == CHROMIUM) {
                  this.set(VERSION, brandVersion);
                }
              }
            }
            break;
          case CPU:
            var archName = uaCH[ARCHITECTURE];
            if (archName) {
              if (archName && uaCH[BITNESS] == "64") archName += "64";
              rgxMapper.call(this.data, archName + ";", rgxMap);
            }
            break;
          case DEVICE:
            if (uaCH[MOBILE]) {
              this.set(TYPE, MOBILE);
            }
            if (uaCH[MODEL]) {
              this.set(MODEL, uaCH[MODEL]);
              if (!this.get(TYPE) || !this.get(VENDOR)) {
                var reParse = {};
                rgxMapper.call(reParse, "droid 9; " + uaCH[MODEL] + ")", rgxMap);
                if (!this.get(TYPE) && !!reParse.type) {
                  this.set(TYPE, reParse.type);
                }
                if (!this.get(VENDOR) && !!reParse.vendor) {
                  this.set(VENDOR, reParse.vendor);
                }
              }
            }
            if (uaCH[FORMFACTORS]) {
              var ff;
              if (typeof uaCH[FORMFACTORS] !== "string") {
                var idx = 0;
                while (!ff && idx < uaCH[FORMFACTORS].length) {
                  ff = strMapper(uaCH[FORMFACTORS][idx++], formFactorsMap);
                }
              } else {
                ff = strMapper(uaCH[FORMFACTORS], formFactorsMap);
              }
              this.set(TYPE, ff);
            }
            break;
          case OS:
            var osName = uaCH[PLATFORM];
            if (osName) {
              var osVersion = uaCH[PLATFORMVER];
              if (osName == WINDOWS) osVersion = parseInt(majorize(osVersion), 10) >= 13 ? "11" : "10";
              this.set(NAME, osName).set(VERSION, osVersion);
            }
            if (this.get(NAME) == WINDOWS && uaCH[MODEL] == "Xbox") {
              this.set(NAME, "Xbox").set(VERSION, undefined2);
            }
            break;
          case RESULT:
            var data = this.data;
            var parse = function(itemType) {
              return data[itemType].getItem().setCH(uaCH).parseCH().get();
            };
            this.set(BROWSER, parse(BROWSER)).set(CPU, parse(CPU)).set(DEVICE, parse(DEVICE)).set(ENGINE, parse(ENGINE)).set(OS, parse(OS));
        }
        return this;
      };
      function UAParser(ua, extensions, headers) {
        if (typeof ua === TYPEOF.OBJECT) {
          if (isExtensions(ua, true)) {
            if (typeof extensions === TYPEOF.OBJECT) {
              headers = extensions;
            }
            extensions = ua;
          } else {
            headers = ua;
            extensions = undefined2;
          }
          ua = undefined2;
        } else if (typeof ua === TYPEOF.STRING && !isExtensions(extensions, true)) {
          headers = extensions;
          extensions = undefined2;
        }
        if (headers) {
          if (typeof headers.append === TYPEOF.FUNCTION) {
            var kv = {};
            headers.forEach(function(v, k) {
              kv[String(k).toLowerCase()] = v;
            });
            headers = kv;
          } else {
            var normalized = {};
            for (var header in headers) {
              if (headers.hasOwnProperty(header)) {
                normalized[String(header).toLowerCase()] = headers[header];
              }
            }
            headers = normalized;
          }
        }
        if (!(this instanceof UAParser)) {
          return new UAParser(ua, extensions, headers).getResult();
        }
        var userAgent = typeof ua === TYPEOF.STRING ? ua : (
          // Passed user-agent string
          headers && headers[USER_AGENT] ? headers[USER_AGENT] : (
            // User-Agent from passed headers
            NAVIGATOR && NAVIGATOR.userAgent ? NAVIGATOR.userAgent : (
              // navigator.userAgent
              EMPTY
            )
          )
        ), httpUACH = new UACHData(headers, true), regexMap = extensions ? extend(defaultRegexes, extensions) : defaultRegexes, createItemFunc = function(itemType) {
          if (itemType == RESULT) {
            return function() {
              return new UAItem(itemType, userAgent, regexMap, httpUACH).set("ua", userAgent).set(BROWSER, this.getBrowser()).set(CPU, this.getCPU()).set(DEVICE, this.getDevice()).set(ENGINE, this.getEngine()).set(OS, this.getOS()).get();
            };
          } else {
            return function() {
              return new UAItem(itemType, userAgent, regexMap[itemType], httpUACH).parseUA().get();
            };
          }
        };
        setProps.call(this, [
          ["getBrowser", createItemFunc(BROWSER)],
          ["getCPU", createItemFunc(CPU)],
          ["getDevice", createItemFunc(DEVICE)],
          ["getEngine", createItemFunc(ENGINE)],
          ["getOS", createItemFunc(OS)],
          ["getResult", createItemFunc(RESULT)],
          ["getUA", function() {
            return userAgent;
          }],
          ["setUA", function(ua2) {
            if (isString(ua2)) userAgent = trim(ua2, UA_MAX_LENGTH);
            return this;
          }]
        ]).setUA(userAgent);
        return this;
      }
      UAParser.VERSION = LIBVERSION;
      UAParser.BROWSER = enumerize([NAME, VERSION, MAJOR, TYPE]);
      UAParser.CPU = enumerize([ARCHITECTURE]);
      UAParser.DEVICE = enumerize([MODEL, VENDOR, TYPE, CONSOLE, MOBILE, SMARTTV, TABLET, WEARABLE, EMBEDDED]);
      UAParser.ENGINE = UAParser.OS = enumerize([NAME, VERSION]);
      if (typeof exports2 !== TYPEOF.UNDEFINED) {
        if (typeof module2 !== TYPEOF.UNDEFINED && module2.exports) {
          exports2 = module2.exports = UAParser;
        }
        exports2.UAParser = UAParser;
      } else {
        if (typeof define === TYPEOF.FUNCTION && define.amd) {
          define(function() {
            return UAParser;
          });
        } else if (isWindow) {
          window2.UAParser = UAParser;
        }
      }
      var $ = isWindow && (window2.jQuery || window2.Zepto);
      if ($ && !$.ua) {
        var parser = new UAParser();
        $.ua = parser.getResult();
        $.ua.get = function() {
          return parser.getUA();
        };
        $.ua.set = function(ua) {
          parser.setUA(ua);
          var result = parser.getResult();
          for (var prop in result) {
            $.ua[prop] = result[prop];
          }
        };
      }
    })(typeof window === "object" ? window : exports2);
  }
});

// node_modules/@trezor/env-utils/lib/jws.js
var require_jws = __commonJS({
  "node_modules/@trezor/env-utils/lib/jws.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.firmwareConfigPublicKey = exports2.publicKey = void 0;
    exports2.publicKey = {
      dev: `-----BEGIN PUBLIC KEY-----
MFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAEbSUHJlr17+NywPS/w+xMkp3dSD8eWXSuAfFKwonZPe5fL63kISipJC+eJP7Mad0WxgyJoiMsZCV6BZPK2jIFdg==
-----END PUBLIC KEY-----`,
      codesign: `-----BEGIN PUBLIC KEY-----
MFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAES7MbBzU/v5BsljkTM8Mz0Jsk+Nn5n2wH
o2/+MUI3TgCVdTbEHhn3HXaY7GJ6TLyWqxn+pIDY9wUUAyUqOStTUQ==
-----END PUBLIC KEY-----`
    };
    exports2.firmwareConfigPublicKey = {
      dev: `
-----BEGIN PUBLIC KEY-----
MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEEKjWdvv8SJm/UN2lXoEXl3ID35b/
hsz3etxANvUgLQ4r0eEhqVUEL5l+dRMgEv4Ycvr3UEcMkSFRPoA8ktxX1A==
-----END PUBLIC KEY-----
`,
      codesign: `
-----BEGIN PUBLIC KEY-----
MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEfEsFXNi5sdMxwiOYh4oRGorCM2RO
IEsfw3m+vWBrLb/r/GYWUVkVXWsZukLwPRZ8asP+7Ifd2ap7GZ2iQzWKCA==
-----END PUBLIC KEY-----
`
    };
  }
});

// node_modules/@trezor/env-utils/lib/envUtils.js
var require_envUtils = __commonJS({
  "node_modules/@trezor/env-utils/lib/envUtils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.envUtils = exports2.getFirmwareReleaseJwsPublicKey = exports2.getJWSPublicKey = exports2.getEnvironment = exports2.isNative = exports2.isDesktop = exports2.isWeb = void 0;
    var ua_parser_js_1 = require_ua_parser();
    var jws_1 = require_jws();
    var isWeb = () => process.env.SUITE_TYPE === "web";
    exports2.isWeb = isWeb;
    var isDesktop = () => process.env.SUITE_TYPE === "desktop";
    exports2.isDesktop = isDesktop;
    var isNative = () => false;
    exports2.isNative = isNative;
    var getEnvironment = () => {
      if ((0, exports2.isWeb)())
        return "web";
      return "desktop";
    };
    exports2.getEnvironment = getEnvironment;
    var userAgentParser;
    var getUserAgent = () => window.navigator.userAgent;
    var getUserAgentParser = () => {
      if (!userAgentParser) {
        const ua = getUserAgent();
        userAgentParser = new ua_parser_js_1.UAParser(ua);
      }
      return userAgentParser;
    };
    var isAndroid = () => /Android/.test(getUserAgent());
    var isChromeOs = () => /CrOS/.test(getUserAgent());
    var getBrowserVersion = () => getUserAgentParser().getBrowser().version || "";
    var getCommitHash = () => process.env.COMMITHASH || "";
    var getOsVersion = async () => {
      const { version } = await getUserAgentParser().getOS().withClientHints();
      return version ?? "";
    };
    var getCpuArch = async () => {
      const { architecture } = await getUserAgentParser().getCPU().withClientHints();
      return architecture ?? "";
    };
    var getSuiteVersion = () => process.env.VERSION || "";
    var getBrowserName = () => {
      const browserName = getUserAgentParser().getBrowser().name?.replace(" ", "");
      return browserName?.toLowerCase() || "";
    };
    var isFirefox = () => getBrowserName() === "firefox";
    var getPlatform = () => window.navigator.platform;
    var getPlatformLanguages = () => window.navigator.languages;
    var getScreenWidth = () => window.screen.width;
    var getScreenHeight = () => window.screen.height;
    var getWindowWidth = () => window.innerWidth;
    var getWindowHeight = () => window.innerHeight;
    var getLocationOrigin = () => window.location.origin;
    var getLocationHostname = () => window.location.hostname;
    var getProcessPlatform = () => typeof process !== "undefined" ? process.platform : "";
    var isMacOs = () => {
      if (getProcessPlatform() === "darwin")
        return true;
      if (typeof window === "undefined")
        return false;
      return getPlatform().toLowerCase().startsWith("mac");
    };
    var isWindows = () => {
      if (getProcessPlatform() === "win32")
        return true;
      if (typeof window === "undefined")
        return false;
      return getPlatform().toLowerCase().startsWith("win");
    };
    var isIOs = () => ["iPhone", "iPad", "iPod"].includes(getPlatform());
    var isLinux = () => {
      if (getProcessPlatform() === "linux")
        return true;
      if (typeof window === "undefined")
        return false;
      if (isAndroid() || isChromeOs())
        return false;
      return getPlatform().toLowerCase().startsWith("linux");
    };
    var isCodesignBuild = () => process.env.IS_CODESIGN_BUILD === "true";
    var getOsName = () => {
      if (isWindows())
        return "windows";
      if (isMacOs())
        return "macos";
      if (isAndroid())
        return "android";
      if (isChromeOs())
        return "chromeos";
      if (isLinux())
        return "linux";
      if (isIOs())
        return "ios";
      return "";
    };
    var getOsNameWeb = () => getUserAgentParser().getOS().name?.replaceAll(" ", "");
    var getOsFamily = () => {
      const osName = getUserAgentParser().getOS().name?.toLowerCase().replaceAll(" ", "");
      if (osName === "windows") {
        return "Windows";
      }
      if (osName === "macos") {
        return "MacOS";
      }
      return "Linux";
    };
    var getDeviceType = () => getUserAgentParser().getDevice().type;
    var getJWSPublicKey = () => isCodesignBuild() ? jws_1.publicKey.codesign : jws_1.publicKey.dev;
    exports2.getJWSPublicKey = getJWSPublicKey;
    var getFirmwareReleaseJwsPublicKey = (useCodeSignKey) => useCodeSignKey ? jws_1.firmwareConfigPublicKey.codesign : jws_1.firmwareConfigPublicKey.dev;
    exports2.getFirmwareReleaseJwsPublicKey = getFirmwareReleaseJwsPublicKey;
    exports2.envUtils = {
      isWeb: exports2.isWeb,
      isDesktop: exports2.isDesktop,
      isNative: exports2.isNative,
      getEnvironment: exports2.getEnvironment,
      getUserAgent,
      isAndroid,
      isChromeOs,
      getOsVersion,
      getCpuArch,
      getBrowserName,
      getBrowserVersion,
      getCommitHash,
      getDeviceType,
      getSuiteVersion,
      isFirefox,
      getPlatform,
      getPlatformLanguages,
      getScreenWidth,
      getScreenHeight,
      getWindowWidth,
      getWindowHeight,
      getLocationOrigin,
      getLocationHostname,
      getProcessPlatform,
      isMacOs,
      isWindows,
      isIOs,
      isLinux,
      isCodesignBuild,
      getOsName,
      getOsNameWeb,
      getOsFamily,
      getJWSPublicKey: exports2.getJWSPublicKey,
      getFirmwareReleaseJwsPublicKey: exports2.getFirmwareReleaseJwsPublicKey
    };
  }
});

// node_modules/@trezor/env-utils/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/@trezor/env-utils/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getFirmwareReleaseJwsPublicKey = exports2.getJWSPublicKey = exports2.getOsFamily = exports2.getOsNameWeb = exports2.getOsName = exports2.isCodesignBuild = exports2.isLinux = exports2.isIOs = exports2.isWindows = exports2.isMacOs = exports2.getProcessPlatform = exports2.getLocationHostname = exports2.getLocationOrigin = exports2.getWindowHeight = exports2.getWindowWidth = exports2.getScreenHeight = exports2.getScreenWidth = exports2.getPlatformLanguages = exports2.getPlatform = exports2.isFirefox = exports2.getSuiteVersion = exports2.getCpuArch = exports2.getOsVersion = exports2.getDeviceType = exports2.getCommitHash = exports2.getBrowserName = exports2.getBrowserVersion = exports2.isChromeOs = exports2.isAndroid = exports2.getUserAgent = exports2.getEnvironment = exports2.isNative = exports2.isDesktop = exports2.isWeb = void 0;
    var envUtils_1 = require_envUtils();
    exports2.isWeb = envUtils_1.envUtils.isWeb, exports2.isDesktop = envUtils_1.envUtils.isDesktop, exports2.isNative = envUtils_1.envUtils.isNative, exports2.getEnvironment = envUtils_1.envUtils.getEnvironment, exports2.getUserAgent = envUtils_1.envUtils.getUserAgent, exports2.isAndroid = envUtils_1.envUtils.isAndroid, exports2.isChromeOs = envUtils_1.envUtils.isChromeOs, exports2.getBrowserVersion = envUtils_1.envUtils.getBrowserVersion, exports2.getBrowserName = envUtils_1.envUtils.getBrowserName, exports2.getCommitHash = envUtils_1.envUtils.getCommitHash, exports2.getDeviceType = envUtils_1.envUtils.getDeviceType, exports2.getOsVersion = envUtils_1.envUtils.getOsVersion, exports2.getCpuArch = envUtils_1.envUtils.getCpuArch, exports2.getSuiteVersion = envUtils_1.envUtils.getSuiteVersion, exports2.isFirefox = envUtils_1.envUtils.isFirefox, exports2.getPlatform = envUtils_1.envUtils.getPlatform, exports2.getPlatformLanguages = envUtils_1.envUtils.getPlatformLanguages, exports2.getScreenWidth = envUtils_1.envUtils.getScreenWidth, exports2.getScreenHeight = envUtils_1.envUtils.getScreenHeight, exports2.getWindowWidth = envUtils_1.envUtils.getWindowWidth, exports2.getWindowHeight = envUtils_1.envUtils.getWindowHeight, exports2.getLocationOrigin = envUtils_1.envUtils.getLocationOrigin, exports2.getLocationHostname = envUtils_1.envUtils.getLocationHostname, exports2.getProcessPlatform = envUtils_1.envUtils.getProcessPlatform, exports2.isMacOs = envUtils_1.envUtils.isMacOs, exports2.isWindows = envUtils_1.envUtils.isWindows, exports2.isIOs = envUtils_1.envUtils.isIOs, exports2.isLinux = envUtils_1.envUtils.isLinux, exports2.isCodesignBuild = envUtils_1.envUtils.isCodesignBuild, exports2.getOsName = envUtils_1.envUtils.getOsName, exports2.getOsNameWeb = envUtils_1.envUtils.getOsNameWeb, exports2.getOsFamily = envUtils_1.envUtils.getOsFamily, exports2.getJWSPublicKey = envUtils_1.envUtils.getJWSPublicKey, exports2.getFirmwareReleaseJwsPublicKey = envUtils_1.envUtils.getFirmwareReleaseJwsPublicKey;
  }
});

// node_modules/@trezor/connect-common/lib/systemInfo.js
var require_systemInfo = __commonJS({
  "node_modules/@trezor/connect-common/lib/systemInfo.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getSystemInfo = exports2.getInstallerPackage = void 0;
    var env_utils_1 = require_lib4();
    var getInstallerPackage = () => {
      const agent = (0, env_utils_1.getUserAgent)();
      switch ((0, env_utils_1.getOsFamily)()) {
        case "MacOS":
          return "mac";
        case "Windows": {
          const arch = agent.match(/(Win64|WOW64)/) ? "64" : "32";
          return `win${arch}`;
        }
        case "Linux": {
          const isRpm = agent.match(/CentOS|Fedora|Mandriva|Mageia|Red Hat|Scientific|SUSE/) ? "rpm" : "deb";
          const is64x = agent.match(/Linux i[3456]86/) ? "32" : "64";
          return `${isRpm}${is64x}`;
        }
        default:
      }
    };
    exports2.getInstallerPackage = getInstallerPackage;
    var getSystemInfo = (supportedBrowsers) => {
      const browserName = (0, env_utils_1.getBrowserName)();
      const browserVersion = (0, env_utils_1.getBrowserVersion)();
      const supportedBrowser = browserName ? supportedBrowsers[browserName.toLowerCase()] : void 0;
      const outdatedBrowser = supportedBrowser ? supportedBrowser.version > parseInt(browserVersion, 10) : false;
      const mobile = (0, env_utils_1.getDeviceType)() === "mobile";
      const supportedMobile = mobile ? "usb" in navigator : true;
      const supported = !!(supportedBrowser && !outdatedBrowser && supportedMobile);
      return {
        os: {
          family: (0, env_utils_1.getOsFamily)(),
          mobile
        },
        browser: {
          supported,
          outdated: outdatedBrowser
        }
      };
    };
    exports2.getSystemInfo = getSystemInfo;
  }
});

// node_modules/@trezor/connect-common/files/firmware/release/releases.v1.json
var require_releases_v1 = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/release/releases.v1.json"(exports2, module2) {
    module2.exports = {
      version: 1,
      timestamp: "2025-09-07T15:05:42.979Z",
      sequence: 1,
      releases: {
        T1B1: {
          "bitcoin-only": {
            firmware_type: "bitcoin-only",
            conditions: {
              environment: {
                min_suite_version: "25.9.0",
                min_suite_native_version: "25.9.0"
              },
              rollout_probability: 100
            },
            releasePath: "firmware/t1b1/bitcoinonly/t1b1-1.13.1-bitcoinonly.json"
          },
          universal: {
            firmware_type: "universal",
            conditions: {
              environment: {
                min_suite_version: "25.9.0",
                min_suite_native_version: "25.9.0"
              },
              rollout_probability: 100
            },
            releasePath: "firmware/t1b1/universal/t1b1-1.13.1-universal.json"
          }
        },
        T2B1: {
          "bitcoin-only": {
            firmware_type: "bitcoin-only",
            conditions: {
              environment: {
                min_suite_version: "25.9.0",
                min_suite_native_version: "25.9.0"
              },
              rollout_probability: 100
            },
            releasePath: "firmware/t2b1/bitcoinonly/t2b1-2.8.10-bitcoinonly.json"
          },
          universal: {
            firmware_type: "universal",
            conditions: {
              environment: {
                min_suite_version: "25.9.0",
                min_suite_native_version: "25.9.0"
              },
              rollout_probability: 100
            },
            releasePath: "firmware/t2b1/universal/t2b1-2.8.10-universal.json"
          }
        },
        T2T1: {
          "bitcoin-only": {
            firmware_type: "bitcoin-only",
            conditions: {
              environment: {
                min_suite_version: "25.9.0",
                min_suite_native_version: "25.9.0"
              },
              rollout_probability: 100
            },
            releasePath: "firmware/t2t1/bitcoinonly/t2t1-2.8.10-bitcoinonly.json"
          },
          universal: {
            firmware_type: "universal",
            conditions: {
              environment: {
                min_suite_version: "25.9.0",
                min_suite_native_version: "25.9.0"
              },
              rollout_probability: 100
            },
            releasePath: "firmware/t2t1/universal/t2t1-2.8.10-universal.json"
          }
        },
        T3B1: {
          "bitcoin-only": {
            firmware_type: "bitcoin-only",
            conditions: {
              environment: {
                min_suite_version: "25.9.0",
                min_suite_native_version: "25.9.0"
              },
              rollout_probability: 100
            },
            releasePath: "firmware/t3b1/bitcoinonly/t3b1-2.8.10-bitcoinonly.json"
          },
          universal: {
            firmware_type: "universal",
            conditions: {
              environment: {
                min_suite_version: "25.9.0",
                min_suite_native_version: "25.9.0"
              },
              rollout_probability: 100
            },
            releasePath: "firmware/t3b1/universal/t3b1-2.8.10-universal.json"
          }
        },
        T3T1: {
          "bitcoin-only": {
            firmware_type: "bitcoin-only",
            conditions: {
              environment: {
                min_suite_version: "25.9.0",
                min_suite_native_version: "25.9.0"
              },
              rollout_probability: 100
            },
            releasePath: "firmware/t3t1/bitcoinonly/t3t1-2.8.10-bitcoinonly.json"
          },
          universal: {
            firmware_type: "universal",
            conditions: {
              environment: {
                min_suite_version: "25.9.0",
                min_suite_native_version: "25.9.0"
              },
              rollout_probability: 100
            },
            releasePath: "firmware/t3t1/universal/t3t1-2.8.10-universal.json"
          }
        }
      },
      intermediaries: {
        T1B1: [
          {
            min_firmware_version: [1, 6, 2],
            min_bootloader_version: [1, 8, 0],
            version: 1
          },
          {
            min_firmware_version: [1, 12, 0],
            min_bootloader_version: [1, 12, 0],
            version: 2
          },
          {
            min_firmware_version: [1, 12, 1],
            min_bootloader_version: [1, 12, 1],
            version: 3
          }
        ]
      }
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t1b1/bitcoinonly/t1b1-1.10.0-bitcoinonly.json
var require_t1b1_1_10_0_bitcoinonly = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t1b1/bitcoinonly/t1b1-1.10.0-bitcoinonly.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [1, 10, 0],
      min_bridge_version: [2, 0, 25],
      min_bootloader_version: [1, 5, 0],
      min_firmware_version: [1, 6, 2],
      bootloader_version: [1, 10, 0],
      firmware_revision: "f4424ece1ccb7fc0d6cad00ff840fac287a34f07",
      translations: {},
      url: "firmware/t1b1/trezor-t1b1-1.10.0-bitcoinonly.bin",
      fingerprint: "20a4068c34ff6dd7d8c510350409376cf7ea744ba668fdcf16da8f1d81fed289",
      changelog: "* Bootloader 1.10.0.\n* Allow decreasing the output value in RBF transactions.\n* Support long PIN of up to 50 digits.\n* Display nLockTime in human-readable form."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t1b1/bitcoinonly/t1b1-1.10.1-bitcoinonly.json
var require_t1b1_1_10_1_bitcoinonly = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t1b1/bitcoinonly/t1b1-1.10.1-bitcoinonly.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [1, 10, 1],
      min_bridge_version: [2, 0, 25],
      min_bootloader_version: [1, 5, 0],
      min_firmware_version: [1, 6, 2],
      bootloader_version: [1, 10, 0],
      firmware_revision: "3204fd682429eed23a82b748c05ae569c7f4481f",
      translations: {},
      url: "firmware/t1b1/trezor-t1b1-1.10.1-bitcoinonly.bin",
      fingerprint: "74227362016a8763c4d5f5b06eeb7eabe5fbd7ed05798b586cc7f4bfef50d7fe",
      changelog: "* Safety checks setting in T1."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t1b1/bitcoinonly/t1b1-1.10.2-bitcoinonly.json
var require_t1b1_1_10_2_bitcoinonly = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t1b1/bitcoinonly/t1b1-1.10.2-bitcoinonly.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [1, 10, 2],
      min_bridge_version: [2, 0, 25],
      min_bootloader_version: [1, 5, 0],
      min_firmware_version: [1, 6, 2],
      bootloader_version: [1, 10, 0],
      firmware_revision: "24bb4016388fca4b998285b95dcd408f4ed0bff6",
      translations: {},
      url: "firmware/t1b1/trezor-t1b1-1.10.2-bitcoinonly.bin",
      fingerprint: "e597b6aef5a2e817f532d27b8501f99f189e432a887877bdd3498cd3a0afc431",
      changelog: "* Security improvements."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t1b1/bitcoinonly/t1b1-1.10.3-bitcoinonly.json
var require_t1b1_1_10_3_bitcoinonly = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t1b1/bitcoinonly/t1b1-1.10.3-bitcoinonly.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [1, 10, 3],
      min_bridge_version: [2, 0, 25],
      min_bootloader_version: [1, 5, 0],
      min_firmware_version: [1, 6, 2],
      bootloader_version: [1, 10, 0],
      firmware_revision: "9276b1702361f70e094286e2f89e919d8a230d5c",
      translations: {},
      url: "firmware/t1b1/trezor-t1b1-1.10.3-bitcoinonly.bin",
      fingerprint: "d1143d2cba9c7dba4d57703d2b7da87859d8668472ffc651177ead6b94e89117",
      changelog: "* Small code improvements"
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t1b1/bitcoinonly/t1b1-1.10.4-bitcoinonly.json
var require_t1b1_1_10_4_bitcoinonly = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t1b1/bitcoinonly/t1b1-1.10.4-bitcoinonly.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [1, 10, 4],
      min_bridge_version: [2, 0, 25],
      min_bootloader_version: [1, 5, 0],
      min_firmware_version: [1, 6, 2],
      bootloader_version: [1, 10, 0],
      firmware_revision: "595b14254c1abb2be3f69e42c7932f1eca8cf1b1",
      translations: {},
      url: "firmware/t1b1/trezor-t1b1-1.10.4-bitcoinonly.bin",
      fingerprint: "30d858b022e218f27854f071d568e5a696c937f1316d83b93aadcd178f3b0a38",
      changelog: "* Support Taproot.\n* Show address confirmation in SignMessage."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t1b1/bitcoinonly/t1b1-1.10.5-bitcoinonly.json
var require_t1b1_1_10_5_bitcoinonly = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t1b1/bitcoinonly/t1b1-1.10.5-bitcoinonly.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [1, 10, 5],
      min_bridge_version: [2, 0, 25],
      min_bootloader_version: [1, 5, 0],
      min_firmware_version: [1, 6, 2],
      bootloader_version: [1, 10, 0],
      firmware_revision: "3f12742669bd782cac374a1750d517f4fd88c43b",
      translations: {},
      url: "firmware/t1b1/trezor-t1b1-1.10.5-bitcoinonly.bin",
      fingerprint: "1d319f643fe2ba5c247b178c7f73b989ab4e43d914a60468566ee7cc5bb9dde0",
      changelog: "* Small code improvements."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t1b1/bitcoinonly/t1b1-1.11.1-bitcoinonly.json
var require_t1b1_1_11_1_bitcoinonly = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t1b1/bitcoinonly/t1b1-1.11.1-bitcoinonly.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [1, 11, 1],
      min_bridge_version: [2, 0, 25],
      min_bootloader_version: [1, 5, 0],
      min_firmware_version: [1, 6, 2],
      bootloader_version: [1, 10, 0],
      firmware_revision: "85a26d2c9593bcdf858c2d718d79951ca927a0c3",
      translations: {},
      url: "firmware/t1b1/trezor-t1b1-1.11.1-bitcoinonly.bin",
      fingerprint: "8e17b95b5d302f203de3a8fe27959efd25e3d5140ac9b5e60412f1b3f624995d",
      changelog: "* Support Electrum signatures in VerifyMessage.\n* Trezor will refuse to sign UTXOs that do not match the provided derivation path (e.g., transactions belonging to a different wallet, or synthetic transaction inputs)."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t1b1/bitcoinonly/t1b1-1.11.2-bitcoinonly.json
var require_t1b1_1_11_2_bitcoinonly = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t1b1/bitcoinonly/t1b1-1.11.2-bitcoinonly.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [1, 11, 2],
      min_bridge_version: [2, 0, 25],
      min_bootloader_version: [1, 5, 0],
      min_firmware_version: [1, 6, 2],
      bootloader_version: [1, 11, 0],
      firmware_revision: "0d87b55ba4fed7eecc72bf2a94ee473830b095e9",
      translations: {},
      url: "firmware/t1b1/trezor-t1b1-1.11.2-bitcoinonly.bin",
      fingerprint: "7e51546f4411ecf44688c681ada72a18495fd08e91f3a0429ab91bc4415b362a",
      changelog: "* Show the fee rate on the signing confirmation screen. \n* Show thousands separator when displaying large amounts \n* Fix potential security issues in recovery workflow. \n* Fix key extraction vulnerability in Cothority Collective Signing (CoSi). \n* Fix nonce bias in CoSi signing."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t1b1/bitcoinonly/t1b1-1.12.1-bitcoinonly.json
var require_t1b1_1_12_1_bitcoinonly = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t1b1/bitcoinonly/t1b1-1.12.1-bitcoinonly.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [1, 12, 1],
      min_bridge_version: [2, 0, 25],
      min_bootloader_version: [1, 12, 0],
      min_firmware_version: [1, 12, 0],
      bootloader_version: [1, 12, 1],
      firmware_revision: "1eb0eb9d91b092e571aac63db4ebff2a07fd8a1f",
      translations: {},
      url: "firmware/t1b1/trezor-t1b1-1.12.1-bitcoinonly.bin",
      fingerprint: "985fb6a8c87f7547fb810f6c4a8331ebf19c677445810358778eb21eca78a181",
      changelog: `* Fee rate shown when replacing transaction.
* Ledger Live legacy derivation path m/44'/coin_type'/0'/account is now supported.
* SLIP-0019 proofs of ownership for native SegWit implemented.
* SLIP-0025 coinjoin accounts implemented for testing purposes.
* Bech32 addresses now not converting to uppercase in QR code to increase compatibility.
* Decimals of fee rate extended to 2 digits.
* Only "sat" displayed instead of "sat BTC".
* Bootloader 1.12.1. included.`
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t1b1/bitcoinonly/t1b1-1.13.0-bitcoinonly.json
var require_t1b1_1_13_0_bitcoinonly = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t1b1/bitcoinonly/t1b1-1.13.0-bitcoinonly.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [1, 13, 0],
      min_bridge_version: [2, 0, 25],
      min_bootloader_version: [1, 12, 0],
      min_firmware_version: [1, 12, 0],
      bootloader_version: [1, 12, 1],
      firmware_revision: "592590cf66a9b62dfeee7e4d2afb6e01005e5b2c",
      translations: {},
      url: "firmware/t1b1/trezor-t1b1-1.13.0-bitcoinonly.bin",
      fingerprint: "253042fb209c78e02482c645b16cc9894c19124e9c9c0c1051b3c68b6e7c700b",
      changelog: "* Multisig-related changes.\n* Reworked PIN processing.\n* Allow showing XPUB using a QR code."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t1b1/bitcoinonly/t1b1-1.13.1-bitcoinonly.json
var require_t1b1_1_13_1_bitcoinonly = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t1b1/bitcoinonly/t1b1-1.13.1-bitcoinonly.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [1, 13, 1],
      min_bridge_version: [2, 0, 25],
      min_bootloader_version: [1, 12, 0],
      min_firmware_version: [1, 12, 0],
      bootloader_version: [1, 12, 1],
      firmware_revision: "2a65d18200580005dc419b9569ed97fae440806a",
      translations: {},
      url: "firmware/t1b1/trezor-t1b1-1.13.1-bitcoinonly.bin",
      fingerprint: "f27095f2e08278a209567e254b9921f6e34b28a9c0fc702a268f210e23057c27",
      changelog: "*"
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t1b1/bitcoinonly/t1b1-1.8.3-bitcoinonly.json
var require_t1b1_1_8_3_bitcoinonly = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t1b1/bitcoinonly/t1b1-1.8.3-bitcoinonly.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [1, 8, 3],
      min_bridge_version: [2, 0, 25],
      min_bootloader_version: [1, 5, 0],
      min_firmware_version: [1, 6, 2],
      bootloader_version: [1, 8, 0],
      firmware_revision: "df0963ec48f01f3d07ffca556e21ff0070cab099",
      translations: {},
      url: "firmware/t1b1/trezor-t1b1-1.8.3-bitcoinonly.bin",
      fingerprint: "13d6089cb935f453eaddbfe193e0ab37924a7aa66f684355a4fe5c660c18247a",
      changelog: "* Small code improvements"
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t1b1/bitcoinonly/t1b1-1.9.0-bitcoinonly.json
var require_t1b1_1_9_0_bitcoinonly = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t1b1/bitcoinonly/t1b1-1.9.0-bitcoinonly.json"(exports2, module2) {
    module2.exports = {
      required: true,
      version: [1, 9, 0],
      min_bridge_version: [2, 0, 25],
      min_bootloader_version: [1, 5, 0],
      min_firmware_version: [1, 6, 2],
      bootloader_version: [1, 8, 0],
      firmware_revision: "0b7a8449f8dd003fc415262b05102d113247d3de",
      translations: {},
      url: "firmware/t1b1/trezor-t1b1-1.9.0-bitcoinonly.bin",
      fingerprint: "93a670dd20d044bf76cfce6eecd2a85918acdebe616229dbb31250fd03a33870",
      changelog: "* Introduce Wipe Code\n* Introduce passphrase cache"
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t1b1/bitcoinonly/t1b1-1.9.1-bitcoinonly.json
var require_t1b1_1_9_1_bitcoinonly = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t1b1/bitcoinonly/t1b1-1.9.1-bitcoinonly.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [1, 9, 1],
      min_bridge_version: [2, 0, 25],
      min_bootloader_version: [1, 5, 0],
      min_firmware_version: [1, 6, 2],
      bootloader_version: [1, 8, 0],
      firmware_revision: "c6b2580cd245ee924507f45e9675f857a3d78768",
      translations: {},
      url: "firmware/t1b1/trezor-t1b1-1.9.1-bitcoinonly.bin",
      fingerprint: "ee743e3bd1e424ceb45a1d877a5422e7af449706f636c459cdd8bb0d4796cba5",
      changelog: "* Refactor Bitcoin signing"
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t1b1/bitcoinonly/t1b1-1.9.2-bitcoinonly.json
var require_t1b1_1_9_2_bitcoinonly = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t1b1/bitcoinonly/t1b1-1.9.2-bitcoinonly.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [1, 9, 2],
      min_bridge_version: [2, 0, 25],
      min_bootloader_version: [1, 5, 0],
      min_firmware_version: [1, 6, 2],
      bootloader_version: [1, 8, 0],
      firmware_revision: "cde8f31ec2ddcb7d35e36edbcf8a71dda983a9ea",
      translations: {},
      url: "firmware/t1b1/trezor-t1b1-1.9.2-bitcoinonly.bin",
      fingerprint: "2762c0ff78c96e23d1d348330e0a3cdf45d83c8fc8c2d48853b7cb602ddc19bb",
      changelog: "* Adds support for multiple change outputs in outgoing transactions."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t1b1/bitcoinonly/t1b1-1.9.3-bitcoinonly.json
var require_t1b1_1_9_3_bitcoinonly = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t1b1/bitcoinonly/t1b1-1.9.3-bitcoinonly.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [1, 9, 3],
      min_bridge_version: [2, 0, 25],
      min_bootloader_version: [1, 5, 0],
      min_firmware_version: [1, 6, 2],
      bootloader_version: [1, 8, 0],
      firmware_revision: "0d5f00668fb3d1c093ff3c879311a91d3a7175c8",
      translations: {},
      url: "firmware/t1b1/trezor-t1b1-1.9.3-bitcoinonly.bin",
      fingerprint: "76f899d60ffd9685713cb420d017565c05c43aadaf0e62b645a50a8db69afef6",
      changelog: "* Improves the Passphrase feature by showing the entered passphrase on the Trezor screen before opening the wallet.\n* Fixes smaller issues in the user interface."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t1b1/bitcoinonly/t1b1-1.9.4-bitcoinonly.json
var require_t1b1_1_9_4_bitcoinonly = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t1b1/bitcoinonly/t1b1-1.9.4-bitcoinonly.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [1, 9, 4],
      min_bridge_version: [2, 0, 25],
      min_bootloader_version: [1, 5, 0],
      min_firmware_version: [1, 6, 2],
      bootloader_version: [1, 8, 0],
      firmware_revision: "ffa96205fb5e22b43e7b08a3dbc3cdeee0931de3",
      translations: {},
      url: "firmware/t1b1/trezor-t1b1-1.9.4-bitcoinonly.bin",
      fingerprint: "3f73dfbcfc48f66c8814f6562524d81888230e0acd1c19b52b6e8772c6c67e7f",
      changelog: "* Replacement transaction signing for replace-by-fee.\n* Support for Output Descriptors export.\n* Show Ypub/Zpub correctly for multisig GetAddress.\n* Show amounts in mBTC, uBTC and sat denominations."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t1b1/universal/t1b1-1.10.0-universal.json
var require_t1b1_1_10_0_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t1b1/universal/t1b1-1.10.0-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [1, 10, 0],
      min_bridge_version: [2, 0, 25],
      min_bootloader_version: [1, 5, 0],
      min_firmware_version: [1, 6, 2],
      bootloader_version: [1, 10, 0],
      firmware_revision: "f4424ece1ccb7fc0d6cad00ff840fac287a34f07",
      translations: {},
      url: "firmware/t1b1/trezor-t1b1-1.10.0.bin",
      fingerprint: "595ba3e8e887cba185e03098f9538e18164f72f9fc82445e691abcd03e5cf0a4",
      changelog: "* Bootloader 1.10.0.\n* Allow decreasing the output value in RBF transactions.\n* Support long PIN of up to 50 digits.\n* Display nLockTime in human-readable form."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t1b1/universal/t1b1-1.10.1-universal.json
var require_t1b1_1_10_1_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t1b1/universal/t1b1-1.10.1-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [1, 10, 1],
      min_bridge_version: [2, 0, 25],
      min_bootloader_version: [1, 5, 0],
      min_firmware_version: [1, 6, 2],
      bootloader_version: [1, 10, 0],
      firmware_revision: "3204fd682429eed23a82b748c05ae569c7f4481f",
      translations: {},
      url: "firmware/t1b1/trezor-t1b1-1.10.1.bin",
      fingerprint: "36400becf1cdddec22b8150d56ff59eef76d37fef60dc465a6f82b4858903886",
      changelog: "* Safety checks setting in T1."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t1b1/universal/t1b1-1.10.2-universal.json
var require_t1b1_1_10_2_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t1b1/universal/t1b1-1.10.2-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [1, 10, 2],
      min_bridge_version: [2, 0, 25],
      min_bootloader_version: [1, 5, 0],
      min_firmware_version: [1, 6, 2],
      bootloader_version: [1, 10, 0],
      firmware_revision: "24bb4016388fca4b998285b95dcd408f4ed0bff6",
      translations: {},
      url: "firmware/t1b1/trezor-t1b1-1.10.2.bin",
      fingerprint: "99707b90a504f7e402f26c3d59cbbdacbc52754cebcce79cc47be528fc889338",
      changelog: "* Security improvements."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t1b1/universal/t1b1-1.10.3-universal.json
var require_t1b1_1_10_3_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t1b1/universal/t1b1-1.10.3-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [1, 10, 3],
      min_bridge_version: [2, 0, 25],
      min_bootloader_version: [1, 5, 0],
      min_firmware_version: [1, 6, 2],
      bootloader_version: [1, 10, 0],
      firmware_revision: "9276b1702361f70e094286e2f89e919d8a230d5c",
      translations: {},
      url: "firmware/t1b1/trezor-t1b1-1.10.3.bin",
      fingerprint: "bf0cc936a9afbf0a4ae7b727a2817fb69fba432d7230a0ff7b79b4a73b845197",
      changelog: "* Remove Lisk.\n* Re-enabled Firo support.\n* Stricter protobuf field handling in Stellar."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t1b1/universal/t1b1-1.10.4-universal.json
var require_t1b1_1_10_4_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t1b1/universal/t1b1-1.10.4-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [1, 10, 4],
      min_bridge_version: [2, 0, 25],
      min_bootloader_version: [1, 5, 0],
      min_firmware_version: [1, 6, 2],
      bootloader_version: [1, 10, 0],
      firmware_revision: "595b14254c1abb2be3f69e42c7932f1eca8cf1b1",
      translations: {},
      url: "firmware/t1b1/trezor-t1b1-1.10.4.bin",
      fingerprint: "74dfdfb9addb9d90fedb2c88794b7236af521d21ef0096f9080c25b597c8af86",
      changelog: "* Support Taproot.\n* Show address confirmation in SignMessage.\n* Support for Ethereum EIP-1559 transactions."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t1b1/universal/t1b1-1.10.5-universal.json
var require_t1b1_1_10_5_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t1b1/universal/t1b1-1.10.5-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [1, 10, 5],
      min_bridge_version: [2, 0, 25],
      min_bootloader_version: [1, 5, 0],
      min_firmware_version: [1, 6, 2],
      bootloader_version: [1, 10, 0],
      firmware_revision: "3f12742669bd782cac374a1750d517f4fd88c43b",
      translations: {},
      url: "firmware/t1b1/trezor-t1b1-1.10.5.bin",
      fingerprint: "7619fcc73c43ca8a3e6aad3dc3eb6551fed05bb218340efe01a02bb96e9f346b",
      changelog: "* Support for blindly signing EIP-712 data."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t1b1/universal/t1b1-1.11.1-universal.json
var require_t1b1_1_11_1_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t1b1/universal/t1b1-1.11.1-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [1, 11, 1],
      min_bridge_version: [2, 0, 25],
      min_bootloader_version: [1, 5, 0],
      min_firmware_version: [1, 6, 2],
      bootloader_version: [1, 10, 0],
      firmware_revision: "85a26d2c9593bcdf858c2d718d79951ca927a0c3",
      translations: {},
      url: "firmware/t1b1/trezor-t1b1-1.11.1.bin",
      fingerprint: "f7c60d0b8c2853afd576867c6562aba5ea52bdc2ce34d0dbb8751f52867c3665",
      changelog: "* Support Electrum signatures in VerifyMessage.\n* Trezor will refuse to sign UTXOs that do not match the provided derivation path (e.g., transactions belonging to a different wallet, or synthetic transaction inputs).\n* Zcash v5 transaction format."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t1b1/universal/t1b1-1.11.2-universal.json
var require_t1b1_1_11_2_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t1b1/universal/t1b1-1.11.2-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [1, 11, 2],
      min_bridge_version: [2, 0, 25],
      min_bootloader_version: [1, 5, 0],
      min_firmware_version: [1, 6, 2],
      bootloader_version: [1, 11, 0],
      firmware_revision: "0d87b55ba4fed7eecc72bf2a94ee473830b095e9",
      translations: {},
      url: "firmware/t1b1/trezor-t1b1-1.11.2.bin",
      fingerprint: "d8b55b68dfe8a8449ce7391e841073ef5d29349638d85b750508bbef5d2de5ec",
      changelog: "* Show the fee rate on the signing confirmation screen. \n* Show thousands separator when displaying large amounts \n* Fix potential security issues in recovery workflow. \n* Fix key extraction vulnerability in Cothority Collective Signing (CoSi). \n* Fix nonce bias in CoSi signing."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t1b1/universal/t1b1-1.12.1-universal.json
var require_t1b1_1_12_1_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t1b1/universal/t1b1-1.12.1-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [1, 12, 1],
      min_bridge_version: [2, 0, 25],
      min_bootloader_version: [1, 12, 0],
      min_firmware_version: [1, 12, 0],
      bootloader_version: [1, 12, 1],
      firmware_revision: "1eb0eb9d91b092e571aac63db4ebff2a07fd8a1f",
      translations: {},
      url: "firmware/t1b1/trezor-t1b1-1.12.1.bin",
      fingerprint: "3c694191f5b66a65cb5bb209adbf113cb40209e644b77162ba996bb7ee8f382b",
      changelog: `* Fee rate shown when replacing transaction.
* Ledger Live legacy derivation path m/44'/coin_type'/0'/account is now supported.
* SLIP-0019 proofs of ownership for native SegWit implemented.
* SLIP-0025 coinjoin accounts implemented for testing purposes.
* Bech32 addresses now not converting to uppercase in QR code to increase compatibility.
* Decimals of fee rate extended to 2 digits.
* Only "sat" displayed instead of "sat BTC".
* Bootloader 1.12.1. included.
* Stellar addresses now shown in full + as a QR code.
* Ethereum fees now wrapped to the next line when needed.`
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t1b1/universal/t1b1-1.13.0-universal.json
var require_t1b1_1_13_0_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t1b1/universal/t1b1-1.13.0-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [1, 13, 0],
      min_bridge_version: [2, 0, 25],
      min_bootloader_version: [1, 12, 0],
      min_firmware_version: [1, 12, 0],
      bootloader_version: [1, 12, 1],
      firmware_revision: "592590cf66a9b62dfeee7e4d2afb6e01005e5b2c",
      translations: {},
      url: "firmware/t1b1/trezor-t1b1-1.13.0.bin",
      fingerprint: "356433bd9de6cb564bf7778fc5de73c56197459523358f267e9235af9e1ce46d",
      changelog: "* Multisig-related changes.\n* Reworked PIN processing.\n* Allow showing XPUB using a QR code."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t1b1/universal/t1b1-1.13.1-universal.json
var require_t1b1_1_13_1_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t1b1/universal/t1b1-1.13.1-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [1, 13, 1],
      min_bridge_version: [2, 0, 25],
      min_bootloader_version: [1, 12, 0],
      min_firmware_version: [1, 12, 0],
      bootloader_version: [1, 12, 1],
      firmware_revision: "2a65d18200580005dc419b9569ed97fae440806a",
      translations: {},
      url: "firmware/t1b1/trezor-t1b1-1.13.1.bin",
      fingerprint: "f588657818ccf99b0046ede3f87eeaf17a0e6e6f1b7853344e18b846ca835328",
      changelog: "* Clear sign ETH staking transactions on Everstake pool.\n* Use\xA0GWei\xA0when formatting large ETH amounts."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t1b1/universal/t1b1-1.3.6-universal.json
var require_t1b1_1_3_6_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t1b1/universal/t1b1-1.3.6-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [1, 3, 6],
      min_bridge_version: [1, 1, 5],
      min_bootloader_version: [1, 0, 0],
      min_firmware_version: [1, 0, 0],
      firmware_revision: "36b9d80120348700264bba518a533d4f82d79cbd",
      translations: {},
      url: "firmware/t1b1/trezor-t1b1-1.3.6.bin",
      fingerprint: "03b559a758961b2bfd4443e6c36c10025268cf033ecd376fdd7a79ff658bf511",
      changelog: "* Enable advanced transactions such as ones with REPLACE-BY-FEE and CHECKLOCKTIMEVERIFY\n* Fix message signing for altcoins\n* Message verification now shows address\n* Enable GPG signing support\n* Enable Ed25519 curve (for SSH and GPG)\n* Use separate deterministic hierarchy for NIST256P1 and Ed25519 curves\n* Users using SSH already need to regenerate their keys using the new firmware!!!"
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t1b1/universal/t1b1-1.4.0-universal.json
var require_t1b1_1_4_0_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t1b1/universal/t1b1-1.4.0-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [1, 4, 0],
      min_bridge_version: [1, 1, 5],
      min_bootloader_version: [1, 0, 0],
      min_firmware_version: [1, 0, 0],
      firmware_revision: "e0e190b3dc29bcb0f6ab9699c439fe7bfbcde370",
      translations: {},
      url: "firmware/t1b1/trezor-t1b1-1.4.0.bin",
      fingerprint: "5764715dbcf8ed88bc0ae1c2f715277f22b67f26c15e1f7543b2b44913b5c255",
      changelog: "* U2F support\n* Ethereum support\n* GPG decryption support\n* Zcash support"
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t1b1/universal/t1b1-1.4.1-universal.json
var require_t1b1_1_4_1_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t1b1/universal/t1b1-1.4.1-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [1, 4, 1],
      min_bridge_version: [1, 1, 5],
      min_bootloader_version: [1, 0, 0],
      min_firmware_version: [1, 0, 0],
      firmware_revision: "ae37ea8a9a2ab96e60714451a7a9502e0ef1ffc9",
      translations: {},
      url: "firmware/t1b1/trezor-t1b1-1.4.1.bin",
      fingerprint: "92636493f76f352213e681bbc26eb3a8844f7b8a3044214b65c3c2c10a0f788c",
      changelog: "* Support for Zcash JoinSplit transactions\n* Enable device lock after 10 minutes of inactivity\n* Enable device lock by pressing left button for 2 seconds\n* Confirm dialog for U2F counter change"
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t1b1/universal/t1b1-1.4.2-universal.json
var require_t1b1_1_4_2_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t1b1/universal/t1b1-1.4.2-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [1, 4, 2],
      min_bridge_version: [1, 1, 5],
      min_bootloader_version: [1, 0, 0],
      min_firmware_version: [1, 0, 0],
      firmware_revision: "14399f100e862608c24a7e214e9ce971c4d32457",
      translations: {},
      url: "firmware/t1b1/trezor-t1b1-1.4.2.bin",
      fingerprint: "a4b39f01bd134d01d7534821445bf779dbe6c25f0fcf7c7cb285a79b17f25e0a",
      changelog: "* New Matrix-based recovery method\n* Minor Ethereum fixes (including EIP-155 replay protection)\n* Minor USB, U2F and GPG fixes"
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t1b1/universal/t1b1-1.5.0-universal.json
var require_t1b1_1_5_0_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t1b1/universal/t1b1-1.5.0-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [1, 5, 0],
      min_bridge_version: [1, 1, 5],
      min_bootloader_version: [1, 0, 0],
      min_firmware_version: [1, 0, 0],
      firmware_revision: "6b74139b4530a4687b4a317b8b08f4329704efc4",
      translations: {},
      url: "firmware/t1b1/trezor-t1b1-1.5.0.bin",
      fingerprint: "c4eddafd29b580d8482cda68e61bdcf1740d77520ef3a603758646bbffe957ea",
      changelog: "* Enable Segwit for Testnet and Litecoin\n* Enable ERC-20 tokens for Ethereum chains"
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t1b1/universal/t1b1-1.5.1-universal.json
var require_t1b1_1_5_1_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t1b1/universal/t1b1-1.5.1-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [1, 5, 1],
      min_bridge_version: [1, 1, 5],
      min_bootloader_version: [1, 0, 0],
      min_firmware_version: [1, 0, 0],
      firmware_revision: "f0d2e7a37142a6d4c7f7e45a6e4427e53123d614",
      translations: {},
      url: "firmware/t1b1/trezor-t1b1-1.5.1.bin",
      fingerprint: "1c1fa9802cbd6a947a4f3e78f209d3efe49eb4abbacb101bbc3a0a709c742707",
      changelog: '* Wipe storage after 16 wrong PIN attempts\n* Enable Segwit for Bitcoin\n* Bcash aka Bitcoin Cash support\n* Message signing/verification for Ethereum and Segwit\n* Make address dialog nicer (switch text/QR via button)\n* Use checksum for Ethereum addresses\n* Add more ERC-20 tokens, handle unrecognized ERC-20 tokens\n* Allow "dry run" recovery procedure\n* Allow separated backup procedure'
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t1b1/universal/t1b1-1.5.2-universal.json
var require_t1b1_1_5_2_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t1b1/universal/t1b1-1.5.2-universal.json"(exports2, module2) {
    module2.exports = {
      required: true,
      version: [1, 5, 2],
      min_bridge_version: [1, 1, 5],
      min_bootloader_version: [1, 0, 0],
      min_firmware_version: [1, 0, 0],
      firmware_revision: "e4cc08775fc9c204f295442f930326eb7877f2d4",
      translations: {},
      url: "firmware/t1b1/trezor-t1b1-1.5.2.bin",
      fingerprint: "99f71379dec893fbe109832a1150f338660be686fe6b4903ff10ff751ba4e448",
      changelog: "* clean memory on start\n* fix storage import from older versions"
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t1b1/universal/t1b1-1.6.0-universal.json
var require_t1b1_1_6_0_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t1b1/universal/t1b1-1.6.0-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [1, 6, 0],
      min_bridge_version: [1, 1, 5],
      min_bootloader_version: [1, 0, 0],
      min_firmware_version: [1, 0, 0],
      firmware_revision: "723cf295a72ce07b96047901bb8c2e461a2488f8",
      translations: {},
      url: "firmware/t1b1/trezor-t1b1-1.6.0.bin",
      fingerprint: "e40f6ce12724c2d24234a7752953b88fd9ec28b3ec72c0dbfa280095a67a06ca",
      changelog: "* Native SegWit (Bech32) address support\n* Show recognized BIP44/BIP49 paths in GetAddress dialog\n* NEM support\n* Expanse and UBIQ chains support\n* Bitcoin Gold, DigiByte, Monacoin support\n* Ed25519 collective signatures (CoSi) support"
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t1b1/universal/t1b1-1.6.1-universal.json
var require_t1b1_1_6_1_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t1b1/universal/t1b1-1.6.1-universal.json"(exports2, module2) {
    module2.exports = {
      required: true,
      version: [1, 6, 1],
      min_bridge_version: [1, 1, 5],
      min_bootloader_version: [1, 0, 0],
      min_firmware_version: [1, 0, 0],
      bootloader_version: [1, 4, 0],
      firmware_revision: "9588e8f2736b60916f51e470deb18f55112a6ebc",
      translations: {},
      url: "firmware/t1b1/trezor-t1b1-1.6.1.bin",
      fingerprint: "83c3190a94e524ac83a1704eb584a2ab53f8a65a893b1ab52e7135812857c807",
      changelog: "* Use fixed-width font for addresses\n* Lots of under-the-hood improvements\n* Fixed issue with write-protection settings"
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t1b1/universal/t1b1-1.6.2-universal.json
var require_t1b1_1_6_2_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t1b1/universal/t1b1-1.6.2-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [1, 6, 2],
      min_bridge_version: [1, 1, 5],
      min_bootloader_version: [1, 0, 0],
      min_firmware_version: [1, 0, 0],
      bootloader_version: [1, 5, 0],
      firmware_revision: "c9113fd3f5fcd78e9e560dbac75ed5aae359eb2d",
      translations: {},
      url: "firmware/t1b1/trezor-t1b1-1.6.2.bin",
      fingerprint: "d31304f793854e343df6ccf1804f7e2abf48ddcd82a379ca2d3711d54127e138",
      changelog: "* Add possibility to set custom auto-lock delay\n* Bitcoin Cash cashaddr support\n* Zcash Overwinter hardfork support\n* Support for new coins:\n  - Decred, Bitcoin Private, Fujicoin, Groestlcoin, Vertcoin, Viacoin, Zcoin\n* Support for new Ethereum networks:\n  - EOS Classic, Ethereum Social, Ellaism, Callisto, EtherGem, Wanchain\n* Support for 500+ new Ethereum tokens"
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t1b1/universal/t1b1-1.6.3-universal.json
var require_t1b1_1_6_3_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t1b1/universal/t1b1-1.6.3-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [1, 6, 3],
      min_bridge_version: [1, 1, 5],
      min_bootloader_version: [1, 0, 0],
      min_firmware_version: [1, 0, 0],
      bootloader_version: [1, 5, 1],
      firmware_revision: "ef86786ff750351ec454c7bae33b4966cfa862d7",
      translations: {},
      url: "firmware/t1b1/trezor-t1b1-1.6.3.bin",
      fingerprint: "e8dbb4b7fe8384afd4c99790277c2f2f366a1a0f3957aa3545c75371a99a8fcc",
      changelog: "* Implement RSKIP-60 Ethereum checksum encoding\n* Add support for new Ethereum networks (ESN, AKA, ETHO, MUSI, PIRL, ATH, GO)\n* Add support for new 80 Ethereum tokens\n* Improve MPU configuration"
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t1b1/universal/t1b1-1.7.1-universal.json
var require_t1b1_1_7_1_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t1b1/universal/t1b1-1.7.1-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [1, 7, 1],
      min_bridge_version: [2, 0, 25],
      min_bootloader_version: [1, 5, 0],
      min_firmware_version: [1, 6, 2],
      bootloader_version: [1, 6, 0],
      firmware_revision: "83f1906cad648c560cd560577317046606398630",
      translations: {},
      url: "firmware/t1b1/trezor-t1b1-1.7.1.bin",
      fingerprint: "1c303c50bb45d3f35da9e962d8405d0b8e89cc45e122496a48fce3995fa71d48",
      changelog: "* Switch from HID to WebUSB\n* Add support for Stellar\n* Add support for Lisk\n* Add support for Zcash Sapling hardfork\n* Implement seedless setup"
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t1b1/universal/t1b1-1.7.2-universal.json
var require_t1b1_1_7_2_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t1b1/universal/t1b1-1.7.2-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [1, 7, 2],
      min_bridge_version: [2, 0, 25],
      min_bootloader_version: [1, 5, 0],
      min_firmware_version: [1, 6, 2],
      bootloader_version: [1, 6, 0],
      firmware_revision: "0b26c529ec49daf584f322f3ef959c79694c8cf5",
      translations: {},
      url: "firmware/t1b1/trezor-t1b1-1.7.2.bin",
      fingerprint: "4d5c7ac191dba315b2433af27c187925fb713d06984cc6f566231d809dd8d370",
      changelog: "* Add support for OMNI layer: OMNI/MAID/USDT\n* U2F fixes\n* Don't ask for PIN if it has been just set"
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t1b1/universal/t1b1-1.7.3-universal.json
var require_t1b1_1_7_3_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t1b1/universal/t1b1-1.7.3-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [1, 7, 3],
      min_bridge_version: [2, 0, 25],
      min_bootloader_version: [1, 5, 0],
      min_firmware_version: [1, 6, 2],
      bootloader_version: [1, 6, 1],
      firmware_revision: "f641e798f91a15c3b09e8dc6a163195dd56f86d2",
      translations: {},
      url: "firmware/t1b1/trezor-t1b1-1.7.3.bin",
      fingerprint: "10acc6aa4f24aff36627473b98c23dc4f6d0220d33bc1e09cb572f02410ffdaf",
      changelog: "* Fix USB issue on some Windows 10 installations"
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t1b1/universal/t1b1-1.8.0-universal.json
var require_t1b1_1_8_0_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t1b1/universal/t1b1-1.8.0-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [1, 8, 0],
      min_bridge_version: [2, 0, 25],
      min_bootloader_version: [1, 5, 0],
      min_firmware_version: [1, 6, 2],
      bootloader_version: [1, 8, 0],
      firmware_revision: "964a622bb512aa85cfcc3e451fc70729cc15bb4f",
      translations: {},
      url: "firmware/t1b1/trezor-t1b1-1.8.0.bin",
      fingerprint: "d65f0c07a6a9c53d8b5287798eb53154b33f9e87cd38a3701970e3d0a750a659",
      changelog: "* Security improvements\n* Upgraded to new storage format\n* Stellar and NEM fixes\n* New coins: ATS, KMD, XPM, XSN, ZCL\n* New ETH tokens"
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t1b1/universal/t1b1-1.8.1-universal.json
var require_t1b1_1_8_1_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t1b1/universal/t1b1-1.8.1-universal.json"(exports2, module2) {
    module2.exports = {
      required: true,
      version: [1, 8, 1],
      min_bridge_version: [2, 0, 25],
      min_bootloader_version: [1, 5, 0],
      min_firmware_version: [1, 6, 2],
      bootloader_version: [1, 8, 0],
      firmware_revision: "0a6a5f85729e663fbeae5ce9e5745918ff6f9d5d",
      translations: {},
      url: "firmware/t1b1/trezor-t1b1-1.8.1.bin",
      fingerprint: "019e849c1eb285a03a92bbad6d18a328af3b4dc6999722ebb47677b403a4cd16",
      changelog: "* Fix fault when using the device with no PIN* Fix OMNI transactions parsing"
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t1b1/universal/t1b1-1.8.2-universal.json
var require_t1b1_1_8_2_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t1b1/universal/t1b1-1.8.2-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [1, 8, 2],
      min_bridge_version: [2, 0, 25],
      min_bootloader_version: [1, 5, 0],
      min_firmware_version: [1, 6, 2],
      bootloader_version: [1, 8, 0],
      firmware_revision: "3c19e3167d69902305a27f10e43abb5fc7a0254d",
      translations: {},
      url: "firmware/t1b1/trezor-t1b1-1.8.2.bin",
      fingerprint: "909742eddcffdc72ca854557962ecad90e97585770f514170abe7a691b0c6eb1",
      changelog: "* Security improvements\n* Fix display of non-divisible OMNI amounts"
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t1b1/universal/t1b1-1.8.3-universal.json
var require_t1b1_1_8_3_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t1b1/universal/t1b1-1.8.3-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [1, 8, 3],
      min_bridge_version: [2, 0, 25],
      min_bootloader_version: [1, 5, 0],
      min_firmware_version: [1, 6, 2],
      bootloader_version: [1, 8, 0],
      firmware_revision: "df0963ec48f01f3d07ffca556e21ff0070cab099",
      translations: {},
      url: "firmware/t1b1/trezor-t1b1-1.8.3.bin",
      fingerprint: "496aecfab867504b2283a9f057a0b2fd9d17970a22c81f6ad74232e7b914ce68",
      changelog: "* Small code improvements"
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t1b1/universal/t1b1-1.9.0-universal.json
var require_t1b1_1_9_0_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t1b1/universal/t1b1-1.9.0-universal.json"(exports2, module2) {
    module2.exports = {
      required: true,
      version: [1, 9, 0],
      min_bridge_version: [2, 0, 25],
      min_bootloader_version: [1, 5, 0],
      min_firmware_version: [1, 6, 2],
      bootloader_version: [1, 8, 0],
      firmware_revision: "0b7a8449f8dd003fc415262b05102d113247d3de",
      translations: {},
      url: "firmware/t1b1/trezor-t1b1-1.9.0.bin",
      fingerprint: "1f40d1e68f9d182888b5b60da5209eff047ec68fcc96a5c9b61b0e55dd07d458",
      changelog: "* Introduce Wipe Code\n* Introduce passphrase cache"
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t1b1/universal/t1b1-1.9.1-universal.json
var require_t1b1_1_9_1_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t1b1/universal/t1b1-1.9.1-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [1, 9, 1],
      min_bridge_version: [2, 0, 25],
      min_bootloader_version: [1, 5, 0],
      min_firmware_version: [1, 6, 2],
      bootloader_version: [1, 8, 0],
      firmware_revision: "c6b2580cd245ee924507f45e9675f857a3d78768",
      translations: {},
      url: "firmware/t1b1/trezor-t1b1-1.9.1.bin",
      fingerprint: "30cde253c46d4fc705f98634a35d06a494cf2a36824622a9c6a573e07f14292d",
      changelog: "* Refactor Bitcoin signing"
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t1b1/universal/t1b1-1.9.2-universal.json
var require_t1b1_1_9_2_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t1b1/universal/t1b1-1.9.2-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [1, 9, 2],
      min_bridge_version: [2, 0, 25],
      min_bootloader_version: [1, 5, 0],
      min_firmware_version: [1, 6, 2],
      bootloader_version: [1, 8, 0],
      firmware_revision: "cde8f31ec2ddcb7d35e36edbcf8a71dda983a9ea",
      translations: {},
      url: "firmware/t1b1/trezor-t1b1-1.9.2.bin",
      fingerprint: "45b83acd1330ddfd5567edbae5ff8028df1c48a493f01d47cc5499ee0be9b991",
      changelog: "* Reintroduces the ability to spend pre-Overwinter (2018) funds on Zcash-like coins.\n* Adds support for multiple change outputs in outgoing transactions.\n* Adds a security check to prevent potential issues with paths used in altcoin transactions."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t1b1/universal/t1b1-1.9.3-universal.json
var require_t1b1_1_9_3_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t1b1/universal/t1b1-1.9.3-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [1, 9, 3],
      min_bridge_version: [2, 0, 25],
      min_bootloader_version: [1, 5, 0],
      min_firmware_version: [1, 6, 2],
      bootloader_version: [1, 8, 0],
      firmware_revision: "0d5f00668fb3d1c093ff3c879311a91d3a7175c8",
      translations: {},
      url: "firmware/t1b1/trezor-t1b1-1.9.3.bin",
      fingerprint: "2589f456559f813d1149be1022e62f2d48fbe28f4d02de933bd888d91035cace",
      changelog: "* Improves the Passphrase feature by showing the entered passphrase on the Trezor screen before opening the wallet.\n* Adds support for Verge (XVG).\n* Drops support for Metaverse (ETP), GINcoin (GIN), Pesetacoin (PTC), and Zel (ZEL).\n* Re-enables spending coins from Bitcoin paths (fixing some compatibility issues with Bitcoin Cash wallets).\n* Fixes smaller issues in the user interface."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t1b1/universal/t1b1-1.9.4-universal.json
var require_t1b1_1_9_4_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t1b1/universal/t1b1-1.9.4-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [1, 9, 4],
      min_bridge_version: [2, 0, 25],
      min_bootloader_version: [1, 5, 0],
      min_firmware_version: [1, 6, 2],
      bootloader_version: [1, 8, 0],
      firmware_revision: "ffa96205fb5e22b43e7b08a3dbc3cdeee0931de3",
      translations: {},
      url: "firmware/t1b1/trezor-t1b1-1.9.4.bin",
      fingerprint: "867017bd784cc4e9ce6f0875c61ea86f89b19380d54045c34608b85472998000",
      changelog: "* Replacement transaction signing for replace-by-fee.\n* Support for Output Descriptors export.\n* Show Ypub/Zpub correctly for multisig GetAddress.\n* Show amounts in mBTC, uBTC and sat denominations."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2b1/bitcoinonly/t2b1-2.6.3-bitcoinonly.json
var require_t2b1_2_6_3_bitcoinonly = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2b1/bitcoinonly/t2b1-2.6.3-bitcoinonly.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 6, 3],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 1, 1],
      min_firmware_version: [2, 6, 1],
      bootloader_version: [2, 1, 4],
      firmware_revision: "2c7cc6e0255dee2339b445b5551eaffb88dbd1b4",
      translations: {},
      url: "firmware/t2b1/trezor-t2b1-2.6.3-bitcoinonly.bin",
      fingerprint: "6aecc9d9fd137a661f38ce36713aa0889b77ec4d35d91c68e01bda225cda2850",
      changelog: "* QR Code for Extended Public Keys (XPUBs). \n* The new bootloader version 2.1.4 is now included for enhanced system performance and security. \n* The screen will now automatically turn off when the device is locked, helping to extend the life of the OLED display and save energy."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2b1/bitcoinonly/t2b1-2.6.4-bitcoinonly.json
var require_t2b1_2_6_4_bitcoinonly = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2b1/bitcoinonly/t2b1-2.6.4-bitcoinonly.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 6, 4],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 1, 1],
      min_firmware_version: [2, 6, 1],
      bootloader_version: [2, 1, 4],
      firmware_revision: "42e9ed0e09033d474dee1a560fe5870646fa440e",
      translations: {},
      url: "firmware/t2b1/trezor-t2b1-2.6.4-bitcoinonly.bin",
      fingerprint: "013d595fc621c12324afd90721c6a37d055d853f6af54d5432e27e6a425656dd",
      changelog: "* Resolved an issue related to the invalid encoding of signatures from the Optiga chip."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2b1/bitcoinonly/t2b1-2.7.0-bitcoinonly.json
var require_t2b1_2_7_0_bitcoinonly = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2b1/bitcoinonly/t2b1-2.7.0-bitcoinonly.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 7, 0],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 1, 1],
      min_firmware_version: [2, 6, 1],
      bootloader_version: [2, 1, 4],
      firmware_revision: "45e8a842a31e62a6d43d7f6ccac62a45e1198ef0",
      translations: {
        "cs-CZ": "firmware/translations/t2b1/translation-T2B1-cs-CZ-2.7.0.bin",
        "de-DE": "firmware/translations/t2b1/translation-T2B1-de-DE-2.7.0.bin",
        "es-ES": "firmware/translations/t2b1/translation-T2B1-es-ES-2.7.0.bin",
        "fr-FR": "firmware/translations/t2b1/translation-T2B1-fr-FR-2.7.0.bin"
      },
      url: "firmware/t2b1/trezor-t2b1-2.7.0-bitcoinonly.bin",
      fingerprint: "bb91489a4790b3668e2f5d574a729a0f43009510550fecb5e04c0937d355b2cf",
      changelog: "* Add translations capability. \n* Add loader to homescreen when locking the device. \n* Allow for going back to previous word in recovery process. \n* Display descriptors for BTC Taproot public keys. \n* Add missing semicolon character to the passphrase entry."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2b1/bitcoinonly/t2b1-2.7.2-bitcoinonly.json
var require_t2b1_2_7_2_bitcoinonly = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2b1/bitcoinonly/t2b1-2.7.2-bitcoinonly.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 7, 2],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 1, 1],
      min_firmware_version: [2, 6, 1],
      bootloader_version: [2, 1, 4],
      firmware_revision: "da75d8f4b67410b40a9cfd2954d183d81dd6e8e8",
      translations: {
        "cs-CZ": "firmware/translations/t2b1/translation-T2B1-cs-CZ-2.7.2.bin",
        "de-DE": "firmware/translations/t2b1/translation-T2B1-de-DE-2.7.2.bin",
        "es-ES": "firmware/translations/t2b1/translation-T2B1-es-ES-2.7.2.bin",
        "fr-FR": "firmware/translations/t2b1/translation-T2B1-fr-FR-2.7.2.bin"
      },
      url: "firmware/t2b1/trezor-t2b1-2.7.2-bitcoinonly.bin",
      fingerprint: "5b6e312430de9db6ad3a843e1ba311f8cff9c6a691c20c0e69b711451a729f40",
      changelog: "* Introducing repeated backups. \n* Multi-share backups can now have any number of shares."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2b1/bitcoinonly/t2b1-2.8.0-bitcoinonly.json
var require_t2b1_2_8_0_bitcoinonly = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2b1/bitcoinonly/t2b1-2.8.0-bitcoinonly.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 8, 0],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 1, 1],
      min_firmware_version: [2, 6, 1],
      bootloader_version: [2, 1, 4],
      firmware_revision: "dd4671a5104952ef505d28d1f9e94d1484b4607a",
      translations: {
        "cs-CZ": "firmware/translations/t2b1/translation-T2B1-cs-CZ-2.8.0.bin",
        "de-DE": "firmware/translations/t2b1/translation-T2B1-de-DE-2.8.0.bin",
        "es-ES": "firmware/translations/t2b1/translation-T2B1-es-ES-2.8.0.bin",
        "fr-FR": "firmware/translations/t2b1/translation-T2B1-fr-FR-2.8.0.bin",
        "it-IT": "firmware/translations/t2b1/translation-T2B1-it-IT-2.8.0.bin",
        "pt-BR": "firmware/translations/t2b1/translation-T2B1-pt-BR-2.8.0.bin"
      },
      url: "firmware/t2b1/trezor-t2b1-2.8.0-bitcoinonly.bin",
      fingerprint: "ae088439d44fc8643b8de28e0d7a8720cd3dbb247619f2742604bbe884542558",
      changelog: "* Removed CoSi functionality. \n* Increased Optiga read timeout to avoid spurious RSODs."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2b1/bitcoinonly/t2b1-2.8.10-bitcoinonly.json
var require_t2b1_2_8_10_bitcoinonly = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2b1/bitcoinonly/t2b1-2.8.10-bitcoinonly.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 8, 10],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 1, 1],
      min_firmware_version: [2, 6, 1],
      bootloader_version: [2, 1, 8],
      firmware_revision: "2a65d18200580005dc419b9569ed97fae440806a",
      translations: {
        "cs-CZ": "firmware/translations/t2b1/translation-T2B1-cs-CZ-2.8.10.bin",
        "de-DE": "firmware/translations/t2b1/translation-T2B1-de-DE-2.8.10.bin",
        "es-ES": "firmware/translations/t2b1/translation-T2B1-es-ES-2.8.10.bin",
        "fr-FR": "firmware/translations/t2b1/translation-T2B1-fr-FR-2.8.10.bin",
        "it-IT": "firmware/translations/t2b1/translation-T2B1-it-IT-2.8.10.bin",
        "pt-BR": "firmware/translations/t2b1/translation-T2B1-pt-BR-2.8.10.bin"
      },
      url: "firmware/t2b1/trezor-t2b1-2.8.10-bitcoinonly.bin",
      fingerprint: "5bd50bbcf6435f97b6dc46f96ad11235965cd8a78619c573c3c0aca6822e9ed2",
      changelog: '* Replaced "next page" icon with "..." ellipsis when confirming long message.\n* Allow firmware upgrade even if language change failed.'
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2b1/bitcoinonly/t2b1-2.8.7-bitcoinonly.json
var require_t2b1_2_8_7_bitcoinonly = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2b1/bitcoinonly/t2b1-2.8.7-bitcoinonly.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 8, 7],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 1, 1],
      min_firmware_version: [2, 6, 1],
      bootloader_version: [2, 1, 8],
      firmware_revision: "8a254aa8eae82f99630df63f40e4d290066a3efc",
      translations: {
        "cs-CZ": "firmware/translations/t2b1/translation-T2B1-cs-CZ-2.8.7.bin",
        "de-DE": "firmware/translations/t2b1/translation-T2B1-de-DE-2.8.7.bin",
        "es-ES": "firmware/translations/t2b1/translation-T2B1-es-ES-2.8.7.bin",
        "fr-FR": "firmware/translations/t2b1/translation-T2B1-fr-FR-2.8.7.bin",
        "it-IT": "firmware/translations/t2b1/translation-T2B1-it-IT-2.8.7.bin",
        "pt-BR": "firmware/translations/t2b1/translation-T2B1-pt-BR-2.8.7.bin"
      },
      url: "firmware/t2b1/trezor-t2b1-2.8.7-bitcoinonly.bin",
      fingerprint: "6381f8a373f9f91a3cf4000a762b8dbf553d11a4a6d433c8863b2fa9eecfd9f1",
      changelog: "* Show last typed PIN number for short period of time.\n* Multisig-related changes.\n* Included new version of bootloader (2.1.8).\n* Fix translation of the 'Enable labeling' screen."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2b1/bitcoinonly/t2b1-2.8.9-bitcoinonly.json
var require_t2b1_2_8_9_bitcoinonly = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2b1/bitcoinonly/t2b1-2.8.9-bitcoinonly.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 8, 9],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 1, 1],
      min_firmware_version: [2, 6, 1],
      bootloader_version: [2, 1, 8],
      firmware_revision: "fad9682201cf9289bba2adb66e6e07ed1cf78936",
      translations: {
        "cs-CZ": "firmware/translations/t2b1/translation-T2B1-cs-CZ-2.8.9.bin",
        "de-DE": "firmware/translations/t2b1/translation-T2B1-de-DE-2.8.9.bin",
        "es-ES": "firmware/translations/t2b1/translation-T2B1-es-ES-2.8.9.bin",
        "fr-FR": "firmware/translations/t2b1/translation-T2B1-fr-FR-2.8.9.bin",
        "it-IT": "firmware/translations/t2b1/translation-T2B1-it-IT-2.8.9.bin",
        "pt-BR": "firmware/translations/t2b1/translation-T2B1-pt-BR-2.8.9.bin"
      },
      url: "firmware/t2b1/trezor-t2b1-2.8.9-bitcoinonly.bin",
      fingerprint: "bde9c5ef485548746150e07a9c5081c25f2bdf127707a41f3c487ca83a6c0667",
      changelog: "* Ability to cancel recovery on word count selection screen.\n* New UI for confirming long messages."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2b1/universal/t2b1-2.6.3-universal.json
var require_t2b1_2_6_3_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2b1/universal/t2b1-2.6.3-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 6, 3],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 1, 1],
      min_firmware_version: [2, 6, 1],
      bootloader_version: [2, 1, 4],
      firmware_revision: "2c7cc6e0255dee2339b445b5551eaffb88dbd1b4",
      translations: {},
      url: "firmware/t2b1/trezor-t2b1-2.6.3.bin",
      fingerprint: "1aea81cf4a823951540a041ae52d1950efade73531f7640c85805f8950f11a38",
      changelog: "* QR Code for Extended Public Keys (XPUBs). \n* The new bootloader version 2.1.4 is now included for enhanced system performance and security. \n* The screen will now automatically turn off when the device is locked, helping to extend the life of the OLED display and save energy."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2b1/universal/t2b1-2.6.4-universal.json
var require_t2b1_2_6_4_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2b1/universal/t2b1-2.6.4-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 6, 4],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 1, 1],
      min_firmware_version: [2, 6, 1],
      bootloader_version: [2, 1, 4],
      firmware_revision: "42e9ed0e09033d474dee1a560fe5870646fa440e",
      translations: {},
      url: "firmware/t2b1/trezor-t2b1-2.6.4.bin",
      fingerprint: "5ac16cb5002aa607908be376378a7fd1a1bc18f7b05e7a047cb1365840cc93ef",
      changelog: "* Trezor Safe 3 now supports Solana, expanding the range of cryptocurrencies it can securely manage. [Universal fw only] \n* Ethereum fees are now uniformly presented in Gwei, enhancing clarity and consistency for users. [Universal fw only] \n* Issue with missing address confirmation screens is now fixed. [Universal fw only] \n* Resolved an issue related to the invalid encoding of signatures from the Optiga chip."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2b1/universal/t2b1-2.7.0-universal.json
var require_t2b1_2_7_0_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2b1/universal/t2b1-2.7.0-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 7, 0],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 1, 1],
      min_firmware_version: [2, 6, 1],
      bootloader_version: [2, 1, 4],
      firmware_revision: "45e8a842a31e62a6d43d7f6ccac62a45e1198ef0",
      translations: {
        "cs-CZ": "firmware/translations/t2b1/translation-T2B1-cs-CZ-2.7.0.bin",
        "de-DE": "firmware/translations/t2b1/translation-T2B1-de-DE-2.7.0.bin",
        "es-ES": "firmware/translations/t2b1/translation-T2B1-es-ES-2.7.0.bin",
        "fr-FR": "firmware/translations/t2b1/translation-T2B1-fr-FR-2.7.0.bin"
      },
      url: "firmware/t2b1/trezor-t2b1-2.7.0.bin",
      fingerprint: "522eb5db073c0f039f7164360668e75a43399d0b4e40edfd06f77f4401cd98aa",
      changelog: "* Add translations capability. \n* Add loader to homescreen when locking the device. \n* Allow for going back to previous word in recovery process. \n* Clear sign ETH staking transactions on Everstake pool. [Universal fw only] \n* Display descriptors for BTC Taproot public keys. \n* Multiple Solana instructions improved. [Universal fw only] \n* Add missing semicolon character to the passphrase entry."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2b1/universal/t2b1-2.7.2-universal.json
var require_t2b1_2_7_2_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2b1/universal/t2b1-2.7.2-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 7, 2],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 1, 1],
      min_firmware_version: [2, 6, 1],
      bootloader_version: [2, 1, 4],
      firmware_revision: "da75d8f4b67410b40a9cfd2954d183d81dd6e8e8",
      translations: {
        "cs-CZ": "firmware/translations/t2b1/translation-T2B1-cs-CZ-2.7.2.bin",
        "de-DE": "firmware/translations/t2b1/translation-T2B1-de-DE-2.7.2.bin",
        "es-ES": "firmware/translations/t2b1/translation-T2B1-es-ES-2.7.2.bin",
        "fr-FR": "firmware/translations/t2b1/translation-T2B1-fr-FR-2.7.2.bin"
      },
      url: "firmware/t2b1/trezor-t2b1-2.7.2.bin",
      fingerprint: "d072560f34782faf5537aa08a48c4e24671d4c60e9c291a00bfbf12cbc425666",
      changelog: "* Introducing repeated backups. \n* Multi-share backups can now have any number of shares. \n* Added support for Cardano Conway certificates [Universal fw only]."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2b1/universal/t2b1-2.8.0-universal.json
var require_t2b1_2_8_0_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2b1/universal/t2b1-2.8.0-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 8, 0],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 1, 1],
      min_firmware_version: [2, 6, 1],
      bootloader_version: [2, 1, 4],
      firmware_revision: "dd4671a5104952ef505d28d1f9e94d1484b4607a",
      translations: {
        "cs-CZ": "firmware/translations/t2b1/translation-T2B1-cs-CZ-2.8.0.bin",
        "de-DE": "firmware/translations/t2b1/translation-T2B1-de-DE-2.8.0.bin",
        "es-ES": "firmware/translations/t2b1/translation-T2B1-es-ES-2.8.0.bin",
        "fr-FR": "firmware/translations/t2b1/translation-T2B1-fr-FR-2.8.0.bin",
        "it-IT": "firmware/translations/t2b1/translation-T2B1-it-IT-2.8.0.bin",
        "pt-BR": "firmware/translations/t2b1/translation-T2B1-pt-BR-2.8.0.bin"
      },
      url: "firmware/t2b1/trezor-t2b1-2.8.0.bin",
      fingerprint: "cf3ce230a69a681199f74cf6ac8c6c431f8fa7e0d0183437f93c5cc029fbd155",
      changelog: "* Removed CoSi functionality. \n* Increased Optiga read timeout to avoid spurious RSODs."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2b1/universal/t2b1-2.8.10-universal.json
var require_t2b1_2_8_10_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2b1/universal/t2b1-2.8.10-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 8, 10],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 1, 1],
      min_firmware_version: [2, 6, 1],
      bootloader_version: [2, 1, 8],
      firmware_revision: "2a65d18200580005dc419b9569ed97fae440806a",
      translations: {
        "cs-CZ": "firmware/translations/t2b1/translation-T2B1-cs-CZ-2.8.10.bin",
        "de-DE": "firmware/translations/t2b1/translation-T2B1-de-DE-2.8.10.bin",
        "es-ES": "firmware/translations/t2b1/translation-T2B1-es-ES-2.8.10.bin",
        "fr-FR": "firmware/translations/t2b1/translation-T2B1-fr-FR-2.8.10.bin",
        "it-IT": "firmware/translations/t2b1/translation-T2B1-it-IT-2.8.10.bin",
        "pt-BR": "firmware/translations/t2b1/translation-T2B1-pt-BR-2.8.10.bin"
      },
      url: "firmware/t2b1/trezor-t2b1-2.8.10.bin",
      fingerprint: "db555520689b1af7c18cb20fc2631fbf07ce4f7dd735c7e64ab279e1ad03a33a",
      changelog: '* Solana: rent fee calculation [#4933]\n* Solana: loadable token definitions [#3541]\n* Replaced "next page" icon with "..." ellipsis when confirming long message.\n* Fixed Solana staking dialog title.\n* Updated EIP-1559 fee-related labels.\n* Allow firmware upgrade even if language change failed.\n* Solana: fees calculation is now exact [#4965]'
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2b1/universal/t2b1-2.8.7-universal.json
var require_t2b1_2_8_7_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2b1/universal/t2b1-2.8.7-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 8, 7],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 1, 1],
      min_firmware_version: [2, 6, 1],
      bootloader_version: [2, 1, 8],
      firmware_revision: "8a254aa8eae82f99630df63f40e4d290066a3efc",
      translations: {
        "cs-CZ": "firmware/translations/t2b1/translation-T2B1-cs-CZ-2.8.7.bin",
        "de-DE": "firmware/translations/t2b1/translation-T2B1-de-DE-2.8.7.bin",
        "es-ES": "firmware/translations/t2b1/translation-T2B1-es-ES-2.8.7.bin",
        "fr-FR": "firmware/translations/t2b1/translation-T2B1-fr-FR-2.8.7.bin",
        "it-IT": "firmware/translations/t2b1/translation-T2B1-it-IT-2.8.7.bin",
        "pt-BR": "firmware/translations/t2b1/translation-T2B1-pt-BR-2.8.7.bin"
      },
      url: "firmware/t2b1/trezor-t2b1-2.8.7.bin",
      fingerprint: "554c6586df79e1281dd377bfb99d7b2594dbac66d749837c6a78b9c5e0751098",
      changelog: "* Show last typed PIN number for short period of time.\n* Multisig-related changes.\n* Simplify UI of Cardano transactions initiated by Trezor Suite.\n* Included new version of bootloader (2.1.8).\n* Fix ETH account number detection.\n* New EVM call contract flow UI.\n* Fix translation of the 'Enable labeling' screen."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2b1/universal/t2b1-2.8.9-universal.json
var require_t2b1_2_8_9_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2b1/universal/t2b1-2.8.9-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 8, 9],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 1, 1],
      min_firmware_version: [2, 6, 1],
      bootloader_version: [2, 1, 8],
      firmware_revision: "fad9682201cf9289bba2adb66e6e07ed1cf78936",
      translations: {
        "cs-CZ": "firmware/translations/t2b1/translation-T2B1-cs-CZ-2.8.9.bin",
        "de-DE": "firmware/translations/t2b1/translation-T2B1-de-DE-2.8.9.bin",
        "es-ES": "firmware/translations/t2b1/translation-T2B1-es-ES-2.8.9.bin",
        "fr-FR": "firmware/translations/t2b1/translation-T2B1-fr-FR-2.8.9.bin",
        "it-IT": "firmware/translations/t2b1/translation-T2B1-it-IT-2.8.9.bin",
        "pt-BR": "firmware/translations/t2b1/translation-T2B1-pt-BR-2.8.9.bin"
      },
      url: "firmware/t2b1/trezor-t2b1-2.8.9.bin",
      fingerprint: "f6e03b48ab163f302bb886da197b6a0e7b390efdc5815b419535c5dee5cac1f7",
      changelog: "* Ability to cancel recovery on word count selection screen.\n* New UI for confirming long messages.\n* Solana staking confirmation dialogs."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2t1/bitcoinonly/t2t1-2.1.5-bitcoinonly.json
var require_t2t1_2_1_5_bitcoinonly = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2t1/bitcoinonly/t2t1-2.1.5-bitcoinonly.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 1, 5],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 0, 0],
      min_firmware_version: [2, 1, 0],
      firmware_revision: "df0963ec48f01f3d07ffca556e21ff0070cab099",
      translations: {},
      url: "firmware/t2t1/trezor-t2t1-2.1.5-bitcoinonly.bin",
      fingerprint: "9de90d9f8ca12506f3b9a4cbe7616294144d965d67daa3a03bfe6c0b74a44843",
      changelog: "* Fix UI for Shamir with 33 words"
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2t1/bitcoinonly/t2t1-2.1.6-bitcoinonly.json
var require_t2t1_2_1_6_bitcoinonly = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2t1/bitcoinonly/t2t1-2.1.6-bitcoinonly.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 1, 6],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 0, 0],
      min_firmware_version: [2, 0, 8],
      firmware_revision: "629fa58d396e732f230866ebe733d268370d7879",
      translations: {},
      url: "firmware/t2t1/trezor-t2t1-2.1.6-bitcoinonly.bin",
      fingerprint: "4e7f0f95d71631159b9e873f36a812c93a10eca1fad5f38c78ae7fbe4c1f6ed4",
      changelog: "* Small code improvements."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2t1/bitcoinonly/t2t1-2.1.7-bitcoinonly.json
var require_t2t1_2_1_7_bitcoinonly = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2t1/bitcoinonly/t2t1-2.1.7-bitcoinonly.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 1, 7],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 0, 0],
      min_firmware_version: [2, 0, 8],
      firmware_revision: "2cabc8b40ce237ee8a7e1926b6269040519d447a",
      translations: {},
      url: "firmware/t2t1/trezor-t2t1-2.1.7-bitcoinonly.bin",
      fingerprint: "fd92ac173a2cf93cc07ced3287e07800ed10466dc38c0c7240d9b20c689dd1d1",
      changelog: "* Super Shamir (with Groups)\n* Fix low memory issue"
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2t1/bitcoinonly/t2t1-2.1.8-bitcoinonly.json
var require_t2t1_2_1_8_bitcoinonly = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2t1/bitcoinonly/t2t1-2.1.8-bitcoinonly.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 1, 8],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 0, 0],
      min_firmware_version: [2, 0, 8],
      firmware_revision: "8eb6ce08995514c67d175b7197feeadeccc48ff0",
      translations: {},
      url: "firmware/t2t1/trezor-t2t1-2.1.8-bitcoinonly.bin",
      fingerprint: "ec752e9fa99a29979497e093b32bdb2b592783e2b48c87d8f6f0c18c73cd3022",
      changelog: "* Show XPUBs in GetAddress for multisig\n* Security improvements"
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2t1/bitcoinonly/t2t1-2.3.0-bitcoinonly.json
var require_t2t1_2_3_0_bitcoinonly = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2t1/bitcoinonly/t2t1-2.3.0-bitcoinonly.json"(exports2, module2) {
    module2.exports = {
      required: true,
      version: [2, 3, 0],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 0, 0],
      min_firmware_version: [2, 0, 8],
      firmware_revision: "0b7a8449f8dd003fc415262b05102d113247d3de",
      translations: {},
      url: "firmware/t2t1/trezor-t2t1-2.3.0-bitcoinonly.bin",
      fingerprint: "bddc0fd3b52fd32d94b776048f62b3d03dcb6ab90140e482a042a2863093115f",
      changelog: "* Introduce Wipe code\n* Introduce SD card protection\n* Introduce passphrase cache\n* Security fixes"
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2t1/bitcoinonly/t2t1-2.3.1-bitcoinonly.json
var require_t2t1_2_3_1_bitcoinonly = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2t1/bitcoinonly/t2t1-2.3.1-bitcoinonly.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 3, 1],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 0, 0],
      min_firmware_version: [2, 0, 8],
      firmware_revision: "c6b2580cd245ee924507f45e9675f857a3d78768",
      translations: {},
      url: "firmware/t2t1/trezor-t2t1-2.3.1-bitcoinonly.bin",
      fingerprint: "41795ec196f74c5d6acecc09047a5eacf1dfca47b0aeaa8442a69568efe20ddb",
      changelog: "* Refactor Bitcoin signing"
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2t1/bitcoinonly/t2t1-2.3.2-bitcoinonly.json
var require_t2t1_2_3_2_bitcoinonly = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2t1/bitcoinonly/t2t1-2.3.2-bitcoinonly.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 3, 2],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 0, 0],
      min_firmware_version: [2, 0, 8],
      firmware_revision: "63ebb8ccb56fc17a72eef91db36a37ff3176519d",
      translations: {},
      url: "firmware/t2t1/trezor-t2t1-2.3.2-bitcoinonly.bin",
      fingerprint: "389cb54fb6fc75489b788ad669ce51f41d47a67af54b8745a0dfe48da38a777f",
      changelog: "* Introduces 'Autolock' feature, which automatically locks the device to enforce the PIN entry after a certain period.\n* Fixes compatibility issues with Casa and GreenAddress.\n* Adds support for multiple change outputs in outgoing transactions.\n* Improves some interface elements."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2t1/bitcoinonly/t2t1-2.3.3-bitcoinonly.json
var require_t2t1_2_3_3_bitcoinonly = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2t1/bitcoinonly/t2t1-2.3.3-bitcoinonly.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 3, 3],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 0, 0],
      min_firmware_version: [2, 0, 8],
      firmware_revision: "0d5f00668fb3d1c093ff3c879311a91d3a7175c8",
      translations: {},
      url: "firmware/t2t1/trezor-t2t1-2.3.3-bitcoinonly.bin",
      fingerprint: "dda77cd7893a5f413f8fc4b2f44d1d43ed4b26e8ced5e6e578cc6b302c1a2310",
      changelog: "* Advances the Passphrase feature by showing the entered passphrase on the Trezor screen before opening the wallet.\n* Introduces a hard limit on transaction fees to prevent accidentally paying extra hefty fees (the limit can be manually disabled).\n* Fixes smaller issues with the user interface, customization, and more."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2t1/bitcoinonly/t2t1-2.3.4-bitcoinonly.json
var require_t2t1_2_3_4_bitcoinonly = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2t1/bitcoinonly/t2t1-2.3.4-bitcoinonly.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 3, 4],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 0, 0],
      min_firmware_version: [2, 0, 8],
      firmware_revision: "50854b9210f7674262c1541272a8c7fd1767b7a9",
      translations: {},
      url: "firmware/t2t1/trezor-t2t1-2.3.4-bitcoinonly.bin",
      fingerprint: "085acbba98163284ef86dea637f9442b924e80fea245f5ebb60d5aab3be2b7b6",
      changelog: "* Small code improvements."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2t1/bitcoinonly/t2t1-2.3.5-bitcoinonly.json
var require_t2t1_2_3_5_bitcoinonly = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2t1/bitcoinonly/t2t1-2.3.5-bitcoinonly.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 3, 5],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 0, 0],
      min_firmware_version: [2, 0, 8],
      firmware_revision: "ffa96205fb5e22b43e7b08a3dbc3cdeee0931de3",
      translations: {},
      url: "firmware/t2t1/trezor-t2t1-2.3.5-bitcoinonly.bin",
      fingerprint: "53e7ee5bfc75cfa6412d8de5461b1ea8d9b7e10970ce7cadae9cbb1e17bbb77d",
      changelog: "* Replacement transaction signing for replace-by-fee and PayJoin.\n* Support for Output Descriptors export.\n* Paginated display for signing/verifying long messages.\n* Show Ypub/Zpub correctly for multisig GetAddress.\n* Show amounts in mBTC, uBTC and sat denominations."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2t1/bitcoinonly/t2t1-2.3.6-bitcoinonly.json
var require_t2t1_2_3_6_bitcoinonly = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2t1/bitcoinonly/t2t1-2.3.6-bitcoinonly.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 3, 6],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 0, 0],
      min_firmware_version: [2, 0, 8],
      firmware_revision: "b19cbf67c6c7c38513947b703df6d4409c59bc98",
      translations: {},
      url: "firmware/t2t1/trezor-t2t1-2.3.6-bitcoinonly.bin",
      fingerprint: "e2cab40bb4c6ae65417b80ad564b905796038a0f5e6d0f50cead257fdd3a9c2d",
      changelog: "* Add compatibility paths for Unchained Capital"
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2t1/bitcoinonly/t2t1-2.4.0-bitcoinonly.json
var require_t2t1_2_4_0_bitcoinonly = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2t1/bitcoinonly/t2t1-2.4.0-bitcoinonly.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 4, 0],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 0, 0],
      min_firmware_version: [2, 0, 8],
      firmware_revision: "ea3596ad89a7993ad7b9d62798de94325ad1717a",
      translations: {},
      url: "firmware/t2t1/trezor-t2t1-2.4.0-bitcoinonly.bin",
      fingerprint: "89c91287ab7a9cd3ec246b6822a0d04b7d40401abef706cccafbb7b98bd6a3d7",
      changelog: "* Locking the device by holding finger on the homescreen.\n* Support PIN of unlimited length.\n* Allow decreasing the output value in RBF transactions.\n* Reduce memory fragmentation.\n* Improve wording when showing multisig XPUBs."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2t1/bitcoinonly/t2t1-2.4.1-bitcoinonly.json
var require_t2t1_2_4_1_bitcoinonly = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2t1/bitcoinonly/t2t1-2.4.1-bitcoinonly.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 4, 1],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 0, 0],
      min_firmware_version: [2, 0, 8],
      firmware_revision: "24bb4016388fca4b998285b95dcd408f4ed0bff6",
      translations: {},
      url: "firmware/t2t1/trezor-t2t1-2.4.1-bitcoinonly.bin",
      fingerprint: "fce4503fcadb68dc72144a562ec0a59e7c8d083e403e01bfc4c584161d79f596",
      changelog: "* Security and major perfomance improvements.\n* Fix red screen on shutdown."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2t1/bitcoinonly/t2t1-2.4.2-bitcoinonly.json
var require_t2t1_2_4_2_bitcoinonly = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2t1/bitcoinonly/t2t1-2.4.2-bitcoinonly.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 4, 2],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 0, 0],
      min_firmware_version: [2, 0, 8],
      firmware_revision: "9276b1702361f70e094286e2f89e919d8a230d5c",
      translations: {},
      url: "firmware/t2t1/trezor-t2t1-2.4.2-bitcoinonly.bin",
      fingerprint: "60fee3c9775d8ccf71099f6f7d277463efd128414cfb9be45656b1a26eeb7301",
      changelog: "* Memory optimization of BTC signing."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2t1/bitcoinonly/t2t1-2.4.3-bitcoinonly.json
var require_t2t1_2_4_3_bitcoinonly = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2t1/bitcoinonly/t2t1-2.4.3-bitcoinonly.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 4, 3],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 0, 0],
      min_firmware_version: [2, 0, 8],
      firmware_revision: "595b14254c1abb2be3f69e42c7932f1eca8cf1b1",
      translations: {},
      url: "firmware/t2t1/trezor-t2t1-2.4.3-bitcoinonly.bin",
      fingerprint: "1744efccabd479526392b281b7e0fc7aa2b4ecb454007dff7ca8c1f8171fad90",
      changelog: "* Support Taproot.\n* Show address confirmation in SignMessage."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2t1/bitcoinonly/t2t1-2.5.1-bitcoinonly.json
var require_t2t1_2_5_1_bitcoinonly = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2t1/bitcoinonly/t2t1-2.5.1-bitcoinonly.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 5, 1],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 0, 0],
      min_firmware_version: [2, 0, 8],
      firmware_revision: "85a26d2c9593bcdf858c2d718d79951ca927a0c3",
      translations: {},
      url: "firmware/t2t1/trezor-t2t1-2.5.1-bitcoinonly.bin",
      fingerprint: "db5d7b211532f717a32fe0b1bd3e3df6ad5464079a896a7f7492ab6e9e030bb5",
      changelog: "* Support Electrum signatures in VerifyMessage.\n* Bitcoin bech32 addresses QR codes have bigger pixels which are easier to scan.\n* Trezor will refuse to sign UTXOs that do not match the provided derivation path (e.g., transactions belonging to a different wallet, or synthetic transaction inputs)."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2t1/bitcoinonly/t2t1-2.5.2-bitcoinonly.json
var require_t2t1_2_5_2_bitcoinonly = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2t1/bitcoinonly/t2t1-2.5.2-bitcoinonly.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 5, 2],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 0, 0],
      min_firmware_version: [2, 0, 8],
      firmware_revision: "0d87b55ba4fed7eecc72bf2a94ee473830b095e9",
      translations: {},
      url: "firmware/t2t1/trezor-t2t1-2.5.2-bitcoinonly.bin",
      fingerprint: "76aa25f9602cfb03cd3e07a82ac09226344eb355355aec216295e43b675eedf7",
      changelog: "* Show the fee rate on the signing confirmation screen. \n* Show thousands separator when displaying large amounts."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2t1/bitcoinonly/t2t1-2.5.3-bitcoinonly.json
var require_t2t1_2_5_3_bitcoinonly = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2t1/bitcoinonly/t2t1-2.5.3-bitcoinonly.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 5, 3],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 0, 0],
      min_firmware_version: [2, 0, 8],
      firmware_revision: "2f03ace311584988d5aeab58fd1acf24ef54711a",
      translations: {},
      url: "firmware/t2t1/trezor-t2t1-2.5.3-bitcoinonly.bin",
      fingerprint: "c094c84ba958129885fa725ee6ddb781b580fd2c7851e83aef9054ba4a10526c",
      changelog: "* Add SLIP-0025 CoinJoin accounts. \n* Show red error header when Trezor doesn't see USB data connection. \n* Show fee rate when replacing transaction. \n* Optimize the signing of BTC transactions. \n* Extend decimals of fee rate to 2 digits. \n* Display only \u201Csat\u201D instead of \u201Csat BTC\u201D."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2t1/bitcoinonly/t2t1-2.6.0-bitcoinonly.json
var require_t2t1_2_6_0_bitcoinonly = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2t1/bitcoinonly/t2t1-2.6.0-bitcoinonly.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 6, 0],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 0, 0],
      min_firmware_version: [2, 0, 8],
      bootloader_version: [2, 1, 0],
      firmware_revision: "88e1f8c7a5c7615723664c64b0a25adc0c409dee",
      translations: {},
      url: "firmware/t2t1/trezor-t2t1-2.6.0-bitcoinonly.bin",
      fingerprint: "54f084dab4be1e64dc2cb970a6de87969407e4d6c48d79acdcf5d374ec0f29d6",
      changelog: ` Show source account path in BTC signing. 
* Ability to reboot the device into bootloader mode directly, without needing to unplug the device. 
* Support for Ledger Live legacy derivation path "m/44'/coin_type'/0'/account". 
* Redesigned UI. 
* Homescreen now supports full-screen images.`
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2t1/bitcoinonly/t2t1-2.6.3-bitcoinonly.json
var require_t2t1_2_6_3_bitcoinonly = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2t1/bitcoinonly/t2t1-2.6.3-bitcoinonly.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 6, 3],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 0, 0],
      min_firmware_version: [2, 0, 8],
      bootloader_version: [2, 1, 4],
      firmware_revision: "2c7cc6e0255dee2339b445b5551eaffb88dbd1b4",
      translations: {},
      url: "firmware/t2t1/trezor-t2t1-2.6.3-bitcoinonly.bin",
      fingerprint: "1765518ca4025d4d46362d07128bb38413831511a2aff0dee1b05e6e58ff5317",
      changelog: "* QR Code for Extended Public Keys (XPUBs). \n* Adjusted buttons for multipage content scrolling, providing a more intuitive and user-friendly experience. \n* The new bootloader version 2.1.4 is now included for enhanced system performance and security."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2t1/bitcoinonly/t2t1-2.6.4-bitcoinonly.json
var require_t2t1_2_6_4_bitcoinonly = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2t1/bitcoinonly/t2t1-2.6.4-bitcoinonly.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 6, 4],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 0, 0],
      min_firmware_version: [2, 0, 8],
      bootloader_version: [2, 1, 4],
      firmware_revision: "42e9ed0e09033d474dee1a560fe5870646fa440e",
      translations: {},
      url: "firmware/t2t1/trezor-t2t1-2.6.4-bitcoinonly.bin",
      fingerprint: "e78da8a00354dd1223da081600f881b71bd297dd565e7a2c0a9880e52575d127",
      changelog: "* The display of spaced addresses has been refined, offering a more user-friendly and visually optimized experience. \n* Boot-up logo display has been optimized, contributing to a smoother and more visually appealing device startup."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2t1/bitcoinonly/t2t1-2.7.0-bitcoinonly.json
var require_t2t1_2_7_0_bitcoinonly = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2t1/bitcoinonly/t2t1-2.7.0-bitcoinonly.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 7, 0],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 0, 0],
      min_firmware_version: [2, 0, 8],
      bootloader_version: [2, 1, 4],
      firmware_revision: "45e8a842a31e62a6d43d7f6ccac62a45e1198ef0",
      translations: {
        "cs-CZ": "firmware/translations/t2t1/translation-T2T1-cs-CZ-2.7.0.bin",
        "de-DE": "firmware/translations/t2t1/translation-T2T1-de-DE-2.7.0.bin",
        "es-ES": "firmware/translations/t2t1/translation-T2T1-es-ES-2.7.0.bin",
        "fr-FR": "firmware/translations/t2t1/translation-T2T1-fr-FR-2.7.0.bin"
      },
      url: "firmware/t2t1/trezor-t2t1-2.7.0-bitcoinonly.bin",
      fingerprint: "c94f07150a6f0bb2862d4c31c6059862aab14f0073dea581118eef51a983bc30",
      changelog: "* Add translations capability. \n* Allow for going back to previous word in recovery process. \n* Display descriptors for BTC Taproot public keys. \n* Fixed blank display delay on startup when display orientation is set to other than north."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2t1/bitcoinonly/t2t1-2.7.2-bitcoinonly.json
var require_t2t1_2_7_2_bitcoinonly = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2t1/bitcoinonly/t2t1-2.7.2-bitcoinonly.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 7, 2],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 0, 0],
      min_firmware_version: [2, 0, 8],
      bootloader_version: [2, 1, 4],
      firmware_revision: "da75d8f4b67410b40a9cfd2954d183d81dd6e8e8",
      translations: {
        "cs-CZ": "firmware/translations/t2t1/translation-T2T1-cs-CZ-2.7.2.bin",
        "de-DE": "firmware/translations/t2t1/translation-T2T1-de-DE-2.7.2.bin",
        "es-ES": "firmware/translations/t2t1/translation-T2T1-es-ES-2.7.2.bin",
        "fr-FR": "firmware/translations/t2t1/translation-T2T1-fr-FR-2.7.2.bin"
      },
      url: "firmware/t2t1/trezor-t2t1-2.7.2-bitcoinonly.bin",
      fingerprint: "cba515383705ec6420c54dd1ffdb33ea7ce4bb04bc6d992c2923880daa53d3e1",
      changelog: "* Introducing repeated backups. \n* Multi-share backups can now have any number of shares."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2t1/bitcoinonly/t2t1-2.8.1-bitcoinonly.json
var require_t2t1_2_8_1_bitcoinonly = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2t1/bitcoinonly/t2t1-2.8.1-bitcoinonly.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 8, 1],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 0, 0],
      min_firmware_version: [2, 0, 8],
      bootloader_version: [2, 1, 6],
      firmware_revision: "632b9561559b7ab6824bb7eeac072874e07b7b82",
      translations: {
        "cs-CZ": "firmware/translations/t2t1/translation-T2T1-cs-CZ-2.8.1.bin",
        "de-DE": "firmware/translations/t2t1/translation-T2T1-de-DE-2.8.1.bin",
        "es-ES": "firmware/translations/t2t1/translation-T2T1-es-ES-2.8.1.bin",
        "fr-FR": "firmware/translations/t2t1/translation-T2T1-fr-FR-2.8.1.bin",
        "it-IT": "firmware/translations/t2t1/translation-T2T1-it-IT-2.8.1.bin",
        "pt-BR": "firmware/translations/t2t1/translation-T2T1-pt-BR-2.8.1.bin"
      },
      url: "firmware/t2t1/trezor-t2t1-2.8.1-bitcoinonly.bin",
      fingerprint: "38ab127fcf4263a18a3b07593301fdd2c6a1a96360b62c131adb849b5d18fae3",
      changelog: "* Fixed displaying of a progress indicator for the formatting operation.\n* Improve precision of PIN validation countdown."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2t1/bitcoinonly/t2t1-2.8.10-bitcoinonly.json
var require_t2t1_2_8_10_bitcoinonly = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2t1/bitcoinonly/t2t1-2.8.10-bitcoinonly.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 8, 10],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 0, 0],
      min_firmware_version: [2, 0, 8],
      bootloader_version: [2, 1, 8],
      firmware_revision: "2a65d18200580005dc419b9569ed97fae440806a",
      translations: {
        "cs-CZ": "firmware/translations/t2t1/translation-T2T1-cs-CZ-2.8.10.bin",
        "de-DE": "firmware/translations/t2t1/translation-T2T1-de-DE-2.8.10.bin",
        "es-ES": "firmware/translations/t2t1/translation-T2T1-es-ES-2.8.10.bin",
        "fr-FR": "firmware/translations/t2t1/translation-T2T1-fr-FR-2.8.10.bin",
        "it-IT": "firmware/translations/t2t1/translation-T2T1-it-IT-2.8.10.bin",
        "pt-BR": "firmware/translations/t2t1/translation-T2T1-pt-BR-2.8.10.bin"
      },
      url: "firmware/t2t1/trezor-t2t1-2.8.10-bitcoinonly.bin",
      fingerprint: "c280cfbe83b261ef30c64eb58f55538b3cceee01ba7d8f57d6e8cbf92527066b",
      changelog: '* Replaced "next page" icon with "..." ellipsis when confirming long message.\n* Fixed upgrade confirmation text overflow.\n* Allow firmware upgrade even if language change failed.'
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2t1/bitcoinonly/t2t1-2.8.7-bitcoinonly.json
var require_t2t1_2_8_7_bitcoinonly = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2t1/bitcoinonly/t2t1-2.8.7-bitcoinonly.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 8, 7],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 0, 0],
      min_firmware_version: [2, 0, 8],
      bootloader_version: [2, 1, 8],
      firmware_revision: "8a254aa8eae82f99630df63f40e4d290066a3efc",
      translations: {
        "cs-CZ": "firmware/translations/t2t1/translation-T2T1-cs-CZ-2.8.7.bin",
        "de-DE": "firmware/translations/t2t1/translation-T2T1-de-DE-2.8.7.bin",
        "es-ES": "firmware/translations/t2t1/translation-T2T1-es-ES-2.8.7.bin",
        "fr-FR": "firmware/translations/t2t1/translation-T2T1-fr-FR-2.8.7.bin",
        "it-IT": "firmware/translations/t2t1/translation-T2T1-it-IT-2.8.7.bin",
        "pt-BR": "firmware/translations/t2t1/translation-T2T1-pt-BR-2.8.7.bin"
      },
      url: "firmware/t2t1/trezor-t2t1-2.8.7-bitcoinonly.bin",
      fingerprint: "7bdf5de0c00c5d15c06d526a5b0d22cfd8343eb3e7aa01ee3c4ed60dd063bbf1",
      changelog: "* Show last typed PIN number for short period of time.\n* Multisig-related changes.\n* Included new version of bootloader (2.1.8).\n* Fix translation of the 'Enable labeling' screen."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2t1/bitcoinonly/t2t1-2.8.8-bitcoinonly.json
var require_t2t1_2_8_8_bitcoinonly = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2t1/bitcoinonly/t2t1-2.8.8-bitcoinonly.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 8, 8],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 0, 0],
      min_firmware_version: [2, 0, 8],
      bootloader_version: [2, 1, 8],
      firmware_revision: "592590cf66a9b62dfeee7e4d2afb6e01005e5b2c",
      translations: {
        "cs-CZ": "firmware/translations/t2t1/translation-T2T1-cs-CZ-2.8.8.bin",
        "de-DE": "firmware/translations/t2t1/translation-T2T1-de-DE-2.8.8.bin",
        "es-ES": "firmware/translations/t2t1/translation-T2T1-es-ES-2.8.8.bin",
        "fr-FR": "firmware/translations/t2t1/translation-T2T1-fr-FR-2.8.8.bin",
        "it-IT": "firmware/translations/t2t1/translation-T2T1-it-IT-2.8.8.bin",
        "pt-BR": "firmware/translations/t2t1/translation-T2T1-pt-BR-2.8.8.bin"
      },
      url: "firmware/t2t1/trezor-t2t1-2.8.8-bitcoinonly.bin",
      fingerprint: "81928bbb5bc855f46a2ccb210173f9676b69d153a513bfa0101abfc063f7aef5",
      changelog: '* Fix "PIN attempts exceeded" screen\n* Fixed a bug resulting in restarting the recovery flow when inputting 33-word mnemonic'
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2t1/bitcoinonly/t2t1-2.8.9-bitcoinonly.json
var require_t2t1_2_8_9_bitcoinonly = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2t1/bitcoinonly/t2t1-2.8.9-bitcoinonly.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 8, 9],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 0, 0],
      min_firmware_version: [2, 0, 8],
      bootloader_version: [2, 1, 8],
      firmware_revision: "fad9682201cf9289bba2adb66e6e07ed1cf78936",
      translations: {
        "cs-CZ": "firmware/translations/t2t1/translation-T2T1-cs-CZ-2.8.9.bin",
        "de-DE": "firmware/translations/t2t1/translation-T2T1-de-DE-2.8.9.bin",
        "es-ES": "firmware/translations/t2t1/translation-T2T1-es-ES-2.8.9.bin",
        "fr-FR": "firmware/translations/t2t1/translation-T2T1-fr-FR-2.8.9.bin",
        "it-IT": "firmware/translations/t2t1/translation-T2T1-it-IT-2.8.9.bin",
        "pt-BR": "firmware/translations/t2t1/translation-T2T1-pt-BR-2.8.9.bin"
      },
      url: "firmware/t2t1/trezor-t2t1-2.8.9-bitcoinonly.bin",
      fingerprint: "e5878fa067df9d1256cdcd86f10869930d85e090c39f807c23f8845472e8d995",
      changelog: "* Ability to cancel recovery on word count selection screen.\n* New UI for confirming long messages."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.0.10-universal.json
var require_t2t1_2_0_10_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.0.10-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 0, 10],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 0, 0],
      min_firmware_version: [2, 0, 5],
      bootloader_version: [2, 0, 2],
      firmware_revision: "5c3a5d4577b568d90bfa3528d0243d74848d994f",
      translations: {},
      url: "firmware/t2t1/trezor-t2t1-2.0.10.bin",
      fingerprint: "fcaa6ee206c2c121eb2d45d065d66f0879f14be45c244d4acf908be1de22275e",
      changelog: "* Fix Monero payment ID computation\n* Fix issue with touch screen and flickering\n* Add support for OMNI layer: OMNI/MAID/USDT\n* Add support for new coins: BTX, CPC, GAME, RVN\n* Add support for new Ethereum tokens"
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.0.5-universal.json
var require_t2t1_2_0_5_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.0.5-universal.json"(exports2, module2) {
    module2.exports = {
      required: true,
      version: [2, 0, 5],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 0, 0],
      min_firmware_version: [2, 0, 5],
      bootloader_version: [2, 0, 0],
      firmware_revision: "8852fb54820032f4f287414aa250df981d25445f",
      translations: {},
      url: "firmware/t2t1/trezor-t2t1-2.0.5.bin",
      fingerprint: "851172eab96c07bf9efb43771cb0fd14dc0320a68de047132c7bd787a1ad64e9",
      changelog: "* First public release"
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.0.6-universal.json
var require_t2t1_2_0_6_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.0.6-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 0, 6],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 0, 0],
      min_firmware_version: [2, 0, 5],
      bootloader_version: [2, 0, 0],
      firmware_revision: "886888b7750402d9a9e12bd990e75c0a8dc6cc86",
      translations: {},
      url: "firmware/t2t1/trezor-t2t1-2.0.6.bin",
      fingerprint: "4eccabf2fd7e121ed0da657c064a65c5694402497e60ea2ac2dcf1e118db9cc6",
      changelog: "* Fix layout for Ethereum transactions\n* Fix public key generation for SSH and GPG\n* Add special characters to passphrase keyboard"
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.0.7-universal.json
var require_t2t1_2_0_7_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.0.7-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 0, 7],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 0, 0],
      min_firmware_version: [2, 0, 5],
      bootloader_version: [2, 0, 0],
      firmware_revision: "5c621800110a791c84865b6b381908e8c2f15283",
      translations: {},
      url: "firmware/t2t1/trezor-t2t1-2.0.7.bin",
      fingerprint: "f3a42e640e526fba6574fafa520fc7d97ef9f557d24da24d9a2ea4176a4c4164",
      changelog: "* Bitcoin Cash cashaddr support\n* Zcash Overwinter hardfork support\n* NEM support\n* Lisk support\n* Show warning on home screen if PIN is not set\n* Support for new coins:\n  - Bitcoin Private, Fujicoin, Vertcoin, Viacoin, Zcoin\n* Support for new Ethereum networks:\n  - EOS Classic, Ethereum Social, Ellaism, Callisto, EtherGem, Wanchain\n* Support for 500+ new Ethereum tokens"
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.0.8-universal.json
var require_t2t1_2_0_8_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.0.8-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 0, 8],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 0, 0],
      min_firmware_version: [2, 0, 5],
      bootloader_version: [2, 0, 0],
      firmware_revision: "939a93221941df8d454569a674f6fb082bf1d423",
      translations: {},
      url: "firmware/t2t1/trezor-t2t1-2.0.8.bin",
      fingerprint: "642b6215bda981f8eacafee34dbee5cdeee7d47d49f605bbe2828a8d9b79813d",
      changelog: "* Monero support\n* Cardano support\n* Stellar support\n* Ripple support\n* Tezos support\n* Decred support\n* Groestlcoin support\n* Zencash support\n* Zcash sapling hardfork support\n* Implemented seedless setup"
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.0.9-universal.json
var require_t2t1_2_0_9_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.0.9-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 0, 9],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 0, 0],
      min_firmware_version: [2, 0, 5],
      bootloader_version: [2, 0, 0],
      firmware_revision: "7c2e9ed5a51dc00dec9d195878c5ad57016b4889",
      translations: {},
      url: "firmware/t2t1/trezor-t2t1-2.0.9.bin",
      fingerprint: "87be93d6966e7a9eff78dc7b434d1a138ec8d1ee0300882d16f90b606f3a806b",
      changelog: "* Small Monero and Segwit bugfixes"
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.1.0-universal.json
var require_t2t1_2_1_0_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.1.0-universal.json"(exports2, module2) {
    module2.exports = {
      required: true,
      version: [2, 1, 0],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 0, 0],
      min_firmware_version: [2, 0, 5],
      bootloader_version: [2, 0, 3],
      firmware_revision: "3f0e3a334e03f49ff819d14cbbec00194c586c27",
      translations: {},
      url: "firmware/t2t1/trezor-t2t1-2.1.0.bin",
      fingerprint: "bb5b0308807b45d41d1e2ab66a468152997ad69a01099789d8a35e464cde999f",
      changelog: "* Security improvements\n* Upgraded to new storage format\n* Ripple, Stellar, Cardano and NEM fixes\n* New coins: ATS, AXE, FLO, GIN, KMD, NIX,\n  PIVX, REOSC, XPM, XSN, ZCL\n* New ETH tokens"
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.1.1-universal.json
var require_t2t1_2_1_1_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.1.1-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 1, 1],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 0, 0],
      min_firmware_version: [2, 0, 5],
      firmware_revision: "7af1d5859458e87efd6957885566aed890a9f781",
      translations: {},
      url: "firmware/t2t1/trezor-t2t1-2.1.1.bin",
      fingerprint: "1b3166a878658fcd2ff82c7ac9a2587da544fd105f678cc7b4d41cba5a8d4c01",
      changelog: "* Hotfix for touchscreen freeze\n* Don't rotate the screen via swipe gesture\n* Set screen rotation via user setting\n* More strict path validations\n* Display non-zero locktime values\n* EOS support\n* Monero UI fixes\n* Speed and memory optimizations"
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.1.4-universal.json
var require_t2t1_2_1_4_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.1.4-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 1, 4],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 0, 0],
      min_firmware_version: [2, 1, 0],
      firmware_revision: "6a1a02ca3c595067ed02a78f2d6c36eb58eaa9ed",
      translations: {},
      url: "firmware/t2t1/trezor-t2t1-2.1.4.bin",
      fingerprint: "820611a92605b1ccc612b9bf8550617aec6962bd2484fcb6ae4792bc498654e4",
      changelog: "* Shamir Backup with Recovery persistence\n* Touchscreen freeze fix\n* Fix display of non-divisible OMNI amounts"
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.1.5-universal.json
var require_t2t1_2_1_5_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.1.5-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 1, 5],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 0, 0],
      min_firmware_version: [2, 1, 0],
      firmware_revision: "df0963ec48f01f3d07ffca556e21ff0070cab099",
      translations: {},
      url: "firmware/t2t1/trezor-t2t1-2.1.5.bin",
      fingerprint: "40e4bfaf3c5ec77872c1aaaac085aafcc443f60279ca2bb38d29c669233fdf62",
      changelog: "* Fix for sluggish U2F authentication when using Shamir\n* Fix UI for Shamir with 33 words\n* Fix Wanchain signing"
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.1.6-universal.json
var require_t2t1_2_1_6_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.1.6-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 1, 6],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 0, 0],
      min_firmware_version: [2, 0, 8],
      firmware_revision: "629fa58d396e732f230866ebe733d268370d7879",
      translations: {},
      url: "firmware/t2t1/trezor-t2t1-2.1.6.bin",
      fingerprint: "e2032ad84108a85d4014d477b955b9181a1a56e6f222ef21bb7d47b503a02f0b",
      changelog: "* Super Shamir (with Groups)\n* FIDO2 support with credential management"
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.1.7-universal.json
var require_t2t1_2_1_7_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.1.7-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 1, 7],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 0, 0],
      min_firmware_version: [2, 0, 8],
      firmware_revision: "2cabc8b40ce237ee8a7e1926b6269040519d447a",
      translations: {},
      url: "firmware/t2t1/trezor-t2t1-2.1.7.bin",
      fingerprint: "acf1b4c6fec3624a8fc53f9130ff53d690c3fa1c134bd4ca3e58ee7b5a0441d8",
      changelog: "* Super Shamir (with Groups)\n* FIDO2 support with credential management\n* Fix low memory issue"
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.1.8-universal.json
var require_t2t1_2_1_8_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.1.8-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 1, 8],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 0, 0],
      min_firmware_version: [2, 0, 8],
      firmware_revision: "8eb6ce08995514c67d175b7197feeadeccc48ff0",
      translations: {},
      url: "firmware/t2t1/trezor-t2t1-2.1.8.bin",
      fingerprint: "8a5fa12132651b6e33344fd025d0d90885f5cc1c342427ebcea4f0ae98b50d8c",
      changelog: "* Support Tezos 005-BABYLON hardfork\n* Show XPUBs in GetAddress for multisig\n* Security improvements"
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.3.0-universal.json
var require_t2t1_2_3_0_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.3.0-universal.json"(exports2, module2) {
    module2.exports = {
      required: true,
      version: [2, 3, 0],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 0, 0],
      min_firmware_version: [2, 0, 8],
      firmware_revision: "0b7a8449f8dd003fc415262b05102d113247d3de",
      translations: {},
      url: "firmware/t2t1/trezor-t2t1-2.3.0.bin",
      fingerprint: "212929f63fe1393e2ff57e06537a38cff281e3cfb3a4e17235079e2f08871e6c",
      changelog: "* Introduce Wipe code\n* Introduce SD card protection\n* Introduce passphrase cache\n* U2F UX improvements\n* Security fixes"
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.3.1-universal.json
var require_t2t1_2_3_1_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.3.1-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 3, 1],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 0, 0],
      min_firmware_version: [2, 0, 8],
      firmware_revision: "c6b2580cd245ee924507f45e9675f857a3d78768",
      translations: {},
      url: "firmware/t2t1/trezor-t2t1-2.3.1.bin",
      fingerprint: "37178a5ec24e34f8a0599aebcadaf206af3ebadef2fc596665d617dd3e05a5db",
      changelog: "* Refactor Bitcoin signing"
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.3.2-universal.json
var require_t2t1_2_3_2_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.3.2-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 3, 2],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 0, 0],
      min_firmware_version: [2, 0, 8],
      firmware_revision: "63ebb8ccb56fc17a72eef91db36a37ff3176519d",
      translations: {},
      url: "firmware/t2t1/trezor-t2t1-2.3.2.bin",
      fingerprint: "f5ccdca0cbe163ecb93df726da72b69abb93f70d24d295db00b3ca2738216160",
      changelog: "* Introduces 'Autolock' feature, which automatically locks the device to enforce the PIN entry after a certain period.\n* Updates the Cardano support to enable staking and other Shelley updates.\n* Reintroduces the ability to spend pre-Overwinter (2018) funds on Zcash-like coins.\n* Fixes compatibility issues with Casa and GreenAddress.\n* Adds support for multiple change outputs in outgoing transactions.\n* Improves some interface elements."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.3.3-universal.json
var require_t2t1_2_3_3_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.3.3-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 3, 3],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 0, 0],
      min_firmware_version: [2, 0, 8],
      firmware_revision: "0d5f00668fb3d1c093ff3c879311a91d3a7175c8",
      translations: {},
      url: "firmware/t2t1/trezor-t2t1-2.3.3.bin",
      fingerprint: "46326222f8afcb82e1cd07867bc3bf8836f4e9d0f367e23b58d1e9bc32cd032e",
      changelog: "* Advances the Passphrase feature by showing the entered passphrase on the Trezor screen before opening the wallet.\n* Adds support for Verge (XVG).\n* Drops support for Metaverse (ETP), GINcoin (GIN), Pesetacoin (PTC), and Zel (ZEL).\n* Introduces a hard limit on transaction fees to prevent accidentally paying extra hefty fees (the limit can be manually disabled).\n* Resolves the problems with generating the Crown addresses.\n* Re-enables spending altcoins from Bitcoin paths (fixing some compatibility issues with Bitcoin Cash wallets).\n* Fixes smaller issues with the user interface, customization, and more."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.3.4-universal.json
var require_t2t1_2_3_4_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.3.4-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 3, 4],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 0, 0],
      min_firmware_version: [2, 0, 8],
      firmware_revision: "50854b9210f7674262c1541272a8c7fd1767b7a9",
      translations: {},
      url: "firmware/t2t1/trezor-t2t1-2.3.4.bin",
      fingerprint: "58b51a6587993965979a744f8fcd5c4761f11ce4bec6b059a5d56bd0987d6658",
      changelog: "* This firmware only contains the changes needed after the latest Monero update (HF13) by introducing support for the CLSAG transactions."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.3.5-universal.json
var require_t2t1_2_3_5_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.3.5-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 3, 5],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 0, 0],
      min_firmware_version: [2, 0, 8],
      firmware_revision: "ffa96205fb5e22b43e7b08a3dbc3cdeee0931de3",
      translations: {},
      url: "firmware/t2t1/trezor-t2t1-2.3.5.bin",
      fingerprint: "c0a6cacfed5c7a691314919c22307c29fbe9522071a9a28669769c014762d386",
      changelog: "* Replacement transaction signing for replace-by-fee and PayJoin.\n* Support for Output Descriptors export.\n* Paginated display for signing/verifying long messages.\n* Show Ypub/Zpub correctly for multisig GetAddress.\n* Show amounts in mBTC, uBTC and sat denominations."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.3.6-universal.json
var require_t2t1_2_3_6_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.3.6-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 3, 6],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 0, 0],
      min_firmware_version: [2, 0, 8],
      firmware_revision: "b19cbf67c6c7c38513947b703df6d4409c59bc98",
      translations: {},
      url: "firmware/t2t1/trezor-t2t1-2.3.6.bin",
      fingerprint: "0efa3ba6135caea7693d145d60441eeb46283fe0b8b1fd59a04af33a638ad237",
      changelog: "* Add compatibility paths for Unchained Capital"
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.4.0-universal.json
var require_t2t1_2_4_0_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.4.0-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 4, 0],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 0, 0],
      min_firmware_version: [2, 0, 8],
      firmware_revision: "ea3596ad89a7993ad7b9d62798de94325ad1717a",
      translations: {},
      url: "firmware/t2t1/trezor-t2t1-2.4.0.bin",
      fingerprint: "d90265ee6d7d499c7d938b5322f71f27042da8a6fdaed54c224d31b65e868def",
      changelog: "* Locking the device by holding finger on the homescreen.\n* Support PIN of unlimited length.\n* Allow decreasing the output value in RBF transactions.\n* Reduce memory fragmentation.\n* Update FIDO icons.\n* Improve wording when showing multisig XPUBs."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.4.1-universal.json
var require_t2t1_2_4_1_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.4.1-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 4, 1],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 0, 0],
      min_firmware_version: [2, 0, 8],
      firmware_revision: "24bb4016388fca4b998285b95dcd408f4ed0bff6",
      translations: {},
      url: "firmware/t2t1/trezor-t2t1-2.4.1.bin",
      fingerprint: "84bc47bb197b3ae7bfb096f03d4a528ccf6c9ef4dfee0aac4022971e4ec91d68",
      changelog: "* Security and major perfomance improvements.\n* Cardano fixes.\n* Fix red screen on shutdown."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.4.2-universal.json
var require_t2t1_2_4_2_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.4.2-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 4, 2],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 0, 0],
      min_firmware_version: [2, 0, 8],
      firmware_revision: "9276b1702361f70e094286e2f89e919d8a230d5c",
      translations: {},
      url: "firmware/t2t1/trezor-t2t1-2.4.2.bin",
      fingerprint: "54ccf155510b5292bd17ed748409d0d135112e24e62eb74184639460beecb213",
      changelog: "* Support for Ethereum EIP1559 transactions.\n* Re-enabled Firo support.\n* Memory optimization of BTC signing and CBOR decoding.\n* Support for large Cardano transactions.\n* Remove Lisk."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.4.3-universal.json
var require_t2t1_2_4_3_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.4.3-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 4, 3],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 0, 0],
      min_firmware_version: [2, 0, 8],
      firmware_revision: "595b14254c1abb2be3f69e42c7932f1eca8cf1b1",
      translations: {},
      url: "firmware/t2t1/trezor-t2t1-2.4.3.bin",
      fingerprint: "a07f69d8d2065006a79c6b5636bd046496dbcb3820b41f1d604d8a4605ca4056",
      changelog: "* Support Taproot.\n* Show address confirmation in SignMessage.\n* Support for advanced Cardano transactions and different derivations for compatibility.\n* Ethereum support for EIP712 (signing typed data)."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.5.1-universal.json
var require_t2t1_2_5_1_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.5.1-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 5, 1],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 0, 0],
      min_firmware_version: [2, 0, 8],
      firmware_revision: "85a26d2c9593bcdf858c2d718d79951ca927a0c3",
      translations: {},
      url: "firmware/t2t1/trezor-t2t1-2.5.1.bin",
      fingerprint: "782d4934897018cac779eebb0d7c66e21da7789b9cd35e1f99f097bdfd9b7d33",
      changelog: "* Support Electrum signatures in VerifyMessage.\n* Support Cardano Alonzo-era transactions (Plutus).\n* Bitcoin bech32 addresses QR codes have bigger pixels which are easier to scan.\n* EIP-1559 transaction correctly show final Hold to Confirm screen.\n* Trezor will refuse to sign UTXOs that do not match the provided derivation path (e.g., transactions belonging to a different wallet, or synthetic transaction inputs).\n* Zcash v5 transaction format."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.5.2-universal.json
var require_t2t1_2_5_2_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.5.2-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 5, 2],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 0, 0],
      min_firmware_version: [2, 0, 8],
      firmware_revision: "0d87b55ba4fed7eecc72bf2a94ee473830b095e9",
      translations: {},
      url: "firmware/t2t1/trezor-t2t1-2.5.2.bin",
      fingerprint: "659b1b698546fa63f24200e148b6f9a7044df31d11a0a5ec7c044f2dd83f4a27",
      changelog: '* Add support for Monero HF15 features. \n* Show the fee rate on the signing confirmation screen. \n* Support for Cardano Babbage era transaction items \n* Add "Show All"/"Show Simple" choice to Cardano transaction signing \n* Show thousands separator when displaying large amounts. \n* Fix Decred transaction weight calculation.'
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.5.3-universal.json
var require_t2t1_2_5_3_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.5.3-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 5, 3],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 0, 0],
      min_firmware_version: [2, 0, 8],
      firmware_revision: "2f03ace311584988d5aeab58fd1acf24ef54711a",
      translations: {},
      url: "firmware/t2t1/trezor-t2t1-2.5.3.bin",
      fingerprint: "4f57dca1abc1a60d82c4fef7c96e86d784fc7a1e5e3da724dd2ae4d14c6350bf",
      changelog: "* Add SLIP-0025 CoinJoin accounts. \n* Show red error header when Trezor doesn't see USB data connection. \n* Add support for Zcash unified addresses. \n* Show fee rate when replacing transaction. \n* Optimize the signing of BTC transactions. \n* Support for Cardano CIP-36 governance registration format. \n* Extend decimals of fee rate to 2 digits. \n* Display only \u201Csat\u201D instead of \u201Csat BTC\u201D. \n* Fix sending XMR transaction to an integrated address. \n* Fix XMR primary address display."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.6.0-universal.json
var require_t2t1_2_6_0_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.6.0-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 6, 0],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 0, 0],
      min_firmware_version: [2, 0, 8],
      bootloader_version: [2, 1, 0],
      firmware_revision: "88e1f8c7a5c7615723664c64b0a25adc0c409dee",
      translations: {},
      url: "firmware/t2t1/trezor-t2t1-2.6.0.bin",
      fingerprint: "050526db604b9acceef2a5a8561bc99ecbe337909283ebb927b556d8e9b13872",
      changelog: `* Show source account path in BTC signing. 
* Address confirmation screen added to EIP712 signing flow. 
* Ability to reboot the device into bootloader mode directly, without needing to unplug the device. 
* Support for Ledger Live legacy derivation path "m/44'/coin_type'/0'/account". 
* Redesigned UI. 
* Homescreen now supports full-screen images. 
* Force basic attestation in FIDO2 for google.com.`
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.6.3-universal.json
var require_t2t1_2_6_3_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.6.3-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 6, 3],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 0, 0],
      min_firmware_version: [2, 0, 8],
      bootloader_version: [2, 1, 4],
      firmware_revision: "2c7cc6e0255dee2339b445b5551eaffb88dbd1b4",
      translations: {},
      url: "firmware/t2t1/trezor-t2t1-2.6.3.bin",
      fingerprint: "9ff0874f2ce3579a7502747578cef65c824097d906e7150b0142f6b9aa395a43",
      changelog: "* QR Code for Extended Public Keys (XPUBs). \n* Adjusted buttons for multipage content scrolling, providing a more intuitive and user-friendly experience. \n* The new bootloader version 2.1.4 is now included for enhanced system performance and security."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.6.4-universal.json
var require_t2t1_2_6_4_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.6.4-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 6, 4],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 0, 0],
      min_firmware_version: [2, 0, 8],
      bootloader_version: [2, 1, 4],
      firmware_revision: "42e9ed0e09033d474dee1a560fe5870646fa440e",
      translations: {},
      url: "firmware/t2t1/trezor-t2t1-2.6.4.bin",
      fingerprint: "441faa92156e8ae0b8247f9434c3ec8cf6ffd872f16fc593b22c4460dfd93913",
      changelog: "* Trezor Model T now supports Solana, expanding the range of cryptocurrencies it can securely manage. [Universal fw only] \n* Ethereum fees are now uniformly presented in Gwei, enhancing clarity and consistency for users. [Universal fw only] \n* The display of spaced addresses has been refined, offering a more user-friendly and visually optimized experience. \n* Boot-up logo display has been optimized, contributing to a smoother and more visually appealing device startup."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.7.0-universal.json
var require_t2t1_2_7_0_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.7.0-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 7, 0],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 0, 0],
      min_firmware_version: [2, 0, 8],
      bootloader_version: [2, 1, 4],
      firmware_revision: "45e8a842a31e62a6d43d7f6ccac62a45e1198ef0",
      translations: {
        "cs-CZ": "firmware/translations/t2t1/translation-T2T1-cs-CZ-2.7.0.bin",
        "de-DE": "firmware/translations/t2t1/translation-T2T1-de-DE-2.7.0.bin",
        "es-ES": "firmware/translations/t2t1/translation-T2T1-es-ES-2.7.0.bin",
        "fr-FR": "firmware/translations/t2t1/translation-T2T1-fr-FR-2.7.0.bin"
      },
      url: "firmware/t2t1/trezor-t2t1-2.7.0.bin",
      fingerprint: "53a645218792e413ad06c27320b7d1adc944b690ce831301bbf11c30352d3278",
      changelog: "* Add translations capability. \n* Allow for going back to previous word in recovery process. \n* Clear sign ETH staking transactions on Everstake pool. [Universal fw only] \n* Display descriptors for BTC Taproot public keys. \n* Fixed blank display delay on startup when display orientation is set to other than north. \n* Multiple Solana instructions improved. [Universal fw only]"
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.7.2-universal.json
var require_t2t1_2_7_2_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.7.2-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 7, 2],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 0, 0],
      min_firmware_version: [2, 0, 8],
      bootloader_version: [2, 1, 4],
      firmware_revision: "da75d8f4b67410b40a9cfd2954d183d81dd6e8e8",
      translations: {
        "cs-CZ": "firmware/translations/t2t1/translation-T2T1-cs-CZ-2.7.2.bin",
        "de-DE": "firmware/translations/t2t1/translation-T2T1-de-DE-2.7.2.bin",
        "es-ES": "firmware/translations/t2t1/translation-T2T1-es-ES-2.7.2.bin",
        "fr-FR": "firmware/translations/t2t1/translation-T2T1-fr-FR-2.7.2.bin"
      },
      url: "firmware/t2t1/trezor-t2t1-2.7.2.bin",
      fingerprint: "d64fcf47a8ead6edf0329583e312136d1548d30990c29cfaa2ce7c67197babcc",
      changelog: "* Introducing repeated backups. \n* Multi-share backups can now have any number of shares. \n* Added support for Cardano Conway certificates [Universal fw only]."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.8.1-universal.json
var require_t2t1_2_8_1_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.8.1-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 8, 1],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 0, 0],
      min_firmware_version: [2, 0, 8],
      bootloader_version: [2, 1, 6],
      firmware_revision: "632b9561559b7ab6824bb7eeac072874e07b7b82",
      translations: {
        "cs-CZ": "firmware/translations/t2t1/translation-T2T1-cs-CZ-2.8.1.bin",
        "de-DE": "firmware/translations/t2t1/translation-T2T1-de-DE-2.8.1.bin",
        "es-ES": "firmware/translations/t2t1/translation-T2T1-es-ES-2.8.1.bin",
        "fr-FR": "firmware/translations/t2t1/translation-T2T1-fr-FR-2.8.1.bin",
        "it-IT": "firmware/translations/t2t1/translation-T2T1-it-IT-2.8.1.bin",
        "pt-BR": "firmware/translations/t2t1/translation-T2T1-pt-BR-2.8.1.bin"
      },
      url: "firmware/t2t1/trezor-t2t1-2.8.1.bin",
      fingerprint: "d3af84a212d32785449ca6575e3cf2a641920b353a82dec9f059083ea5d4b149",
      changelog: "* Fixed displaying of a progress indicator for the formatting operation.\n* Improve precision of PIN validation countdown.\n* Solana: Improved support for AToken Create operation."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.8.10-universal.json
var require_t2t1_2_8_10_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.8.10-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 8, 10],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 0, 0],
      min_firmware_version: [2, 0, 8],
      bootloader_version: [2, 1, 8],
      firmware_revision: "2a65d18200580005dc419b9569ed97fae440806a",
      translations: {
        "cs-CZ": "firmware/translations/t2t1/translation-T2T1-cs-CZ-2.8.10.bin",
        "de-DE": "firmware/translations/t2t1/translation-T2T1-de-DE-2.8.10.bin",
        "es-ES": "firmware/translations/t2t1/translation-T2T1-es-ES-2.8.10.bin",
        "fr-FR": "firmware/translations/t2t1/translation-T2T1-fr-FR-2.8.10.bin",
        "it-IT": "firmware/translations/t2t1/translation-T2T1-it-IT-2.8.10.bin",
        "pt-BR": "firmware/translations/t2t1/translation-T2T1-pt-BR-2.8.10.bin"
      },
      url: "firmware/t2t1/trezor-t2t1-2.8.10.bin",
      fingerprint: "91feae69ada0f98b72f19191f1d1e083b579c26079f7e6fcd751fae0902ec72f",
      changelog: '* Add Nostr support (in debug mode only!).\n* Solana: rent fee calculation [#4933]\n* Solana: loadable token definitions [#3541]\n* Replaced "next page" icon with "..." ellipsis when confirming long message.\n* Fixed upgrade confirmation text overflow.\n* Fixed Solana staking dialog fonts.\n* Updated EIP-1559 fee-related labels.\n* Allow firmware upgrade even if language change failed.\n* Solana: fees calculation is now exact [#4965]'
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.8.7-universal.json
var require_t2t1_2_8_7_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.8.7-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 8, 7],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 0, 0],
      min_firmware_version: [2, 0, 8],
      bootloader_version: [2, 1, 8],
      firmware_revision: "8a254aa8eae82f99630df63f40e4d290066a3efc",
      translations: {
        "cs-CZ": "firmware/translations/t2t1/translation-T2T1-cs-CZ-2.8.7.bin",
        "de-DE": "firmware/translations/t2t1/translation-T2T1-de-DE-2.8.7.bin",
        "es-ES": "firmware/translations/t2t1/translation-T2T1-es-ES-2.8.7.bin",
        "fr-FR": "firmware/translations/t2t1/translation-T2T1-fr-FR-2.8.7.bin",
        "it-IT": "firmware/translations/t2t1/translation-T2T1-it-IT-2.8.7.bin",
        "pt-BR": "firmware/translations/t2t1/translation-T2T1-pt-BR-2.8.7.bin"
      },
      url: "firmware/t2t1/trezor-t2t1-2.8.7.bin",
      fingerprint: "7f7bae53913c3a339f22adddb16db70b11bcf908af1c7a5986bae09af9d4ab62",
      changelog: "* Show last typed PIN number for short period of time.\n* Multisig-related changes.\n* Simplify UI of Cardano transactions initiated by Trezor Suite.\n* Included new version of bootloader (2.1.8).\n* Fix ETH account number detection.\n* New EVM call contract flow UI.\n* Fix translation of the 'Enable labeling' screen."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.8.8-universal.json
var require_t2t1_2_8_8_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.8.8-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 8, 8],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 0, 0],
      min_firmware_version: [2, 0, 8],
      bootloader_version: [2, 1, 8],
      firmware_revision: "592590cf66a9b62dfeee7e4d2afb6e01005e5b2c",
      translations: {
        "cs-CZ": "firmware/translations/t2t1/translation-T2T1-cs-CZ-2.8.8.bin",
        "de-DE": "firmware/translations/t2t1/translation-T2T1-de-DE-2.8.8.bin",
        "es-ES": "firmware/translations/t2t1/translation-T2T1-es-ES-2.8.8.bin",
        "fr-FR": "firmware/translations/t2t1/translation-T2T1-fr-FR-2.8.8.bin",
        "it-IT": "firmware/translations/t2t1/translation-T2T1-it-IT-2.8.8.bin",
        "pt-BR": "firmware/translations/t2t1/translation-T2T1-pt-BR-2.8.8.bin"
      },
      url: "firmware/t2t1/trezor-t2t1-2.8.8.bin",
      fingerprint: "f4888bed3e75205464910f3956d1f3ad19bb73e093b31c9141a66226a7081990",
      changelog: '* Fix "PIN attempts exceeded" screen\n* Fixed a bug resulting in restarting the recovery flow when inputting 33-word mnemonic'
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.8.9-universal.json
var require_t2t1_2_8_9_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t2t1/universal/t2t1-2.8.9-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 8, 9],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 0, 0],
      min_firmware_version: [2, 0, 8],
      bootloader_version: [2, 1, 8],
      firmware_revision: "fad9682201cf9289bba2adb66e6e07ed1cf78936",
      translations: {
        "cs-CZ": "firmware/translations/t2t1/translation-T2T1-cs-CZ-2.8.9.bin",
        "de-DE": "firmware/translations/t2t1/translation-T2T1-de-DE-2.8.9.bin",
        "es-ES": "firmware/translations/t2t1/translation-T2T1-es-ES-2.8.9.bin",
        "fr-FR": "firmware/translations/t2t1/translation-T2T1-fr-FR-2.8.9.bin",
        "it-IT": "firmware/translations/t2t1/translation-T2T1-it-IT-2.8.9.bin",
        "pt-BR": "firmware/translations/t2t1/translation-T2T1-pt-BR-2.8.9.bin"
      },
      url: "firmware/t2t1/trezor-t2t1-2.8.9.bin",
      fingerprint: "ec61dba50be195f1cbb78688a0b92fb293c23150b68f5dab3b44420a106fca17",
      changelog: "* Ability to cancel recovery on word count selection screen.\n* Account info for ETH transactions.\n* New UI for confirming long messages.\n* Solana staking confirmation dialogs."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t3b1/bitcoinonly/t3b1-2.8.10-bitcoinonly.json
var require_t3b1_2_8_10_bitcoinonly = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t3b1/bitcoinonly/t3b1-2.8.10-bitcoinonly.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 8, 10],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 1, 7],
      min_firmware_version: [2, 8, 3],
      bootloader_version: [2, 1, 10],
      firmware_revision: "2a65d18200580005dc419b9569ed97fae440806a",
      translations: {
        "cs-CZ": "firmware/translations/t3b1/translation-T3B1-cs-CZ-2.8.10.bin",
        "de-DE": "firmware/translations/t3b1/translation-T3B1-de-DE-2.8.10.bin",
        "es-ES": "firmware/translations/t3b1/translation-T3B1-es-ES-2.8.10.bin",
        "fr-FR": "firmware/translations/t3b1/translation-T3B1-fr-FR-2.8.10.bin",
        "it-IT": "firmware/translations/t3b1/translation-T3B1-it-IT-2.8.10.bin",
        "pt-BR": "firmware/translations/t3b1/translation-T3B1-pt-BR-2.8.10.bin"
      },
      url: "firmware/t3b1/trezor-t3b1-2.8.10-bitcoinonly.bin",
      fingerprint: "5a0aa661b61d056f72b83bf0d5c7eb4ddc84d6370fb977be794b145e49e8ff3f",
      changelog: '* Upgrade bundled bootloader to 2.1.10.\n* Replaced "next page" icon with "..." ellipsis when confirming long message.\n* Allow firmware upgrade even if language change failed.'
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t3b1/bitcoinonly/t3b1-2.8.3-bitcoinonly.json
var require_t3b1_2_8_3_bitcoinonly = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t3b1/bitcoinonly/t3b1-2.8.3-bitcoinonly.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 8, 3],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 1, 7],
      min_firmware_version: [2, 8, 3],
      bootloader_version: [2, 1, 8],
      firmware_revision: "7f373ae71eca855dd41b4a0fdcc7cadaa13a8281",
      translations: {
        "cs-CZ": "firmware/translations/t3b1/translation-T3B1-cs-CZ-2.8.3.bin",
        "de-DE": "firmware/translations/t3b1/translation-T3B1-de-DE-2.8.3.bin",
        "es-ES": "firmware/translations/t3b1/translation-T3B1-es-ES-2.8.3.bin",
        "fr-FR": "firmware/translations/t3b1/translation-T3B1-fr-FR-2.8.3.bin",
        "it-IT": "firmware/translations/t3b1/translation-T3B1-it-IT-2.8.3.bin",
        "pt-BR": "firmware/translations/t3b1/translation-T3B1-pt-BR-2.8.3.bin"
      },
      url: "firmware/t3b1/trezor-t3b1-2.8.3-bitcoinonly.bin",
      fingerprint: "070a61b2a8653e4f9857810b6610d0a15f76ba627c7b6e5654a6de9a1c529049",
      changelog: "* Fix persistent word when going to previous word during recovery process.\n* Fix display orientation south."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t3b1/bitcoinonly/t3b1-2.8.7-bitcoinonly.json
var require_t3b1_2_8_7_bitcoinonly = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t3b1/bitcoinonly/t3b1-2.8.7-bitcoinonly.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 8, 7],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 1, 7],
      min_firmware_version: [2, 8, 3],
      bootloader_version: [2, 1, 8],
      firmware_revision: "8a254aa8eae82f99630df63f40e4d290066a3efc",
      translations: {
        "cs-CZ": "firmware/translations/t3b1/translation-T3B1-cs-CZ-2.8.7.bin",
        "de-DE": "firmware/translations/t3b1/translation-T3B1-de-DE-2.8.7.bin",
        "es-ES": "firmware/translations/t3b1/translation-T3B1-es-ES-2.8.7.bin",
        "fr-FR": "firmware/translations/t3b1/translation-T3B1-fr-FR-2.8.7.bin",
        "it-IT": "firmware/translations/t3b1/translation-T3B1-it-IT-2.8.7.bin",
        "pt-BR": "firmware/translations/t3b1/translation-T3B1-pt-BR-2.8.7.bin"
      },
      url: "firmware/t3b1/trezor-t3b1-2.8.7-bitcoinonly.bin",
      fingerprint: "4737a6e12d0ebff19fec3aceb212adff57bbcea7a44f8208caf91cc656382d94",
      changelog: "* Show last typed PIN number for short period of time.\n* Multisig-related changes.\n* Included new version of bootloader (2.1.8).\n* Fix translation of the 'Enable labeling' screen."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t3b1/bitcoinonly/t3b1-2.8.9-bitcoinonly.json
var require_t3b1_2_8_9_bitcoinonly = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t3b1/bitcoinonly/t3b1-2.8.9-bitcoinonly.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 8, 9],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 1, 7],
      min_firmware_version: [2, 8, 3],
      bootloader_version: [2, 1, 8],
      firmware_revision: "fad9682201cf9289bba2adb66e6e07ed1cf78936",
      translations: {
        "cs-CZ": "firmware/translations/t3b1/translation-T3B1-cs-CZ-2.8.9.bin",
        "de-DE": "firmware/translations/t3b1/translation-T3B1-de-DE-2.8.9.bin",
        "es-ES": "firmware/translations/t3b1/translation-T3B1-es-ES-2.8.9.bin",
        "fr-FR": "firmware/translations/t3b1/translation-T3B1-fr-FR-2.8.9.bin",
        "it-IT": "firmware/translations/t3b1/translation-T3B1-it-IT-2.8.9.bin",
        "pt-BR": "firmware/translations/t3b1/translation-T3B1-pt-BR-2.8.9.bin"
      },
      url: "firmware/t3b1/trezor-t3b1-2.8.9-bitcoinonly.bin",
      fingerprint: "d3905f15221f7b2733e5496986ceb1a3b39f390c4439e2d3cc89d5f3b7423278",
      changelog: "* Ability to cancel recovery on word count selection screen.\n* New UI for confirming long messages."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t3b1/universal/t3b1-2.8.10-universal.json
var require_t3b1_2_8_10_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t3b1/universal/t3b1-2.8.10-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 8, 10],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 1, 7],
      min_firmware_version: [2, 8, 3],
      bootloader_version: [2, 1, 10],
      firmware_revision: "2a65d18200580005dc419b9569ed97fae440806a",
      translations: {
        "cs-CZ": "firmware/translations/t3b1/translation-T3B1-cs-CZ-2.8.10.bin",
        "de-DE": "firmware/translations/t3b1/translation-T3B1-de-DE-2.8.10.bin",
        "es-ES": "firmware/translations/t3b1/translation-T3B1-es-ES-2.8.10.bin",
        "fr-FR": "firmware/translations/t3b1/translation-T3B1-fr-FR-2.8.10.bin",
        "it-IT": "firmware/translations/t3b1/translation-T3B1-it-IT-2.8.10.bin",
        "pt-BR": "firmware/translations/t3b1/translation-T3B1-pt-BR-2.8.10.bin"
      },
      url: "firmware/t3b1/trezor-t3b1-2.8.10.bin",
      fingerprint: "ad763b0193bf2814bdb9807b51226e1c7639693e912e9334db3f446091943369",
      changelog: '* Upgrade bundled bootloader to 2.1.10.\n* Add Nostr support (in debug mode only!).\n* Solana: rent fee calculation [#4933]\n* Solana: loadable token definitions [#3541]\n* Replaced "next page" icon with "..." ellipsis when confirming long message.\n* Fixed Solana staking dialog title.\n* Updated EIP-1559 fee-related labels.\n* Allow firmware upgrade even if language change failed.\n* Solana: fees calculation is now exact [#4965]'
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t3b1/universal/t3b1-2.8.3-universal.json
var require_t3b1_2_8_3_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t3b1/universal/t3b1-2.8.3-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 8, 3],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 1, 7],
      min_firmware_version: [2, 8, 3],
      bootloader_version: [2, 1, 8],
      firmware_revision: "7f373ae71eca855dd41b4a0fdcc7cadaa13a8281",
      translations: {
        "cs-CZ": "firmware/translations/t3b1/translation-T3B1-cs-CZ-2.8.3.bin",
        "de-DE": "firmware/translations/t3b1/translation-T3B1-de-DE-2.8.3.bin",
        "es-ES": "firmware/translations/t3b1/translation-T3B1-es-ES-2.8.3.bin",
        "fr-FR": "firmware/translations/t3b1/translation-T3B1-fr-FR-2.8.3.bin",
        "it-IT": "firmware/translations/t3b1/translation-T3B1-it-IT-2.8.3.bin",
        "pt-BR": "firmware/translations/t3b1/translation-T3B1-pt-BR-2.8.3.bin"
      },
      url: "firmware/t3b1/trezor-t3b1-2.8.3.bin",
      fingerprint: "b659bdc5ddce208d46ce649fc7a8995ae49541c7c41a88ddaac5dfc038ffb5de",
      changelog: "* Renamed MATIC to POL, following a network upgrade.\n* Fix persistent word when going to previous word during recovery process.\n* Fix display orientation south."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t3b1/universal/t3b1-2.8.7-universal.json
var require_t3b1_2_8_7_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t3b1/universal/t3b1-2.8.7-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 8, 7],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 1, 7],
      min_firmware_version: [2, 8, 3],
      bootloader_version: [2, 1, 8],
      firmware_revision: "8a254aa8eae82f99630df63f40e4d290066a3efc",
      translations: {
        "cs-CZ": "firmware/translations/t3b1/translation-T3B1-cs-CZ-2.8.7.bin",
        "de-DE": "firmware/translations/t3b1/translation-T3B1-de-DE-2.8.7.bin",
        "es-ES": "firmware/translations/t3b1/translation-T3B1-es-ES-2.8.7.bin",
        "fr-FR": "firmware/translations/t3b1/translation-T3B1-fr-FR-2.8.7.bin",
        "it-IT": "firmware/translations/t3b1/translation-T3B1-it-IT-2.8.7.bin",
        "pt-BR": "firmware/translations/t3b1/translation-T3B1-pt-BR-2.8.7.bin"
      },
      url: "firmware/t3b1/trezor-t3b1-2.8.7.bin",
      fingerprint: "1dd5ec22c2609beb6d17a97bf9b4f42a18af1c12db2446d29a945f4ece8727f6",
      changelog: "* Show last typed PIN number for short period of time.\n* Multisig-related changes.\n* Simplify UI of Cardano transactions initiated by Trezor Suite.\n* Included new version of bootloader (2.1.8).\n* Fix ETH account number detection.\n* New EVM call contract flow UI.\n* Fix translation of the 'Enable labeling' screen."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t3b1/universal/t3b1-2.8.9-universal.json
var require_t3b1_2_8_9_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t3b1/universal/t3b1-2.8.9-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 8, 9],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 1, 7],
      min_firmware_version: [2, 8, 3],
      bootloader_version: [2, 1, 8],
      firmware_revision: "fad9682201cf9289bba2adb66e6e07ed1cf78936",
      translations: {
        "cs-CZ": "firmware/translations/t3b1/translation-T3B1-cs-CZ-2.8.9.bin",
        "de-DE": "firmware/translations/t3b1/translation-T3B1-de-DE-2.8.9.bin",
        "es-ES": "firmware/translations/t3b1/translation-T3B1-es-ES-2.8.9.bin",
        "fr-FR": "firmware/translations/t3b1/translation-T3B1-fr-FR-2.8.9.bin",
        "it-IT": "firmware/translations/t3b1/translation-T3B1-it-IT-2.8.9.bin",
        "pt-BR": "firmware/translations/t3b1/translation-T3B1-pt-BR-2.8.9.bin"
      },
      url: "firmware/t3b1/trezor-t3b1-2.8.9.bin",
      fingerprint: "5b3a639c5b6423d87f4c0a3855dc4be8ad7e5be6d6b1b33f93ab1a54f3f36a91",
      changelog: "* Ability to cancel recovery on word count selection screen.\n* New UI for confirming long messages.\n* Solana staking confirmation dialogs."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t3t1/bitcoinonly/t3t1-2.7.2-bitcoinonly.json
var require_t3t1_2_7_2_bitcoinonly = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t3t1/bitcoinonly/t3t1-2.7.2-bitcoinonly.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 7, 2],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 1, 6],
      min_firmware_version: [2, 7, 2],
      bootloader_version: [2, 1, 6],
      firmware_revision: "da75d8f4b67410b40a9cfd2954d183d81dd6e8e8",
      translations: {
        "cs-CZ": "firmware/translations/t3t1/translation-T3T1-cs-CZ-2.7.2.bin",
        "de-DE": "firmware/translations/t3t1/translation-T3T1-de-DE-2.7.2.bin",
        "es-ES": "firmware/translations/t3t1/translation-T3T1-es-ES-2.7.2.bin",
        "fr-FR": "firmware/translations/t3t1/translation-T3T1-fr-FR-2.7.2.bin"
      },
      url: "firmware/t3t1/trezor-t3t1-2.7.2-bitcoinonly.bin",
      fingerprint: "246cca86b0a8cfcac6b7e6b3fcf55f543a8a9c9fd1f8ff88cd0de00640cb25eb",
      changelog: "* Introducing repeated backups. \n* Multi-share backups can now have any number of shares."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t3t1/bitcoinonly/t3t1-2.8.0-bitcoinonly.json
var require_t3t1_2_8_0_bitcoinonly = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t3t1/bitcoinonly/t3t1-2.8.0-bitcoinonly.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 8, 0],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 1, 6],
      min_firmware_version: [2, 7, 2],
      bootloader_version: [2, 1, 6],
      firmware_revision: "dd4671a5104952ef505d28d1f9e94d1484b4607a",
      translations: {
        "cs-CZ": "firmware/translations/t3t1/translation-T3T1-cs-CZ-2.8.0.bin",
        "de-DE": "firmware/translations/t3t1/translation-T3T1-de-DE-2.8.0.bin",
        "es-ES": "firmware/translations/t3t1/translation-T3T1-es-ES-2.8.0.bin",
        "fr-FR": "firmware/translations/t3t1/translation-T3T1-fr-FR-2.8.0.bin"
      },
      url: "firmware/t3t1/trezor-t3t1-2.8.0-bitcoinonly.bin",
      fingerprint: "3dc847cc396fe83f5a324242097a4cf97fc64acf90516efcfcf23b6d3103a992",
      changelog: "* Added tutorial flow. \n* Added Animated device label on homescreen/lockscreen. \n* Added word counter during wallet creation. \n* Improved change homescreen flow. \n* Improved swipe behavior and animations. \n* Increased Optiga read timeout to avoid spurious RSODs. \n* Fixed swipe back from address QR code screen. \n* Fixed device authenticity check. \n* Removed CoSi functionality."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t3t1/bitcoinonly/t3t1-2.8.1-bitcoinonly.json
var require_t3t1_2_8_1_bitcoinonly = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t3t1/bitcoinonly/t3t1-2.8.1-bitcoinonly.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 8, 1],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 1, 6],
      min_firmware_version: [2, 7, 2],
      bootloader_version: [2, 1, 6],
      firmware_revision: "632b9561559b7ab6824bb7eeac072874e07b7b82",
      translations: {
        "cs-CZ": "firmware/translations/t3t1/translation-T3T1-cs-CZ-2.8.1.bin",
        "de-DE": "firmware/translations/t3t1/translation-T3T1-de-DE-2.8.1.bin",
        "es-ES": "firmware/translations/t3t1/translation-T3T1-es-ES-2.8.1.bin",
        "fr-FR": "firmware/translations/t3t1/translation-T3T1-fr-FR-2.8.1.bin"
      },
      url: "firmware/t3t1/trezor-t3t1-2.8.1-bitcoinonly.bin",
      fingerprint: "6b17de0c89c9a7876687d6b9c44673f4aca7f8819237a755090848a3829bc36b",
      changelog: "* Added PIN keyboard animation.\n* Added menu entry animation.\n* Added screen brightness settings.\n* Screen transitions and animations were improved and are now more smooth.\n* Improved precision of PIN validation countdown.\n* Improved instruction screens during multi-share recovery process.\n* New UI of firmware update.\n* Improved share words swiping animation during wallet creation.\n* Fixed title sometimes not fitting into result screen.\n* Improved touch layer precision.\n* Fixed \u201CMore info\u201D screen during multi-share backup creation.\n* Fixed title sometimes not fitting into result screen.\n* Adjusted detection of swipes: vertical swipes are preferred over horizontal swipes now."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t3t1/bitcoinonly/t3t1-2.8.10-bitcoinonly.json
var require_t3t1_2_8_10_bitcoinonly = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t3t1/bitcoinonly/t3t1-2.8.10-bitcoinonly.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 8, 10],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 1, 6],
      min_firmware_version: [2, 7, 2],
      bootloader_version: [2, 1, 10],
      firmware_revision: "2a65d18200580005dc419b9569ed97fae440806a",
      translations: {
        "cs-CZ": "firmware/translations/t3t1/translation-T3T1-cs-CZ-2.8.10.bin",
        "de-DE": "firmware/translations/t3t1/translation-T3T1-de-DE-2.8.10.bin",
        "es-ES": "firmware/translations/t3t1/translation-T3T1-es-ES-2.8.10.bin",
        "fr-FR": "firmware/translations/t3t1/translation-T3T1-fr-FR-2.8.10.bin",
        "it-IT": "firmware/translations/t3t1/translation-T3T1-it-IT-2.8.10.bin",
        "pt-BR": "firmware/translations/t3t1/translation-T3T1-pt-BR-2.8.10.bin"
      },
      url: "firmware/t3t1/trezor-t3t1-2.8.10-bitcoinonly.bin",
      fingerprint: "11d3f68d08f3f95c04dd526826f81eb7918df85928cfcef73beeae3132342bf0",
      changelog: '* Visual cues to distinguish unlocked state on Homescreen.\n* Replaced "next page" icon with "..." ellipsis when confirming long message.\n* Allow firmware upgrade even if language change failed.'
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t3t1/bitcoinonly/t3t1-2.8.3-bitcoinonly.json
var require_t3t1_2_8_3_bitcoinonly = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t3t1/bitcoinonly/t3t1-2.8.3-bitcoinonly.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 8, 3],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 1, 6],
      min_firmware_version: [2, 7, 2],
      bootloader_version: [2, 1, 8],
      firmware_revision: "7f373ae71eca855dd41b4a0fdcc7cadaa13a8281",
      translations: {
        "cs-CZ": "firmware/translations/t3t1/translation-T3T1-cs-CZ-2.8.3.bin",
        "de-DE": "firmware/translations/t3t1/translation-T3T1-de-DE-2.8.3.bin",
        "es-ES": "firmware/translations/t3t1/translation-T3T1-es-ES-2.8.3.bin",
        "fr-FR": "firmware/translations/t3t1/translation-T3T1-fr-FR-2.8.3.bin",
        "it-IT": "firmware/translations/t3t1/translation-T3T1-it-IT-2.8.3.bin",
        "pt-BR": "firmware/translations/t3t1/translation-T3T1-pt-BR-2.8.3.bin"
      },
      url: "firmware/t3t1/trezor-t3t1-2.8.3-bitcoinonly.bin",
      fingerprint: "9eaf99a9420d2a3b9377102eb06b938f5a1886ecb06cccde7fd3cb7a39e1abd7",
      changelog: "* Added reassuring screen when entering empty passphrase on device.\n* Fix persistent word when going to previous word during recovery process.\n* Added missing info about remaining shares in super-shamir recovery."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t3t1/bitcoinonly/t3t1-2.8.7-bitcoinonly.json
var require_t3t1_2_8_7_bitcoinonly = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t3t1/bitcoinonly/t3t1-2.8.7-bitcoinonly.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 8, 7],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 1, 6],
      min_firmware_version: [2, 7, 2],
      bootloader_version: [2, 1, 9],
      firmware_revision: "8a254aa8eae82f99630df63f40e4d290066a3efc",
      translations: {
        "cs-CZ": "firmware/translations/t3t1/translation-T3T1-cs-CZ-2.8.7.bin",
        "de-DE": "firmware/translations/t3t1/translation-T3T1-de-DE-2.8.7.bin",
        "es-ES": "firmware/translations/t3t1/translation-T3T1-es-ES-2.8.7.bin",
        "fr-FR": "firmware/translations/t3t1/translation-T3T1-fr-FR-2.8.7.bin",
        "it-IT": "firmware/translations/t3t1/translation-T3T1-it-IT-2.8.7.bin",
        "pt-BR": "firmware/translations/t3t1/translation-T3T1-pt-BR-2.8.7.bin"
      },
      url: "firmware/t3t1/trezor-t3t1-2.8.7-bitcoinonly.bin",
      fingerprint: "2f58de2b7c2c29b6a2f14909ad0941e4aa9dd6d3e1416ab66c512a743b5385a9",
      changelog: "* Show last typed PIN number for short period of time.\n* Multisig-related changes.\n* Included new version of bootloader (2.1.9).\n* Fix XPUB confirmed success screen title.\n* Fix incorrect navigation in handy menu while signing BTC message.\n* Fix translation of the 'Enable labeling' screen."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t3t1/bitcoinonly/t3t1-2.8.9-bitcoinonly.json
var require_t3t1_2_8_9_bitcoinonly = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t3t1/bitcoinonly/t3t1-2.8.9-bitcoinonly.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 8, 9],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 1, 6],
      min_firmware_version: [2, 7, 2],
      bootloader_version: [2, 1, 10],
      firmware_revision: "fad9682201cf9289bba2adb66e6e07ed1cf78936",
      translations: {
        "cs-CZ": "firmware/translations/t3t1/translation-T3T1-cs-CZ-2.8.9.bin",
        "de-DE": "firmware/translations/t3t1/translation-T3T1-de-DE-2.8.9.bin",
        "es-ES": "firmware/translations/t3t1/translation-T3T1-es-ES-2.8.9.bin",
        "fr-FR": "firmware/translations/t3t1/translation-T3T1-fr-FR-2.8.9.bin",
        "it-IT": "firmware/translations/t3t1/translation-T3T1-it-IT-2.8.9.bin",
        "pt-BR": "firmware/translations/t3t1/translation-T3T1-pt-BR-2.8.9.bin"
      },
      url: "firmware/t3t1/trezor-t3t1-2.8.9-bitcoinonly.bin",
      fingerprint: "ac995c394f7a7b3ea4cbd9c04977621d6d2fbef30bba856f707f585f34866ac4",
      changelog: '* Ability to cancel recovery flow on word count selection screen.\n* New UI for confirming long messages.\n* Changed "swipe to continue" to "tap to continue". Screens still respond to swipe-up, but the preferred interaction method is now tapping the lower part of the screen.'
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t3t1/universal/t3t1-2.7.2-universal.json
var require_t3t1_2_7_2_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t3t1/universal/t3t1-2.7.2-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 7, 2],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 1, 6],
      min_firmware_version: [2, 7, 2],
      bootloader_version: [2, 1, 6],
      firmware_revision: "da75d8f4b67410b40a9cfd2954d183d81dd6e8e8",
      translations: {
        "cs-CZ": "firmware/translations/t3t1/translation-T3T1-cs-CZ-2.7.2.bin",
        "de-DE": "firmware/translations/t3t1/translation-T3T1-de-DE-2.7.2.bin",
        "es-ES": "firmware/translations/t3t1/translation-T3T1-es-ES-2.7.2.bin",
        "fr-FR": "firmware/translations/t3t1/translation-T3T1-fr-FR-2.7.2.bin"
      },
      url: "firmware/t3t1/trezor-t3t1-2.7.2.bin",
      fingerprint: "4daa5fd3c4c92ee0d76855997dde09a7ee25f4165b118c521ab10957c5fc92b0",
      changelog: "* Introducing repeated backups. \n* Multi-share backups can now have any number of shares. \n* Added support for Cardano Conway certificates [Universal fw only]."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t3t1/universal/t3t1-2.8.0-universal.json
var require_t3t1_2_8_0_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t3t1/universal/t3t1-2.8.0-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 8, 0],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 1, 6],
      min_firmware_version: [2, 7, 2],
      bootloader_version: [2, 1, 6],
      firmware_revision: "dd4671a5104952ef505d28d1f9e94d1484b4607a",
      translations: {
        "cs-CZ": "firmware/translations/t3t1/translation-T3T1-cs-CZ-2.8.0.bin",
        "de-DE": "firmware/translations/t3t1/translation-T3T1-de-DE-2.8.0.bin",
        "es-ES": "firmware/translations/t3t1/translation-T3T1-es-ES-2.8.0.bin",
        "fr-FR": "firmware/translations/t3t1/translation-T3T1-fr-FR-2.8.0.bin"
      },
      url: "firmware/t3t1/trezor-t3t1-2.8.0.bin",
      fingerprint: "bd199ce0934769aca5c3a91f71fd48e533d88c8cf087b76ac49db415fa08c286",
      changelog: "* Added tutorial flow. \n* Added Animated device label on homescreen/lockscreen. \n* Added word counter during wallet creation. \n* Improved change homescreen flow. \n* Improved swipe behavior and animations. \n* Increased Optiga read timeout to avoid spurious RSODs. \n* Fixed swipe back from address QR code screen. \n* Fixed device authenticity check. \n* Removed CoSi functionality."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t3t1/universal/t3t1-2.8.1-universal.json
var require_t3t1_2_8_1_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t3t1/universal/t3t1-2.8.1-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 8, 1],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 1, 6],
      min_firmware_version: [2, 7, 2],
      bootloader_version: [2, 1, 6],
      firmware_revision: "632b9561559b7ab6824bb7eeac072874e07b7b82",
      translations: {
        "cs-CZ": "firmware/translations/t3t1/translation-T3T1-cs-CZ-2.8.1.bin",
        "de-DE": "firmware/translations/t3t1/translation-T3T1-de-DE-2.8.1.bin",
        "es-ES": "firmware/translations/t3t1/translation-T3T1-es-ES-2.8.1.bin",
        "fr-FR": "firmware/translations/t3t1/translation-T3T1-fr-FR-2.8.1.bin"
      },
      url: "firmware/t3t1/trezor-t3t1-2.8.1.bin",
      fingerprint: "6a064df4a928e1264d682a34cc014fc9272f312e0f8a8270ff88d6f1408fe68b",
      changelog: "* Added PIN keyboard animation.\n* Added menu entry animation.\n* Added screen brightness settings.\n* Screen transitions and animations were improved and are now more smooth.\n* Improved precision of PIN validation countdown.\n* Improved instruction screens during multi-share recovery process.\n* New UI of firmware update.\n* Improved share words swiping animation during wallet creation.\n* Solana: Improved support for AToken Create operation.\n* Fixed title sometimes not fitting into result screen.\n* Improved touch layer precision.\n* Fixed \u201CMore info\u201D screen during multi-share backup creation.\n* Fixed title sometimes not fitting into result screen.\n* Adjusted detection of swipes: vertical swipes are preferred over horizontal swipes now."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t3t1/universal/t3t1-2.8.10-universal.json
var require_t3t1_2_8_10_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t3t1/universal/t3t1-2.8.10-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 8, 10],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 1, 6],
      min_firmware_version: [2, 7, 2],
      bootloader_version: [2, 1, 10],
      firmware_revision: "2a65d18200580005dc419b9569ed97fae440806a",
      translations: {
        "cs-CZ": "firmware/translations/t3t1/translation-T3T1-cs-CZ-2.8.10.bin",
        "de-DE": "firmware/translations/t3t1/translation-T3T1-de-DE-2.8.10.bin",
        "es-ES": "firmware/translations/t3t1/translation-T3T1-es-ES-2.8.10.bin",
        "fr-FR": "firmware/translations/t3t1/translation-T3T1-fr-FR-2.8.10.bin",
        "it-IT": "firmware/translations/t3t1/translation-T3T1-it-IT-2.8.10.bin",
        "pt-BR": "firmware/translations/t3t1/translation-T3T1-pt-BR-2.8.10.bin"
      },
      url: "firmware/t3t1/trezor-t3t1-2.8.10.bin",
      fingerprint: "f6f50b4a419b041a59620ef681047c27af0902798e0227397c532dd70736694a",
      changelog: '* Add Nostr support (in debug mode only!).\n* Visual cues to distinguish unlocked state on Homescreen.\n* Solana: rent fee calculation [#4933]\n* Solana: loadable token definitions [#3541]\n* Replaced "next page" icon with "..." ellipsis when confirming long message.\n* Updated EIP-1559 fee-related labels.\n* Allow firmware upgrade even if language change failed.\n* Solana: fees calculation is now exact [#4965]'
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t3t1/universal/t3t1-2.8.3-universal.json
var require_t3t1_2_8_3_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t3t1/universal/t3t1-2.8.3-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 8, 3],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 1, 6],
      min_firmware_version: [2, 7, 2],
      bootloader_version: [2, 1, 8],
      firmware_revision: "7f373ae71eca855dd41b4a0fdcc7cadaa13a8281",
      translations: {
        "cs-CZ": "firmware/translations/t3t1/translation-T3T1-cs-CZ-2.8.3.bin",
        "de-DE": "firmware/translations/t3t1/translation-T3T1-de-DE-2.8.3.bin",
        "es-ES": "firmware/translations/t3t1/translation-T3T1-es-ES-2.8.3.bin",
        "fr-FR": "firmware/translations/t3t1/translation-T3T1-fr-FR-2.8.3.bin",
        "it-IT": "firmware/translations/t3t1/translation-T3T1-it-IT-2.8.3.bin",
        "pt-BR": "firmware/translations/t3t1/translation-T3T1-pt-BR-2.8.3.bin"
      },
      url: "firmware/t3t1/trezor-t3t1-2.8.3.bin",
      fingerprint: "0de51126c17cc0ac623800638dc851c0abd5b787cad5f3aa5843ea2c4cf8248a",
      changelog: "* Added reassuring screen when entering empty passphrase on device.\n* Improved ETH send and staking flow.\n* Redesigned FIDO2 UI.\n* Renamed MATIC to POL, following a network upgrade.\n* Fix persistent word when going to previous word during recovery process.\n* Added missing info about remaining shares in super-shamir recovery."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t3t1/universal/t3t1-2.8.7-universal.json
var require_t3t1_2_8_7_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t3t1/universal/t3t1-2.8.7-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 8, 7],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 1, 6],
      min_firmware_version: [2, 7, 2],
      bootloader_version: [2, 1, 9],
      firmware_revision: "8a254aa8eae82f99630df63f40e4d290066a3efc",
      translations: {
        "cs-CZ": "firmware/translations/t3t1/translation-T3T1-cs-CZ-2.8.7.bin",
        "de-DE": "firmware/translations/t3t1/translation-T3T1-de-DE-2.8.7.bin",
        "es-ES": "firmware/translations/t3t1/translation-T3T1-es-ES-2.8.7.bin",
        "fr-FR": "firmware/translations/t3t1/translation-T3T1-fr-FR-2.8.7.bin",
        "it-IT": "firmware/translations/t3t1/translation-T3T1-it-IT-2.8.7.bin",
        "pt-BR": "firmware/translations/t3t1/translation-T3T1-pt-BR-2.8.7.bin"
      },
      url: "firmware/t3t1/trezor-t3t1-2.8.7.bin",
      fingerprint: "be15ee1f4b7891dc965512455f8d17067ff54a7047e28ed06cec8d56529ab2ef",
      changelog: "* Show last typed PIN number for short period of time.\n* Multisig-related changes.\n* Simplify UI of Cardano transactions initiated by Trezor Suite.\n* Included new version of bootloader (2.1.9).\n* Fix ETH account number detection.\n* Show account info in ETH send/stake flow.\n* Fix XPUB confirmed success screen title.\n* New EVM call contract flow UI.\n* Fix incorrect navigation in handy menu while signing BTC message.\n* Fix translation of the 'Enable labeling' screen."
    };
  }
});

// node_modules/@trezor/connect-common/files/firmware/t3t1/universal/t3t1-2.8.9-universal.json
var require_t3t1_2_8_9_universal = __commonJS({
  "node_modules/@trezor/connect-common/files/firmware/t3t1/universal/t3t1-2.8.9-universal.json"(exports2, module2) {
    module2.exports = {
      required: false,
      version: [2, 8, 9],
      min_bridge_version: [2, 0, 7],
      min_bootloader_version: [2, 1, 6],
      min_firmware_version: [2, 7, 2],
      bootloader_version: [2, 1, 10],
      firmware_revision: "fad9682201cf9289bba2adb66e6e07ed1cf78936",
      translations: {
        "cs-CZ": "firmware/translations/t3t1/translation-T3T1-cs-CZ-2.8.9.bin",
        "de-DE": "firmware/translations/t3t1/translation-T3T1-de-DE-2.8.9.bin",
        "es-ES": "firmware/translations/t3t1/translation-T3T1-es-ES-2.8.9.bin",
        "fr-FR": "firmware/translations/t3t1/translation-T3T1-fr-FR-2.8.9.bin",
        "it-IT": "firmware/translations/t3t1/translation-T3T1-it-IT-2.8.9.bin",
        "pt-BR": "firmware/translations/t3t1/translation-T3T1-pt-BR-2.8.9.bin"
      },
      url: "firmware/t3t1/trezor-t3t1-2.8.9.bin",
      fingerprint: "3a0228ae58bfd65ba341b33a34138d0d70a9a16f5d2db387f9ee2659d797dedf",
      changelog: '* Ability to cancel recovery flow on word count selection screen.\n* New UI for confirming long messages.\n* Solana staking confirmation dialogs.\n* Changed "swipe to continue" to "tap to continue". Screens still respond to swipe-up, but the preferred interaction method is now tapping the lower part of the screen.'
    };
  }
});

// node_modules/@trezor/connect-common/lib/map-releases.js
var require_map_releases = __commonJS({
  "node_modules/@trezor/connect-common/lib/map-releases.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.firmwareAssets = void 0;
    exports2.firmwareAssets = {
      release: {
        "releases.v1": require_releases_v1()
      },
      t1b1: {
        bitcoinonly: {
          "t1b1-1.10.0-bitcoinonly": require_t1b1_1_10_0_bitcoinonly(),
          "t1b1-1.10.1-bitcoinonly": require_t1b1_1_10_1_bitcoinonly(),
          "t1b1-1.10.2-bitcoinonly": require_t1b1_1_10_2_bitcoinonly(),
          "t1b1-1.10.3-bitcoinonly": require_t1b1_1_10_3_bitcoinonly(),
          "t1b1-1.10.4-bitcoinonly": require_t1b1_1_10_4_bitcoinonly(),
          "t1b1-1.10.5-bitcoinonly": require_t1b1_1_10_5_bitcoinonly(),
          "t1b1-1.11.1-bitcoinonly": require_t1b1_1_11_1_bitcoinonly(),
          "t1b1-1.11.2-bitcoinonly": require_t1b1_1_11_2_bitcoinonly(),
          "t1b1-1.12.1-bitcoinonly": require_t1b1_1_12_1_bitcoinonly(),
          "t1b1-1.13.0-bitcoinonly": require_t1b1_1_13_0_bitcoinonly(),
          "t1b1-1.13.1-bitcoinonly": require_t1b1_1_13_1_bitcoinonly(),
          "t1b1-1.8.3-bitcoinonly": require_t1b1_1_8_3_bitcoinonly(),
          "t1b1-1.9.0-bitcoinonly": require_t1b1_1_9_0_bitcoinonly(),
          "t1b1-1.9.1-bitcoinonly": require_t1b1_1_9_1_bitcoinonly(),
          "t1b1-1.9.2-bitcoinonly": require_t1b1_1_9_2_bitcoinonly(),
          "t1b1-1.9.3-bitcoinonly": require_t1b1_1_9_3_bitcoinonly(),
          "t1b1-1.9.4-bitcoinonly": require_t1b1_1_9_4_bitcoinonly()
        },
        universal: {
          "t1b1-1.10.0-universal": require_t1b1_1_10_0_universal(),
          "t1b1-1.10.1-universal": require_t1b1_1_10_1_universal(),
          "t1b1-1.10.2-universal": require_t1b1_1_10_2_universal(),
          "t1b1-1.10.3-universal": require_t1b1_1_10_3_universal(),
          "t1b1-1.10.4-universal": require_t1b1_1_10_4_universal(),
          "t1b1-1.10.5-universal": require_t1b1_1_10_5_universal(),
          "t1b1-1.11.1-universal": require_t1b1_1_11_1_universal(),
          "t1b1-1.11.2-universal": require_t1b1_1_11_2_universal(),
          "t1b1-1.12.1-universal": require_t1b1_1_12_1_universal(),
          "t1b1-1.13.0-universal": require_t1b1_1_13_0_universal(),
          "t1b1-1.13.1-universal": require_t1b1_1_13_1_universal(),
          "t1b1-1.3.6-universal": require_t1b1_1_3_6_universal(),
          "t1b1-1.4.0-universal": require_t1b1_1_4_0_universal(),
          "t1b1-1.4.1-universal": require_t1b1_1_4_1_universal(),
          "t1b1-1.4.2-universal": require_t1b1_1_4_2_universal(),
          "t1b1-1.5.0-universal": require_t1b1_1_5_0_universal(),
          "t1b1-1.5.1-universal": require_t1b1_1_5_1_universal(),
          "t1b1-1.5.2-universal": require_t1b1_1_5_2_universal(),
          "t1b1-1.6.0-universal": require_t1b1_1_6_0_universal(),
          "t1b1-1.6.1-universal": require_t1b1_1_6_1_universal(),
          "t1b1-1.6.2-universal": require_t1b1_1_6_2_universal(),
          "t1b1-1.6.3-universal": require_t1b1_1_6_3_universal(),
          "t1b1-1.7.1-universal": require_t1b1_1_7_1_universal(),
          "t1b1-1.7.2-universal": require_t1b1_1_7_2_universal(),
          "t1b1-1.7.3-universal": require_t1b1_1_7_3_universal(),
          "t1b1-1.8.0-universal": require_t1b1_1_8_0_universal(),
          "t1b1-1.8.1-universal": require_t1b1_1_8_1_universal(),
          "t1b1-1.8.2-universal": require_t1b1_1_8_2_universal(),
          "t1b1-1.8.3-universal": require_t1b1_1_8_3_universal(),
          "t1b1-1.9.0-universal": require_t1b1_1_9_0_universal(),
          "t1b1-1.9.1-universal": require_t1b1_1_9_1_universal(),
          "t1b1-1.9.2-universal": require_t1b1_1_9_2_universal(),
          "t1b1-1.9.3-universal": require_t1b1_1_9_3_universal(),
          "t1b1-1.9.4-universal": require_t1b1_1_9_4_universal()
        }
      },
      t2b1: {
        bitcoinonly: {
          "t2b1-2.6.3-bitcoinonly": require_t2b1_2_6_3_bitcoinonly(),
          "t2b1-2.6.4-bitcoinonly": require_t2b1_2_6_4_bitcoinonly(),
          "t2b1-2.7.0-bitcoinonly": require_t2b1_2_7_0_bitcoinonly(),
          "t2b1-2.7.2-bitcoinonly": require_t2b1_2_7_2_bitcoinonly(),
          "t2b1-2.8.0-bitcoinonly": require_t2b1_2_8_0_bitcoinonly(),
          "t2b1-2.8.10-bitcoinonly": require_t2b1_2_8_10_bitcoinonly(),
          "t2b1-2.8.7-bitcoinonly": require_t2b1_2_8_7_bitcoinonly(),
          "t2b1-2.8.9-bitcoinonly": require_t2b1_2_8_9_bitcoinonly()
        },
        universal: {
          "t2b1-2.6.3-universal": require_t2b1_2_6_3_universal(),
          "t2b1-2.6.4-universal": require_t2b1_2_6_4_universal(),
          "t2b1-2.7.0-universal": require_t2b1_2_7_0_universal(),
          "t2b1-2.7.2-universal": require_t2b1_2_7_2_universal(),
          "t2b1-2.8.0-universal": require_t2b1_2_8_0_universal(),
          "t2b1-2.8.10-universal": require_t2b1_2_8_10_universal(),
          "t2b1-2.8.7-universal": require_t2b1_2_8_7_universal(),
          "t2b1-2.8.9-universal": require_t2b1_2_8_9_universal()
        }
      },
      t2t1: {
        bitcoinonly: {
          "t2t1-2.1.5-bitcoinonly": require_t2t1_2_1_5_bitcoinonly(),
          "t2t1-2.1.6-bitcoinonly": require_t2t1_2_1_6_bitcoinonly(),
          "t2t1-2.1.7-bitcoinonly": require_t2t1_2_1_7_bitcoinonly(),
          "t2t1-2.1.8-bitcoinonly": require_t2t1_2_1_8_bitcoinonly(),
          "t2t1-2.3.0-bitcoinonly": require_t2t1_2_3_0_bitcoinonly(),
          "t2t1-2.3.1-bitcoinonly": require_t2t1_2_3_1_bitcoinonly(),
          "t2t1-2.3.2-bitcoinonly": require_t2t1_2_3_2_bitcoinonly(),
          "t2t1-2.3.3-bitcoinonly": require_t2t1_2_3_3_bitcoinonly(),
          "t2t1-2.3.4-bitcoinonly": require_t2t1_2_3_4_bitcoinonly(),
          "t2t1-2.3.5-bitcoinonly": require_t2t1_2_3_5_bitcoinonly(),
          "t2t1-2.3.6-bitcoinonly": require_t2t1_2_3_6_bitcoinonly(),
          "t2t1-2.4.0-bitcoinonly": require_t2t1_2_4_0_bitcoinonly(),
          "t2t1-2.4.1-bitcoinonly": require_t2t1_2_4_1_bitcoinonly(),
          "t2t1-2.4.2-bitcoinonly": require_t2t1_2_4_2_bitcoinonly(),
          "t2t1-2.4.3-bitcoinonly": require_t2t1_2_4_3_bitcoinonly(),
          "t2t1-2.5.1-bitcoinonly": require_t2t1_2_5_1_bitcoinonly(),
          "t2t1-2.5.2-bitcoinonly": require_t2t1_2_5_2_bitcoinonly(),
          "t2t1-2.5.3-bitcoinonly": require_t2t1_2_5_3_bitcoinonly(),
          "t2t1-2.6.0-bitcoinonly": require_t2t1_2_6_0_bitcoinonly(),
          "t2t1-2.6.3-bitcoinonly": require_t2t1_2_6_3_bitcoinonly(),
          "t2t1-2.6.4-bitcoinonly": require_t2t1_2_6_4_bitcoinonly(),
          "t2t1-2.7.0-bitcoinonly": require_t2t1_2_7_0_bitcoinonly(),
          "t2t1-2.7.2-bitcoinonly": require_t2t1_2_7_2_bitcoinonly(),
          "t2t1-2.8.1-bitcoinonly": require_t2t1_2_8_1_bitcoinonly(),
          "t2t1-2.8.10-bitcoinonly": require_t2t1_2_8_10_bitcoinonly(),
          "t2t1-2.8.7-bitcoinonly": require_t2t1_2_8_7_bitcoinonly(),
          "t2t1-2.8.8-bitcoinonly": require_t2t1_2_8_8_bitcoinonly(),
          "t2t1-2.8.9-bitcoinonly": require_t2t1_2_8_9_bitcoinonly()
        },
        universal: {
          "t2t1-2.0.10-universal": require_t2t1_2_0_10_universal(),
          "t2t1-2.0.5-universal": require_t2t1_2_0_5_universal(),
          "t2t1-2.0.6-universal": require_t2t1_2_0_6_universal(),
          "t2t1-2.0.7-universal": require_t2t1_2_0_7_universal(),
          "t2t1-2.0.8-universal": require_t2t1_2_0_8_universal(),
          "t2t1-2.0.9-universal": require_t2t1_2_0_9_universal(),
          "t2t1-2.1.0-universal": require_t2t1_2_1_0_universal(),
          "t2t1-2.1.1-universal": require_t2t1_2_1_1_universal(),
          "t2t1-2.1.4-universal": require_t2t1_2_1_4_universal(),
          "t2t1-2.1.5-universal": require_t2t1_2_1_5_universal(),
          "t2t1-2.1.6-universal": require_t2t1_2_1_6_universal(),
          "t2t1-2.1.7-universal": require_t2t1_2_1_7_universal(),
          "t2t1-2.1.8-universal": require_t2t1_2_1_8_universal(),
          "t2t1-2.3.0-universal": require_t2t1_2_3_0_universal(),
          "t2t1-2.3.1-universal": require_t2t1_2_3_1_universal(),
          "t2t1-2.3.2-universal": require_t2t1_2_3_2_universal(),
          "t2t1-2.3.3-universal": require_t2t1_2_3_3_universal(),
          "t2t1-2.3.4-universal": require_t2t1_2_3_4_universal(),
          "t2t1-2.3.5-universal": require_t2t1_2_3_5_universal(),
          "t2t1-2.3.6-universal": require_t2t1_2_3_6_universal(),
          "t2t1-2.4.0-universal": require_t2t1_2_4_0_universal(),
          "t2t1-2.4.1-universal": require_t2t1_2_4_1_universal(),
          "t2t1-2.4.2-universal": require_t2t1_2_4_2_universal(),
          "t2t1-2.4.3-universal": require_t2t1_2_4_3_universal(),
          "t2t1-2.5.1-universal": require_t2t1_2_5_1_universal(),
          "t2t1-2.5.2-universal": require_t2t1_2_5_2_universal(),
          "t2t1-2.5.3-universal": require_t2t1_2_5_3_universal(),
          "t2t1-2.6.0-universal": require_t2t1_2_6_0_universal(),
          "t2t1-2.6.3-universal": require_t2t1_2_6_3_universal(),
          "t2t1-2.6.4-universal": require_t2t1_2_6_4_universal(),
          "t2t1-2.7.0-universal": require_t2t1_2_7_0_universal(),
          "t2t1-2.7.2-universal": require_t2t1_2_7_2_universal(),
          "t2t1-2.8.1-universal": require_t2t1_2_8_1_universal(),
          "t2t1-2.8.10-universal": require_t2t1_2_8_10_universal(),
          "t2t1-2.8.7-universal": require_t2t1_2_8_7_universal(),
          "t2t1-2.8.8-universal": require_t2t1_2_8_8_universal(),
          "t2t1-2.8.9-universal": require_t2t1_2_8_9_universal()
        }
      },
      t3b1: {
        bitcoinonly: {
          "t3b1-2.8.10-bitcoinonly": require_t3b1_2_8_10_bitcoinonly(),
          "t3b1-2.8.3-bitcoinonly": require_t3b1_2_8_3_bitcoinonly(),
          "t3b1-2.8.7-bitcoinonly": require_t3b1_2_8_7_bitcoinonly(),
          "t3b1-2.8.9-bitcoinonly": require_t3b1_2_8_9_bitcoinonly()
        },
        universal: {
          "t3b1-2.8.10-universal": require_t3b1_2_8_10_universal(),
          "t3b1-2.8.3-universal": require_t3b1_2_8_3_universal(),
          "t3b1-2.8.7-universal": require_t3b1_2_8_7_universal(),
          "t3b1-2.8.9-universal": require_t3b1_2_8_9_universal()
        }
      },
      t3t1: {
        bitcoinonly: {
          "t3t1-2.7.2-bitcoinonly": require_t3t1_2_7_2_bitcoinonly(),
          "t3t1-2.8.0-bitcoinonly": require_t3t1_2_8_0_bitcoinonly(),
          "t3t1-2.8.1-bitcoinonly": require_t3t1_2_8_1_bitcoinonly(),
          "t3t1-2.8.10-bitcoinonly": require_t3t1_2_8_10_bitcoinonly(),
          "t3t1-2.8.3-bitcoinonly": require_t3t1_2_8_3_bitcoinonly(),
          "t3t1-2.8.7-bitcoinonly": require_t3t1_2_8_7_bitcoinonly(),
          "t3t1-2.8.9-bitcoinonly": require_t3t1_2_8_9_bitcoinonly()
        },
        universal: {
          "t3t1-2.7.2-universal": require_t3t1_2_7_2_universal(),
          "t3t1-2.8.0-universal": require_t3t1_2_8_0_universal(),
          "t3t1-2.8.1-universal": require_t3t1_2_8_1_universal(),
          "t3t1-2.8.10-universal": require_t3t1_2_8_10_universal(),
          "t3t1-2.8.3-universal": require_t3t1_2_8_3_universal(),
          "t3t1-2.8.7-universal": require_t3t1_2_8_7_universal(),
          "t3t1-2.8.9-universal": require_t3t1_2_8_9_universal()
        }
      }
    };
  }
});

// node_modules/@trezor/connect-common/lib/index.js
var require_lib5 = __commonJS({
  "node_modules/@trezor/connect-common/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_storage(), exports2);
    tslib_1.__exportStar(require_abstract(), exports2);
    tslib_1.__exportStar(require_systemInfo(), exports2);
    tslib_1.__exportStar(require_map_releases(), exports2);
  }
});

// node_modules/@trezor/connect-web/lib/channels/serviceworker-window.js
var require_serviceworker_window = __commonJS({
  "node_modules/@trezor/connect-web/lib/channels/serviceworker-window.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ServiceWorkerWindowChannel = void 0;
    var connect_common_1 = require_lib5();
    var ServiceWorkerWindowChannel = class extends connect_common_1.AbstractMessageChannel {
      port;
      name;
      allowSelfOrigin;
      currentId;
      constructor({ name, channel, logger, lazyHandshake, legacyMode, allowSelfOrigin = false, currentId }) {
        super({
          channel,
          sendFn: (message) => {
            if (!this.port)
              throw new Error("port not assigned");
            this.port.postMessage(message);
          },
          logger,
          lazyHandshake,
          legacyMode
        });
        this.name = name;
        this.allowSelfOrigin = allowSelfOrigin;
        this.currentId = currentId;
        this.connect();
      }
      connect() {
        chrome.runtime.onConnect.addListener((port) => {
          if (port.name !== this.name)
            return;
          if (this.currentId?.() && this.currentId?.() !== port.sender?.tab?.id)
            return;
          this.port = port;
          this.port.onMessage.addListener((message, { sender }) => {
            if (!sender) {
              this.logger?.error("service-worker-window", "no sender");
              return;
            }
            const { origin } = sender;
            const whitelist = [
              "https://connect.trezor.io",
              "https://staging-connect.trezor.io",
              "https://suite.corp.sldev.cz",
              "https://dev.suite.sldev.cz",
              "http://localhost:8088"
            ];
            const webextensionId = chrome?.runtime?.id;
            if (webextensionId) {
              whitelist.push(`chrome-extension://${webextensionId}`);
            }
            const webextensionUrl = chrome?.runtime?.getURL("");
            if (webextensionUrl) {
              whitelist.push(webextensionUrl.slice(0, -1));
            }
            if (!origin) {
              this.logger?.error("connect-webextension/messageChannel/extensionPort/onMessage", "no origin");
              return;
            }
            if (!whitelist.includes(origin)) {
              this.logger?.error("connect-webextension/messageChannel/extensionPort/onMessage", "origin not whitelisted", origin);
              return;
            }
            if (origin === self.origin && !this.allowSelfOrigin) {
              return;
            }
            this.onMessage(message);
          });
        });
        this.isConnected = true;
      }
      disconnect() {
        if (!this.isConnected)
          return;
        this.port?.disconnect();
        this.clear();
        this.isConnected = false;
      }
    };
    exports2.ServiceWorkerWindowChannel = ServiceWorkerWindowChannel;
  }
});

// node_modules/@trezor/connect-web/lib/channels/window-window.js
var require_window_window = __commonJS({
  "node_modules/@trezor/connect-web/lib/channels/window-window.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WindowWindowChannel = void 0;
    var connect_common_1 = require_lib5();
    var WindowWindowChannel = class extends connect_common_1.AbstractMessageChannel {
      _windowHere;
      _listener;
      constructor({ windowHere, windowPeer, channel, logger, origin, legacyMode }) {
        super({
          channel,
          sendFn: (message) => {
            windowPeer()?.postMessage(message, origin);
          },
          logger,
          legacyMode
        });
        this._listener = this.listener.bind(this);
        this._windowHere = windowHere;
        this.connect();
      }
      listener(event) {
        const message = {
          ...event.data,
          success: true,
          origin: event.origin,
          payload: event.data.payload || {},
          channel: event.data.channel || {
            peer: this.channel.here,
            here: this.channel.peer
          }
        };
        this.onMessage(message);
      }
      connect() {
        this._windowHere.addEventListener("message", this._listener);
        this.isConnected = true;
      }
      disconnect() {
        if (!this.isConnected)
          return;
        this._windowHere.removeEventListener("message", this._listener);
        this.isConnected = false;
      }
    };
    exports2.WindowWindowChannel = WindowWindowChannel;
  }
});

// node_modules/@trezor/connect-web/lib/popup/index.js
var require_popup2 = __commonJS({
  "node_modules/@trezor/connect-web/lib/popup/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PopupManager = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var events_1 = tslib_1.__importDefault(require_events());
    var version_1 = require_version();
    var events_2 = require_events2();
    var urlUtils_1 = require_urlUtils();
    var utils_1 = require_lib();
    var showPopupRequest_1 = require_showPopupRequest();
    var serviceworker_window_1 = require_serviceworker_window();
    var window_window_1 = require_window_window();
    var checkIfTabExists = (tabId) => new Promise((resolve) => {
      if (!tabId)
        return resolve(false);
      function callback() {
        if (chrome.runtime.lastError) {
          resolve(false);
        } else {
          resolve(true);
        }
      }
      chrome.tabs.get(tabId, callback);
    });
    var POPUP_REQUEST_TIMEOUT = 850;
    var POPUP_CLOSE_INTERVAL = 500;
    var POPUP_OPEN_TIMEOUT = 5e3;
    var PopupManager = class extends events_1.default {
      popupWindow;
      settings;
      origin;
      locked = false;
      channel;
      channelIframe;
      handshakePromise;
      iframeHandshakePromise;
      popupPromise;
      requestTimeout;
      openTimeout;
      closeInterval;
      extensionTabId = 0;
      logger;
      constructor(settings2, { logger }) {
        super();
        this.settings = settings2;
        this.origin = (0, urlUtils_1.getOrigin)(settings2.popupSrc);
        this.logger = logger;
        if (this.isWebExtensionWithTab()) {
          this.channel = new serviceworker_window_1.ServiceWorkerWindowChannel({
            name: "trezor-connect",
            channel: {
              here: "@trezor/connect-webextension",
              peer: "@trezor/connect-content-script"
            },
            logger,
            currentId: () => {
              if (this.popupWindow?.mode === "tab")
                return this.popupWindow?.tab.id;
            },
            legacyMode: !this.settings.useCoreInPopup
          });
        } else {
          this.channel = new window_window_1.WindowWindowChannel({
            windowHere: window,
            windowPeer: () => {
              if (this.popupWindow?.mode === "window")
                return this.popupWindow?.window;
            },
            channel: {
              here: "@trezor/connect-web",
              peer: "@trezor/connect-popup"
            },
            logger,
            origin: this.origin,
            legacyMode: !this.settings.useCoreInPopup
          });
        }
        if (!this.settings.useCoreInPopup) {
          this.iframeHandshakePromise = (0, utils_1.createDeferred)(events_2.IFRAME.LOADED);
          this.channelIframe = new window_window_1.WindowWindowChannel({
            windowHere: window,
            windowPeer: () => window,
            channel: {
              here: "@trezor/connect-web",
              peer: "@trezor/connect-iframe"
            },
            logger,
            origin: this.origin
          });
          this.channelIframe?.on("message", this.handleMessage.bind(this));
        }
        if (this.settings.useCoreInPopup) {
          this.handshakePromise = (0, utils_1.createDeferred)();
          this.channel.on("message", this.handleCoreMessage.bind(this));
          return;
        } else if (this.isWebExtensionWithTab()) {
          this.channel.on("message", this.handleExtensionMessage.bind(this));
        } else {
          this.channel.on("message", this.handleMessage.bind(this));
        }
        this.channel.init();
      }
      async request() {
        if (this.settings.useCoreInPopup && this.popupWindow?.mode === "tab") {
          const currentPopupExists = await checkIfTabExists(this.popupWindow?.tab?.id);
          if (!currentPopupExists) {
            this.clear();
          }
        }
        if (this.locked) {
          if (this.popupWindow?.mode === "tab" && this.popupWindow.tab.id) {
            chrome.tabs.update(this.popupWindow.tab.id, { active: true });
          } else if (this.popupWindow?.mode === "window") {
            this.popupWindow.window.focus();
          }
          return;
        }
        if (this.popupWindow && !this.locked) {
          this.close();
        }
        const openFn = this.open.bind(this);
        this.locked = true;
        const timeout = this.settings.env === "webextension" ? 1 : POPUP_REQUEST_TIMEOUT;
        this.requestTimeout = setTimeout(() => {
          this.requestTimeout = void 0;
          openFn();
        }, timeout);
      }
      unlock() {
        this.locked = false;
      }
      open() {
        const src = this.settings.popupSrc;
        this.popupPromise = (0, utils_1.createDeferred)(events_2.POPUP.LOADED);
        const url = this.buildPopupUrl(src);
        this.openWrapper(url);
        this.closeInterval = setInterval(() => {
          if (!this.popupWindow)
            return;
          if (this.popupWindow.mode === "tab" && this.popupWindow.tab.id) {
            chrome.tabs.get(this.popupWindow.tab.id, (tab) => {
              if (!tab) {
                this.emitClosed();
                this.clear();
              }
            });
          } else if (this.popupWindow.mode === "window" && this.popupWindow.window.closed) {
            this.clear();
            this.emitClosed();
          }
        }, POPUP_CLOSE_INTERVAL);
        if (this.settings.useCoreInPopup) {
          return;
        }
        this.openTimeout = setTimeout(() => {
          this.clear();
          (0, showPopupRequest_1.showPopupRequest)(this.open.bind(this), () => {
            this.emitClosed();
          });
        }, POPUP_OPEN_TIMEOUT);
      }
      buildPopupUrl(src) {
        const params = new URLSearchParams();
        params.set("version", version_1.VERSION);
        params.set("env", this.settings.env);
        if (this.settings.env === "webextension" && chrome?.runtime?.id) {
          params.set("extension-id", chrome.runtime.id);
          params.set("cs-ver", version_1.CONTENT_SCRIPT_VERSION.toString());
        }
        return src + "?" + params.toString();
      }
      openWrapper(url) {
        if (this.isWebExtensionWithTab()) {
          chrome.windows.getCurrent((currentWindow) => {
            this.logger.debug("opening popup. currentWindow: ", currentWindow);
            if (currentWindow.type !== "normal") {
              chrome.windows.create({ url }, (newWindow) => {
                chrome.tabs.query({
                  windowId: newWindow?.id,
                  active: true
                }, (tabs) => {
                  this.popupWindow = { mode: "tab", tab: tabs[0] };
                  this.injectContentScript(tabs[0].id);
                });
              });
            } else {
              chrome.tabs.query({
                currentWindow: true,
                active: true
              }, (tabs) => {
                this.extensionTabId = tabs[0].id;
                chrome.tabs.create({
                  url,
                  index: tabs[0].index + 1
                }, (tab) => {
                  this.popupWindow = { mode: "tab", tab };
                  this.injectContentScript(tab.id);
                });
              });
            }
          });
        } else {
          const windowResult = window.open(url, "modal");
          if (!windowResult)
            return;
          this.popupWindow = { mode: "window", window: windowResult };
        }
        if (!this.channel.isConnected) {
          this.channel.connect();
        }
      }
      injectContentScript = (tabId) => {
        chrome.permissions.getAll((permissions) => {
          if (permissions.permissions?.includes("scripting")) {
            (0, utils_1.scheduleAction)(() => chrome.scripting.executeScript({
              target: { tabId },
              func: () => {
              }
            }).then(() => {
              this.logger.debug("content script injected");
            }).catch((error) => {
              this.logger.error("content script injection error", error);
              throw error;
            }), { attempts: new Array(3).fill({ timeout: 100 }) });
          } else {
          }
        });
      };
      handleCoreMessage(message) {
        if (message.type === events_2.POPUP.BOOTSTRAP) {
          this.channel.init();
        } else if (message.type === events_2.POPUP.LOADED) {
          this.handleMessage(message);
          this.channel.postMessage({
            type: events_2.POPUP.INIT,
            payload: {
              settings: this.settings,
              useCore: true
            }
          });
        } else if (message.type === events_2.POPUP.CORE_LOADED) {
          this.channel.postMessage({
            type: events_2.POPUP.HANDSHAKE,
            payload: { settings: this.settings }
          });
          this.handshakePromise?.resolve();
        } else if (message.type === events_2.POPUP.CLOSED) {
          this.emitClosed();
        } else if (message.type === events_2.POPUP.CONTENT_SCRIPT_LOADED) {
          const { contentScriptVersion } = message.payload;
          if (contentScriptVersion !== version_1.CONTENT_SCRIPT_VERSION) {
            console.warn(`Content script version mismatch. Expected ${version_1.CONTENT_SCRIPT_VERSION}, got ${contentScriptVersion}`);
          }
        } else if (message.event === events_2.DEVICE_EVENT) {
          this.emit(events_2.DEVICE_EVENT, message);
        }
      }
      handleExtensionMessage(data) {
        if (data.type === events_2.POPUP.ERROR || data.type === events_2.POPUP.LOADED || data.type === events_2.POPUP.BOOTSTRAP) {
          this.handleMessage(data);
        } else if (data.type === events_2.POPUP.EXTENSION_USB_PERMISSIONS) {
          chrome.tabs.query({
            currentWindow: true,
            active: true
          }, (tabs) => {
            chrome.tabs.create({
              url: "trezor-usb-permissions.html",
              index: tabs[0].index + 1
            }, (_tab) => {
            });
          });
        } else if (data.type === events_2.POPUP.CLOSE_WINDOW) {
          this.clear();
        }
      }
      handleMessage(data) {
        if (data.type === events_2.IFRAME.LOADED) {
          this.iframeHandshakePromise?.resolve(data.payload);
        } else if (data.type === events_2.POPUP.BOOTSTRAP) {
          if (this.openTimeout)
            clearTimeout(this.openTimeout);
        } else if (data.type === events_2.POPUP.ERROR && this.popupWindow) {
          const errorMessage = data.payload && typeof data.payload.error === "string" ? data.payload.error : null;
          this.emit(events_2.POPUP.CLOSED, errorMessage ? `Popup error: ${errorMessage}` : null);
          this.clear();
        } else if (data.type === events_2.POPUP.LOADED) {
          if (this.openTimeout)
            clearTimeout(this.openTimeout);
          if (this.popupPromise) {
            this.popupPromise.resolve();
            this.popupPromise = void 0;
          }
          this.iframeHandshakePromise?.promise.then((payload) => {
            this.channel.postMessage({
              type: events_2.POPUP.INIT,
              payload: {
                ...payload,
                settings: this.settings
              }
            });
          });
        } else if (data.type === events_2.POPUP.CANCEL_POPUP_REQUEST) {
          clearTimeout(this.requestTimeout);
          if (this.popupPromise) {
            this.close();
          }
          this.unlock();
        } else if (data.type === events_2.UI.CLOSE_UI_WINDOW) {
          this.clear(false);
        }
      }
      clear(focus = true) {
        this.locked = false;
        this.popupPromise = void 0;
        this.handshakePromise = (0, utils_1.createDeferred)();
        if (this.channel) {
          this.channel.disconnect();
        }
        if (this.requestTimeout) {
          clearTimeout(this.requestTimeout);
          this.requestTimeout = void 0;
        }
        if (this.openTimeout) {
          clearTimeout(this.openTimeout);
          this.openTimeout = void 0;
        }
        if (this.closeInterval) {
          clearInterval(this.closeInterval);
          this.closeInterval = void 0;
        }
        if (focus && this.extensionTabId) {
          chrome.tabs.update(this.extensionTabId, { active: true });
          this.extensionTabId = 0;
        }
      }
      close() {
        if (!this.popupWindow)
          return;
        this.logger.debug("closing popup");
        if (this.popupWindow.mode === "tab") {
          let _e = chrome.runtime.lastError;
          if (this.popupWindow.tab.id) {
            chrome.tabs.remove(this.popupWindow.tab.id, () => {
              _e = chrome.runtime.lastError;
              if (_e) {
                this.logger.error("closed with error", _e);
              }
            });
          }
        } else if (this.popupWindow.mode === "window") {
          this.popupWindow.window.close();
        }
        this.popupWindow = void 0;
        if (this.settings?.useCoreInPopup) {
          this.channel.clear();
        }
      }
      async postMessage(message) {
        if (!this.popupWindow && message.type !== events_2.UI.REQUEST_UI_WINDOW && this.openTimeout) {
          this.clear();
          (0, showPopupRequest_1.showPopupRequest)(this.open.bind(this), () => {
            this.emitClosed();
          });
          return;
        }
        if (this.popupPromise) {
          await this.popupPromise.promise;
        }
        if (this.popupWindow?.mode === "window") {
          this.popupWindow.window.postMessage(message, this.origin);
        } else if (this.popupWindow?.mode === "tab") {
          this.channel.postMessage(message);
        }
      }
      isWebExtensionWithTab() {
        return this.settings?.env === "webextension" && typeof chrome !== "undefined" && typeof chrome?.tabs !== "undefined";
      }
      emitClosed() {
        if (this.settings?.useCoreInPopup) {
          this.channel.resolveMessagePromises({
            code: "Method_Interrupted",
            error: events_2.POPUP.CLOSED
          });
        }
        this.emit(events_2.POPUP.CLOSED);
      }
    };
    exports2.PopupManager = PopupManager;
  }
});

// node_modules/@trezor/connect-web/lib/webusb/button.js
var require_button = __commonJS({
  "node_modules/@trezor/connect-web/lib/webusb/button.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var render = (className = "", url) => {
      const query = className || ".trezor-webusb-button";
      const buttons = document.querySelectorAll(query);
      const src = `${url}?${Date.now()}`;
      buttons.forEach((b2) => {
        if (b2.getElementsByTagName("iframe").length < 1) {
          const bounds = b2.getBoundingClientRect();
          const btnIframe = document.createElement("iframe");
          btnIframe.frameBorder = "0";
          btnIframe.width = `${Math.round(bounds.width)}px`;
          btnIframe.height = `${Math.round(bounds.height)}px`;
          btnIframe.style.position = "absolute";
          btnIframe.style.top = "0px";
          btnIframe.style.left = "0px";
          btnIframe.style.zIndex = "1";
          btnIframe.setAttribute("allow", "usb");
          btnIframe.setAttribute("scrolling", "no");
          btnIframe.src = src;
          b2.append(btnIframe);
        }
      });
    };
    exports2.default = render;
  }
});

// node_modules/@trezor/connect-web/lib/impl/core-in-iframe.js
var require_core_in_iframe = __commonJS({
  "node_modules/@trezor/connect-web/lib/impl/core-in-iframe.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TrezorConnect = exports2.CoreInIframe = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var events_1 = tslib_1.__importDefault(require_events());
    var ERRORS = tslib_1.__importStar(require_errors2());
    var config_1 = require_config();
    var events_2 = require_events2();
    var factory_1 = require_factory();
    var debug_1 = require_debug2();
    var createDeferredManager_1 = require_createDeferredManager();
    var connectSettings_1 = require_connectSettings2();
    var iframe = tslib_1.__importStar(require_iframe2());
    var popup = tslib_1.__importStar(require_popup2());
    var button_1 = tslib_1.__importDefault(require_button());
    var CoreInIframe = class {
      eventEmitter = new events_1.default();
      _settings;
      _log;
      _popupManager;
      _messagePromises;
      boundHandleMessage = this.handleMessage.bind(this);
      boundDispose = this.dispose.bind(this);
      constructor() {
        this._settings = (0, connectSettings_1.parseConnectSettings)();
        this._log = (0, debug_1.initLog)("@trezor/connect-web");
        this._messagePromises = (0, createDeferredManager_1.createDeferredManager)({ initialId: 1 });
      }
      initPopupManager() {
        const pm = new popup.PopupManager(this._settings, { logger: this._log });
        pm.on(events_2.POPUP.CLOSED, (error) => {
          iframe.postMessage({
            type: events_2.POPUP.CLOSED,
            payload: error ? { error } : null
          });
        });
        return pm;
      }
      manifest(data) {
        this._settings = (0, connectSettings_1.parseConnectSettings)({
          ...this._settings,
          manifest: data
        });
      }
      dispose() {
        this.eventEmitter.removeAllListeners();
        iframe.dispose();
        this._settings = (0, connectSettings_1.parseConnectSettings)();
        if (this._popupManager) {
          this._popupManager.close();
        }
        window.removeEventListener("message", this.boundHandleMessage);
        window.removeEventListener("unload", this.boundDispose);
        return Promise.resolve(void 0);
      }
      cancel(error) {
        if (this._popupManager) {
          this._popupManager.emit(events_2.POPUP.CLOSED, error);
        }
      }
      handleMessage(messageEvent) {
        if (messageEvent.origin !== iframe.origin)
          return;
        const message = (0, events_2.parseMessage)(messageEvent.data);
        this._log.log("handleMessage", message);
        switch (message.event) {
          case events_2.RESPONSE_EVENT: {
            const { id: id2 = 0, success, payload, device } = message;
            const resolved = this._messagePromises.resolve(id2, {
              id: id2,
              success,
              payload,
              device
            });
            if (!resolved)
              this._log.warn(`Unknown message id ${id2}`);
            break;
          }
          case events_2.DEVICE_EVENT:
            this.eventEmitter.emit(message.event, message);
            this.eventEmitter.emit(message.type, message.payload);
            break;
          case events_2.TRANSPORT_EVENT:
            this.eventEmitter.emit(message.event, message);
            this.eventEmitter.emit(message.type, message.payload);
            break;
          case events_2.BLOCKCHAIN_EVENT:
            this.eventEmitter.emit(message.event, message);
            this.eventEmitter.emit(message.type, message.payload);
            break;
          case events_2.UI_EVENT:
            if (message.type === events_2.IFRAME.BOOTSTRAP) {
              iframe.clearTimeout();
              break;
            }
            if (message.type === events_2.IFRAME.LOADED) {
              iframe.initPromise.resolve();
            }
            if (message.type === events_2.IFRAME.ERROR) {
              iframe.initPromise.reject(message.payload.error);
            }
            this.eventEmitter.emit(message.event, message);
            this.eventEmitter.emit(message.type, message.payload);
            break;
          default:
            this._log.log("Undefined message", messageEvent.data);
        }
      }
      async init(settings2) {
        if (iframe.instance) {
          throw ERRORS.TypedError("Init_AlreadyInitialized");
        }
        this._settings = (0, connectSettings_1.parseConnectSettings)({ ...this._settings, ...settings2 });
        if (!this._settings.manifest) {
          throw ERRORS.TypedError("Init_ManifestMissing");
        }
        if (!this._settings.transports?.length) {
          this._settings.transports = ["BridgeTransport", "WebUsbTransport"];
        }
        if (!this._settings.coreMode) {
          this._settings.coreMode = "auto";
        }
        if (this._settings.lazyLoad) {
          this._settings.lazyLoad = false;
          return;
        }
        if (!this._popupManager) {
          this._popupManager = this.initPopupManager();
        }
        this._log.enabled = !!this._settings.debug;
        window.addEventListener("message", this.boundHandleMessage);
        window.addEventListener("unload", this.boundDispose);
        await iframe.init(this._settings);
        if (this._settings.coreMode === "auto") {
          const { promiseId, promise } = this._messagePromises.create();
          this._log.debug("coreMode = auto, Checking bridge availability");
          iframe.postMessage({ id: promiseId, type: events_2.TRANSPORT.GET_INFO });
          const response = await promise;
          this._log.debug("Bridge availability response", response);
          if (response.payload === void 0 && navigator.usb && this._settings.transports?.includes("WebUsbTransport")) {
            throw ERRORS.TypedError("Transport_Missing");
          }
        }
        if (this._settings.sharedLogger !== false) {
          iframe.initIframeLogger();
        }
      }
      setTransports() {
        throw new Error("Unsupported right now");
      }
      async call(params) {
        if (!iframe.instance && !iframe.timeout) {
          this._settings = (0, connectSettings_1.parseConnectSettings)(this._settings);
          if (!this._settings.manifest) {
            return (0, events_2.createErrorMessage)(ERRORS.TypedError("Init_ManifestMissing"));
          }
          if (!this._popupManager) {
            this._popupManager = this.initPopupManager();
          }
          try {
            await this.init(this._settings);
          } catch (error) {
            if (this._popupManager) {
              this._popupManager.clear();
            }
            return (0, events_2.createErrorMessage)(error);
          }
        }
        if (iframe.timeout) {
          await iframe.initPromise.promise;
        }
        if (iframe.error) {
          return (0, events_2.createErrorMessage)(iframe.error);
        }
        if (this._settings.popup && this._popupManager) {
          this._popupManager.request();
        }
        try {
          const { promiseId, promise } = this._messagePromises.create();
          iframe.postMessage({ id: promiseId, type: events_2.IFRAME.CALL, payload: params });
          const response = await promise;
          if (response) {
            if (!response.success && response.payload.code !== "Device_CallInProgress" && this._popupManager) {
              this._popupManager.unlock();
            }
            return response;
          }
          if (this._popupManager) {
            this._popupManager.unlock();
          }
          return (0, events_2.createErrorMessage)(ERRORS.TypedError("Method_NoResponse"));
        } catch (error) {
          this._log.error("__call error", error);
          if (this._popupManager) {
            this._popupManager.clear(false);
          }
          return (0, events_2.createErrorMessage)(error);
        }
      }
      uiResponse(response) {
        if (!iframe.instance) {
          throw ERRORS.TypedError("Init_NotInitialized");
        }
        iframe.postMessage(response);
      }
      renderWebUSBButton(className) {
        (0, button_1.default)(className, this._settings.webusbSrc);
      }
      async requestLogin(params) {
        if (typeof params.callback === "function") {
          const { callback } = params;
          const loginChallengeListener = async (event) => {
            const { data } = event;
            if (data && data.type === events_2.UI.LOGIN_CHALLENGE_REQUEST) {
              try {
                const payload = await callback();
                iframe.postMessage({
                  type: events_2.UI.LOGIN_CHALLENGE_RESPONSE,
                  payload
                });
              } catch (error) {
                iframe.postMessage({
                  type: events_2.UI.LOGIN_CHALLENGE_RESPONSE,
                  payload: error.message
                });
              }
            }
          };
          window.addEventListener("message", loginChallengeListener, false);
          const response = await this.call({
            method: "requestLogin",
            ...params,
            asyncChallenge: true,
            callback: null
          });
          window.removeEventListener("message", loginChallengeListener);
          return response;
        }
        return this.call({ method: "requestLogin", ...params });
      }
      disableWebUSB() {
        if (!iframe.instance) {
          throw ERRORS.TypedError("Init_NotInitialized");
        }
        iframe.postMessage({ type: events_2.TRANSPORT.DISABLE_WEBUSB });
      }
      async requestWebUSBDevice() {
        try {
          await window.navigator.usb.requestDevice({ filters: config_1.config.webusb });
          iframe.postMessage({ type: events_2.TRANSPORT.REQUEST_DEVICE });
        } catch {
        }
      }
    };
    exports2.CoreInIframe = CoreInIframe;
    var impl = new CoreInIframe();
    exports2.TrezorConnect = (0, factory_1.factory)({
      eventEmitter: impl.eventEmitter,
      init: impl.init.bind(impl),
      call: impl.call.bind(impl),
      setTransports: impl.setTransports.bind(impl),
      manifest: impl.manifest.bind(impl),
      requestLogin: impl.requestLogin.bind(impl),
      uiResponse: impl.uiResponse.bind(impl),
      cancel: impl.cancel.bind(impl),
      dispose: impl.dispose.bind(impl)
    }, {
      renderWebUSBButton: impl.renderWebUSBButton.bind(impl),
      disableWebUSB: impl.disableWebUSB.bind(impl),
      requestWebUSBDevice: impl.requestWebUSBDevice.bind(impl)
    });
  }
});

// node_modules/@trezor/connect-web/lib/impl/core-in-popup.js
var require_core_in_popup = __commonJS({
  "node_modules/@trezor/connect-web/lib/impl/core-in-popup.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TrezorConnect = exports2.CoreInPopup = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var events_1 = tslib_1.__importDefault(require_events());
    var ERRORS = tslib_1.__importStar(require_errors2());
    var events_2 = require_events2();
    var factory_1 = require_factory();
    var debug_1 = require_debug2();
    var utils_1 = require_lib();
    var connectSettings_1 = require_connectSettings2();
    var popup = tslib_1.__importStar(require_popup2());
    var CoreInPopup = class {
      eventEmitter = new events_1.default();
      _settings;
      logger;
      popupManagerLogger;
      _popupManager;
      constructor() {
        this._settings = (0, connectSettings_1.parseConnectSettings)();
        this.logger = (0, debug_1.initLog)("@trezor/connect-web");
        this.popupManagerLogger = (0, debug_1.initLog)("@trezor/connect-web/popupManager");
      }
      logWriterFactory(popupManager) {
        return {
          add: (message) => {
            popupManager.channel.postMessage({
              event: events_2.UI_EVENT,
              type: events_2.IFRAME.LOG,
              payload: message
            }, { usePromise: false, useQueue: true });
          }
        };
      }
      manifest(data) {
        this._settings = (0, connectSettings_1.parseConnectSettings)({
          ...this._settings,
          manifest: data
        });
      }
      dispose() {
        this.eventEmitter.removeAllListeners();
        this._settings = (0, connectSettings_1.parseConnectSettings)();
        if (this._popupManager) {
          this._popupManager.close();
        }
        return Promise.resolve(void 0);
      }
      cancel(error) {
        if (this._popupManager) {
          this._popupManager.emit(events_2.POPUP.CLOSED, error);
        }
      }
      init(settings2) {
        const oldSettings = (0, connectSettings_1.parseConnectSettings)({
          ...this._settings
        });
        const newSettings = (0, connectSettings_1.parseConnectSettings)({
          ...this._settings,
          ...settings2
        });
        if (!newSettings.transports?.length) {
          newSettings.transports = ["BridgeTransport", "WebUsbTransport"];
        }
        newSettings.useCoreInPopup = true;
        if (typeof window !== "undefined" && window?.location?.origin) {
          newSettings.origin = window.location.origin;
        }
        const equalSettings = JSON.stringify(oldSettings) === JSON.stringify(newSettings);
        this._settings = newSettings;
        if (!this._popupManager || !equalSettings) {
          if (this._popupManager)
            this._popupManager.close();
          this._popupManager = new popup.PopupManager(this._settings, {
            logger: this.popupManagerLogger
          });
          this._popupManager.on(events_2.DEVICE_EVENT, (event) => {
            this.eventEmitter.emit(events_2.DEVICE_EVENT, event);
          });
          (0, debug_1.setLogWriter)(() => this.logWriterFactory(this._popupManager));
        }
        this.logger.enabled = !!settings2.debug;
        if (!this._settings.manifest) {
          throw ERRORS.TypedError("Init_ManifestMissing");
        }
        this.logger.debug("initiated");
        return Promise.resolve();
      }
      setTransports() {
        throw new Error("Unsupported right now");
      }
      async call(params) {
        this.logger.debug("call", params);
        if (!this._popupManager) {
          return (0, events_2.createErrorMessage)(ERRORS.TypedError("Init_NotInitialized"));
        }
        if (this._settings.popup) {
          await this._popupManager.request();
        }
        const popupClosed = (0, utils_1.createDeferred)();
        const popupClosedHandler = () => {
          this.logger.log("Popup closed during initialization");
          popupClosed.reject(ERRORS.TypedError("Method_Interrupted"));
        };
        this._popupManager.once(events_2.POPUP.CLOSED, popupClosedHandler);
        try {
          this.logger.debug("call: popup initialing");
          await Promise.race([popupClosed.promise, this.callInit()]);
          this.logger.debug("call: popup initialized");
          const response = await this._popupManager.channel.postMessage({
            type: events_2.IFRAME.CALL,
            payload: params
          });
          this.logger.debug("call: response: ", response);
          if (response) {
            if (this._popupManager && response.success) {
              this._popupManager.clear();
            }
            return {
              success: response.success,
              payload: response.payload,
              device: response.device
            };
          }
          throw ERRORS.TypedError("Method_NoResponse");
        } catch (error) {
          this.logger.error("call: error", error);
          this._popupManager.clear(false);
          return (0, events_2.createErrorMessage)(error);
        } finally {
          this._popupManager.removeListener(events_2.POPUP.CLOSED, popupClosedHandler);
        }
      }
      async callInit() {
        if (!this._popupManager) {
          throw ERRORS.TypedError("Init_NotInitialized");
        }
        await this._popupManager.channel.init();
        if (this._settings.env === "webextension") {
          await this._popupManager.popupPromise?.promise;
          this._popupManager.channel.postMessage({
            type: events_2.POPUP.INIT,
            payload: {
              settings: this._settings,
              useCore: true
            }
          });
        }
        await this._popupManager.handshakePromise?.promise;
      }
      uiResponse(response) {
        const { type, payload } = response;
        this._popupManager?.channel?.postMessage({ event: events_2.UI_EVENT, type, payload });
      }
      renderWebUSBButton() {
      }
      requestLogin() {
        throw ERRORS.TypedError("Method_InvalidPackage");
      }
      disableWebUSB() {
        throw ERRORS.TypedError("Method_InvalidPackage");
      }
      requestWebUSBDevice() {
        throw ERRORS.TypedError("Method_InvalidPackage");
      }
    };
    exports2.CoreInPopup = CoreInPopup;
    var impl = new CoreInPopup();
    exports2.TrezorConnect = (0, factory_1.factory)({
      eventEmitter: impl.eventEmitter,
      init: impl.init.bind(impl),
      call: impl.call.bind(impl),
      setTransports: impl.setTransports.bind(impl),
      manifest: impl.manifest.bind(impl),
      requestLogin: impl.requestLogin.bind(impl),
      uiResponse: impl.uiResponse.bind(impl),
      cancel: impl.cancel.bind(impl),
      dispose: impl.dispose.bind(impl)
    });
  }
});

// node_modules/@trezor/websocket-client/lib/ws-browser.js
var require_ws_browser = __commonJS({
  "node_modules/@trezor/websocket-client/lib/ws-browser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var events_1 = require_events();
    var client_1 = require_client();
    var WSWrapper = class _WSWrapper extends events_1.EventEmitter {
      _ws;
      static CONNECTING = 0;
      static OPEN = 1;
      static CLOSING = 2;
      static CLOSED = 3;
      constructor(url, _protocols, _websocketOptions) {
        super();
        this._ws = new WebSocket(url);
        this._ws.onclose = () => {
          this.emit("close");
        };
        this._ws.onopen = () => {
          this.emit("open");
        };
        this._ws.onerror = (_event) => {
          this.emit("error", new client_1.WebsocketError(`WsWrapper error. Ready state: ${this.readyState}`));
        };
        this._ws.onmessage = (message) => {
          this.emit("message", message.data);
        };
      }
      close() {
        if (this.readyState === _WSWrapper.OPEN) {
          this._ws.close();
        }
      }
      send(message) {
        if (this.readyState !== _WSWrapper.OPEN) {
          throw new client_1.WebsocketError(`Connection is not open. state: ${this.readyState}`);
        }
        this._ws.send(message);
      }
      get readyState() {
        return this._ws.readyState;
      }
    };
    exports2.default = WSWrapper;
  }
});

// node_modules/@trezor/websocket-client/lib/client.js
var require_client = __commonJS({
  "node_modules/@trezor/websocket-client/lib/client.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WebsocketClient = exports2.WebsocketError = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var ws_1 = tslib_1.__importDefault(require_ws_browser());
    var utils_1 = require_lib();
    var DEFAULT_TIMEOUT = 20 * 1e3;
    var DEFAULT_PING_TIMEOUT = 50 * 1e3;
    var WebsocketError = class extends Error {
    };
    exports2.WebsocketError = WebsocketError;
    var WebsocketClient = class extends utils_1.TypedEmitter {
      options;
      messages;
      emitter = this;
      ws;
      pingTimeout;
      connectPromise;
      ping() {
        return this.sendMessage({ type: "ping" });
      }
      constructor(options) {
        super();
        this.options = options;
        this.messages = (0, utils_1.createDeferredManager)({
          timeout: this.options.timeout || DEFAULT_TIMEOUT,
          onTimeout: (promiseId) => this.onMessageTimeout(promiseId)
        });
      }
      initWebsocket({ url, timeout, headers, agent }) {
        if (typeof url !== "string") {
          throw new WebsocketError("websocket_no_url");
        }
        if (url.startsWith("http")) {
          url = url.replace("http", "ws");
        }
        return new ws_1.default(url, {
          timeout,
          headers: {
            Origin: "https://node.trezor.io",
            ...headers
          },
          agent
        });
      }
      setPingTimeout() {
        clearTimeout(this.pingTimeout);
        const doPing = () => {
          if (this.isConnected()) {
            return this.onPing().catch(() => {
            });
          }
        };
        this.pingTimeout = this.isConnected() ? setTimeout(doPing, this.options.pingTimeout || DEFAULT_PING_TIMEOUT) : void 0;
      }
      onPing() {
        return this.ping();
      }
      onMessageTimeout(_promiseId) {
        const { ws } = this;
        if (!ws)
          return;
        this.messages.rejectAll(new WebsocketError("websocket_timeout"));
        ws.close();
      }
      onError() {
        this.onClose();
      }
      sendMessage(message, { timeout } = {}) {
        const { ws } = this;
        if (!ws || !this.isConnected())
          throw new WebsocketError("websocket_not_initialized");
        const { promiseId, promise } = this.messages.create(timeout);
        const req = { id: promiseId.toString(), ...message };
        this.setPingTimeout();
        this.options.onSending?.(message);
        ws.send(JSON.stringify(req));
        return promise;
      }
      sendRawMessage(message) {
        const { ws } = this;
        if (!ws || !this.isConnected())
          throw new WebsocketError("websocket_not_initialized");
        ws.send(message, {
          binary: typeof message !== "string"
        });
        this.setPingTimeout();
      }
      onMessage(message, messageValidation) {
        try {
          const data = JSON.parse(message.toString());
          const messageId = Number(data.id);
          try {
            const payload = messageValidation ? messageValidation(data) : data;
            if (payload) {
              this.messages.resolve(messageId, payload);
            }
          } catch (error) {
            this.messages.reject(messageId, error);
          }
        } catch {
        } finally {
          this.setPingTimeout();
        }
      }
      async connect() {
        if (this.connectPromise) {
          return this.connectPromise;
        }
        if (this.isConnected())
          return Promise.resolve();
        if (this.ws?.readyState === ws_1.default.CLOSING) {
          await new Promise((resolve) => this.emitter.once("disconnected", resolve));
        }
        const dfd = (0, utils_1.createDeferred)();
        this.connectPromise = dfd.promise;
        const ws = this.createWebsocket ? this.createWebsocket() : this.initWebsocket(this.options);
        const connectionTimeout = setTimeout(() => {
          this.onClose();
          dfd.reject(new WebsocketError("websocket_timeout"));
          try {
            ws.close();
          } catch {
          }
        }, this.options.connectionTimeout || this.options.timeout || DEFAULT_TIMEOUT);
        ws.once("error", (error) => {
          clearTimeout(connectionTimeout);
          this.onClose();
          dfd.reject(new WebsocketError(error.message));
        });
        ws.on("open", () => {
          clearTimeout(connectionTimeout);
          this.init();
          dfd.resolve();
        });
        this.ws = ws;
        return dfd.promise.finally(() => {
          this.connectPromise = void 0;
        });
      }
      init() {
        const { ws } = this;
        if (!ws || !this.isConnected()) {
          throw Error("Websocket init cannot be called");
        }
        ws.removeAllListeners();
        ws.on("error", (_error) => this.onError());
        ws.on("message", (message) => this.onMessage(message));
        ws.on("close", () => {
          this.emitter.emit("disconnected");
          this.onClose();
        });
      }
      disconnect() {
        if (this.isConnected()) {
          const disconnectPromise = new Promise((resolve) => {
            this.ws?.once("close", resolve);
          });
          this.ws?.close();
          return disconnectPromise;
        }
        return Promise.resolve();
      }
      isConnected() {
        return this.ws?.readyState === ws_1.default.OPEN;
      }
      onClose() {
        clearTimeout(this.pingTimeout);
        this.ws?.removeAllListeners();
        this.ws?.on("error", () => {
        });
        this.messages.rejectAll(new WebsocketError("Websocket closed unexpectedly"));
      }
      dispose() {
        this.removeAllListeners();
        this.disconnect();
        this.onClose();
      }
    };
    exports2.WebsocketClient = WebsocketClient;
  }
});

// node_modules/@trezor/websocket-client/lib/index.js
var require_lib6 = __commonJS({
  "node_modules/@trezor/websocket-client/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WebsocketClient = void 0;
    var client_1 = require_client();
    Object.defineProperty(exports2, "WebsocketClient", { enumerable: true, get: function() {
      return client_1.WebsocketClient;
    } });
  }
});

// node_modules/@trezor/connect-web/lib/impl/core-in-suite-desktop.js
var require_core_in_suite_desktop = __commonJS({
  "node_modules/@trezor/connect-web/lib/impl/core-in-suite-desktop.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TrezorConnect = exports2.CoreInSuiteDesktop = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var events_1 = tslib_1.__importDefault(require_events());
    var ERRORS = tslib_1.__importStar(require_errors2());
    var events_2 = require_events2();
    var factory_1 = require_factory();
    var websocket_client_1 = require_lib6();
    var client_1 = require_client();
    var connectSettings_1 = require_connectSettings2();
    var CoreInSuiteDesktop = class {
      eventEmitter = new events_1.default();
      _settings;
      ws;
      constructor() {
        this._settings = (0, connectSettings_1.parseConnectSettings)();
        this.ws = new websocket_client_1.WebsocketClient({ url: "ws://127.0.0.1:21335/connect-ws" });
      }
      manifest(data) {
        this._settings = (0, connectSettings_1.parseConnectSettings)({
          ...this._settings,
          manifest: data
        });
      }
      dispose() {
        this.eventEmitter.removeAllListeners();
        this._settings = (0, connectSettings_1.parseConnectSettings)();
        this.ws.dispose();
        return Promise.resolve(void 0);
      }
      cancel(_error) {
        this.ws.sendMessage({
          type: events_2.POPUP.CLOSED,
          payload: { error: _error }
        });
      }
      async handshake() {
        if (!this.ws) {
          throw ERRORS.TypedError("Desktop_ConnectionMissing", "No websocket connection");
        }
        try {
          const response = await this.ws.sendMessage({
            type: events_2.POPUP.HANDSHAKE,
            payload: {
              settings: this._settings
            }
          }, {
            timeout: 3e3
          });
          if (!response) {
            throw ERRORS.TypedError("Desktop_ConnectionMissing", "No response");
          }
          return response;
        } catch (err) {
          throw ERRORS.TypedError("Desktop_ConnectionMissing", err.message);
        }
      }
      async init(settings2) {
        const newSettings = (0, connectSettings_1.parseConnectSettings)({
          ...this._settings,
          ...settings2
        });
        if (!newSettings.manifest || !newSettings.manifest.appName) {
          throw ERRORS.TypedError("Init_ManifestMissing", "Manifest is missing or manifest.appName is not set");
        }
        if (!newSettings.transports?.length) {
          newSettings.transports = ["BridgeTransport", "WebUsbTransport"];
        }
        this._settings = newSettings;
        return await this.connect();
      }
      async connect() {
        try {
          await this.ws.connect();
        } catch (err) {
          throw err instanceof client_1.WebsocketError ? ERRORS.TypedError("Desktop_ConnectionMissing", err.message) : err;
        }
      }
      setTransports() {
        throw new Error("Unsupported");
      }
      async call(params) {
        try {
          if (!this.ws.isConnected()) {
            await this.connect();
          }
          await this.handshake();
          const response = await this.ws.sendMessage({
            type: events_2.IFRAME.CALL,
            payload: params
          }, {
            timeout: 0
          });
          if (!response) {
            throw ERRORS.TypedError("Desktop_ConnectionMissing", "No response");
          }
          return response;
        } catch (err) {
          return {
            success: false,
            payload: ERRORS.serializeError(err instanceof client_1.WebsocketError ? ERRORS.TypedError("Desktop_ConnectionMissing", err.message) : err)
          };
        }
      }
      uiResponse(_response) {
        throw ERRORS.TypedError("Method_InvalidPackage");
      }
      requestLogin() {
        throw ERRORS.TypedError("Method_InvalidPackage");
      }
      disableWebUSB() {
        throw ERRORS.TypedError("Method_InvalidPackage");
      }
      requestWebUSBDevice() {
        throw ERRORS.TypedError("Method_InvalidPackage");
      }
      renderWebUSBButton() {
      }
    };
    exports2.CoreInSuiteDesktop = CoreInSuiteDesktop;
    var impl = new CoreInSuiteDesktop();
    exports2.TrezorConnect = (0, factory_1.factory)({
      eventEmitter: impl.eventEmitter,
      init: impl.init.bind(impl),
      call: impl.call.bind(impl),
      setTransports: impl.setTransports.bind(impl),
      manifest: impl.manifest.bind(impl),
      requestLogin: impl.requestLogin.bind(impl),
      uiResponse: impl.uiResponse.bind(impl),
      cancel: impl.cancel.bind(impl),
      dispose: impl.dispose.bind(impl)
    });
  }
});

// node_modules/@trezor/connect/lib/types/api/index.js
var require_api = __commonJS({
  "node_modules/@trezor/connect/lib/types/api/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@trezor/connect/lib/types/account.js
var require_account = __commonJS({
  "node_modules/@trezor/connect/lib/types/account.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@trezor/device-utils/lib/modeUtils.js
var require_modeUtils = __commonJS({
  "node_modules/@trezor/device-utils/lib/modeUtils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isDeviceInBootloaderMode = void 0;
    var isDeviceInBootloaderMode = (device) => !!device?.features?.bootloader_mode;
    exports2.isDeviceInBootloaderMode = isDeviceInBootloaderMode;
  }
});

// node_modules/@trezor/device-utils/lib/types.js
var require_types3 = __commonJS({
  "node_modules/@trezor/device-utils/lib/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FirmwareType = void 0;
    var FirmwareType;
    (function(FirmwareType2) {
      FirmwareType2["BitcoinOnly"] = "bitcoin-only";
      FirmwareType2["Universal"] = "universal";
    })(FirmwareType || (exports2.FirmwareType = FirmwareType = {}));
  }
});

// node_modules/@trezor/device-utils/lib/firmwareUtils.js
var require_firmwareUtils = __commonJS({
  "node_modules/@trezor/device-utils/lib/firmwareUtils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isBitcoinOnlyDevice = exports2.hasBitcoinOnlyFirmware = exports2.getFirmwareVersion = exports2.getFirmwareVersionArray = exports2.getFirmwareRevision = exports2.getFirmwareSource = void 0;
    var modeUtils_1 = require_modeUtils();
    var types_1 = require_types3();
    var getFirmwareSource = (device) => {
      if (device?.mode === "bootloader") {
        return "NA - bootloader";
      }
      if (device?.authenticityChecks?.firmwareRevision?.success && device?.authenticityChecks?.firmwareHash?.success) {
        return "official";
      }
      return "unknown";
    };
    exports2.getFirmwareSource = getFirmwareSource;
    var getFirmwareRevision = (device) => device?.features?.revision || "";
    exports2.getFirmwareRevision = getFirmwareRevision;
    var getFirmwareVersionArray = (device) => {
      if (!device?.features) {
        return null;
      }
      const { features } = device;
      if ((0, modeUtils_1.isDeviceInBootloaderMode)(device)) {
        return features.fw_major ? [features.fw_major, features.fw_minor, features.fw_patch] : null;
      }
      return [features.major_version, features.minor_version, features.patch_version];
    };
    exports2.getFirmwareVersionArray = getFirmwareVersionArray;
    var getFirmwareVersion = (device) => {
      if (!device?.features) {
        return "";
      }
      const { features } = device;
      if ((0, modeUtils_1.isDeviceInBootloaderMode)(device)) {
        return features.fw_major ? `${features.fw_major}.${features.fw_minor}.${features.fw_patch}` : "";
      }
      return `${features.major_version}.${features.minor_version}.${features.patch_version}`;
    };
    exports2.getFirmwareVersion = getFirmwareVersion;
    var hasBitcoinOnlyFirmware = (device) => device?.firmwareType === types_1.FirmwareType.BitcoinOnly;
    exports2.hasBitcoinOnlyFirmware = hasBitcoinOnlyFirmware;
    var isBitcoinOnlyDevice = (device) => !!device?.features?.unit_btconly && device?.firmwareType !== types_1.FirmwareType.Universal;
    exports2.isBitcoinOnlyDevice = isBitcoinOnlyDevice;
  }
});

// node_modules/@trezor/device-utils/lib/bootloaderUtils.js
var require_bootloaderUtils = __commonJS({
  "node_modules/@trezor/device-utils/lib/bootloaderUtils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getBootloaderVersion = exports2.getBootloaderHash = void 0;
    var modeUtils_1 = require_modeUtils();
    var getBootloaderHash = (device) => device?.features?.bootloader_hash || "";
    exports2.getBootloaderHash = getBootloaderHash;
    var getBootloaderVersion = (device) => {
      if (!device?.features) {
        return "";
      }
      const { features } = device;
      if ((0, modeUtils_1.isDeviceInBootloaderMode)(device) && features.major_version) {
        return `${features.major_version}.${features.minor_version}.${features.patch_version}`;
      }
      return "";
    };
    exports2.getBootloaderVersion = getBootloaderVersion;
  }
});

// node_modules/@trezor/device-utils/lib/deviceModelInternal.js
var require_deviceModelInternal = __commonJS({
  "node_modules/@trezor/device-utils/lib/deviceModelInternal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DeviceModelInternal = void 0;
    var DeviceModelInternal;
    (function(DeviceModelInternal2) {
      DeviceModelInternal2["T1B1"] = "T1B1";
      DeviceModelInternal2["T2T1"] = "T2T1";
      DeviceModelInternal2["T2B1"] = "T2B1";
      DeviceModelInternal2["T3B1"] = "T3B1";
      DeviceModelInternal2["T3T1"] = "T3T1";
      DeviceModelInternal2["T3W1"] = "T3W1";
      DeviceModelInternal2["UNKNOWN"] = "UNKNOWN";
    })(DeviceModelInternal || (exports2.DeviceModelInternal = DeviceModelInternal = {}));
  }
});

// node_modules/@trezor/device-utils/lib/deviceModelInternalUtils.js
var require_deviceModelInternalUtils = __commonJS({
  "node_modules/@trezor/device-utils/lib/deviceModelInternalUtils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getNarrowedDeviceModelInternal = void 0;
    var deviceModelInternal_1 = require_deviceModelInternal();
    var getNarrowedDeviceModelInternal = (model) => model === deviceModelInternal_1.DeviceModelInternal.T2B1 ? deviceModelInternal_1.DeviceModelInternal.T3B1 : model;
    exports2.getNarrowedDeviceModelInternal = getNarrowedDeviceModelInternal;
  }
});

// node_modules/@trezor/device-utils/lib/models.js
var require_models = __commonJS({
  "node_modules/@trezor/device-utils/lib/models.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.models = void 0;
    var safe3Model = {
      name: "Trezor Safe 3",
      colors: {
        "1": "Cosmic Black",
        "2": "Stellar Silver",
        "3": "Solar Gold",
        "4": "Galactic Rose",
        "5": "Bitcoin Orange"
      }
    };
    exports2.models = {
      UNKNOWN: {
        name: "Unknown",
        colors: safe3Model.colors
      },
      T1B1: {
        name: "Trezor Model One",
        colors: {}
      },
      T2T1: {
        name: "Trezor Model T",
        colors: {}
      },
      T2B1: safe3Model,
      T3B1: safe3Model,
      T3T1: {
        name: "Trezor Safe 5",
        colors: {
          "1": "Black Graphite",
          "2": "Violet Ore",
          "3": "Green Beryl",
          "4": "Bitcoin Orange",
          "5": "Freedom Edition"
        }
      },
      T3W1: {
        name: "Trezor Safe 7",
        colors: {
          "1": "Fantastic Ethereum",
          "2": "Lunatic Dogecoin",
          "3": "Galactic Litecoin"
        },
        frontColors: {
          "1": "1",
          "2": "2",
          "3": "1"
        }
      }
    };
  }
});

// node_modules/@trezor/device-utils/lib/deviceColorUtils.js
var require_deviceColorUtils = __commonJS({
  "node_modules/@trezor/device-utils/lib/deviceColorUtils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getDeviceColorVariant = exports2.normalizeDeviceColorVariant = void 0;
    var normalizeDeviceColorVariant = (colorVariant) => colorVariant || 1;
    exports2.normalizeDeviceColorVariant = normalizeDeviceColorVariant;
    var getDeviceColorVariant = (device) => (0, exports2.normalizeDeviceColorVariant)(device.features?.unit_color ?? device.thp?.properties?.model_variant);
    exports2.getDeviceColorVariant = getDeviceColorVariant;
  }
});

// node_modules/@trezor/device-utils/lib/index.js
var require_lib7 = __commonJS({
  "node_modules/@trezor/device-utils/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_firmwareUtils(), exports2);
    tslib_1.__exportStar(require_bootloaderUtils(), exports2);
    tslib_1.__exportStar(require_modeUtils(), exports2);
    tslib_1.__exportStar(require_types3(), exports2);
    tslib_1.__exportStar(require_deviceModelInternal(), exports2);
    tslib_1.__exportStar(require_deviceModelInternalUtils(), exports2);
    tslib_1.__exportStar(require_models(), exports2);
    tslib_1.__exportStar(require_deviceColorUtils(), exports2);
  }
});

// node_modules/@trezor/connect/lib/types/fees.js
var require_fees = __commonJS({
  "node_modules/@trezor/connect/lib/types/fees.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SelectFeeLevel = exports2.FeeLevel = exports2.FeeInfo = void 0;
    var schema_utils_1 = require_lib2();
    exports2.FeeInfo = schema_utils_1.Type.Object({
      blockTime: schema_utils_1.Type.Number(),
      minFee: schema_utils_1.Type.Number(),
      maxFee: schema_utils_1.Type.Number(),
      minPriorityFee: schema_utils_1.Type.Number(),
      dustLimit: schema_utils_1.Type.Number()
    });
    exports2.FeeLevel = schema_utils_1.Type.Object({
      label: schema_utils_1.Type.Union([
        schema_utils_1.Type.Literal("high"),
        schema_utils_1.Type.Literal("normal"),
        schema_utils_1.Type.Literal("economy"),
        schema_utils_1.Type.Literal("low"),
        schema_utils_1.Type.Literal("custom")
      ]),
      blocks: schema_utils_1.Type.Number(),
      feePerUnit: schema_utils_1.Type.String(),
      feePerTx: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      feeLimit: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      baseFeePerGas: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      maxFeePerGas: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      maxPriorityFeePerGas: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    });
    exports2.SelectFeeLevel = schema_utils_1.Type.Union([
      schema_utils_1.Type.Object({
        name: schema_utils_1.Type.String(),
        fee: schema_utils_1.Type.Literal("0"),
        feePerByte: schema_utils_1.Type.Optional(schema_utils_1.Type.Undefined()),
        blocks: schema_utils_1.Type.Optional(schema_utils_1.Type.Undefined()),
        disabled: schema_utils_1.Type.Literal(true)
      }),
      schema_utils_1.Type.Object({
        name: schema_utils_1.Type.String(),
        fee: schema_utils_1.Type.String(),
        feePerByte: schema_utils_1.Type.String(),
        blocks: schema_utils_1.Type.Number(),
        minutes: schema_utils_1.Type.Number(),
        total: schema_utils_1.Type.String()
      })
    ]);
  }
});

// node_modules/@trezor/connect/lib/types/coinInfo.js
var require_coinInfo = __commonJS({
  "node_modules/@trezor/connect/lib/types/coinInfo.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CoinInfo = exports2.MiscNetworkInfo = exports2.EthereumNetworkInfoDefinitionValues = exports2.EthereumNetworkInfo = exports2.BitcoinNetworkInfo = exports2.BlockchainLink = exports2.CoinSupport = exports2.CoinObj = exports2.Network = exports2.Bip32 = void 0;
    var device_utils_1 = require_lib7();
    var schema_utils_1 = require_lib2();
    var fees_1 = require_fees();
    exports2.Bip32 = schema_utils_1.Type.Object({
      public: schema_utils_1.Type.Number(),
      private: schema_utils_1.Type.Number()
    });
    exports2.Network = schema_utils_1.Type.Object({
      messagePrefix: schema_utils_1.Type.String(),
      bech32: schema_utils_1.Type.String(),
      bip32: exports2.Bip32,
      pubKeyHash: schema_utils_1.Type.Number(),
      scriptHash: schema_utils_1.Type.Number(),
      wif: schema_utils_1.Type.Number(),
      forkId: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    });
    exports2.CoinObj = schema_utils_1.Type.Object({
      coin: schema_utils_1.Type.String(),
      identity: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    });
    exports2.CoinSupport = schema_utils_1.Type.Composite([
      schema_utils_1.Type.Object({
        connect: schema_utils_1.Type.Boolean()
      }),
      schema_utils_1.Type.Record(schema_utils_1.Type.KeyOfEnum(device_utils_1.DeviceModelInternal), schema_utils_1.Type.Union([schema_utils_1.Type.String(), schema_utils_1.Type.Literal(false)]))
    ]);
    exports2.BlockchainLink = schema_utils_1.Type.Object({
      type: schema_utils_1.Type.String(),
      url: schema_utils_1.Type.Array(schema_utils_1.Type.String())
    });
    var Common = schema_utils_1.Type.Object({
      label: schema_utils_1.Type.String(),
      name: schema_utils_1.Type.String(),
      shortcut: schema_utils_1.Type.String(),
      slip44: schema_utils_1.Type.Number(),
      support: exports2.CoinSupport,
      decimals: schema_utils_1.Type.Number(),
      blockchainLink: schema_utils_1.Type.Optional(exports2.BlockchainLink),
      blockTime: schema_utils_1.Type.Number(),
      minFee: schema_utils_1.Type.Number(),
      maxFee: schema_utils_1.Type.Number(),
      minPriorityFee: schema_utils_1.Type.Number(),
      defaultFees: schema_utils_1.Type.Array(fees_1.FeeLevel)
    });
    exports2.BitcoinNetworkInfo = schema_utils_1.Type.Intersect([
      Common,
      schema_utils_1.Type.Object({
        type: schema_utils_1.Type.Literal("bitcoin"),
        cashAddrPrefix: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
        curveName: schema_utils_1.Type.String(),
        dustLimit: schema_utils_1.Type.Number(),
        forceBip143: schema_utils_1.Type.Boolean(),
        hashGenesisBlock: schema_utils_1.Type.String(),
        maxAddressLength: schema_utils_1.Type.Number(),
        maxFeeSatoshiKb: schema_utils_1.Type.Number(),
        minAddressLength: schema_utils_1.Type.Number(),
        minFeeSatoshiKb: schema_utils_1.Type.Number(),
        segwit: schema_utils_1.Type.Boolean(),
        xPubMagic: schema_utils_1.Type.Number(),
        xPubMagicSegwitNative: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
        xPubMagicSegwit: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
        taproot: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
        network: exports2.Network,
        isBitcoin: schema_utils_1.Type.Boolean()
      })
    ]);
    exports2.EthereumNetworkInfo = schema_utils_1.Type.Intersect([
      Common,
      schema_utils_1.Type.Object({
        type: schema_utils_1.Type.Literal("ethereum"),
        chainId: schema_utils_1.Type.Number(),
        network: schema_utils_1.Type.Optional(schema_utils_1.Type.Undefined())
      })
    ]);
    exports2.EthereumNetworkInfoDefinitionValues = schema_utils_1.Type.Omit(exports2.EthereumNetworkInfo, [
      "minFee",
      "maxFee",
      "defaultFees",
      "minPriorityFee",
      "blockTime"
    ]);
    exports2.MiscNetworkInfo = schema_utils_1.Type.Intersect([
      Common,
      schema_utils_1.Type.Object({
        type: schema_utils_1.Type.Union([schema_utils_1.Type.Literal("misc"), schema_utils_1.Type.Literal("nem")]),
        curve: schema_utils_1.Type.String(),
        network: schema_utils_1.Type.Optional(schema_utils_1.Type.Undefined())
      })
    ]);
    exports2.CoinInfo = schema_utils_1.Type.Union([exports2.BitcoinNetworkInfo, exports2.EthereumNetworkInfo, exports2.MiscNetworkInfo]);
  }
});

// node_modules/@trezor/connect/lib/types/device.js
var require_device2 = __commonJS({
  "node_modules/@trezor/connect/lib/types/device.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.asBluetoothDeviceId = exports2.asDeviceUniquePath = void 0;
    var asDeviceUniquePath = (id2) => id2;
    exports2.asDeviceUniquePath = asDeviceUniquePath;
    var asBluetoothDeviceId = (id2) => id2;
    exports2.asBluetoothDeviceId = asBluetoothDeviceId;
  }
});

// node_modules/@trezor/connect/lib/types/firmware.js
var require_firmware2 = __commonJS({
  "node_modules/@trezor/connect/lib/types/firmware.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@trezor/connect/lib/types/params.js
var require_params = __commonJS({
  "node_modules/@trezor/connect/lib/types/params.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PublicKey = exports2.GetPublicKey = exports2.GetAddress = exports2.DerivationPath = exports2.Bundle = void 0;
    var schema_utils_1 = require_lib2();
    var Bundle = (type) => schema_utils_1.Type.Object({ bundle: schema_utils_1.Type.Array(type, { minItems: 1 }) });
    exports2.Bundle = Bundle;
    exports2.DerivationPath = schema_utils_1.Type.Union([schema_utils_1.Type.String(), schema_utils_1.Type.Array(schema_utils_1.Type.Number())], {
      description: "Derivation Path (BIP32).",
      $id: "DerivationPath"
    });
    exports2.GetAddress = schema_utils_1.Type.Object({
      path: exports2.DerivationPath,
      address: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      showOnTrezor: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean({ default: true })),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      useEventListener: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    });
    exports2.GetPublicKey = schema_utils_1.Type.Object({
      path: exports2.DerivationPath,
      showOnTrezor: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      suppressBackupWarning: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    });
    exports2.PublicKey = schema_utils_1.Type.Object({
      publicKey: schema_utils_1.Type.String(),
      path: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      serializedPath: schema_utils_1.Type.String()
    });
  }
});

// node_modules/@trezor/connect/lib/types/settings.js
var require_settings = __commonJS({
  "node_modules/@trezor/connect/lib/types/settings.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@trezor/connect/lib/types/api/cardano/index.js
var require_cardano2 = __commonJS({
  "node_modules/@trezor/connect/lib/types/api/cardano/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CardanoSignedMessage = exports2.CardanoMessageHeaders = exports2.CardanoMessageUnprotectedHeaders = exports2.CardanoMessageProtectedHeaders = exports2.CardanoSignMessage = exports2.CardanoSignedTxData = exports2.CardanoAuxiliaryDataSupplement = exports2.CardanoSignedTxWitness = exports2.CardanoSignTransactionExtended = exports2.CardanoSignTransaction = exports2.CardanoAuxiliaryData = exports2.CardanoCVoteRegistrationParameters = exports2.CardanoCVoteRegistrationDelegation = exports2.CardanoReferenceInput = exports2.CardanoRequiredSigner = exports2.CardanoCollateralInput = exports2.CardanoMint = exports2.CardanoWithdrawal = exports2.CardanoCertificate = exports2.CardanoDRep = exports2.CardanoPoolParameters = exports2.CardanoPoolMargin = exports2.CardanoPoolMetadata = exports2.CardanoPoolRelay = exports2.CardanoPoolOwner = exports2.CardanoOutput = exports2.CardanoAssetGroup = exports2.CardanoToken = exports2.CardanoInput = exports2.CardanoGetPublicKey = exports2.CardanoNativeScriptHash = exports2.CardanoGetNativeScriptHash = exports2.CardanoNativeScript = exports2.CardanoGetAddress = exports2.CardanoAddressParameters = exports2.CardanoCertificatePointer = void 0;
    var schema_utils_1 = require_lib2();
    var constants_1 = require_constants4();
    var params_1 = require_params();
    exports2.CardanoCertificatePointer = schema_utils_1.Type.Object({
      blockIndex: schema_utils_1.Type.Number(),
      txIndex: schema_utils_1.Type.Number(),
      certificateIndex: schema_utils_1.Type.Number()
    });
    exports2.CardanoAddressParameters = schema_utils_1.Type.Object({
      addressType: constants_1.PROTO.EnumCardanoAddressType,
      path: schema_utils_1.Type.Optional(params_1.DerivationPath),
      stakingPath: schema_utils_1.Type.Optional(params_1.DerivationPath),
      stakingKeyHash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      certificatePointer: schema_utils_1.Type.Optional(exports2.CardanoCertificatePointer),
      paymentScriptHash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      stakingScriptHash: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    });
    exports2.CardanoGetAddress = schema_utils_1.Type.Object({
      addressParameters: exports2.CardanoAddressParameters,
      protocolMagic: schema_utils_1.Type.Number(),
      networkId: schema_utils_1.Type.Number(),
      address: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      showOnTrezor: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      derivationType: schema_utils_1.Type.Optional(constants_1.PROTO.EnumCardanoDerivationType),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    });
    exports2.CardanoNativeScript = schema_utils_1.Type.Recursive((This) => schema_utils_1.Type.Object({
      type: constants_1.PROTO.EnumCardanoNativeScriptType,
      scripts: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(This)),
      keyHash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      keyPath: schema_utils_1.Type.Optional(params_1.DerivationPath),
      requiredSignaturesCount: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      invalidBefore: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      invalidHereafter: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }));
    exports2.CardanoGetNativeScriptHash = schema_utils_1.Type.Object({
      script: exports2.CardanoNativeScript,
      displayFormat: constants_1.PROTO.EnumCardanoNativeScriptHashDisplayFormat,
      derivationType: schema_utils_1.Type.Optional(constants_1.PROTO.EnumCardanoDerivationType)
    });
    exports2.CardanoNativeScriptHash = schema_utils_1.Type.Object({
      scriptHash: schema_utils_1.Type.String()
    });
    exports2.CardanoGetPublicKey = schema_utils_1.Type.Intersect([
      params_1.GetPublicKey,
      schema_utils_1.Type.Object({
        derivationType: schema_utils_1.Type.Optional(constants_1.PROTO.EnumCardanoDerivationType)
      })
    ]);
    exports2.CardanoInput = schema_utils_1.Type.Object({
      path: schema_utils_1.Type.Optional(params_1.DerivationPath),
      prev_hash: schema_utils_1.Type.String(),
      prev_index: schema_utils_1.Type.Number()
    });
    exports2.CardanoToken = schema_utils_1.Type.Object({
      assetNameBytes: schema_utils_1.Type.String(),
      amount: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      mintAmount: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    });
    exports2.CardanoAssetGroup = schema_utils_1.Type.Object({
      policyId: schema_utils_1.Type.String(),
      tokenAmounts: schema_utils_1.Type.Array(exports2.CardanoToken)
    });
    exports2.CardanoOutput = schema_utils_1.Type.Intersect([
      schema_utils_1.Type.Union([
        schema_utils_1.Type.Object({
          addressParameters: exports2.CardanoAddressParameters
        }),
        schema_utils_1.Type.Object({
          address: schema_utils_1.Type.String()
        })
      ]),
      schema_utils_1.Type.Object({
        amount: schema_utils_1.Type.String(),
        tokenBundle: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(exports2.CardanoAssetGroup)),
        datumHash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
        format: schema_utils_1.Type.Optional(constants_1.PROTO.EnumCardanoTxOutputSerializationFormat),
        inlineDatum: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
        referenceScript: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
      })
    ]);
    exports2.CardanoPoolOwner = schema_utils_1.Type.Object({
      stakingKeyPath: schema_utils_1.Type.Optional(params_1.DerivationPath),
      stakingKeyHash: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    });
    exports2.CardanoPoolRelay = schema_utils_1.Type.Object({
      type: constants_1.PROTO.EnumCardanoPoolRelayType,
      ipv4Address: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      ipv6Address: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      port: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      hostName: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    });
    exports2.CardanoPoolMetadata = schema_utils_1.Type.Object({
      url: schema_utils_1.Type.String(),
      hash: schema_utils_1.Type.String()
    });
    exports2.CardanoPoolMargin = schema_utils_1.Type.Object({
      numerator: schema_utils_1.Type.String(),
      denominator: schema_utils_1.Type.String()
    });
    exports2.CardanoPoolParameters = schema_utils_1.Type.Object({
      poolId: schema_utils_1.Type.String(),
      vrfKeyHash: schema_utils_1.Type.String(),
      pledge: schema_utils_1.Type.String(),
      cost: schema_utils_1.Type.String(),
      margin: exports2.CardanoPoolMargin,
      rewardAccount: schema_utils_1.Type.String(),
      owners: schema_utils_1.Type.Array(exports2.CardanoPoolOwner, { minItems: 1 }),
      relays: schema_utils_1.Type.Array(exports2.CardanoPoolRelay),
      metadata: schema_utils_1.Type.Optional(exports2.CardanoPoolMetadata)
    });
    exports2.CardanoDRep = schema_utils_1.Type.Object({
      type: constants_1.PROTO.EnumCardanoDRepType,
      keyHash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      scriptHash: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    });
    exports2.CardanoCertificate = schema_utils_1.Type.Object({
      type: constants_1.PROTO.EnumCardanoCertificateType,
      path: schema_utils_1.Type.Optional(params_1.DerivationPath),
      pool: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      poolParameters: schema_utils_1.Type.Optional(exports2.CardanoPoolParameters),
      scriptHash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      keyHash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      deposit: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      dRep: schema_utils_1.Type.Optional(exports2.CardanoDRep)
    });
    exports2.CardanoWithdrawal = schema_utils_1.Type.Object({
      path: schema_utils_1.Type.Optional(params_1.DerivationPath),
      amount: schema_utils_1.Type.String(),
      scriptHash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      keyHash: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    });
    exports2.CardanoMint = schema_utils_1.Type.Array(exports2.CardanoAssetGroup);
    exports2.CardanoCollateralInput = schema_utils_1.Type.Object({
      path: schema_utils_1.Type.Optional(params_1.DerivationPath),
      prev_hash: schema_utils_1.Type.String(),
      prev_index: schema_utils_1.Type.Number()
    });
    exports2.CardanoRequiredSigner = schema_utils_1.Type.Object({
      keyPath: schema_utils_1.Type.Optional(params_1.DerivationPath),
      keyHash: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    });
    exports2.CardanoReferenceInput = schema_utils_1.Type.Object({
      prev_hash: schema_utils_1.Type.String(),
      prev_index: schema_utils_1.Type.Number()
    });
    exports2.CardanoCVoteRegistrationDelegation = schema_utils_1.Type.Object({
      votePublicKey: schema_utils_1.Type.String(),
      weight: schema_utils_1.Type.Number()
    });
    exports2.CardanoCVoteRegistrationParameters = schema_utils_1.Type.Object({
      votePublicKey: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      stakingPath: params_1.DerivationPath,
      paymentAddressParameters: schema_utils_1.Type.Optional(exports2.CardanoAddressParameters),
      nonce: schema_utils_1.Type.String(),
      format: schema_utils_1.Type.Optional(constants_1.PROTO.EnumCardanoCVoteRegistrationFormat),
      delegations: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(exports2.CardanoCVoteRegistrationDelegation)),
      votingPurpose: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      paymentAddress: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    });
    exports2.CardanoAuxiliaryData = schema_utils_1.Type.Object({
      hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      cVoteRegistrationParameters: schema_utils_1.Type.Optional(exports2.CardanoCVoteRegistrationParameters)
    });
    exports2.CardanoSignTransaction = schema_utils_1.Type.Object({
      inputs: schema_utils_1.Type.Array(exports2.CardanoInput),
      outputs: schema_utils_1.Type.Array(exports2.CardanoOutput),
      fee: schema_utils_1.Type.Uint(),
      ttl: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint()),
      certificates: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(exports2.CardanoCertificate)),
      withdrawals: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(exports2.CardanoWithdrawal)),
      validityIntervalStart: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      auxiliaryData: schema_utils_1.Type.Optional(exports2.CardanoAuxiliaryData),
      mint: schema_utils_1.Type.Optional(exports2.CardanoMint),
      scriptDataHash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      collateralInputs: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(exports2.CardanoCollateralInput)),
      requiredSigners: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(exports2.CardanoRequiredSigner)),
      collateralReturn: schema_utils_1.Type.Optional(exports2.CardanoOutput),
      totalCollateral: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      referenceInputs: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(exports2.CardanoReferenceInput)),
      additionalWitnessRequests: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(params_1.DerivationPath)),
      protocolMagic: schema_utils_1.Type.Number(),
      networkId: schema_utils_1.Type.Number(),
      signingMode: constants_1.PROTO.EnumCardanoTxSigningMode,
      derivationType: schema_utils_1.Type.Optional(constants_1.PROTO.EnumCardanoDerivationType),
      includeNetworkId: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      tagCborSets: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    });
    exports2.CardanoSignTransactionExtended = schema_utils_1.Type.Intersect([
      exports2.CardanoSignTransaction,
      schema_utils_1.Type.Object({
        unsignedTx: schema_utils_1.Type.Object({
          body: schema_utils_1.Type.String(),
          hash: schema_utils_1.Type.String()
        }),
        testnet: schema_utils_1.Type.Boolean()
      })
    ]);
    exports2.CardanoSignedTxWitness = schema_utils_1.Type.Object({
      type: constants_1.PROTO.EnumCardanoTxWitnessType,
      pubKey: schema_utils_1.Type.String(),
      signature: schema_utils_1.Type.String(),
      chainCode: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    });
    exports2.CardanoAuxiliaryDataSupplement = schema_utils_1.Type.Object({
      type: constants_1.PROTO.EnumCardanoTxAuxiliaryDataSupplementType,
      auxiliaryDataHash: schema_utils_1.Type.String(),
      cVoteRegistrationSignature: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    });
    exports2.CardanoSignedTxData = schema_utils_1.Type.Object({
      hash: schema_utils_1.Type.String(),
      witnesses: schema_utils_1.Type.Array(exports2.CardanoSignedTxWitness),
      auxiliaryDataSupplement: schema_utils_1.Type.Optional(exports2.CardanoAuxiliaryDataSupplement)
    });
    exports2.CardanoSignMessage = schema_utils_1.Type.Object({
      path: params_1.DerivationPath,
      payload: schema_utils_1.Type.String(),
      preferHexDisplay: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      networkId: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      protocolMagic: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      addressParameters: schema_utils_1.Type.Optional(exports2.CardanoAddressParameters),
      derivationType: schema_utils_1.Type.Optional(constants_1.PROTO.EnumCardanoDerivationType)
    });
    exports2.CardanoMessageProtectedHeaders = schema_utils_1.Type.Object({
      1: schema_utils_1.Type.Literal(constants_1.CARDANO.ALGORITHM_IDS.EdDSA),
      address: schema_utils_1.Type.String()
    });
    exports2.CardanoMessageUnprotectedHeaders = schema_utils_1.Type.Object({
      hashed: schema_utils_1.Type.Boolean(),
      version: schema_utils_1.Type.Number()
    });
    exports2.CardanoMessageHeaders = schema_utils_1.Type.Object({
      protected: exports2.CardanoMessageProtectedHeaders,
      unprotected: exports2.CardanoMessageUnprotectedHeaders
    });
    exports2.CardanoSignedMessage = schema_utils_1.Type.Object({
      headers: exports2.CardanoMessageHeaders,
      payload: schema_utils_1.Type.String(),
      signature: schema_utils_1.Type.String(),
      pubKey: schema_utils_1.Type.String(),
      coseSignature: schema_utils_1.Type.String(),
      coseKey: schema_utils_1.Type.String()
    });
  }
});

// node_modules/@trezor/connect/lib/types/api/bitcoin/index.js
var require_bitcoin = __commonJS({
  "node_modules/@trezor/connect/lib/types/api/bitcoin/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.VerifyMessage = exports2.SignMessage = void 0;
    var schema_utils_1 = require_lib2();
    var params_1 = require_params();
    exports2.SignMessage = schema_utils_1.Type.Object({
      path: params_1.DerivationPath,
      coin: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      message: schema_utils_1.Type.String(),
      hex: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      no_script_type: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    });
    exports2.VerifyMessage = schema_utils_1.Type.Object({
      address: schema_utils_1.Type.String(),
      signature: schema_utils_1.Type.String(),
      message: schema_utils_1.Type.String(),
      coin: schema_utils_1.Type.String(),
      hex: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    });
  }
});

// node_modules/@trezor/connect/lib/types/api/eos/index.js
var require_eos = __commonJS({
  "node_modules/@trezor/connect/lib/types/api/eos/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EosSignTransaction = exports2.EosSDKTransaction = exports2.EosTxAction = exports2.EosTxActionCommon = exports2.EosAuthorization = exports2.EosTxHeader = exports2.EosPublicKey = void 0;
    var schema_utils_1 = require_lib2();
    var constants_1 = require_constants4();
    var params_1 = require_params();
    exports2.EosPublicKey = schema_utils_1.Type.Object({
      wifPublicKey: schema_utils_1.Type.String(),
      rawPublicKey: schema_utils_1.Type.String(),
      path: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      serializedPath: schema_utils_1.Type.String()
    });
    exports2.EosTxHeader = schema_utils_1.Type.Object({
      expiration: schema_utils_1.Type.Union([schema_utils_1.Type.Uint(), schema_utils_1.Type.String()]),
      refBlockNum: schema_utils_1.Type.Number(),
      refBlockPrefix: schema_utils_1.Type.Number(),
      maxNetUsageWords: schema_utils_1.Type.Number(),
      maxCpuUsageMs: schema_utils_1.Type.Number(),
      delaySec: schema_utils_1.Type.Number()
    });
    exports2.EosAuthorization = schema_utils_1.Type.Object({
      threshold: schema_utils_1.Type.Number(),
      keys: schema_utils_1.Type.Array(constants_1.PROTO.EosAuthorizationKey),
      accounts: schema_utils_1.Type.Array(schema_utils_1.Type.Object({
        permission: constants_1.PROTO.EosPermissionLevel,
        weight: schema_utils_1.Type.Number()
      })),
      waits: schema_utils_1.Type.Array(constants_1.PROTO.EosAuthorizationWait)
    });
    exports2.EosTxActionCommon = schema_utils_1.Type.Object({
      account: schema_utils_1.Type.String(),
      authorization: schema_utils_1.Type.Array(constants_1.PROTO.EosPermissionLevel)
    });
    exports2.EosTxAction = schema_utils_1.Type.Union([
      schema_utils_1.Type.Intersect([
        exports2.EosTxActionCommon,
        schema_utils_1.Type.Object({
          name: schema_utils_1.Type.Literal("transfer"),
          data: schema_utils_1.Type.Object({
            from: schema_utils_1.Type.String(),
            to: schema_utils_1.Type.String(),
            quantity: schema_utils_1.Type.String(),
            memo: schema_utils_1.Type.String()
          })
        })
      ]),
      schema_utils_1.Type.Intersect([
        exports2.EosTxActionCommon,
        schema_utils_1.Type.Object({
          name: schema_utils_1.Type.Literal("delegatebw"),
          data: schema_utils_1.Type.Object({
            from: schema_utils_1.Type.String(),
            receiver: schema_utils_1.Type.String(),
            stake_net_quantity: schema_utils_1.Type.String(),
            stake_cpu_quantity: schema_utils_1.Type.String(),
            transfer: schema_utils_1.Type.Boolean()
          })
        })
      ]),
      schema_utils_1.Type.Intersect([
        exports2.EosTxActionCommon,
        schema_utils_1.Type.Object({
          name: schema_utils_1.Type.Literal("undelegatebw"),
          data: schema_utils_1.Type.Object({
            from: schema_utils_1.Type.String(),
            receiver: schema_utils_1.Type.String(),
            unstake_net_quantity: schema_utils_1.Type.String(),
            unstake_cpu_quantity: schema_utils_1.Type.String()
          })
        })
      ]),
      schema_utils_1.Type.Intersect([
        exports2.EosTxActionCommon,
        schema_utils_1.Type.Object({
          name: schema_utils_1.Type.Literal("buyram"),
          data: schema_utils_1.Type.Object({
            payer: schema_utils_1.Type.String(),
            receiver: schema_utils_1.Type.String(),
            quant: schema_utils_1.Type.String()
          })
        })
      ]),
      schema_utils_1.Type.Intersect([
        exports2.EosTxActionCommon,
        schema_utils_1.Type.Object({
          name: schema_utils_1.Type.Literal("buyrambytes"),
          data: constants_1.PROTO.EosActionBuyRamBytes
        })
      ]),
      schema_utils_1.Type.Intersect([
        exports2.EosTxActionCommon,
        schema_utils_1.Type.Object({
          name: schema_utils_1.Type.Literal("sellram"),
          data: constants_1.PROTO.EosActionSellRam
        })
      ]),
      schema_utils_1.Type.Intersect([
        exports2.EosTxActionCommon,
        schema_utils_1.Type.Object({
          name: schema_utils_1.Type.Literal("voteproducer"),
          data: schema_utils_1.Type.Object({
            voter: schema_utils_1.Type.String(),
            proxy: schema_utils_1.Type.String(),
            producers: schema_utils_1.Type.Array(schema_utils_1.Type.String())
          })
        })
      ]),
      schema_utils_1.Type.Intersect([
        exports2.EosTxActionCommon,
        schema_utils_1.Type.Object({
          name: schema_utils_1.Type.Literal("refund"),
          data: constants_1.PROTO.EosActionRefund
        })
      ]),
      schema_utils_1.Type.Intersect([
        exports2.EosTxActionCommon,
        schema_utils_1.Type.Object({
          name: schema_utils_1.Type.Literal("updateauth"),
          data: schema_utils_1.Type.Object({
            account: schema_utils_1.Type.String(),
            permission: schema_utils_1.Type.String(),
            parent: schema_utils_1.Type.String(),
            auth: exports2.EosAuthorization
          })
        })
      ]),
      schema_utils_1.Type.Intersect([
        exports2.EosTxActionCommon,
        schema_utils_1.Type.Object({
          name: schema_utils_1.Type.Literal("deleteauth"),
          data: constants_1.PROTO.EosActionDeleteAuth
        })
      ]),
      schema_utils_1.Type.Intersect([
        exports2.EosTxActionCommon,
        schema_utils_1.Type.Object({
          name: schema_utils_1.Type.Literal("linkauth"),
          data: constants_1.PROTO.EosActionLinkAuth
        })
      ]),
      schema_utils_1.Type.Intersect([
        exports2.EosTxActionCommon,
        schema_utils_1.Type.Object({
          name: schema_utils_1.Type.Literal("unlinkauth"),
          data: constants_1.PROTO.EosActionUnlinkAuth
        })
      ]),
      schema_utils_1.Type.Intersect([
        exports2.EosTxActionCommon,
        schema_utils_1.Type.Object({
          name: schema_utils_1.Type.Literal("newaccount"),
          data: schema_utils_1.Type.Object({
            creator: schema_utils_1.Type.String(),
            name: schema_utils_1.Type.String(),
            owner: exports2.EosAuthorization,
            active: exports2.EosAuthorization
          })
        })
      ])
    ]);
    exports2.EosSDKTransaction = schema_utils_1.Type.Object({
      chainId: schema_utils_1.Type.String(),
      header: exports2.EosTxHeader,
      actions: schema_utils_1.Type.Array(schema_utils_1.Type.Union([
        exports2.EosTxAction,
        schema_utils_1.Type.Intersect([
          exports2.EosTxActionCommon,
          schema_utils_1.Type.Object({
            name: schema_utils_1.Type.String(),
            data: schema_utils_1.Type.String()
          })
        ])
      ]))
    });
    exports2.EosSignTransaction = schema_utils_1.Type.Object({
      path: params_1.DerivationPath,
      transaction: exports2.EosSDKTransaction,
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    });
  }
});

// node_modules/@trezor/connect/lib/types/api/ripple/index.js
var require_ripple = __commonJS({
  "node_modules/@trezor/connect/lib/types/api/ripple/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RippleSignedTx = exports2.RippleSignTransaction = exports2.RippleTransaction = exports2.RipplePayment = void 0;
    var schema_utils_1 = require_lib2();
    var params_1 = require_params();
    exports2.RipplePayment = schema_utils_1.Type.Object({
      amount: schema_utils_1.Type.String(),
      destination: schema_utils_1.Type.String(),
      destinationTag: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    });
    exports2.RippleTransaction = schema_utils_1.Type.Object({
      fee: schema_utils_1.Type.String(),
      flags: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      sequence: schema_utils_1.Type.Number(),
      maxLedgerVersion: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      payment: exports2.RipplePayment
    });
    exports2.RippleSignTransaction = schema_utils_1.Type.Object({
      path: params_1.DerivationPath,
      transaction: exports2.RippleTransaction,
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    });
    exports2.RippleSignedTx = schema_utils_1.Type.Object({
      serializedTx: schema_utils_1.Type.String(),
      signature: schema_utils_1.Type.String()
    });
  }
});

// node_modules/@trezor/connect/lib/types/api/ethereum/index.js
var require_ethereum = __commonJS({
  "node_modules/@trezor/connect/lib/types/api/ethereum/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EthereumVerifyMessage = exports2.EthereumSignTypedHash = exports2.EthereumSignTypedData = exports2.EthereumSignTypedDataMessage = exports2.EthereumSignTypedDataTypes = exports2.EthereumSignedTx = exports2.EthereumSignTransaction = exports2.EthereumTransactionEIP1559 = exports2.EthereumAccessList = exports2.EthereumTransaction = exports2.EthereumSignMessage = void 0;
    var schema_utils_1 = require_lib2();
    var constants_1 = require_constants4();
    var params_1 = require_params();
    exports2.EthereumSignMessage = schema_utils_1.Type.Object({
      path: params_1.DerivationPath,
      message: schema_utils_1.Type.String(),
      hex: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    });
    exports2.EthereumTransaction = schema_utils_1.Type.Object({
      to: schema_utils_1.Type.Union([schema_utils_1.Type.String(), schema_utils_1.Type.Null()]),
      value: schema_utils_1.Type.String(),
      gasPrice: schema_utils_1.Type.String(),
      gasLimit: schema_utils_1.Type.String(),
      maxFeePerGas: schema_utils_1.Type.Optional(schema_utils_1.Type.Undefined()),
      maxPriorityFeePerGas: schema_utils_1.Type.Optional(schema_utils_1.Type.Undefined()),
      nonce: schema_utils_1.Type.String(),
      data: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      chainId: schema_utils_1.Type.Number(),
      txType: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      payment_req: schema_utils_1.Type.Optional(constants_1.PROTO.PaymentRequest)
    });
    exports2.EthereumAccessList = schema_utils_1.Type.Object({
      address: schema_utils_1.Type.String(),
      storageKeys: schema_utils_1.Type.Array(schema_utils_1.Type.String())
    });
    exports2.EthereumTransactionEIP1559 = schema_utils_1.Type.Object({
      to: schema_utils_1.Type.Union([schema_utils_1.Type.String(), schema_utils_1.Type.Null()]),
      value: schema_utils_1.Type.String(),
      gasLimit: schema_utils_1.Type.String(),
      gasPrice: schema_utils_1.Type.Optional(schema_utils_1.Type.Undefined()),
      nonce: schema_utils_1.Type.String(),
      data: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      chainId: schema_utils_1.Type.Number(),
      maxFeePerGas: schema_utils_1.Type.String(),
      maxPriorityFeePerGas: schema_utils_1.Type.String(),
      accessList: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(exports2.EthereumAccessList)),
      payment_req: schema_utils_1.Type.Optional(constants_1.PROTO.PaymentRequest)
    });
    exports2.EthereumSignTransaction = schema_utils_1.Type.Object({
      path: params_1.DerivationPath,
      transaction: schema_utils_1.Type.Union([exports2.EthereumTransaction, exports2.EthereumTransactionEIP1559]),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    });
    exports2.EthereumSignedTx = schema_utils_1.Type.Object({
      v: schema_utils_1.Type.String(),
      r: schema_utils_1.Type.String(),
      s: schema_utils_1.Type.String(),
      serializedTx: schema_utils_1.Type.String()
    });
    var EthereumSignTypedDataTypeProperty = schema_utils_1.Type.Object({
      name: schema_utils_1.Type.String(),
      type: schema_utils_1.Type.String()
    });
    exports2.EthereumSignTypedDataTypes = schema_utils_1.Type.Object({
      EIP712Domain: schema_utils_1.Type.Array(EthereumSignTypedDataTypeProperty)
    }, {
      additionalProperties: schema_utils_1.Type.Array(EthereumSignTypedDataTypeProperty)
    });
    exports2.EthereumSignTypedDataMessage = schema_utils_1.Type.Object({
      types: exports2.EthereumSignTypedDataTypes,
      primaryType: schema_utils_1.Type.String(),
      domain: schema_utils_1.Type.Object({
        name: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
        version: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
        chainId: schema_utils_1.Type.Optional(schema_utils_1.Type.Union([schema_utils_1.Type.Number(), schema_utils_1.Type.BigInt(), schema_utils_1.Type.String()])),
        verifyingContract: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
        salt: schema_utils_1.Type.Optional(schema_utils_1.Type.Union([schema_utils_1.Type.ArrayBuffer(), schema_utils_1.Type.String()]))
      }),
      message: schema_utils_1.Type.Object({}, {
        additionalProperties: schema_utils_1.Type.Any()
      })
    });
    exports2.EthereumSignTypedData = schema_utils_1.Type.Object({
      path: params_1.DerivationPath,
      data: exports2.EthereumSignTypedDataMessage,
      metamask_v4_compat: schema_utils_1.Type.Boolean(),
      domain_separator_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.Undefined()),
      message_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.Undefined())
    });
    exports2.EthereumSignTypedHash = schema_utils_1.Type.Object({
      path: params_1.DerivationPath,
      data: exports2.EthereumSignTypedDataMessage,
      metamask_v4_compat: schema_utils_1.Type.Boolean(),
      domain_separator_hash: schema_utils_1.Type.String(),
      message_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    });
    exports2.EthereumVerifyMessage = schema_utils_1.Type.Object({
      address: schema_utils_1.Type.String(),
      message: schema_utils_1.Type.String(),
      hex: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      signature: schema_utils_1.Type.String()
    });
  }
});

// node_modules/@trezor/connect/lib/types/api/solana/index.js
var require_solana = __commonJS({
  "node_modules/@trezor/connect/lib/types/api/solana/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SolanaComposedTransaction = exports2.SolanaComposeTransaction = exports2.SolanaProgramName = exports2.SolanaSignedTransaction = exports2.SolanaSignTransaction = exports2.SolanaTxAdditionalInfo = exports2.SolanaTxTokenAccountInfo = exports2.SolanaPublicKey = void 0;
    var schema_utils_1 = require_lib2();
    var params_1 = require_params();
    exports2.SolanaPublicKey = schema_utils_1.Type.Intersect([
      params_1.PublicKey,
      schema_utils_1.Type.Object({
        publicKey: schema_utils_1.Type.String(),
        publicKeyBase58: schema_utils_1.Type.String()
      })
    ]);
    exports2.SolanaTxTokenAccountInfo = schema_utils_1.Type.Object({
      baseAddress: schema_utils_1.Type.String(),
      tokenProgram: schema_utils_1.Type.String(),
      tokenMint: schema_utils_1.Type.String(),
      tokenAccount: schema_utils_1.Type.String(),
      symbol: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    });
    exports2.SolanaTxAdditionalInfo = schema_utils_1.Type.Object({
      tokenAccountsInfos: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(exports2.SolanaTxTokenAccountInfo, { minItems: 1 })),
      isDevnet: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    });
    exports2.SolanaSignTransaction = schema_utils_1.Type.Object({
      path: schema_utils_1.Type.Union([schema_utils_1.Type.String(), schema_utils_1.Type.Array(schema_utils_1.Type.Number())]),
      serializedTx: schema_utils_1.Type.String(),
      additionalInfo: schema_utils_1.Type.Optional(exports2.SolanaTxAdditionalInfo),
      serialize: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    });
    exports2.SolanaSignedTransaction = schema_utils_1.Type.Object({
      signature: schema_utils_1.Type.String(),
      serializedTx: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    });
    exports2.SolanaProgramName = schema_utils_1.Type.Union([
      schema_utils_1.Type.Literal("spl-token"),
      schema_utils_1.Type.Literal("spl-token-2022")
    ]);
    var SolanaComposeTransactionCommon = {
      fromAddress: schema_utils_1.Type.String(),
      amount: schema_utils_1.Type.String(),
      blockHash: schema_utils_1.Type.String(),
      lastValidBlockHeight: schema_utils_1.Type.Number(),
      priorityFees: schema_utils_1.Type.Optional(schema_utils_1.Type.Object({
        computeUnitPrice: schema_utils_1.Type.String(),
        computeUnitLimit: schema_utils_1.Type.String()
      })),
      token: schema_utils_1.Type.Optional(schema_utils_1.Type.Object({
        mint: schema_utils_1.Type.String(),
        program: exports2.SolanaProgramName,
        decimals: schema_utils_1.Type.Number(),
        accounts: schema_utils_1.Type.Array(schema_utils_1.Type.Object({ publicKey: schema_utils_1.Type.String(), balance: schema_utils_1.Type.String() }))
      })),
      coin: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      identity: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    };
    var SolanaComposeSerializedTransaction = schema_utils_1.Type.Object({
      ...SolanaComposeTransactionCommon,
      toAddress: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      serializedTx: schema_utils_1.Type.String()
    });
    var SolanaComposeTransactionRaw = schema_utils_1.Type.Object({
      ...SolanaComposeTransactionCommon,
      toAddress: schema_utils_1.Type.String(),
      serializedTx: schema_utils_1.Type.Optional(schema_utils_1.Type.Undefined())
    });
    exports2.SolanaComposeTransaction = schema_utils_1.Type.Union([
      SolanaComposeSerializedTransaction,
      SolanaComposeTransactionRaw
    ]);
    exports2.SolanaComposedTransaction = schema_utils_1.Type.Object({
      serializedTx: schema_utils_1.Type.String(),
      additionalInfo: schema_utils_1.Type.Object({
        newAccountProgramName: schema_utils_1.Type.Optional(exports2.SolanaProgramName),
        tokenAccountInfo: schema_utils_1.Type.Optional(exports2.SolanaTxTokenAccountInfo)
      })
    });
  }
});

// node_modules/@trezor/connect/lib/types/api/stellar/index.js
var require_stellar = __commonJS({
  "node_modules/@trezor/connect/lib/types/api/stellar/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StellarOperationMessage = exports2.StellarSignedTx = exports2.StellarSignTransaction = exports2.StellarTransaction = exports2.StellarOperation = exports2.StellarClaimClaimableBalanceOperation = exports2.StellarInflationOperation = exports2.StellarBumpSequenceOperation = exports2.StellarManageDataOperation = exports2.StellarAccountMergeOperation = exports2.StellarAllowTrustOperation = exports2.StellarChangeTrustOperation = exports2.StellarSetOptionsOperation = exports2.StellarManageBuyOfferOperation = exports2.StellarManageSellOfferOperation = exports2.StellarPassiveSellOfferOperation = exports2.StellarPathPaymentStrictSendOperation = exports2.StellarPathPaymentStrictReceiveOperation = exports2.StellarPaymentOperation = exports2.StellarCreateAccountOperation = exports2.StellarAsset = void 0;
    var schema_utils_1 = require_lib2();
    var constants_1 = require_constants4();
    var params_1 = require_params();
    exports2.StellarAsset = schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Union([constants_1.PROTO.EnumStellarAssetType, schema_utils_1.Type.KeyOfEnum(constants_1.PROTO.StellarAssetType)]),
      code: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      issuer: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    });
    exports2.StellarCreateAccountOperation = schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Literal("createAccount"),
      source: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      destination: schema_utils_1.Type.String(),
      startingBalance: schema_utils_1.Type.String()
    });
    exports2.StellarPaymentOperation = schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Literal("payment"),
      source: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      destination: schema_utils_1.Type.String(),
      asset: exports2.StellarAsset,
      amount: schema_utils_1.Type.String()
    });
    exports2.StellarPathPaymentStrictReceiveOperation = schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Literal("pathPaymentStrictReceive"),
      source: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      sendAsset: exports2.StellarAsset,
      sendMax: schema_utils_1.Type.Uint(),
      destination: schema_utils_1.Type.String(),
      destAsset: exports2.StellarAsset,
      destAmount: schema_utils_1.Type.Uint(),
      path: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(exports2.StellarAsset))
    });
    exports2.StellarPathPaymentStrictSendOperation = schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Literal("pathPaymentStrictSend"),
      source: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      sendAsset: exports2.StellarAsset,
      sendAmount: schema_utils_1.Type.Uint(),
      destination: schema_utils_1.Type.String(),
      destAsset: exports2.StellarAsset,
      destMin: schema_utils_1.Type.Uint(),
      path: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(exports2.StellarAsset))
    });
    exports2.StellarPassiveSellOfferOperation = schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Literal("createPassiveSellOffer"),
      source: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      buying: exports2.StellarAsset,
      selling: exports2.StellarAsset,
      amount: schema_utils_1.Type.Uint(),
      price: schema_utils_1.Type.Object({
        n: schema_utils_1.Type.Number(),
        d: schema_utils_1.Type.Number()
      })
    });
    exports2.StellarManageSellOfferOperation = schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Literal("manageSellOffer"),
      source: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      buying: exports2.StellarAsset,
      selling: exports2.StellarAsset,
      amount: schema_utils_1.Type.Uint(),
      offerId: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint()),
      price: schema_utils_1.Type.Object({
        n: schema_utils_1.Type.Number(),
        d: schema_utils_1.Type.Number()
      })
    });
    exports2.StellarManageBuyOfferOperation = schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Literal("manageBuyOffer"),
      source: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      buying: exports2.StellarAsset,
      selling: exports2.StellarAsset,
      amount: schema_utils_1.Type.Uint(),
      offerId: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint()),
      price: schema_utils_1.Type.Object({
        n: schema_utils_1.Type.Number(),
        d: schema_utils_1.Type.Number()
      })
    });
    exports2.StellarSetOptionsOperation = schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Literal("setOptions"),
      source: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      signer: schema_utils_1.Type.Optional(schema_utils_1.Type.Object({
        type: constants_1.PROTO.EnumStellarSignerType,
        key: schema_utils_1.Type.Union([schema_utils_1.Type.String(), schema_utils_1.Type.Buffer()]),
        weight: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
      })),
      inflationDest: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      clearFlags: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      setFlags: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      masterWeight: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint()),
      lowThreshold: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint()),
      medThreshold: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint()),
      highThreshold: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint()),
      homeDomain: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    });
    exports2.StellarChangeTrustOperation = schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Literal("changeTrust"),
      source: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      line: exports2.StellarAsset,
      limit: schema_utils_1.Type.String()
    });
    exports2.StellarAllowTrustOperation = schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Literal("allowTrust"),
      source: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      trustor: schema_utils_1.Type.String(),
      assetCode: schema_utils_1.Type.String(),
      assetType: constants_1.PROTO.EnumStellarAssetType,
      authorize: schema_utils_1.Type.Optional(schema_utils_1.Type.Union([schema_utils_1.Type.Boolean(), schema_utils_1.Type.Undefined()]))
    });
    exports2.StellarAccountMergeOperation = schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Literal("accountMerge"),
      source: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      destination: schema_utils_1.Type.String()
    });
    exports2.StellarManageDataOperation = schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Literal("manageData"),
      source: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      name: schema_utils_1.Type.String(),
      value: schema_utils_1.Type.Optional(schema_utils_1.Type.Union([schema_utils_1.Type.String(), schema_utils_1.Type.Buffer()]))
    });
    exports2.StellarBumpSequenceOperation = schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Literal("bumpSequence"),
      source: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      bumpTo: schema_utils_1.Type.Uint()
    });
    exports2.StellarInflationOperation = schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Literal("inflation"),
      source: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    });
    exports2.StellarClaimClaimableBalanceOperation = schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Literal("claimClaimableBalance"),
      source: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      balanceId: schema_utils_1.Type.String()
    });
    exports2.StellarOperation = schema_utils_1.Type.Union([
      exports2.StellarCreateAccountOperation,
      exports2.StellarPaymentOperation,
      exports2.StellarPathPaymentStrictReceiveOperation,
      exports2.StellarPathPaymentStrictSendOperation,
      exports2.StellarPassiveSellOfferOperation,
      exports2.StellarManageSellOfferOperation,
      exports2.StellarManageBuyOfferOperation,
      exports2.StellarSetOptionsOperation,
      exports2.StellarChangeTrustOperation,
      exports2.StellarAllowTrustOperation,
      exports2.StellarAccountMergeOperation,
      exports2.StellarInflationOperation,
      exports2.StellarManageDataOperation,
      exports2.StellarBumpSequenceOperation,
      exports2.StellarClaimClaimableBalanceOperation
    ]);
    exports2.StellarTransaction = schema_utils_1.Type.Object({
      source: schema_utils_1.Type.String(),
      fee: schema_utils_1.Type.Number(),
      sequence: schema_utils_1.Type.Uint(),
      timebounds: schema_utils_1.Type.Optional(schema_utils_1.Type.Object({
        minTime: schema_utils_1.Type.Number(),
        maxTime: schema_utils_1.Type.Number()
      })),
      memo: schema_utils_1.Type.Optional(schema_utils_1.Type.Object({
        type: constants_1.PROTO.EnumStellarMemoType,
        id: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint()),
        text: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
        hash: schema_utils_1.Type.Optional(schema_utils_1.Type.Union([schema_utils_1.Type.String(), schema_utils_1.Type.Buffer()]))
      })),
      operations: schema_utils_1.Type.Array(exports2.StellarOperation)
    });
    exports2.StellarSignTransaction = schema_utils_1.Type.Object({
      path: params_1.DerivationPath,
      networkPassphrase: schema_utils_1.Type.String(),
      transaction: exports2.StellarTransaction
    });
    exports2.StellarSignedTx = schema_utils_1.Type.Object({
      publicKey: schema_utils_1.Type.String(),
      signature: schema_utils_1.Type.String()
    });
    exports2.StellarOperationMessage = schema_utils_1.Type.Union([
      schema_utils_1.Type.Intersect([
        schema_utils_1.Type.Object({
          type: schema_utils_1.Type.Literal("StellarCreateAccountOp")
        }),
        constants_1.PROTO.StellarCreateAccountOp
      ]),
      schema_utils_1.Type.Intersect([
        schema_utils_1.Type.Object({
          type: schema_utils_1.Type.Literal("StellarPaymentOp")
        }),
        constants_1.PROTO.StellarPaymentOp
      ]),
      schema_utils_1.Type.Intersect([
        schema_utils_1.Type.Object({
          type: schema_utils_1.Type.Literal("StellarPathPaymentStrictReceiveOp")
        }),
        constants_1.PROTO.StellarPathPaymentStrictReceiveOp
      ]),
      schema_utils_1.Type.Intersect([
        schema_utils_1.Type.Object({
          type: schema_utils_1.Type.Literal("StellarPathPaymentStrictSendOp")
        }),
        constants_1.PROTO.StellarPathPaymentStrictSendOp
      ]),
      schema_utils_1.Type.Intersect([
        schema_utils_1.Type.Object({
          type: schema_utils_1.Type.Literal("StellarManageSellOfferOp")
        }),
        constants_1.PROTO.StellarManageSellOfferOp
      ]),
      schema_utils_1.Type.Intersect([
        schema_utils_1.Type.Object({
          type: schema_utils_1.Type.Literal("StellarManageBuyOfferOp")
        }),
        constants_1.PROTO.StellarManageBuyOfferOp
      ]),
      schema_utils_1.Type.Intersect([
        schema_utils_1.Type.Object({
          type: schema_utils_1.Type.Literal("StellarCreatePassiveSellOfferOp")
        }),
        constants_1.PROTO.StellarCreatePassiveSellOfferOp
      ]),
      schema_utils_1.Type.Intersect([
        schema_utils_1.Type.Object({
          type: schema_utils_1.Type.Literal("StellarSetOptionsOp")
        }),
        constants_1.PROTO.StellarSetOptionsOp
      ]),
      schema_utils_1.Type.Intersect([
        schema_utils_1.Type.Object({
          type: schema_utils_1.Type.Literal("StellarChangeTrustOp")
        }),
        constants_1.PROTO.StellarChangeTrustOp
      ]),
      schema_utils_1.Type.Intersect([
        schema_utils_1.Type.Object({
          type: schema_utils_1.Type.Literal("StellarAllowTrustOp")
        }),
        constants_1.PROTO.StellarAllowTrustOp
      ]),
      schema_utils_1.Type.Intersect([
        schema_utils_1.Type.Object({
          type: schema_utils_1.Type.Literal("StellarAccountMergeOp")
        }),
        constants_1.PROTO.StellarAccountMergeOp
      ]),
      schema_utils_1.Type.Intersect([
        schema_utils_1.Type.Object({
          type: schema_utils_1.Type.Literal("StellarManageDataOp")
        }),
        constants_1.PROTO.StellarManageDataOp
      ]),
      schema_utils_1.Type.Intersect([
        schema_utils_1.Type.Object({
          type: schema_utils_1.Type.Literal("StellarBumpSequenceOp")
        }),
        constants_1.PROTO.StellarBumpSequenceOp
      ]),
      schema_utils_1.Type.Intersect([
        schema_utils_1.Type.Object({
          type: schema_utils_1.Type.Literal("StellarClaimClaimableBalanceOp")
        }),
        constants_1.PROTO.StellarClaimClaimableBalanceOp
      ])
    ]);
  }
});

// node_modules/@trezor/connect/lib/types/api/tezos/index.js
var require_tezos = __commonJS({
  "node_modules/@trezor/connect/lib/types/api/tezos/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TezosSignTransaction = exports2.TezosOperation = exports2.TezosDelegationOperation = exports2.TezosOriginationOperation = exports2.TezosTransactionOperation = exports2.TezosParametersManager = exports2.TezosManagerTransfer = exports2.TezosRevealOperation = void 0;
    var schema_utils_1 = require_lib2();
    var params_1 = require_params();
    exports2.TezosRevealOperation = schema_utils_1.Type.Object({
      source: schema_utils_1.Type.String(),
      fee: schema_utils_1.Type.Number(),
      counter: schema_utils_1.Type.Number(),
      gas_limit: schema_utils_1.Type.Number(),
      storage_limit: schema_utils_1.Type.Number(),
      public_key: schema_utils_1.Type.String()
    });
    exports2.TezosManagerTransfer = schema_utils_1.Type.Object({
      destination: schema_utils_1.Type.String(),
      amount: schema_utils_1.Type.Number()
    });
    exports2.TezosParametersManager = schema_utils_1.Type.Object({
      set_delegate: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      cancel_delegate: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      transfer: schema_utils_1.Type.Optional(exports2.TezosManagerTransfer)
    });
    exports2.TezosTransactionOperation = schema_utils_1.Type.Object({
      source: schema_utils_1.Type.String(),
      destination: schema_utils_1.Type.String(),
      amount: schema_utils_1.Type.Number(),
      counter: schema_utils_1.Type.Number(),
      fee: schema_utils_1.Type.Number(),
      gas_limit: schema_utils_1.Type.Number(),
      storage_limit: schema_utils_1.Type.Number(),
      parameters: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(schema_utils_1.Type.Number())),
      parameters_manager: schema_utils_1.Type.Optional(exports2.TezosParametersManager)
    });
    exports2.TezosOriginationOperation = schema_utils_1.Type.Object({
      source: schema_utils_1.Type.String(),
      balance: schema_utils_1.Type.Number(),
      delegate: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      script: params_1.DerivationPath,
      fee: schema_utils_1.Type.Number(),
      counter: schema_utils_1.Type.Number(),
      gas_limit: schema_utils_1.Type.Number(),
      storage_limit: schema_utils_1.Type.Number()
    });
    exports2.TezosDelegationOperation = schema_utils_1.Type.Object({
      source: schema_utils_1.Type.String(),
      delegate: schema_utils_1.Type.String(),
      fee: schema_utils_1.Type.Number(),
      counter: schema_utils_1.Type.Number(),
      gas_limit: schema_utils_1.Type.Number(),
      storage_limit: schema_utils_1.Type.Number()
    });
    exports2.TezosOperation = schema_utils_1.Type.Object({
      reveal: schema_utils_1.Type.Optional(exports2.TezosRevealOperation),
      transaction: schema_utils_1.Type.Optional(exports2.TezosTransactionOperation),
      origination: schema_utils_1.Type.Optional(exports2.TezosOriginationOperation),
      delegation: schema_utils_1.Type.Optional(exports2.TezosDelegationOperation)
    });
    exports2.TezosSignTransaction = schema_utils_1.Type.Object({
      path: params_1.DerivationPath,
      branch: schema_utils_1.Type.String(),
      operation: exports2.TezosOperation,
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    });
  }
});

// node_modules/@trezor/connect/lib/types/index.js
var require_types4 = __commonJS({
  "node_modules/@trezor/connect/lib/types/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FirmwareType = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_api(), exports2);
    tslib_1.__exportStar(require_account(), exports2);
    tslib_1.__exportStar(require_coinInfo(), exports2);
    tslib_1.__exportStar(require_device2(), exports2);
    tslib_1.__exportStar(require_fees(), exports2);
    tslib_1.__exportStar(require_firmware2(), exports2);
    tslib_1.__exportStar(require_params(), exports2);
    tslib_1.__exportStar(require_settings(), exports2);
    tslib_1.__exportStar(require_cardano2(), exports2);
    tslib_1.__exportStar(require_bitcoin(), exports2);
    tslib_1.__exportStar(require_eos(), exports2);
    tslib_1.__exportStar(require_ripple(), exports2);
    tslib_1.__exportStar(require_ethereum(), exports2);
    tslib_1.__exportStar(require_solana(), exports2);
    tslib_1.__exportStar(require_stellar(), exports2);
    tslib_1.__exportStar(require_tezos(), exports2);
    var device_utils_1 = require_lib7();
    Object.defineProperty(exports2, "FirmwareType", { enumerable: true, get: function() {
      return device_utils_1.FirmwareType;
    } });
  }
});

// node_modules/@trezor/connect/lib/exports.js
var require_exports = __commonJS({
  "node_modules/@trezor/connect/lib/exports.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseConnectSettings = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_constants4(), exports2);
    tslib_1.__exportStar(require_events2(), exports2);
    tslib_1.__exportStar(require_types4(), exports2);
    var connectSettings_1 = require_connectSettings();
    Object.defineProperty(exports2, "parseConnectSettings", { enumerable: true, get: function() {
      return connectSettings_1.parseConnectSettings;
    } });
  }
});

// node_modules/@trezor/connect-web/lib/index.js
var require_lib8 = __commonJS({
  "node_modules/@trezor/connect-web/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var factory_1 = require_factory();
    var dynamic_1 = require_dynamic();
    var connectSettings_1 = require_connectSettings2();
    var core_in_iframe_1 = require_core_in_iframe();
    var core_in_popup_1 = require_core_in_popup();
    var core_in_suite_desktop_1 = require_core_in_suite_desktop();
    var IFRAME_ERRORS = ["Init_IframeBlocked", "Init_IframeTimeout", "Transport_Missing"];
    var impl = new dynamic_1.TrezorConnectDynamic({
      implementations: [
        {
          type: "iframe",
          impl: new core_in_iframe_1.CoreInIframe()
        },
        {
          type: "core-in-popup",
          impl: new core_in_popup_1.CoreInPopup()
        },
        {
          type: "core-in-suite-desktop",
          impl: new core_in_suite_desktop_1.CoreInSuiteDesktop()
        }
      ],
      getInitTarget: (settings2) => {
        if (settings2.coreMode === "iframe") {
          return "iframe";
        } else if (settings2.coreMode === "popup") {
          return "core-in-popup";
        } else if (settings2.coreMode === "suite-desktop") {
          return "core-in-suite-desktop";
        } else {
          if (settings2.coreMode && settings2.coreMode !== "auto") {
            console.warn(`Invalid coreMode: ${settings2.coreMode}`);
          }
          return "iframe";
        }
      },
      handleBeforeCall: async () => {
        const isCoreModeDesktop = impl.lastSettings?.coreMode === "suite-desktop";
        const isCoreModeAuto = impl.lastSettings?.coreMode === "auto" || impl.lastSettings?.coreMode === void 0;
        if (isCoreModeDesktop || isCoreModeAuto) {
          await impl.switchTarget("core-in-suite-desktop");
        }
      },
      handleErrorFallback: async (errorCode) => {
        const env = (0, connectSettings_1.getEnv)();
        const isCoreModeDisabled = impl.lastSettings?.popup === false || env === "webextension";
        const isCoreModeAuto = impl.lastSettings?.coreMode === "auto" || impl.lastSettings?.coreMode === void 0;
        if (impl.getTargetType() === "core-in-suite-desktop" && (errorCode === "Desktop_ConnectionMissing" || errorCode === "Method_Unsupported")) {
          await impl.switchTarget("iframe");
          return true;
        }
        if (!isCoreModeDisabled && isCoreModeAuto && IFRAME_ERRORS.includes(errorCode)) {
          const webUsbUnavailableInBrowser = !navigator?.usb;
          const webUsbDisabledInSettings = impl.lastSettings?.transports?.includes("WebUsbTransport") === false;
          if (errorCode === "Transport_Missing" && (webUsbUnavailableInBrowser || webUsbDisabledInSettings)) {
            return false;
          }
          await impl.switchTarget("core-in-popup");
          return true;
        }
        return false;
      }
    });
    var TrezorConnect2 = (0, factory_1.factory)({
      eventEmitter: impl.eventEmitter,
      init: impl.init.bind(impl),
      call: impl.call.bind(impl),
      setTransports: impl.setTransports.bind(impl),
      manifest: impl.manifest.bind(impl),
      requestLogin: impl.requestLogin.bind(impl),
      uiResponse: impl.uiResponse.bind(impl),
      cancel: impl.cancel.bind(impl),
      dispose: impl.dispose.bind(impl)
    }, {
      renderWebUSBButton: impl.getTarget().renderWebUSBButton.bind(impl),
      disableWebUSB: impl.getTarget().disableWebUSB.bind(impl),
      requestWebUSBDevice: impl.getTarget().requestWebUSBDevice.bind(impl)
    });
    exports2.default = TrezorConnect2;
    tslib_1.__exportStar(require_exports(), exports2);
  }
});

// lib/devices.ts
var drivers = /* @__PURE__ */ new Map();
function registerDriver(driver) {
  drivers.set(driver.type, driver);
}
function getDriver(type) {
  return drivers.get(type);
}
function getAllDrivers() {
  return Array.from(drivers.values());
}
function getSupportedDrivers() {
  return getAllDrivers().filter((d) => d.isSupported());
}
var DeviceManager = class {
  connectedDevices = /* @__PURE__ */ new Map();
  deviceTypeMap = /* @__PURE__ */ new Map();
  listeners = /* @__PURE__ */ new Set();
  async enumerateAll() {
    const devices2 = [];
    for (const driver of getSupportedDrivers()) {
      try {
        const driverDevices = await driver.enumerate();
        for (const device of driverDevices) {
          this.connectedDevices.set(device.id, device);
          this.deviceTypeMap.set(device.id, driver.type);
          devices2.push(device);
        }
      } catch (error) {
        console.warn(`Failed to enumerate ${driver.type} devices:`, error);
      }
    }
    return devices2;
  }
  async connectDevice(type) {
    const driver = getDriver(type);
    if (!driver) {
      throw new Error(`No driver for device type: ${type}`);
    }
    if (!driver.isSupported()) {
      throw new Error(`Device type ${type} is not supported in this environment`);
    }
    const device = await driver.connect();
    this.connectedDevices.set(device.id, device);
    this.deviceTypeMap.set(device.id, type);
    this.notifyListeners();
    return device;
  }
  async disconnectDevice(deviceId) {
    const type = this.deviceTypeMap.get(deviceId);
    if (!type) {
      throw new Error(`Unknown device: ${deviceId}`);
    }
    const driver = getDriver(type);
    if (driver) {
      await driver.disconnect(deviceId);
    }
    this.connectedDevices.delete(deviceId);
    this.deviceTypeMap.delete(deviceId);
    this.notifyListeners();
  }
  async getXpub(deviceId, path) {
    const type = this.deviceTypeMap.get(deviceId);
    if (!type) {
      const devices2 = await this.enumerateAll();
      const device = devices2.find((d) => d.id === deviceId);
      if (!device) {
        throw new Error(`Device not found: ${deviceId}`);
      }
    }
    const deviceType = this.deviceTypeMap.get(deviceId);
    const driver = getDriver(deviceType);
    if (!driver) {
      throw new Error(`No driver for device: ${deviceId}`);
    }
    return driver.getXpub(deviceId, path);
  }
  async signPSBT(deviceId, psbt, inputPaths) {
    const type = this.deviceTypeMap.get(deviceId);
    if (!type) {
      throw new Error(`Unknown device: ${deviceId}`);
    }
    const driver = getDriver(type);
    if (!driver) {
      throw new Error(`No driver for device type: ${type}`);
    }
    return driver.signPSBT(deviceId, psbt, inputPaths);
  }
  async verifyAddress(deviceId, path, address) {
    const type = this.deviceTypeMap.get(deviceId);
    if (!type) {
      throw new Error(`Unknown device: ${deviceId}`);
    }
    const driver = getDriver(type);
    if (!driver) {
      throw new Error(`No driver for device type: ${type}`);
    }
    return driver.verifyAddress(deviceId, path, address);
  }
  getConnectedDevices() {
    return Array.from(this.connectedDevices.values());
  }
  getDevice(deviceId) {
    return this.connectedDevices.get(deviceId);
  }
  onDeviceChange(callback) {
    this.listeners.add(callback);
    return () => this.listeners.delete(callback);
  }
  notifyListeners() {
    const devices2 = this.getConnectedDevices();
    for (const listener of this.listeners) {
      try {
        listener(devices2);
      } catch (error) {
        console.error("Device change listener error:", error);
      }
    }
  }
};
var deviceManager = new DeviceManager();

// lib/ledger.ts
var LEDGER_VENDOR_ID = 11415;
var LEDGER_MODELS = {
  1: "Ledger Nano S",
  4: "Ledger Nano X",
  5: "Ledger Nano S Plus",
  6: "Ledger Stax",
  7: "Ledger Flex"
};
var connections = /* @__PURE__ */ new Map();
function getDeviceId(device) {
  return `ledger-${device.vendorId}-${device.productId}-${device.serialNumber || "unknown"}`;
}
function getModelName(productId) {
  return LEDGER_MODELS[productId] || "Ledger Device";
}
var ledgerDriver = {
  type: "ledger",
  isSupported() {
    return typeof navigator !== "undefined" && "usb" in navigator;
  },
  async enumerate() {
    if (!this.isSupported()) return [];
    try {
      const devices2 = await navigator.usb.getDevices();
      const ledgerDevices2 = devices2.filter((d) => d.vendorId === LEDGER_VENDOR_ID);
      return ledgerDevices2.map((device) => ({
        id: getDeviceId(device),
        type: "ledger",
        model: getModelName(device.productId),
        fingerprint: null,
        // Will be populated on connect
        connected: device.opened
      }));
    } catch (error) {
      console.error("Failed to enumerate Ledger devices:", error);
      return [];
    }
  },
  async connect() {
    if (!this.isSupported()) {
      throw new Error("WebUSB not supported");
    }
    const [{ default: TransportWebUSB2 }, { default: AppBtc }] = await Promise.all([
      Promise.resolve().then(() => (init_TransportWebUSB(), TransportWebUSB_exports)),
      Promise.resolve().then(() => (init_Btc(), Btc_exports))
    ]);
    const transport = await TransportWebUSB2.create();
    const device = transport.device;
    const deviceId = getDeviceId(device);
    const app = new AppBtc({ transport });
    let fingerprint = null;
    try {
      const masterKey = await app.getWalletXpub({ path: "m/0'" });
      const result = await app.getWalletXpub({ path: "m/84'/0'/0'" });
      fingerprint = result.masterFingerprint?.toString(16).padStart(8, "0") || null;
    } catch (error) {
      console.warn("Could not get fingerprint from Ledger:", error);
    }
    connections.set(deviceId, { device, transport, app });
    return {
      id: deviceId,
      type: "ledger",
      model: getModelName(device.productId),
      fingerprint,
      connected: true
    };
  },
  async disconnect(deviceId) {
    const connection = connections.get(deviceId);
    if (connection) {
      try {
        await connection.transport.close();
      } catch (error) {
        console.warn("Error closing Ledger transport:", error);
      }
      connections.delete(deviceId);
    }
  },
  async getXpub(deviceId, path) {
    let connection = connections.get(deviceId);
    if (!connection) {
      const device = await this.connect();
      if (device.id !== deviceId) {
        throw new Error("Connected device does not match requested device ID");
      }
      connection = connections.get(deviceId);
    }
    if (!connection) {
      throw new Error("Failed to connect to Ledger device");
    }
    try {
      const result = await connection.app.getWalletXpub({ path });
      return {
        xpub: result.xpub,
        fingerprint: result.masterFingerprint?.toString(16).padStart(8, "0") || "",
        path
      };
    } catch (error) {
      if (error.statusCode === 27013) {
        throw new Error("User rejected the request on the Ledger device");
      }
      if (error.statusCode === 27266) {
        throw new Error("Bitcoin app not open on Ledger device");
      }
      throw new Error(`Ledger error: ${error.message || error}`);
    }
  },
  async signPSBT(deviceId, psbtBase64, inputPaths) {
    const connection = connections.get(deviceId);
    if (!connection) {
      throw new Error("Ledger device not connected");
    }
    try {
      const psbtBuffer = Buffer.from(psbtBase64, "base64");
      const result = await connection.app.signPsbt(psbtBuffer, inputPaths);
      const signedPsbtBase64 = Buffer.from(result.psbt).toString("base64");
      return {
        signedPsbt: signedPsbtBase64,
        signatures: result.signatures?.length || inputPaths.length
      };
    } catch (error) {
      if (error.statusCode === 27013) {
        throw new Error("User rejected the transaction on the Ledger device");
      }
      if (error.statusCode === 27266) {
        throw new Error("Bitcoin app not open on Ledger device");
      }
      if (error.statusCode === 28416) {
        throw new Error("Ledger device error - please reconnect the device");
      }
      throw new Error(`Ledger signing error: ${error.message || error}`);
    }
  },
  async verifyAddress(deviceId, path, address) {
    const connection = connections.get(deviceId);
    if (!connection) {
      throw new Error("Ledger device not connected");
    }
    try {
      const result = await connection.app.getWalletAddress(
        path,
        true,
        // display on device
        void 0,
        // account (optional)
        void 0,
        // change (optional)
        void 0
        // address index (optional)
      );
      return result.address === address;
    } catch (error) {
      if (error.statusCode === 27013) {
        return false;
      }
      throw new Error(`Ledger address verification error: ${error.message || error}`);
    }
  }
};

// lib/trezor.ts
var TrezorConnect = null;
var initialized = false;
var connectedDevices = /* @__PURE__ */ new Map();
async function initTrezorConnect() {
  if (initialized) return;
  const module2 = await Promise.resolve().then(() => __toESM(require_lib8(), 1));
  TrezorConnect = module2.default;
  await TrezorConnect.init({
    lazyLoad: false,
    manifest: {
      email: "support@sanctuary.local",
      appUrl: "https://sanctuary.local"
    },
    // Use the extension's popup for Trezor Connect UI
    popup: true,
    debug: false,
    // Connect to Trezor Bridge or WebUSB
    transports: ["BridgeTransport", "WebUsbTransport"]
  });
  TrezorConnect.on("DEVICE_EVENT", (event) => {
    if (event.type === "device-connect" || event.type === "device-changed") {
      const device = event.payload;
      if (device.features) {
        const hwDevice = {
          id: device.id || `trezor-${device.path}`,
          type: "trezor",
          model: getTrezorModel(device.features.model),
          fingerprint: null,
          // Will be populated when getting xpub
          connected: device.connected,
          needsPin: device.features.pin_protection && !device.features.unlocked,
          needsPassphrase: device.features.passphrase_protection
        };
        connectedDevices.set(hwDevice.id, hwDevice);
      }
    } else if (event.type === "device-disconnect") {
      const device = event.payload;
      const deviceId = device.id || `trezor-${device.path}`;
      connectedDevices.delete(deviceId);
    }
  });
  initialized = true;
}
function getTrezorModel(model) {
  switch (model) {
    case "1":
      return "Trezor Model One";
    case "T":
      return "Trezor Model T";
    case "R":
      return "Trezor Safe 3";
    case "T3T1":
      return "Trezor Safe 5";
    default:
      return "Trezor Device";
  }
}
function pathToArray(path) {
  return path.replace(/^m\//, "").split("/").map((segment) => {
    const hardened = segment.endsWith("'") || segment.endsWith("h");
    const num = parseInt(segment.replace(/['h]$/, ""), 10);
    return hardened ? num + 2147483648 : num;
  });
}
var trezorDriver = {
  type: "trezor",
  isSupported() {
    return typeof window !== "undefined";
  },
  async enumerate() {
    if (!this.isSupported()) return [];
    try {
      await initTrezorConnect();
      return Array.from(connectedDevices.values());
    } catch (error) {
      console.error("Failed to enumerate Trezor devices:", error);
      return [];
    }
  },
  async connect() {
    await initTrezorConnect();
    if (!TrezorConnect) {
      throw new Error("Trezor Connect not initialized");
    }
    const result = await TrezorConnect.getFeatures();
    if (!result.success) {
      throw new Error(result.payload.error || "Failed to connect to Trezor");
    }
    const features = result.payload;
    const deviceId = features.device_id || `trezor-${Date.now()}`;
    let fingerprint = null;
    try {
      const xpubResult = await TrezorConnect.getPublicKey({
        path: "m/84'/0'/0'",
        showOnTrezor: false
      });
      if (xpubResult.success) {
        fingerprint = xpubResult.payload.fingerprint?.toString(16).padStart(8, "0") || null;
      }
    } catch (error) {
      console.warn("Could not get fingerprint from Trezor:", error);
    }
    const device = {
      id: deviceId,
      type: "trezor",
      model: getTrezorModel(features.model),
      fingerprint,
      connected: true,
      needsPin: features.pin_protection && !features.unlocked,
      needsPassphrase: features.passphrase_protection
    };
    connectedDevices.set(deviceId, device);
    return device;
  },
  async disconnect(deviceId) {
    connectedDevices.delete(deviceId);
  },
  async getXpub(deviceId, path) {
    await initTrezorConnect();
    if (!TrezorConnect) {
      throw new Error("Trezor Connect not initialized");
    }
    const result = await TrezorConnect.getPublicKey({
      path,
      showOnTrezor: true
      // Show on device for verification
    });
    if (!result.success) {
      if (result.payload.code === "Failure_ActionCancelled") {
        throw new Error("User rejected the request on the Trezor device");
      }
      throw new Error(result.payload.error || "Failed to get xpub from Trezor");
    }
    return {
      xpub: result.payload.xpub,
      fingerprint: result.payload.fingerprint?.toString(16).padStart(8, "0") || "",
      path
    };
  },
  async signPSBT(deviceId, psbtBase64, inputPaths) {
    await initTrezorConnect();
    if (!TrezorConnect) {
      throw new Error("Trezor Connect not initialized");
    }
    const result = await TrezorConnect.signTransaction({
      inputs: inputPaths.map((path, index) => ({
        address_n: pathToArray(path),
        prev_hash: "",
        // Will be filled from PSBT
        prev_index: 0,
        // Will be filled from PSBT
        amount: "0",
        // Will be filled from PSBT
        script_type: "SPENDWITNESS"
        // Assume native segwit for now
      })),
      outputs: [],
      // Will be filled from PSBT
      coin: "btc",
      // Pass the raw PSBT for modern Trezor firmware
      serialize: false
    });
    if (!result.success) {
      if (result.payload.code === "Failure_ActionCancelled") {
        throw new Error("User rejected the transaction on the Trezor device");
      }
      throw new Error(result.payload.error || "Failed to sign with Trezor");
    }
    return {
      signedPsbt: psbtBase64,
      // TODO: Merge signatures from result
      signatures: result.payload.signatures?.length || inputPaths.length
    };
  },
  async verifyAddress(deviceId, path, address) {
    await initTrezorConnect();
    if (!TrezorConnect) {
      throw new Error("Trezor Connect not initialized");
    }
    const pathParts = path.split("/");
    const purpose = parseInt(pathParts[1]?.replace("'", "") || "84", 10);
    let scriptType;
    switch (purpose) {
      case 44:
        scriptType = "SPENDADDRESS";
        break;
      case 49:
        scriptType = "SPENDP2SHWITNESS";
        break;
      case 84:
      default:
        scriptType = "SPENDWITNESS";
        break;
    }
    const result = await TrezorConnect.getAddress({
      path,
      showOnTrezor: true,
      // Display on device for user verification
      scriptType,
      coin: "btc"
    });
    if (!result.success) {
      if (result.payload.code === "Failure_ActionCancelled") {
        return false;
      }
      throw new Error(result.payload.error || "Failed to verify address with Trezor");
    }
    return result.payload.address === address;
  }
};

// background/service-worker.ts
registerDriver(ledgerDriver);
registerDriver(trezorDriver);
var lastKnownDevices = [];
function broadcastDeviceUpdate(devices2) {
  chrome.tabs.query({}, (tabs) => {
    for (const tab of tabs) {
      if (tab.id) {
        chrome.tabs.sendMessage(tab.id, {
          type: "DEVICE_UPDATE",
          devices: devices2
        }).catch(() => {
        });
      }
    }
  });
}
deviceManager.onDeviceChange((devices2) => {
  lastKnownDevices = devices2;
  broadcastDeviceUpdate(devices2);
  updateBadge(devices2);
});
function updateBadge(devices2) {
  const connectedCount = devices2.filter((d) => d.connected).length;
  if (connectedCount > 0) {
    chrome.action.setBadgeText({ text: String(connectedCount) });
    chrome.action.setBadgeBackgroundColor({ color: "#22c55e" });
  } else {
    chrome.action.setBadgeText({ text: "" });
  }
}
chrome.runtime.onMessage.addListener(
  (message, sender, sendResponse) => {
    if (sender.tab?.url) {
      const url = new URL(sender.tab.url);
      const allowedOrigins = [
        "localhost",
        "127.0.0.1",
        "sanctuary.local"
      ];
      const isAllowed = allowedOrigins.some(
        (origin) => url.hostname === origin || url.hostname.endsWith(`.${origin}`)
      );
      if (!isAllowed) {
        sendResponse({
          success: false,
          error: "Origin not allowed"
        });
        return false;
      }
    }
    handleMessage(message).then(sendResponse).catch((error) => {
      sendResponse({
        success: false,
        error: error.message || "Unknown error"
      });
    });
    return true;
  }
);
async function handleMessage(message) {
  switch (message.type) {
    case "GET_STATUS":
      return {
        success: true,
        data: {
          devices: lastKnownDevices,
          supported: {
            ledger: ledgerDriver.isSupported(),
            trezor: trezorDriver.isSupported()
          }
        }
      };
    case "GET_DEVICES":
      try {
        const devices2 = await deviceManager.enumerateAll();
        lastKnownDevices = devices2;
        return {
          success: true,
          data: devices2
        };
      } catch (error) {
        return {
          success: false,
          error: error.message || "Failed to enumerate devices"
        };
      }
    case "CONNECT_DEVICE":
      try {
        const deviceType = message.payload.deviceType;
        const device = await deviceManager.connectDevice(deviceType);
        return {
          success: true,
          data: device
        };
      } catch (error) {
        return {
          success: false,
          error: error.message || "Failed to connect device"
        };
      }
    case "DISCONNECT_DEVICE":
      try {
        await deviceManager.disconnectDevice(message.payload.deviceId);
        return {
          success: true
        };
      } catch (error) {
        return {
          success: false,
          error: error.message || "Failed to disconnect device"
        };
      }
    case "GET_XPUB":
      try {
        const { path, deviceId } = message.payload;
        let targetDeviceId = deviceId;
        if (!targetDeviceId) {
          const devices2 = deviceManager.getConnectedDevices();
          if (devices2.length === 0) {
            throw new Error("No device connected");
          }
          targetDeviceId = devices2[0].id;
        }
        const result = await deviceManager.getXpub(targetDeviceId, path);
        return {
          success: true,
          data: result
        };
      } catch (error) {
        return {
          success: false,
          error: error.message || "Failed to get xpub"
        };
      }
    case "SIGN_PSBT":
      try {
        const { psbt, inputPaths, deviceId } = message.payload;
        let targetDeviceId = deviceId;
        if (!targetDeviceId) {
          const devices2 = deviceManager.getConnectedDevices();
          if (devices2.length === 0) {
            throw new Error("No device connected");
          }
          targetDeviceId = devices2[0].id;
        }
        const result = await deviceManager.signPSBT(
          targetDeviceId,
          psbt,
          inputPaths
        );
        return {
          success: true,
          data: result
        };
      } catch (error) {
        return {
          success: false,
          error: error.message || "Failed to sign PSBT"
        };
      }
    case "VERIFY_ADDRESS":
      try {
        const { path, address, deviceId } = message.payload;
        let targetDeviceId = deviceId;
        if (!targetDeviceId) {
          const devices2 = deviceManager.getConnectedDevices();
          if (devices2.length === 0) {
            throw new Error("No device connected");
          }
          targetDeviceId = devices2[0].id;
        }
        const verified = await deviceManager.verifyAddress(targetDeviceId, path, address);
        return {
          success: true,
          data: verified
        };
      } catch (error) {
        return {
          success: false,
          error: error.message || "Failed to verify address"
        };
      }
    default:
      return {
        success: false,
        error: `Unknown message type: ${message.type}`
      };
  }
}
chrome.runtime.onConnectExternal.addListener((port) => {
  console.log("External connection from:", port.sender?.url);
  port.onMessage.addListener(async (message) => {
    try {
      const response = await handleMessage(message);
      port.postMessage(response);
    } catch (error) {
      port.postMessage({
        success: false,
        error: error.message || "Unknown error"
      });
    }
  });
});
setInterval(async () => {
  try {
    const devices2 = await deviceManager.enumerateAll();
    const changed = devices2.length !== lastKnownDevices.length || devices2.some((d, i) => d.id !== lastKnownDevices[i]?.id || d.connected !== lastKnownDevices[i]?.connected);
    if (changed) {
      lastKnownDevices = devices2;
      broadcastDeviceUpdate(devices2);
      updateBadge(devices2);
    }
  } catch (error) {
    console.error("Device enumeration error:", error);
  }
}, 5e3);
console.log("Sanctuary HW Bridge service worker started");
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/curve.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/weierstrass.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/_shortw_utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

long/umd/index.js:
  (**
   * @license
   * Copyright 2009 The Closure Library Authors
   * Copyright 2020 Daniel Wirtz / The long.js Authors.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   *)
*/
