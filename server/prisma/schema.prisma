// Sanctuary Wallet Database Schema
// This schema defines all database tables and relationships for the wallet backend

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "linux-musl-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ========================================
// USER MANAGEMENT
// ========================================

model User {
  id        String   @id @default(uuid())
  username  String   @unique
  password  String   // Hashed with bcrypt
  email     String?  @unique
  isAdmin   Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // User preferences (stored as JSON)
  preferences Json?

  // Two-Factor Authentication
  twoFactorEnabled    Boolean  @default(false)
  twoFactorSecret     String?  // TOTP secret (base32)
  twoFactorBackupCodes String? // JSON array of hashed backup codes

  // Relationships
  wallets     WalletUser[]
  devices     Device[]
  transactions Transaction[]
  groupMemberships GroupMember[]
  pushDevices PushDevice[]
  draftTransactions DraftTransaction[]

  @@index([isAdmin])                      // For admin user lookups
  @@map("users")
}

model Group {
  id          String   @id @default(uuid())
  name        String
  description String?
  purpose     String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relationships
  members GroupMember[]
  wallets Wallet[]

  @@map("groups")
}

model GroupMember {
  id        String   @id @default(uuid())
  userId    String
  groupId   String
  role      String   @default("member") // member, admin
  createdAt DateTime @default(now())

  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  group Group @relation(fields: [groupId], references: [id], onDelete: Cascade)

  @@unique([userId, groupId])
  @@index([userId])
  @@index([groupId])
  @@map("group_members")
}

// ========================================
// WALLET MANAGEMENT
// ========================================

model Wallet {
  id          String   @id @default(uuid())
  name        String
  type        String   // single_sig, multi_sig
  scriptType  String   // native_segwit, nested_segwit, taproot, legacy
  network     String   @default("mainnet") // mainnet, testnet, regtest

  // Multi-sig configuration
  quorum      Int?     // e.g., 2 for 2-of-3
  totalSigners Int?    // e.g., 3 for 2-of-3

  // Wallet descriptors
  descriptor  String?  // Output descriptor
  fingerprint String?  // Master key fingerprint

  // Optional group ownership
  groupId     String?
  groupRole   String   @default("viewer") // Role for group members: owner, signer, viewer

  // Sync metadata - for caching layer
  lastSyncedAt    DateTime?  // Last successful full sync
  lastSyncStatus  String?    // success, failed, partial
  lastSyncError   String?    // Error message if failed
  syncInProgress  Boolean    @default(false)

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relationships
  users        WalletUser[]
  devices      WalletDevice[]
  addresses    Address[]
  transactions Transaction[]
  utxos        UTXO[]
  labels       Label[]
  group        Group?   @relation(fields: [groupId], references: [id])
  draftTransactions DraftTransaction[]

  @@index([groupId])
  @@index([syncInProgress])               // For sync service startup & scheduling
  @@index([lastSyncedAt])                 // For stale wallet detection
  @@map("wallets")
}

model WalletUser {
  id        String   @id @default(uuid())
  walletId  String
  userId    String
  role      String   @default("viewer") // owner, signer, viewer
  createdAt DateTime @default(now())

  wallet Wallet @relation(fields: [walletId], references: [id], onDelete: Cascade)
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([walletId, userId])
  @@index([userId])
  @@map("wallet_users")
}

// ========================================
// HARDWARE DEVICES
// ========================================

// Hardware device model catalog - stores device specifications and capabilities
model HardwareDeviceModel {
  id              String   @id @default(uuid())
  name            String   @unique // Display name (e.g., "ColdCard Mk4")
  slug            String   @unique // URL-friendly identifier (e.g., "coldcard-mk4")
  manufacturer    String   // Company name (e.g., "Coinkite")

  // Connectivity capabilities (stored as array of strings)
  connectivity    String[] // usb, bluetooth, nfc, sd_card, qr_code, air_gapped

  // Security features
  secureElement   Boolean  @default(false)
  openSource      Boolean  @default(false)
  airGapped       Boolean  @default(false)

  // Bitcoin features
  supportsBitcoinOnly Boolean @default(true)
  supportsMultisig    Boolean @default(true)
  supportsTaproot     Boolean @default(false)
  supportsPassphrase  Boolean @default(true)

  // Supported script types (stored as array)
  scriptTypes     String[] // legacy, nested_segwit, native_segwit, taproot

  // Display info
  hasScreen       Boolean  @default(true)
  screenType      String?  // e-ink, lcd, oled, none

  // Additional info
  releaseYear     Int?
  discontinued    Boolean  @default(false)
  imageUrl        String?
  websiteUrl      String?

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relationship to user's registered devices
  devices         Device[]

  @@index([manufacturer])                 // For device catalog filtering
  @@index([discontinued])                 // For active device filtering
  @@map("hardware_device_models")
}

// User's registered device instances
model Device {
  id              String   @id @default(uuid())
  userId          String
  modelId         String?  // Reference to HardwareDeviceModel
  type            String   // Legacy field for backward compatibility
  label           String
  fingerprint     String   @unique
  derivationPath  String?  // e.g., m/84'/0'/0'
  xpub            String   // Extended public key
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  user    User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  model   HardwareDeviceModel? @relation(fields: [modelId], references: [id])
  wallets WalletDevice[]

  @@index([userId])
  @@index([modelId])                      // For device by model lookups
  @@map("devices")
}

model WalletDevice {
  id        String   @id @default(uuid())
  walletId  String
  deviceId  String
  signerIndex Int?   // For multi-sig wallets
  createdAt DateTime @default(now())

  wallet Wallet @relation(fields: [walletId], references: [id], onDelete: Cascade)
  device Device @relation(fields: [deviceId], references: [id], onDelete: Cascade)

  @@unique([walletId, deviceId])
  @@index([deviceId])
  @@map("wallet_devices")
}

// ========================================
// BITCOIN DATA
// ========================================

model Address {
  id             String   @id @default(uuid())
  walletId       String
  address        String   @unique
  derivationPath String   // e.g., m/84'/0'/0'/0/0
  index          Int
  used           Boolean  @default(false)
  createdAt      DateTime @default(now())

  wallet       Wallet        @relation(fields: [walletId], references: [id], onDelete: Cascade)
  transactions Transaction[]
  addressLabels AddressLabel[]

  @@index([walletId])                     // For address listing queries
  @@index([walletId, used])
  @@map("addresses")
}

model Transaction {
  id            String   @id @default(uuid())
  txid          String
  walletId      String
  userId        String?
  type          String   // sent, received
  amount        BigInt   // Amount in satoshis
  fee           BigInt?  // Fee in satoshis
  balanceAfter  BigInt?  // Wallet balance after this transaction (running balance)
  confirmations Int      @default(0)
  blockHeight   Int?
  blockTime     DateTime?
  label         String?
  memo          String?
  rawTx         String?  // Raw transaction hex
  counterpartyAddress String? // Sender address (for receives) or recipient address (for sends)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // RBF tracking
  replacedByTxid     String?  // If this tx was replaced, points to replacement
  replacementForTxid String?  // If this is a replacement, points to original
  rbfStatus          String   @default("active")  // active, replaced, confirmed

  wallet  Wallet   @relation(fields: [walletId], references: [id], onDelete: Cascade)
  user    User?    @relation(fields: [userId], references: [id])
  address Address? @relation(fields: [addressId], references: [id])
  addressId String?
  transactionLabels TransactionLabel[]

  @@unique([txid, walletId])  // Same blockchain tx can exist for multiple wallets
  @@index([walletId])
  @@index([txid])
  @@index([walletId, blockHeight(sort: Desc)])
  @@index([walletId, type])           // For filtering by transaction type
  @@index([blockTime])                 // For date-range exports
  @@index([walletId, confirmations])   // For pending transaction queries
  @@index([walletId, blockTime, createdAt]) // For running balance calculation
  @@index([userId])                    // For user-filtered transaction queries
  @@index([addressId])                 // For transaction by address lookups
  @@index([walletId, rbfStatus])       // For filtering replaced transactions
  @@index([replacedByTxid])            // For finding replacement chains
  @@index([replacementForTxid])        // For finding original transactions
  @@map("transactions")
}

model UTXO {
  id            String   @id @default(uuid())
  walletId      String
  txid          String
  vout          Int      // Output index
  address       String
  amount        BigInt   // Amount in satoshis
  scriptPubKey  String
  confirmations Int      @default(0)
  blockHeight   Int?
  spent         Boolean  @default(false)
  spentTxid     String?  // Transaction ID that spent this UTXO
  frozen        Boolean  @default(false) // Prevent UTXO from being used in transactions
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  wallet Wallet @relation(fields: [walletId], references: [id], onDelete: Cascade)
  draftLock DraftUtxoLock?  // If locked by a draft, points to the lock record

  @@unique([txid, vout])
  @@index([walletId])                  // For balance calculations
  @@index([walletId, spent])
  @@index([walletId, frozen])          // For UTXO selection excluding frozen
  @@map("utxos")
}

// ========================================
// DRAFT TRANSACTIONS
// ========================================

model DraftTransaction {
  id              String   @id @default(uuid())
  walletId        String
  userId          String

  // Transaction parameters (user inputs)
  recipient       String
  amount          BigInt
  feeRate         Float
  selectedUtxoIds String[] // Format: "txid:vout"
  enableRBF       Boolean  @default(true)
  subtractFees    Boolean  @default(false)
  sendMax         Boolean  @default(false)
  outputs         Json?    // Multiple outputs: [{ address, amount, sendMax? }]

  // RBF flag - skip UTXO locking for RBF transactions (they reuse same UTXOs)
  isRBF           Boolean  @default(false)

  // Labels
  label           String?
  memo            String?

  // Generated PSBT data
  psbtBase64      String   // Unsigned PSBT
  signedPsbtBase64 String? // Partially/fully signed PSBT
  fee             BigInt
  totalInput      BigInt
  totalOutput     BigInt
  changeAmount    BigInt
  changeAddress   String?
  effectiveAmount BigInt
  inputPaths      String[] // Derivation paths for signing

  // Signing status (for multisig)
  status          String   @default("unsigned") // unsigned, partial, signed
  signedDeviceIds String[] // Device IDs that have signed

  // Timestamps
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  expiresAt       DateTime? // Optional auto-cleanup

  wallet Wallet @relation(fields: [walletId], references: [id], onDelete: Cascade)
  user   User   @relation(fields: [userId], references: [id])
  utxoLocks DraftUtxoLock[]

  @@index([walletId, status])
  @@index([userId])
  @@index([expiresAt])                 // For hourly maintenance cleanup
  @@map("draft_transactions")
}

// Junction table for locking UTXOs to drafts (prevents double-spend in drafts)
model DraftUtxoLock {
  id        String   @id @default(uuid())
  draftId   String
  utxoId    String
  createdAt DateTime @default(now())

  draft DraftTransaction @relation(fields: [draftId], references: [id], onDelete: Cascade)
  utxo  UTXO             @relation(fields: [utxoId], references: [id], onDelete: Cascade)

  @@unique([draftId, utxoId])  // Same UTXO can only be in same draft once
  @@unique([utxoId])           // CRITICAL: Each UTXO can only be in ONE draft
  @@index([draftId])
  @@index([utxoId])
  @@map("draft_utxo_locks")
}

// ========================================
// SYSTEM CONFIGURATION
// ========================================

model NodeConfig {
  id               String   @id @default(uuid())
  type             String   // bitcoin_core, electrum
  host             String   // Primary/legacy server host (kept for backward compatibility)
  port             Int      // Primary/legacy server port
  useSsl           Boolean  @default(false)
  username         String?
  password         String?
  isDefault        Boolean  @default(false)
  explorerUrl      String?
  feeEstimatorUrl  String?  // URL for mempool.space-compatible API (defaults to mempool.space)
  mempoolEstimator String   @default("mempool_space") // simple, mempool_space

  // TLS certificate verification (for SSL connections)
  // When true, self-signed certificates are allowed (verification disabled)
  // Default: false (verify certificates for security)
  allowSelfSignedCert Boolean @default(false)

  // Connection pooling settings (Electrum only)
  poolEnabled        Boolean @default(false)  // false = single server mode, true = multi-server pool
  poolMinConnections Int     @default(1)
  poolMaxConnections Int     @default(5)

  // Load balancing strategy: round_robin, least_connections, failover_only
  poolLoadBalancing  String  @default("round_robin")

  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  // Relationship to server list
  servers          ElectrumServer[]

  @@map("node_configs")
}

// Electrum server configuration for multi-server pool
model ElectrumServer {
  id           String   @id @default(uuid())
  nodeConfigId String
  label        String   // User-friendly name (e.g., "Blockstream SSL", "My Umbrel")
  host         String
  port         Int
  useSsl       Boolean  @default(true)
  priority     Int      @default(0)  // Lower = higher priority (0 is highest)
  enabled      Boolean  @default(true)

  // Health tracking
  lastHealthCheck   DateTime?
  healthCheckFails  Int       @default(0)  // Consecutive failures
  isHealthy         Boolean   @default(true)

  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  nodeConfig   NodeConfig @relation(fields: [nodeConfigId], references: [id], onDelete: Cascade)

  @@index([nodeConfigId])
  @@index([priority])
  @@map("electrum_servers")
}

model FeeEstimate {
  id          String   @id @default(uuid())
  fastest     Float    // sat/vB
  halfHour    Float    // sat/vB
  hour        Float    // sat/vB
  createdAt   DateTime @default(now())

  @@index([createdAt])                 // For daily maintenance cleanup
  @@map("fee_estimates")
}

model SystemSetting {
  id        String   @id @default(uuid())
  key       String   @unique
  value     String   // JSON-encoded value
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("system_settings")
}

model PriceData {
  id        String   @id @default(uuid())
  currency  String   // USD, EUR, GBP, etc.
  price     Float
  source    String   // mempool, coingecko, kraken
  createdAt DateTime @default(now())

  @@index([currency, createdAt])
  @@index([createdAt])                 // For daily maintenance cleanup
  @@map("price_data")
}

// ========================================
// LABELS & TAGGING
// ========================================

model Label {
  id          String   @id @default(uuid())
  walletId    String
  name        String
  color       String   @default("#6366f1") // Hex color for display
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  wallet              Wallet             @relation(fields: [walletId], references: [id], onDelete: Cascade)
  transactionLabels   TransactionLabel[]
  addressLabels       AddressLabel[]

  @@unique([walletId, name]) // Labels must be unique per wallet
  @@index([walletId])
  @@map("labels")
}

model TransactionLabel {
  id            String   @id @default(uuid())
  transactionId String
  labelId       String
  createdAt     DateTime @default(now())

  transaction Transaction @relation(fields: [transactionId], references: [id], onDelete: Cascade)
  label       Label       @relation(fields: [labelId], references: [id], onDelete: Cascade)

  @@unique([transactionId, labelId])
  @@index([transactionId])
  @@index([labelId])
  @@map("transaction_labels")
}

model AddressLabel {
  id        String   @id @default(uuid())
  addressId String
  labelId   String
  createdAt DateTime @default(now())

  address Address @relation(fields: [addressId], references: [id], onDelete: Cascade)
  label   Label   @relation(fields: [labelId], references: [id], onDelete: Cascade)

  @@unique([addressId, labelId])
  @@index([addressId])
  @@index([labelId])
  @@map("address_labels")
}

// ========================================
// AUDIT LOGGING
// ========================================

model AuditLog {
  id        String   @id @default(uuid())
  userId    String?  // Null for system events or failed auth
  username  String   // Stored separately in case user is deleted
  action    String   // e.g., "user.create", "wallet.share", "backup.create"
  category  String   // auth, user, wallet, device, admin, system
  details   Json?    // Additional context (target user, wallet name, etc.)
  ipAddress String?  // Client IP address
  userAgent String?  // Browser/client info
  success   Boolean  @default(true)
  errorMsg  String?  // Error message if success=false
  createdAt DateTime @default(now())

  @@index([userId])
  @@index([action])
  @@index([category])
  @@index([createdAt])
  @@index([userId, createdAt])         // For user activity timeline
  @@index([success, createdAt])        // For security monitoring queries
  @@map("audit_logs")
}

// ========================================
// PUSH NOTIFICATIONS
// ========================================

model PushDevice {
  id          String   @id @default(uuid())
  userId      String
  token       String   @unique  // Device token from APNs/FCM
  platform    String   // "ios" or "android"
  deviceName  String?  // User-friendly name (e.g., "John's iPhone")
  appVersion  String?  // Mobile app version
  lastUsedAt  DateTime @default(now())
  createdAt   DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([platform])                  // For notification routing by platform
  @@map("push_devices")
}
