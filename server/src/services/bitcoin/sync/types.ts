/**
 * Sync Pipeline Types
 *
 * Type definitions for the modular wallet sync pipeline.
 */

import type { Address, Wallet, Transaction, UTXO } from '@prisma/client';
import type { NodeClientInterface } from '../nodeClient';

// ============================================
// Core Types
// ============================================

/** Bitcoin network type */
export type BitcoinNetwork = 'mainnet' | 'testnet' | 'signet' | 'regtest';

/** Transaction history entry from Electrum */
export interface TxHistoryEntry {
  tx_hash: string;
  height: number;
}

/** UTXO entry from Electrum */
export interface ElectrumUTXO {
  tx_hash: string;
  tx_pos: number;
  height: number;
  value: number;
}

/** Raw transaction details from node/Electrum */
export interface RawTransaction {
  txid: string;
  time?: number;
  blocktime?: number;
  vin: TransactionInput[];
  vout: TransactionOutput[];
  confirmations?: number;
  blockhash?: string;
  hex?: string;
}

/** Transaction input */
export interface TransactionInput {
  txid?: string;
  vout?: number;
  coinbase?: string;
  prevout?: {
    scriptPubKey?: {
      address?: string;
      addresses?: string[];
    };
    value?: number;
  };
}

/** Transaction output */
export interface TransactionOutput {
  value: number;
  n: number;
  scriptPubKey: {
    hex?: string;
    address?: string;
    addresses?: string[];
    type?: string;
  };
}

// ============================================
// Sync Context
// ============================================

/** Statistics collected during sync */
export interface SyncStats {
  historiesFetched: number;
  transactionsProcessed: number;
  newTransactionsCreated: number;
  utxosFetched: number;
  utxosCreated: number;
  utxosMarkedSpent: number;
  addressesUpdated: number;
  newAddressesGenerated: number;
  correctedConsolidations: number;
}

/** Context passed between sync phases */
export interface SyncContext {
  // Identifiers
  walletId: string;
  wallet: Wallet;
  network: BitcoinNetwork;

  // Services
  client: NodeClientInterface;

  // Input data
  addresses: Address[];
  walletAddressSet: Set<string>;
  addressMap: Map<string, Address>;
  addressToDerivationPath: Map<string, string>;

  // Phase outputs (accumulated)
  historyResults: Map<string, TxHistoryEntry[]>;
  allTxids: Set<string>;
  existingTxMap: Map<string, boolean>;
  existingTxidSet: Set<string>;
  newTxids: string[];
  txDetailsCache: Map<string, RawTransaction>;
  txHeightMap: Map<string, number>;

  // UTXO phase data
  utxoResults: Array<{ address: string; utxos: ElectrumUTXO[] }>;
  successfullyFetchedAddresses: Set<string>;
  allUtxoKeys: Set<string>;
  utxoDataMap: Map<string, { address: string; utxo: ElectrumUTXO }>;

  // Results
  newTransactions: TransactionCreateData[];
  /** New addresses generated by gap limit expansion (simplified type from ensureGapLimit) */
  newAddresses: Array<{ address: string; derivationPath: string }>;

  // Tracking
  stats: SyncStats;
  startTime: number;
  currentBlockHeight: number;
  viaTor: boolean;

  // Phase tracking
  completedPhases: string[];
}

/** Data for creating a new transaction */
export interface TransactionCreateData {
  txid: string;
  walletId: string;
  addressId: string;
  type: 'received' | 'sent' | 'consolidation';
  amount: bigint;
  fee?: bigint | null;
  confirmations: number;
  blockHeight: number | null;
  blockTime: Date | null;
  rbfStatus: 'active' | 'confirmed' | 'replaced';
}

/** Data for creating a transaction input record */
export interface TxInputCreateData {
  transactionId: string;
  inputIndex: number;
  txid: string;
  vout: number;
  address: string;
  amount: bigint;
  derivationPath?: string;
}

/** Data for creating a transaction output record */
export interface TxOutputCreateData {
  transactionId: string;
  outputIndex: number;
  address: string;
  amount: bigint;
  scriptPubKey?: string;
  outputType: string;
  isOurs: boolean;
}

/** Data for creating a UTXO record */
export interface UTXOCreateData {
  walletId: string;
  txid: string;
  vout: number;
  address: string;
  amount: bigint;
  scriptPubKey: string;
  confirmations: number;
  blockHeight: number | null;
  spent: boolean;
}

// ============================================
// Phase Types
// ============================================

/** Phase function signature */
export type SyncPhase = {
  name: string;
  execute: (ctx: SyncContext) => Promise<SyncContext>;
};

/** Pipeline options */
export interface PipelineOptions {
  /** Skip certain phases (by name) */
  skipPhases?: string[];
  /** Run only these phases (by name) */
  onlyPhases?: string[];
  /** Callback after each phase completes */
  onPhaseComplete?: (phaseName: string, ctx: SyncContext) => void;
}

/** Sync result returned to caller */
export interface SyncResult {
  addresses: number;
  transactions: number;
  utxos: number;
  stats: SyncStats;
  elapsedMs: number;
}

// ============================================
// Error Types
// ============================================

/** Error thrown during sync pipeline execution */
export class SyncPipelineError extends Error {
  constructor(
    public readonly cause: Error,
    public readonly completedPhases: string[],
    public readonly failedPhase: string,
    public readonly context?: Partial<SyncContext>
  ) {
    super(`Sync pipeline failed at phase "${failedPhase}": ${cause.message}`);
    this.name = 'SyncPipelineError';
  }
}
