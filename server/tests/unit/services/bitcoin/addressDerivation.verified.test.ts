/**
 * Address Derivation - Cross-Implementation Verification Tests
 *
 * These tests verify that our address derivation implementation produces
 * correct addresses by comparing against vectors that have been verified
 * by multiple independent implementations (Bitcoin Core, Caravan, Python, Go).
 *
 * The vectors are generated by scripts/verify-addresses/ and only include
 * addresses where ALL implementations produced identical results.
 *
 * This is the most critical test suite for address generation correctness.
 * If funds are lost due to incorrect address generation, it's catastrophic.
 */

import { describe, it, expect, beforeAll } from 'vitest';
import {
  deriveAddress,
  deriveAddressFromDescriptor,
  validateXpub,
  convertToStandardXpub,
} from '../../../../src/services/bitcoin/addressDerivation';
import {
  VERIFIED_SINGLESIG_VECTORS,
  VERIFIED_MULTISIG_VECTORS,
  type VerifiedSingleSigVector,
  type VerifiedMultisigVector,
} from '../../../fixtures/verified-address-vectors';

describe('Address Derivation - Cross-Implementation Verification', () => {
  describe('Single-sig address verification', () => {
    // Skip if no vectors (generation script hasn't been run)
    if (VERIFIED_SINGLESIG_VECTORS.length === 0) {
      it.skip('No verified vectors available - run scripts/verify-addresses/npm run generate', () => {});
      return;
    }

    describe('Native SegWit (P2WPKH)', () => {
      const nativeSegwitVectors = VERIFIED_SINGLESIG_VECTORS.filter(
        v => v.scriptType === 'native_segwit'
      );

      it.each(nativeSegwitVectors.map(v => [v.description, v]))(
        '%s',
        (_desc: string, vector: VerifiedSingleSigVector) => {
          const result = deriveAddress(vector.xpub, vector.index, {
            scriptType: 'native_segwit',
            network: vector.network,
            change: vector.change,
          });

          expect(result.address).toBe(vector.expectedAddress);
        }
      );
    });

    describe('Nested SegWit (P2SH-P2WPKH)', () => {
      const nestedSegwitVectors = VERIFIED_SINGLESIG_VECTORS.filter(
        v => v.scriptType === 'nested_segwit'
      );

      if (nestedSegwitVectors.length === 0) {
        it.skip('No nested segwit vectors available', () => {});
        return;
      }

      it.each(nestedSegwitVectors.map(v => [v.description, v]))(
        '%s',
        (_desc: string, vector: VerifiedSingleSigVector) => {
          const result = deriveAddress(vector.xpub, vector.index, {
            scriptType: 'nested_segwit',
            network: vector.network,
            change: vector.change,
          });

          expect(result.address).toBe(vector.expectedAddress);
        }
      );
    });

    describe('Legacy (P2PKH)', () => {
      const legacyVectors = VERIFIED_SINGLESIG_VECTORS.filter(
        v => v.scriptType === 'legacy'
      );

      if (legacyVectors.length === 0) {
        it.skip('No legacy vectors available', () => {});
        return;
      }

      it.each(legacyVectors.map(v => [v.description, v]))(
        '%s',
        (_desc: string, vector: VerifiedSingleSigVector) => {
          const result = deriveAddress(vector.xpub, vector.index, {
            scriptType: 'legacy',
            network: vector.network,
            change: vector.change,
          });

          expect(result.address).toBe(vector.expectedAddress);
        }
      );
    });

    describe('Taproot (P2TR)', () => {
      const taprootVectors = VERIFIED_SINGLESIG_VECTORS.filter(
        v => v.scriptType === 'taproot'
      );

      if (taprootVectors.length === 0) {
        it.skip('No taproot vectors available', () => {});
        return;
      }

      it.each(taprootVectors.map(v => [v.description, v]))(
        '%s',
        (_desc: string, vector: VerifiedSingleSigVector) => {
          const result = deriveAddress(vector.xpub, vector.index, {
            scriptType: 'taproot',
            network: vector.network,
            change: vector.change,
          });

          expect(result.address).toBe(vector.expectedAddress);
        }
      );
    });
  });

  describe('Multisig address verification', () => {
    // Skip if no vectors
    if (VERIFIED_MULTISIG_VECTORS.length === 0) {
      it.skip('No verified multisig vectors available - run scripts/verify-addresses/npm run generate', () => {});
      return;
    }

    describe('P2WSH (Native SegWit Multisig)', () => {
      const p2wshVectors = VERIFIED_MULTISIG_VECTORS.filter(
        v => v.scriptType === 'p2wsh'
      );

      if (p2wshVectors.length === 0) {
        it.skip('No P2WSH vectors available', () => {});
        return;
      }

      it.each(p2wshVectors.map(v => [v.description, v]))(
        '%s',
        (_desc: string, vector: VerifiedMultisigVector) => {
          // Build descriptor from xpubs using wildcard format
          // The implementation derives at <0;1>/* where the index is substituted
          const keyExprs = vector.xpubs.map(xpub => `${xpub}/<0;1>/*`);
          const descriptor = `wsh(sortedmulti(${vector.threshold},${keyExprs.join(',')}))`;

          const result = deriveAddressFromDescriptor(descriptor, vector.index, {
            network: vector.network,
            change: vector.change,
          });

          expect(result.address).toBe(vector.expectedAddress);
        }
      );
    });

    describe('P2SH-P2WSH (Nested SegWit Multisig)', () => {
      const p2shP2wshVectors = VERIFIED_MULTISIG_VECTORS.filter(
        v => v.scriptType === 'p2sh_p2wsh'
      );

      if (p2shP2wshVectors.length === 0) {
        it.skip('No P2SH-P2WSH vectors available', () => {});
        return;
      }

      it.each(p2shP2wshVectors.map(v => [v.description, v]))(
        '%s',
        (_desc: string, vector: VerifiedMultisigVector) => {
          // Build descriptor from xpubs using wildcard format
          const keyExprs = vector.xpubs.map(xpub => `${xpub}/<0;1>/*`);
          const descriptor = `sh(wsh(sortedmulti(${vector.threshold},${keyExprs.join(',')})))`;

          const result = deriveAddressFromDescriptor(descriptor, vector.index, {
            network: vector.network,
            change: vector.change,
          });

          expect(result.address).toBe(vector.expectedAddress);
        }
      );
    });

    describe('Key ordering consistency', () => {
      // Get all key ordering test vectors
      const keyOrderingVectors = VERIFIED_MULTISIG_VECTORS.filter(
        v => v.description.includes('key ordering')
      );

      if (keyOrderingVectors.length < 2) {
        it.skip('Not enough key ordering vectors for comparison', () => {});
        return;
      }

      it('should produce identical addresses regardless of input key order', () => {
        // All key ordering tests should produce the same address
        const addresses = keyOrderingVectors.map(v => v.expectedAddress);
        const uniqueAddresses = new Set(addresses);

        expect(uniqueAddresses.size).toBe(1);
        expect(addresses).toHaveLength(keyOrderingVectors.length);
      });
    });
  });

  describe('Address derivation properties', () => {
    // Use vectors to verify determinism
    const sampleVector = VERIFIED_SINGLESIG_VECTORS[0];

    if (!sampleVector) {
      it.skip('No vectors available for property tests', () => {});
      return;
    }

    it('should be deterministic - same inputs always produce same output', () => {
      const result1 = deriveAddress(sampleVector.xpub, sampleVector.index, {
        scriptType: sampleVector.scriptType,
        network: sampleVector.network,
        change: sampleVector.change,
      });

      const result2 = deriveAddress(sampleVector.xpub, sampleVector.index, {
        scriptType: sampleVector.scriptType,
        network: sampleVector.network,
        change: sampleVector.change,
      });

      expect(result1.address).toBe(result2.address);
      expect(result1.derivationPath).toBe(result2.derivationPath);
    });

    it('should produce different addresses for different indices', () => {
      const vectors = VERIFIED_SINGLESIG_VECTORS.filter(
        v => v.scriptType === sampleVector.scriptType &&
             v.network === sampleVector.network &&
             v.change === sampleVector.change
      );

      if (vectors.length < 2) {
        return; // Need at least 2 vectors
      }

      const addresses = vectors.map(v => v.expectedAddress);
      const uniqueAddresses = new Set(addresses);

      // All addresses should be unique
      expect(uniqueAddresses.size).toBe(addresses.length);
    });

    it('should produce different addresses for receive vs change', () => {
      const receiveVectors = VERIFIED_SINGLESIG_VECTORS.filter(
        v => v.scriptType === 'native_segwit' &&
             v.network === 'mainnet' &&
             v.change === false &&
             v.index === 0
      );

      const changeVectors = VERIFIED_SINGLESIG_VECTORS.filter(
        v => v.scriptType === 'native_segwit' &&
             v.network === 'mainnet' &&
             v.change === true &&
             v.index === 0
      );

      if (receiveVectors.length === 0 || changeVectors.length === 0) {
        return; // Need both vectors
      }

      expect(receiveVectors[0].expectedAddress).not.toBe(changeVectors[0].expectedAddress);
    });
  });

  describe('High index derivation', () => {
    // Test that high indices work correctly
    const highIndexVectors = VERIFIED_SINGLESIG_VECTORS.filter(
      v => v.index >= 999
    );

    if (highIndexVectors.length === 0) {
      it.skip('No high index vectors available', () => {});
      return;
    }

    it.each(highIndexVectors.map(v => [v.description, v]))(
      '%s',
      (_desc: string, vector: VerifiedSingleSigVector) => {
        const result = deriveAddress(vector.xpub, vector.index, {
          scriptType: vector.scriptType,
          network: vector.network,
          change: vector.change,
        });

        expect(result.address).toBe(vector.expectedAddress);
      }
    );
  });

  describe('xpub validation', () => {
    const vectors = VERIFIED_SINGLESIG_VECTORS;

    if (vectors.length === 0) {
      it.skip('No vectors available', () => {});
      return;
    }

    it('should validate xpubs from verified vectors', () => {
      for (const vector of vectors.slice(0, 5)) { // Test first 5
        const result = validateXpub(vector.xpub, vector.network);
        expect(result.valid).toBe(true);
      }
    });

    it('should reject invalid xpubs', () => {
      const result = validateXpub('invalid-xpub-string', 'mainnet');
      expect(result.valid).toBe(false);
      expect(result.error).toBeDefined();
    });
  });
});

describe('Verification coverage summary', () => {
  it('should have sufficient single-sig coverage', () => {
    // Log coverage for visibility
    const scriptTypes = new Set(VERIFIED_SINGLESIG_VECTORS.map(v => v.scriptType));
    const networks = new Set(VERIFIED_SINGLESIG_VECTORS.map(v => v.network));

    console.log(`Single-sig vectors: ${VERIFIED_SINGLESIG_VECTORS.length}`);
    console.log(`Script types covered: ${[...scriptTypes].join(', ')}`);
    console.log(`Networks covered: ${[...networks].join(', ')}`);

    // We should have at least some vectors
    expect(VERIFIED_SINGLESIG_VECTORS.length).toBeGreaterThan(0);
  });

  it('should have multisig coverage (if vectors exist)', () => {
    if (VERIFIED_MULTISIG_VECTORS.length > 0) {
      const scriptTypes = new Set(VERIFIED_MULTISIG_VECTORS.map(v => v.scriptType));

      console.log(`Multisig vectors: ${VERIFIED_MULTISIG_VECTORS.length}`);
      console.log(`Multisig script types covered: ${[...scriptTypes].join(', ')}`);

      expect(VERIFIED_MULTISIG_VECTORS.length).toBeGreaterThan(0);
    }
  });
});
